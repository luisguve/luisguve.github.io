






















































[{"categories":["Projects"],"contents":"ManyLMS is an e-learning platform built on top of Strapi, React Router 7, Typescript and other technologies.\nOutline The idea Platform features The stack The API The frontend Conclusion Landing Page The idea This project doesn\u0026rsquo;t necessarily bring a huge amount of innovation on the e-learning platforms that already exists, but it\u0026rsquo;s just another way of doing this type of application.\nThe main idea is to apply a JAMstack approach in this application, where the platform is a static website, and the backend is just an API that serves static content only once to build the website and just adds the dynamism that\u0026rsquo;s necessary to allow users to authenticate, create orders, confirm payments and take courses.\nIf we compare this approach to a WordPress website, we are taking out most of the overhead that implies rendering the pages everytime a user visits them. Despite that there are plugins for caching that may improve the performance, it\u0026rsquo;s still never going to be faster and more efficient than just static content served by a CDN. That\u0026rsquo;s why React Router 7 and Headless CMSs are so popular right now.\nPlatform features and user stories The following user stories illustrates the desired features the platform should have.\nAs an administrator, I want to: login in the admin panel. create categories. create courses. upload lectures. organise courses into categories. assign lectures to courses. As a student, I want to: login in the platform. view the available courses. add courses to the shopping cart. review the shopping cart. create an order. pay with credit card or paypal. view the courses i\u0026rsquo;ve purchased in my learning page. go to the course page from my learning page and watch the videos. mark lectures as seen. come back later and resume where I left. The requirements The backend requires to handle user authentication, permissions, different data structures as content types and define relationships between them. It also requires to allow uploading videos to some third party platform that supports streaming on demand.\nThe frontend is a web platform where users can register and login, view and buy courses, leave comments and reviews and take courses.\nThe API Since all of the features involve authentication, permissions and roles, and because there is no need to reinvent the wheel, I chose to use Strapi to build the backend for it\u0026rsquo;s simplicity, ease of use and great developer experience, whereas for streaming videos on demand, I chose to use Mux.com.\nThe instance of Strapi and the Postgres database it requires was deployed in the cloud hosting platform https://fly.io.\nStrapi is good for managing users, content that\u0026rsquo;s typically updated and fetched via CRUD API, and setting up relations between content types.\nThe platform needs the following content types:\nCategory to group courses Course Lecture Module to group lectures Order Student: has many courses Student-Course: stores a student\u0026rsquo;s current lecture of a course Video Strapi makes the creation of these content types and setting up relationships between them really straightforward.\nBelow are some screenshots of these content types and the relationships between them:\nThe frontend The platform where users are able to login, view, buy and view courses is a web application built with React Router 7. Among the features of this application are:\nState managed by Context API Interface styled with Bootstrap Play streaming videos with @mux/mux-player-react library Use of localStorage to save user session Below are some sample screenshots of how this app looks like\nConclusion and final thoughts While building this project, I learned:\nHow streaming on demand works and how to use a streaming provider How to statically build websites with React Router 7 and Strapi How to setup dynamic pages in React Router 7 How to process payments with Stripe and Paypal How to build custom plugins in Strapi How to publish packages to NPM Project source codes: https://github.com/luisguve/maestro-backend\nhttps://github.com/luisguve/new-lms-remix\n","image":"//localhost:1313/images/project/manylms/frontend/course_overview.png","permalink":"//localhost:1313/projects/e-learning-platform-maestro-lms/","tags":["Strapi","React","React Router 7","Typescript","Mux"],"title":"ManyLMS: E-Learning platform"},{"categories":["Projects"],"contents":"Rutieri is a SaaS platform built with Strapi, React Native, Typescript and other technologies.\nOutline The idea Platform features The stack The API The frontend The mobile app Conclusion Landing Page The idea Before starting to write a single line of code, it is generally a good idea to think about the problem, it\u0026rsquo;s limitations and whether or not it has already been solved by someone else (AKA competitors).\nThe problem I was looking into had to do with the way in which public and private transportation companies manage their routes, drivers and users. This process is generally carried out on paper, e.g. not digital, hence this could be problematic in case of new drivers joining the organization or in case of restricting access to data to only specific users.\nAfter a little bit of research, I could only find one platform that provides a similiar solution but for their own company.\nPlatform features and user stories The following user stories illustrates the desired features the platform should have in order to solve the aforementioned problems.\nAs an administrator user, I want to: login in the admin panel. create an organization. create routes in the organization. invite drivers and users to the organization. manage requests to join the organization. assign routes to drivers in the organization. see in real time the drivers and users currently active in the map of the different routes. As a driver, I want to: login in the mobile app. join an organization by entering the code in the search bar. see my route on the map. become visible to passengers on the road. see the passengers waiting on the road. remove my visibility and finish my run. As a passenger, I want to: login in the mobile app. join an organization by entering the code in the search bar. see the different routes of my organization in the map. search for a destination and get the available routes that pass nearby. see the drivers currently active on the routes in real time. become visible to drivers of a route. The requirements The backend requires to handle user authentication, permissions, different data structures as content types and define relations between them. It\u0026rsquo;s also necessary to synchronise passengers and drivers and view them on a map real time in the administration panel as well as in the mobile app.\nThe administration panel is a web page that fetches data from the backend as well as from the real time data provider and it\u0026rsquo;s goal is to provide a way for administrators to manage their organization and users. We\u0026rsquo;re talking about a Single Page Application built in React.\nAs for the mobile application, there isn\u0026rsquo;t a better choice nowadays than React Native and it works just fine in this case.\nThe API Since all of the features involve authentication, permissions and roles, and because there is no need to reinvent the wheel, I chose to use Strapi to build the backend for it\u0026rsquo;s simplicity, ease of use and great developer experience, whereas for realtime data, I used Firebase.\nThe instance of Strapi and the Postgres database it requires was deployed in the cloud hosting platform https://fly.io.\nStrapi is good for managing users, content that\u0026rsquo;s typically updated and fetched via CRUD API, and relations between content types.\nThe platform needs the following content types:\nOrganizations to group routes, drivers and users Routes Two user roles: drivers and users (passengers) Below are some screenshots of the overview of these content types\nAs I said before, Strapi makes the creation of these content types and the relationships between them really straightforward.\nHowever, not everything related to the API can be provided by Strapi. Some realtime features need to be addressed with other solutions, such as geolocation data in real time for drivers and users to synchronise each other, maps and the ability to search for places. Such features were implemented using Firebase, Google Maps and Google Places.\nThe frontend The platform where users are able to login as administrators and manage their organizations and users is a single page web application built in React. Among the features of this project that I think stand out are:\nState managed by Context API Interface styled with Bootstrap React Router for pages Leaflet to display the map GeoFire library to synchronise geolocation data in real time with Firebase Use of localStorage to save user session Below are some sample screenshots of how this app looks like\nThe mobile application This one is by far the most complex part of this project.\nThe project was bootstraped with Infinitered\u0026rsquo;s Ignite, which provides a great boilerplate and surely saved me of what would have been between 1-2 months of work.\nIgnite\u0026rsquo;s boilerplate includes many features out of the box, including:\nReact Native and Typescript (of course) React Navigation MobX-State-Tree for state management Expo SDK for developer experience AsyncStorage for persistence apisauce as REST client And some other libraries and features that make React Native apps super powerful and a joy to work on.\nIt consists of three screens:\nWelcome screen Login screen Map screen In the welcome screen, users are able to go to the login screen if not logged in. Otherwise, if they\u0026rsquo;re in an organisation, it shows their role and org\u0026rsquo;s information, and if they\u0026rsquo;re not, they are able to enter the organisation code and request to join as driver or as passenger.\nWelcome screens Login screens If the user is a driver in an organisation, the welcome screen also shows the route assigned to them. By tapping on it, it takes them to the map, where they can see themselves and start the tour, becoming visible to passengers on the road but being able to see passengers on the road as well.\nDrivers can finish the tour at any time by pressing the button stop.\nIf the user is a passenger in an organisation, the welcome screen shows the different routes available in the organisation. By tapping on them, they are taken to the map where they can see themselves, the route and the drivers on the road.\nPassengers are able to navigate between the available routes and search for the location they want to go to by using the search bar at the top of the map screen, filtering out the routes that pass nearby (less than 200 meters), if there are. Google Places API and turf library work together in this search process.\nPassengers become visible to drivers on the road by pressing the button wait and if they press the button again, they stop waiting and are removed from the driver\u0026rsquo;s map.\nMap screens The start/wait and finish buttons dispatch actions that update their location in firebase, so that passengers are able to see the bus on the map as it moves in real time and viceversa.\nAs for the state management, the project consists of two models and three stores from Mobx-State-Tree library: User and Route models, user-status, route-store and root-store stores.\nUser model Located in /app/models/user/user.ts\nconst OrganizationModel = types.model({ name: types.string, code: types.string, id: types.identifierNumber, drivers: types.number, rutas: types.array(RouteModel) }) const UserModel = types .model(\u0026#34;User\u0026#34;) .props({ id: types.identifierNumber, username: types.string, email: types.string, token: types.string, role: types.union(types.literal(\u0026#34;passenger\u0026#34;), types.literal(\u0026#34;driver\u0026#34;)), ruta: types.maybeNull(RouteModel), organization: types.maybeNull(OrganizationModel), pending_request: types.maybeNull(OrganizationModel), }) Route model Located in /app/models/route/route.ts\nThis model follows the GeoJSON format for routes.\nconst RouteModel = types .model(\u0026#34;Ruta\u0026#34;) .props({ id: types.identifierNumber, name: types.string, latlong: types.maybeNull(types.model({ lat: types.number, longt: types.number })), coords: types.model({ type: FeatureTypes, features: types.array(types.model({ type: types.string, geometry: types.model({ type: types.string, coordinates: types.union(types.array(types.number), types.array(types.array(types.number))) }), properties: types.model({ name: types.string }) })) }) }) user-status store Located in /app/models/user-status/user-status.ts\nThis store is responsible for managing the state of the user. It stores the user once it\u0026rsquo;s logged in and removes it when the user logs out. It also has some views to get the user key for firebase purposes, get the role and get the route in case of a driver.\nThis store has some methods that get the user location from the device\u0026rsquo;s GPS, displays the user icon on the map and sends it to firebase.\nconst UserStatusModel = types .model(\u0026#34;UserStatus\u0026#34;) .extend(withEnvironment) .props({ user: types.maybeNull(UserModel), location: types.maybeNull( types.model({latitude: types.number, longitude: types.number}) ), visibility: types.maybeNull(types.number) }) route-store store Located in /app/models/route-store/route-store.ts\nThis store is responsible for managing the state of the available routes. It stores the routes, drivers and passengers on the different routes. It also has some view methods to filter the routes that pass nearby a destination specified by the user, get passengers waiting on a given route and get drivers active in a specific route.\nThis store initializes a GeoQuery from Geofire library and listens for events to set, update and remove drivers and passengers from the map as they move.\nconst RouteStoreModel = types .model(\u0026#34;RouteStore\u0026#34;) .props({ routes: types.array(RouteModel), passengers: types.map(types.model({ key: types.identifier, location: types.array(types.number) })), drivers: types.map(types.model({ key: types.identifier, location: types.array(types.number) })), destinationAddress: types.maybeNull(types.model({ name: types.string, coords: types.array(types.number) })) }) Conclusion and final thoughts Using a CMS as the backend can make the development a lot faster than building the API from scratch and with Strapi this is specially true. On the other hand, Strapi doesn\u0026rsquo;t really make a good fit for real time applications, therefore, Firebase is the way to go in this case.\nAs of the client side, React always works very good for pretty much any kind of application, and because React Native uses React under the hood, it is so convenient for us React developers and ir works pretty good for almost any kind of application as well.\nHowever, one thing that I didn\u0026rsquo;t mention in this post was the use of Typescript; I find this quote by Brice Wilson pretty good to point out the whole purpose and motivation to learn and use (well) this powerful language and tool ecosystem:\n\u0026ldquo;You won\u0026rsquo;t have to wait for a frustrated user to report the error. All of this means that you provide value to your users faster, and that\u0026rsquo;s really what it\u0026rsquo;s all about.\u0026rdquo;\nAll in all, I got a lot of learning by building this project, both in languages/frameworks used and production stuff such as infrastructure, cloud hosting and cloud-based APIs.\nProject landing page: https://rutieri.netlify.app\n","image":"//localhost:1313/images/project/rutieri/landing/homepage.webp","permalink":"//localhost:1313/projects/saas-platform-rutieri/","tags":["Strapi","React Native","React","Typescript","Firebase"],"title":"SaaS platform: Rutieri"},{"categories":["Tutorial"],"contents":"Enable comments in a Strapi application and display them in the frontend with React\nOutline Introduction Prerequisites What is Strapi Comment Manager? Installation Configuration Display comments on the frontend Installation of Strapi Comments Client Usage of Strapi Comments Client Plugin settings Manage comments Full source code of the frontend Conclusion Introduction A comment system comes in very handy for pretty much any kind of website. In the JAMstack ecosystem, while it\u0026rsquo;s ok to rely on third party solutions hosted on their own platform such as Disqus to enable comments, you usually want to keep your content and all the stuff related to it in the same admin dashboard.\nIn this article, I\u0026rsquo;ll show you how to enable and manage comments for your content very easily using the Comment Manager plugin, and display them in your frontend application.\nPrerequisites You should have a basic understanding of the following.\nBasic knowledge of JavaScript Basic knowledge of React (OPTIONAL) Basic understanding of Strapi - get started here. Your Strapi V4 project setup What is Strapi Comment Manager? Strapi Comment Manager is a plugin that enables comments for pretty much any kind of content. It allows your users to post comments and anyone can get the comments associated with a given slug.\nWith this plugin, admin users can view and manage very easily all the comments from the Strapi administration dashboard. Within the dashboard, you will be able to delete comments and subcomments and leave replies on comments.\nInstallation Once into the Strapi project root, you can install the plugin by running the following command:\nnpm install strapi-plugin-comment-manager Next, build the project to see the new plugin in the dashboard with the following command:\nnpm run build And that\u0026rsquo;s it! If everything runs correctly, the plugin should now be installed.\nConfiguration Now you need to enable some permissions so that the frontend can access the endpoints to post and fetch comments.\nIn your Strapi admin dashboard, head over to Settings, then over to Roles under Users \u0026amp; Permissions Plugin.\nLet\u0026rsquo;s first setup the Public API; click on Public and hit the dropdown button of Comment Manager. Now check count, find and getPageSize, then hit the Save button. Below is a screenshot of a proper configuration:\nNow let\u0026rsquo;s setup the Authenticated API. Go back to Roles and click on Authenticated. Open the dropdown for Comment Manager and mark as checked the option create on both Comment and Subcomment. Below is a screenshot of a proper configuration:\nWith this configuration, the frontend should now be able to make requests to get and post comments.\nDisplay comments on the frontend The plugin exposes an API to get and post comments if you want to have fine-grained control over the workflow of your comments system and you can check the documentation on the package page, but this plugin also comes with a purpose-built React component library that makes it super easy to get up and running without getting your hands dirty.\nThis components library is called strapi-comments-client, fully supports typescript and it handles for you all of the complexity of fetching and posting comments and subcomments for every content ID that you pass to it.\nInstallation of Strapi Comments Client You will need to have installed react ^17.0.2, react-dom ^17.0.2 and react-router-dom ^5.2.0.\nInside of your React project, run this command:\nnpm install strapi-comments-client --save Usage of Strapi Comments Client Using this library is very easy!\nThis library exports three main components:\nCommentsProvider Comments CommentForm And you can import them this way:\nimport { CommentsProvider, Comments, CommentForm } from \u0026#34;strapi-comments-client\u0026#34; All you have to do is wrap your App component into the CommentsProvider component. Then you will be able to place anywhere in your app the Comments component to render a list of comments for a given content ID and the CommentForm component to render a form to post comments.\nFor example, this could be your index.js or main.js file:\nimport React from \u0026#39;react\u0026#39; import ReactDOM from \u0026#39;react-dom\u0026#39; // The address of your strapi backend instance const STRAPI = \u0026#34;http://localhost:1337\u0026#34; ReactDOM.render( \u0026lt;React.StrictMode\u0026gt; \u0026lt;CommentsProvider apiURL={STRAPI}\u0026gt; \u0026lt;App /\u0026gt; \u0026lt;/CommentsProvider\u0026gt; \u0026lt;/React.StrictMode\u0026gt;, document.getElementById(\u0026#39;root\u0026#39;) ) Where apiURL is the URL of your running Strapi application, and this property is required.\nThis way, the comments provider will do all the magic of fetching and posting comments for you!\nThis library also exports an utility React.Context to update some of the parameters for fetching and posting comments:\nimport { CommentsConfigContext } from \u0026#34;strapi-comments-client\u0026#34; This CommentsConfigContext exposes two setter functions: setUser and setContentID\nWith setContentID you can load the comments for a given content and post comments to it. It receives a single parameter of type string and must be URLized, i.e. no spaces.\nWith setUser you can set the credentials of a given user to authorize the posting of comments. It receives a single parameter of type IUser, with the following Typescript interface:\ninterface IUser { username: string, email: string, id: string, token: string // This is a JWT } It\u0026rsquo;s a little confusing but we\u0026rsquo;ll see how to use it in a component:\nconst App = () =\u0026gt; { const { setUser, setContentID } = useContext(CommentsConfigContext) // The following data should come from Strapi Users and Permissions Plugin // for authenticated requests const user = { username: \u0026#34;John Doe\u0026#34;, email: \u0026#34;jhohndoe@gmail.com\u0026#34;, id: 5, token: \u0026#34;this_should_be_a_JWT\u0026#34; } if (user) { setUser(user) } setContentID(\u0026#34;sample-content-1\u0026#34;) // Load comments for this content return ( \u0026lt;\u0026gt; { !user \u0026amp;\u0026amp; \u0026lt;Login /\u0026gt; } \u0026lt;CommentForm /\u0026gt; \u0026lt;Comments /\u0026gt; \u0026lt;/\u0026gt; ) } And that\u0026rsquo;s it!\nAfter setting the content ID through setContentID, CommentsProvider will start loading the comments for the given content ID and the CommentForm will render an input to post comments related to the given content ID if there is a user. Otherwise, it will display the message Login to post a comment.\nHere\u0026rsquo;s how the interface looks like so far:\nThere\u0026rsquo;s also a button to Leave a reply, which will open a form to post a subcomment associated with the parent comment.\nThis library exports one more component: ErrorBox\nimport { ErrorBox } from \u0026#34;strapi-comments-client\u0026#34; .It\u0026rsquo;s useful if you\u0026rsquo;d like to display error messages when things go wrong fetching or posting comments.\nYou can place this component wherever you want, for example in between the CommentForm and the Comments components.\nIf you\u0026rsquo;re wondering how this error box looks like, here you have a sample:\nGeneral settings You can customize the page size, i.e. specify how many comments are returned at once.\nIn the Strapi admin panel, head over to Settings, then select Pagination under Comment Manager Plugin.\nHere you\u0026rsquo;ll find an input to set the page size, which defaults to 10.\nManage comments Once you\u0026rsquo;ve got the plugin up an running, as users start to post comments, you can manage and reply to them as admin from the Comment Manager section of the left sidebar in the Strapi admin dashboard.\nHere you can see two tabs: one for the latest comments and one for comments grouped by content ID.\nIn both of them you can delete comments and subcomments as well as leave replies.\nExample project You can find a full working example of a React App using the Strapi Comments Client Library in this repo\nConclusion With this plugin you can enable and manage comments for any content with little effort and even use a component library to display the comments in your frontend application made with React.\nAnd that\u0026rsquo;s it! The features are pretty basic at the moment but if there\u0026rsquo;s interest, I\u0026rsquo;m willing to work on more features as well as improve the UI/UX.\n","image":"//localhost:1313/images/post/strapilogo.jpg","permalink":"//localhost:1313/blogs/how-to-enable-and-manage-comments-in-your-strapi-application/","tags":["Strapi","Strapi tutorials"],"title":"How To Enable And Manage Comments In Your Strapi Application."},{"categories":["Documentation"],"contents":"Comment Manager is a Strapi plugin to allow your users to post comments.\nWith this plugin you can enable and manage comments for your content very easily!\nRequirements You should have installed an instance of Strapi v4.x.x\nInstallation Run the following command in your project root:\nnpm install strapi-plugin-comment-manager Configurarion For your frontend to have access to the API, enable the following permissions for Comment Manager from Users \u0026amp; Permissions Plugin on your project settings:\nFor public, enable: count, find and getPageSize.\nFor authenticated, enable create on both Comment and Subcomment.\nDisplay comments on the frontend Comments can be displayed in the frontend in two ways:\nUsing the React components library strapi-comments-client (recommended) Build your custom frontend using the API API There are some Typescript interfaces that will help to get an idea of the data structures.\nComments: interface IComment { id: string, from_admin: boolean, createdAt: string, content: string, author: IAuthor | null, subcomments?: ISubcomment[] } Subcomments: interface ISubcomment { id: string, from_admin: boolean, createdAt: string, content: string, author: IAuthor | null, } Authors: IAuthor { username: string, email: string, id: string } The following endpoints are exposed to fetch and post comments and subcomments:\nGet comments for a content ID Method: GET\nPath: /api/comment-manager/comments/:slug\nOptional query parameters: start, ignoreCount\nReturns:\n{ commentsCount?: Number, comments: IComment[] } The parameter start indicates how many comments to skip. This is for pagination purposes.\nThe parameter ignoreCount indicates whether or not to return the total number of comments associated with the given slug.\nGet the number of comments associated with a given content ID Method: GET\nPath: /api/comment-manager/comments/:slug/count\nReturns:\n{ count: Number } Post a comment Method: POST\nPath: /api/comment-manager/comments/:slug\nAuthentication: Bearer token\nPayload:\n{ content: string } Returns:\n{ id: Number } Post a subcomment Method: POST\nPath: /api/comment-manager/subcomments/:parent-id\nAuthentication: Bearer token\nPayload:\n{ content: string } Returns:\n{ id: Number } Get the page size Method: GET\nPath: /api/comment-manager/page-size\nReturns:\n{ pageSize: Number } General settings The plugin allows to set how many comments are returned per page by going to the Pagination section under Comment Manager Plugin on the Settings section.\nThe default page size is 10.\nManagement of comments Admin users are able to delete comments and subcomments as well as leave replies as admins from within the plugin page of the Strapi admin dashboard.\nThe plugin interface has two tabs: one for the latest comments and one for comments by content ID.\nRoadmap and future plans The plugin is pretty basic but it can be improved with more features and a better UI/UX. Collaborations and suggestions are very welcome.\n","image":"//localhost:1313/images/post/strapilogo.jpg","permalink":"//localhost:1313/blogs/strapi-plugin-comment-manager/","tags":["Strapi","Strapi plugins"],"title":"Strapi Plugin Comment Manager"},{"categories":["Projects"],"contents":"In this post I’m going to share my experience on building a SaaS using the headless CMS Strapi as the Backend, React Native and other technologies.\nOutline Introduction What is SaaS? The problem What is Strapi? Developing features in Strapi The frontend: How to get content Conclusion Landing Page Introduction Very often, developers, product and project managers, testers and pretty much the entire team share their ideas to decide what language and which framework they\u0026rsquo;ll use to build their next project. Some considerations must be taken into account, from which in my opinion there are three that are the most important:\nDeveloper experience and ease of use Does the language and framework chosen provide a good developer experience? Is the langauge the same for the backend and frontend?\nDeadlines Is there a deadline to finish the project? if so, there is a good chance to finish the project on time if the team chooses the language they have more experience in.\nMaintainability As there will be usually more than one person working on the same part at the same time, if everything is kept organised, the whole development process will be frictionless.\nWith that in mind, developers and project managers will have a better insight on which language/framework to use.\nOther aspects should also be considered such as what the data structure will look like.\nIn my case, as it is usual, the backend of my project needs a database for users and their roles among other entities and their relations and a dashboard to allow admins to manage the data, and I was lucky to find out Strapi, as it includes a lot of these features out of the box with one single line of command to get started.\nWhat is SaaS? SaaS stands for Software-as-a-Service and it just means that a software is provided as a service in the cloud and it gives a solution to a specific problem, for which the users are willing to pay either monthly or annual subscription.\nThe problem Before starting to write a single line of code, it is generally a good idea to think about the problem, it\u0026rsquo;s limitations and whether or not it has already been solved by someone else (AKA competitors).\nThe problem I was looking into had to do with the way in which public and private transportation companies manage their routes, drivers and users. After a little bit of research, I could only find one platform that provides a similiar solution but for their own company.\nSo the platform I built needed the following content types:\nOrganizations to group routes, drivers and users Routes Two user roles: drivers and users (passengers) As I said before, Strapi makes the creation of these content types and the relationships between them really easy, but let\u0026rsquo;s first see what is Strapi and how it turns the API development into a satisfactory and fun experience.\nWhat is Strapi? Strapi is an open source headless CMS that allows developers to build complete RESTful APIs in just a couple of days instead of months. It includes a lot of useful features as plugins out of the box. Users and Roles management, Media library and an interface to create, view, edit and delete content are just some of them.\nRegarding the API, how does it makes the development faster?\nFirst of all, it enforces a specific folder structure, which helps to keep everything well organised and clean.\nSecondly, all database schemas are generated automatically and queries are made in JSON format, which really saves a lot of time.\nLastly, we can add more features to our Strapi application very easily via plugins from the marketplace.\nIt\u0026rsquo;s also worth noting that Strapi is a self-hosted CMS, which means that we can host it in whatever cloud platform we want, as well as test it locally in our computers before deploying it to the cloud.\nDeveloping features in Strapi Creating and configuring endpoints in Strapi is as straightforward as declaring a JSON in a single file:\nCreating controllers is straightforward as well:\nEvery controller gets all the data related to the request in the ctx parameter and it\u0026rsquo;s also used to send the response. This keeps everything in one place and really helps to improve the readability.\nOnce the API endpoints are defined, the next step is to enable the permissions for the specific user roles to have access to these endpoints:\nThe frontend: how to get content Since Strapi is a headless CMS, it\u0026rsquo;ll only provide content through the API. That means that the content can be consumed from anywhere. In our case, this content will be used in two applications: one for the organization owners and one for the users and drivers.\nThe application for the organization owners is a dashboard where administrators can create organizations, routes, accept drivers and users in the organization and assign routes to drivers. This is just a React Application:\nThe application for drivers and users is a mobile application built in React Native. Firebase was used to synchronise geolocation data in real time between drivers and users and display this information in a Map from Google Maps:\nConclusion Using a CMS as the backend can make the development a lot faster than building the API from scratch and with Strapi this is specially true. Furthermore, this becomes more important when building a brand-new product, as it\u0026rsquo;s usually recommended to launch as soon as possible to gather feedback from the users and validate the idea.\nProject landing page: https://rutieri.netlify.app\n","image":"//localhost:1313/images/post/03.webp","permalink":"//localhost:1313/blogs/how-i-built-a-saas-on-top-of-strapi-and-why-you-should-too/","tags":["Strapi","React Native","Typescript"],"title":"How I Built A SaaS On Top Of Strapi, And Why You Should Too"},{"categories":["Tutorial"],"contents":"Enable User Reviews in a Strapi application and display them in the frontend with React\nOutline Introduction Prerequisites What is Strapi Ratings? Installation Configuration Display user reviews on the frontend Plugin settings Manage user reviews Full source code of the frontend Conclusion Introduction Ratings systems have become a crucial part of any website with ecommerce capabilites, as they allow the users to post reviews on the items they purchase and publish their opinion to the public. A couple of reviews can make the difference between pressing the “Buy” button and moving on to the next website in the Google search results.\nIn this article, I\u0026rsquo;ll show you how to enable and manage user reviews for your content very easily using the Ratings plugin, and display them in your frontend application.\nPrerequisites First of all, you need to have a basic understanding of the following.\nBasic knowledge of JavaScript Basic knowledge of React (OPTIONAL) Basic understanding of Strapi - get started here. Your Strapi V4 project setup What is Strapi Ratings? Strapi Ratings is a plugin that gives your Strapi application the ability to manage ratings for pretty much any kind of content. It allows your users to post reviews and anyone can get the reviews associated with a given slug.\nWith this plugin, admin users can view and manage very easily all the reviews from the Strapi administration dashboard. Within the dashboard, you will be able to see reviews related to content slugs as well as delete reviews.\nInstallation Once into the Strapi project root, you can install the plugin by running the following command:\nnpm install strapi-plugin-ratings Next, build the project to see the new plugin in the dashboard with the following command:\nnpm run build And that\u0026rsquo;s it! If everything runs correctly, the plugin should now be installed.\nConfiguration Now you need to enable some permissions so that the frontend can access the endpoints to post and fetch reviews.\nIn your Strapi admin dashboard, head over to Settings, then over to Roles under Users \u0026amp; Permissions Plugin.\nLet\u0026rsquo;s first setup the Public API; click on Public and hit the dropdown button of Ratings. Now check count, find, getPageSize and getStats, then hit the Save button. Below is a screenshot of a proper configuration:\nNow let\u0026rsquo;s setup the Authenticated API. Go back to Roles and click on Authenticated. Open the dropdown for Ratings and mark as checked the options create, find and getUserReview. Below is a screenshot of a proper configuration:\nWith this configuration, the frontend should now be able to make requests to get and post user reviews.\nDisplay use reviews on the frontend The plugin exposes an API to get and post reviews if you want to have fine-grained control over the workflow of your ratings system and you can check the documentation on the package page, but this plugin also comes with a purpose-built React component library that makes it super easy to get up and running without getting your hands dirty.\nThis components library is called strapi-ratings-client, fully supports typescript and it takes care of all the complexity of fetching and posting user reviews for every content ID that you pass to it.\nInstallation of Strapi Ratings Client You will need to have installed react ^17.0.2, react-dom ^17.0.2, bootstrap ^5.1.3 and @popperjs/core^2.11.2\nInside of your React project, run this command:\nnpm install strapi-ratings-client --save Usage of Strapi Ratings Client Using this library is very easy!\nThis library exports three main components:\nReviewsProvider Reviews ReviewForm And you can import them this way:\nimport { ReviewsProvider, Reviews, ReviewForm } from \u0026#34;strapi-ratings-client\u0026#34; All you have to do is wrap your App component into the ReviewsProvider component. Then you will be able to place anywhere in your app the Reviews component to render a list of user reviews for a given content ID and the ReviewForm component to render a form to allow your users to post reviews.\nFor example, this could be your index.js or main.js file:\nimport React from \u0026#39;react\u0026#39; import ReactDOM from \u0026#39;react-dom\u0026#39; // The address of your strapi backend instance const STRAPI = \u0026#34;http://localhost:1337\u0026#34; ReactDOM.render( \u0026lt;React.StrictMode\u0026gt; \u0026lt;ReviewsProvider apiURL={STRAPI}\u0026gt; \u0026lt;App /\u0026gt; \u0026lt;/ReviewsProvider\u0026gt; \u0026lt;/React.StrictMode\u0026gt;, document.getElementById(\u0026#39;root\u0026#39;) ) Where apiURL is the URL of your running Strapi application, and this property is required.\nThis way, the ratings provider will do all the magic of fetching and posting comments for you!\nThis library also exports an utility React.Context to update some of the parameters for fetching and posting reviews:\nimport { ReviewsConfigContext } from \u0026#34;strapi-ratings-client\u0026#34; This ReviewsConfigContext exposes three setter functions: setUser, setContentID and setCanPostReview.\nWith setContentID you can load the ratings for a given content and post reviews to it. It receives a single parameter of type string and must be URLized, i.e. no spaces.\nWith setUser you can set the credentials of a given user to authorize the posting of reviews. It receives a single parameter of type IUser, with the following Typescript interface:\ninterface IUser { username: string, email: string, id: string, token: string // This is a JWT } With setCanPostReview, you can enable the user to post a review on the given content. This is useful for when you only allow a user to post a review after they purchase the product.\nIt\u0026rsquo;s a little confusing but we\u0026rsquo;ll see how to use it in a component:\nconst App = () =\u0026gt; { const { setUser, setContentID, setCanPostReview } = useContext(ReviewsConfigContext) // The following data should come from Strapi Users and Permissions Plugin // for authenticated requests. const user = { username: \u0026#34;John Doe\u0026#34;, email: \u0026#34;jhohndoe@gmail.com\u0026#34;, id: 5, token: \u0026#34;this_should_be_a_JWT\u0026#34; } if (user) { setUser(user) } setContentID(\u0026#34;sample-content-1\u0026#34;) // Load reviews for this content setCanPostReview(true) // Allow this user to post a review return ( \u0026lt;\u0026gt; { !user \u0026amp;\u0026amp; \u0026lt;Login /\u0026gt; } \u0026lt;ReviewForm /\u0026gt; \u0026lt;Reviews /\u0026gt; \u0026lt;/\u0026gt; ) } And that\u0026rsquo;s it!\nAfter setting the content ID through setContentID, ReviewsProvider will start loading the reviews for the given content ID and the ReviewForm will render an input to post a user review related to the given content ID if there is a user and he’s allowed to post a review. Otherwise, it will display the message Login to post a review or nothing at all if the user is not allowed to post a review.\nHere\u0026rsquo;s how the interface looks like so far:\nThis library exports one more component: ErrorBox\nimport { ErrorBox } from \u0026#34;strapi-ratings-client\u0026#34; .It\u0026rsquo;s useful for when you\u0026rsquo;d like to display error messages when things go wrong fetching or posting reviews.\nYou can place this component wherever you want, for example in between the ReviewForm and the Reviews components.\nIf you\u0026rsquo;re wondering how this error box looks like, here‘s a screenshot:\nGeneral settings You can customize the page size, i.e. specify how many user reviews are showed at once.\nIn the Strapi admin panel, head over to Settings, then select Pagination under Ratings Plugin.\nHere you\u0026rsquo;ll find an input to set the page size, which defaults to 10.\nManage reviews Once you\u0026rsquo;ve got the plugin up an running, as users start to post reviews, you can view them from within the Ratings section of the left sidebar in the Strapi admin dashboard.\nHere you can see two tabs: one for the latest reviews and one for reviews grouped by content ID.\nIn both of them you can delete unwanted reviews.\nExample project You can find a full working example of a React App using the Strapi Ratings Client Library in this repo: https://github.com/luisguve/strapi-ratings-client-example\nConclusion With this plugin you can enable and manage user reviews for any content with little effort and even use a library of components styled with Bootstrap to display the user reviews in your frontend.\nAnd that\u0026rsquo;s it! The features are pretty basic at the moment but if there\u0026rsquo;s interest, I\u0026rsquo;m willing to work on more features as well as improve the UI/UX.\n","image":"//localhost:1313/images/post/tutorial-ratings.webp","permalink":"//localhost:1313/blogs/how-to-enable-and-manage-user-reviews-in-your-strapi-application/","tags":["Strapi","Strapi tutorials"],"title":"How To Enable And Manage User Reviews In Your Strapi Application"},{"categories":["Documentation"],"contents":"Ratings is a Strapi plugin that allows your users to post reviews.\nEnable and manage user reviews for your content very easily!\nRequirements You should have installed an instance of Strapi v4.x.x\nInstallation Run the following command in your project root:\nnpm install strapi-plugin-ratings Then, rebuild the admin dashboard using the following command\nnpm run build Configurarion For your frontend to have access to the API, enable the following permissions for Ratings from Users \u0026amp; Permissions Plugin on your project settings:\nFor public, enable: count, find, getPageSize and getStats.\nFor authenticated, enable create, find and getUserReview.\nDisplay user reviews on the frontend Reviews can be displayed in the frontend in two ways:\nUsing the React components library strapi-ratings-client (recommended) Build your custom frontend using the API endpoints, described as follows: API There are some Typescript interfaces that will help to get an idea of the data structures.\nReviews: interface IReview { id: number, createdAt: string, comment: string | null, author: IAuthor | null, score: number, } Authors: interface IAuthor { username: string, email: string, id: number } Content Stats interface IStats { averageScore: number; reviewsCount: number | null; } The following endpoints are exposed to fetch and post reviews:\nGet reviews for a content ID Method: GET\nPath: /api/ratings/reviews/:slug\nOptional query parameters: start, ignoreCount\nReturns:\n{ reviewsCount: number, averageScore: number, userReview: IReview | null, reviews: IReview[] } The parameter start indicates how many reviews to skip. This is for pagination purposes.\nThe parameter ignoreCount indicates whether or not to return the total number of reviews associated with the given slug.\nGet review stats for a content ID Method: GET\nPath: /api/ratings/reviews/:slug/stats\nReturns:\n{ averageScore: number, reviewsCount: number | null } Get the number of reviews associated with a given content ID Method: GET\nPath: /api/ratings/reviews/:slug/count\nReturns:\n{ count: number } Post a review Method: POST\nPath: /api/ratings/reviews/:slug\nAuthentication: Bearer token\nPayload:\n{ content: string } Returns:\n{ id: number } By default, every authenticated user can post reviews on any content.\nIn order to customize this behavior, e.g. allowing or disallowing a user from posting reviews, you must extend the service userCanPostReview from whithin register function in ./src/index.js. For example:\nstrapi.service(\u0026#34;plugin::ratings.review\u0026#34;).userCanPostReview = async (user, slug) =\u0026gt; { /* Here you will check whether or not the user is allowed to post a review on this content ID and return either true or false. */ return true } Notice that userCanPostReview will receive two parameters: the user from Users \u0026amp; Permissions Plugin, containing it\u0026rsquo;s id, username, confirmed, etc., and the slug, which is a string and refers to the content ID which the review is being posted on.\nIn case this function returns false, the response of the endpoint will be 403 (forbidden) with the text User cannot post a review on this content.\nGet the page size Method: GET\nPath: /api/ratings/page-size\nReturns:\n{ pageSize: number } General settings The plugin allows to set how many reviews are returned per page by going to the Pagination section under Ratings Plugin of the Settings section.\nThe default page size is 10.\nManagement of reviews Admin users are able to delete reviews from within the plugin page of the Strapi admin dashboard.\nThe plugin interface has two tabs: one for the latest reviews and one for reviews by content ID.\nRoadmap and future plans The plugin is pretty basic but it can be improved with more features and a better UI/UX. Collaborations and suggestions are very welcome.\n","image":"//localhost:1313/images/post/ratings.webp","permalink":"//localhost:1313/blogs/strapi-plugin-ratings/","tags":["Strapi","Strapi plugins"],"title":"Strapi Plugin Ratings"},{"categories":["Projects"],"contents":"ManyLMS is an e-learning platform built on top of Strapi, React Router 7, Typescript and other technologies.\nOutline The idea Platform features The stack The API The frontend Conclusion Landing Page The idea This project doesn\u0026rsquo;t necessarily bring a huge amount of innovation on the e-learning platforms that already exists, but it\u0026rsquo;s just another way of doing this type of application.\nThe main idea is to apply a JAMstack approach in this application, where the platform is a static website, and the backend is just an API that serves static content only once to build the website and just adds the dynamism that\u0026rsquo;s necessary to allow users to authenticate, create orders, confirm payments and take courses.\nIf we compare this approach to a WordPress website, we are taking out most of the overhead that implies rendering the pages everytime a user visits them. Despite that there are plugins for caching that may improve the performance, it\u0026rsquo;s still never going to be faster and more efficient than just static content served by a CDN. That\u0026rsquo;s why React Router 7 and Headless CMSs are so popular right now.\nPlatform features and user stories The following user stories illustrates the desired features the platform should have.\nAs an administrator, I want to: login in the admin panel. create categories. create courses. upload lectures. organise courses into categories. assign lectures to courses. As a student, I want to: login in the platform. view the available courses. add courses to the shopping cart. review the shopping cart. create an order. pay with credit card or paypal. view the courses i\u0026rsquo;ve purchased in my learning page. go to the course page from my learning page and watch the videos. mark lectures as seen. come back later and resume where I left. The requirements The backend requires to handle user authentication, permissions, different data structures as content types and define relationships between them. It also requires to allow uploading videos to some third party platform that supports streaming on demand.\nThe frontend is a web platform where users can register and login, view and buy courses, leave comments and reviews and take courses.\nThe API Since all of the features involve authentication, permissions and roles, and because there is no need to reinvent the wheel, I chose to use Strapi to build the backend for it\u0026rsquo;s simplicity, ease of use and great developer experience, whereas for streaming videos on demand, I chose to use Mux.com.\nThe instance of Strapi and the Postgres database it requires was deployed in the cloud hosting platform https://fly.io.\nStrapi is good for managing users, content that\u0026rsquo;s typically updated and fetched via CRUD API, and setting up relations between content types.\nThe platform needs the following content types:\nCategory to group courses Course Lecture Module to group lectures Order Student: has many courses Student-Course: stores a student\u0026rsquo;s current lecture of a course Video Strapi makes the creation of these content types and setting up relationships between them really straightforward.\nBelow are some screenshots of these content types and the relationships between them:\nThe frontend The platform where users are able to login, view, buy and view courses is a web application built with React Router 7. Among the features of this application are:\nState managed by Context API Interface styled with Bootstrap Play streaming videos with @mux/mux-player-react library Use of localStorage to save user session Below are some sample screenshots of how this app looks like\nConclusion and final thoughts While building this project, I learned:\nHow streaming on demand works and how to use a streaming provider How to statically build websites with React Router 7 and Strapi How to setup dynamic pages in React Router 7 How to process payments with Stripe and Paypal How to build custom plugins in Strapi How to publish packages to NPM Project source codes: https://github.com/luisguve/maestro-backend\nhttps://github.com/luisguve/new-lms-remix\n","image":"//localhost:1313/images/project/manylms/frontend/course_overview.png","permalink":"//localhost:1313/projects/e-learning-platform-maestro-lms/","tags":["Strapi","React","React Router 7","Typescript","Mux"],"title":"ManyLMS: E-Learning platform"},{"categories":["Projects"],"contents":"Chile Nativo is a travel tour website for Patagonia experiences, built on top of WordPress with the Themosis framework, featuring a modern frontend implementation based on a Figma design using Vue 3, Laravel Mix, and a comprehensive SCSS architecture.\nOutline The project Design implementation The stack Frontend architecture Key features Conclusion Live website The project Chile Nativo is a travel company specializing in Patagonia tours, offering experiences in destinations like Torres del Paine, Tierra del Fuego, and Isla Navarino. The website serves as the primary platform for showcasing tours, managing bookings, and providing information about their travel experiences.\nThe frontend development was based on a comprehensive Figma design, requiring pixel-perfect implementation of complex UI components, interactive forms, filtering systems, and responsive layouts that work seamlessly across all devices.\nDesign implementation The entire frontend was built from a detailed Figma design, ensuring:\nPixel-perfect accuracy: Matching the design specifications precisely Responsive design: Implementing breakpoints and mobile-first approach Component consistency: Maintaining design system patterns throughout Interactive elements: Translating static designs into dynamic, interactive components Animation and transitions: Implementing smooth user experience enhancements The stack The frontend stack consists of:\nVue 3.2.4: Modern reactive framework for building interactive components Laravel Mix 6.0: Asset compilation and bundling SCSS: Advanced styling with a well-organized architecture Pinia 2.3.1: State management for Vue applications Vee-Validate 4.15.0: Form validation with Yup schemas Axios 1.6.8: HTTP client for API requests Splide.js 4.1.4: Modern carousel and slider components Headroom.js: Header behavior on scroll Plyr 3.7.8: Video player implementation SweetAlert2: Modern alert dialogs jQuery 3.7.1: Legacy support and DOM manipulation utilities Frontend architecture Vue components The application features a comprehensive set of Vue 3 components organized by functionality:\nFiltering and Search Components:\nToursFilter.vue: Advanced tour filtering with multiple criteria TourDatesFilter.vue: Date-based filtering for tour availability ToursFilterDropdown.vue \u0026amp; ToursFilterDropdownMobile.vue: Responsive filter dropdowns TestimonialsFilter.vue: Filtering system for customer testimonials NewsFilter.vue: Blog and news filtering SearchResults.vue: Search results display with pagination Form Components:\nPersonalizedTripForm.vue: Multi-step form for custom trip requests with validation ContactFormSimple.vue: Contact form with reCAPTCHA integration FormHelp.vue: Help center form FormGiftCard.vue: Gift card purchase form FormCareers.vue: Job application form NewsletterForm.vue: Newsletter subscription Card Components:\nTour.vue \u0026amp; TourLoading.vue: Tour card display with loading states TourDate.vue \u0026amp; TourDateLoading.vue: Tour date selection cards Testimonial.vue \u0026amp; TestimonialLoading.vue: Customer testimonial cards Blog.vue \u0026amp; BlogLoading.vue: Blog post cards Team.vue \u0026amp; TeamLoading.vue: Team member cards ResourceCard.vue \u0026amp; ResourceLoading.vue: Resource display cards Utility Components:\nPagination.vue: Reusable pagination component Select.vue: Custom select dropdown with search Loader.vue \u0026amp; LoaderFullScreen.vue: Loading indicators EmptyState.vue: Empty state displays ContentResources.vue: Resource content management TeamTabsFilter.vue: Tabbed team member filtering SCSS architecture The styling follows a well-organized SCSS architecture:\nscss/ ├── abstracts/ # Variables, mixins, functions │ ├── _functions.scss │ ├── _mixins.scss │ ├── _variables.scss │ ├── _mq.scss # Media query mixins │ └── _keyframes.scss ├── base/ # Base styles and typography │ ├── _typography.scss │ ├── _colors.scss │ ├── _fonts.scss │ └── _reset.scss └── components/ # Component-specific styles └── [125 component files] Key SCSS features:\nBEM methodology: Consistent naming convention throughout Media query mixins: Using sass-mq for responsive design Modular architecture: Each component has its own SCSS file Abstract layer: Reusable variables, mixins, and functions Vue transitions: Custom transition styles for Vue components JavaScript architecture The JavaScript is organized into two main entry points:\nMain application (app.js):\nInitializes core application functionality Sets up jQuery plugins and utilities Handles legacy browser support Vue application (vue/main.js):\nConfigures Vue 3 app with Pinia for state management Registers global Vue components Sets up Vee-Validate configuration Integrates third-party Vue plugins (VueTelInput, etc.) Component utilities (app/components/):\nheader.js: Header behavior and navigation footer.js: Footer functionality splide.js: Carousel initialization slick.js: Legacy carousel support accordions.js: Accordion interactions tabs.js: Tab functionality scrollTrigger.js: Scroll-based animations video.js: Video player setup sticky-sidebar.js: Sticky sidebar behavior Key features Multi-step forms The PersonalizedTripForm.vue component implements a sophisticated multi-step form with:\nStep-by-step navigation with progress indicators Form validation using Vee-Validate and Yup schemas Dynamic form fields based on user selections Phone number input with international support (VueTelInput) reCAPTCHA integration for spam protection Loading states and error handling Advanced filtering system The tour filtering system (ToursFilter.vue) provides:\nMultiple filter criteria (destination, activity type, trip type, month) Real-time filtering with URL parameter synchronization Responsive design with mobile accordion interface Custom select components with search functionality Empty states and loading indicators Integration with WordPress backend via Axios Responsive design The entire website is fully responsive with:\nMobile-first approach Breakpoint management using sass-mq Touch-friendly interactions Optimized images and assets Performance optimizations for mobile devices Performance optimizations Code splitting: Laravel Mix extracts vendor libraries Asset versioning: Automatic cache busting Image optimization: Lazy loading and responsive images Minification: Production builds are minified and optimized Tree shaking: Unused code elimination in production Accessibility Semantic HTML structure ARIA labels where appropriate Keyboard navigation support Focus management in forms Screen reader considerations Development workflow The project uses Laravel Mix for asset compilation:\n// Development npm run dev // Compile assets npm run watch // Watch for changes npm run hot // Hot module replacement // Production npm run production // Optimized production build BrowserSync integration provides:\nLive reloading during development Synchronized browser testing Proxy configuration for WordPress development Conclusion and final thoughts Building the Chile Nativo frontend from a Figma design was an excellent opportunity to:\nMaster Vue 3: Working with the Composition API, reactive systems, and modern Vue patterns Implement complex forms: Multi-step forms with validation, international phone inputs, and reCAPTCHA Build scalable architecture: Organizing 40+ Vue components and 125+ SCSS files in a maintainable structure Optimize performance: Implementing code splitting, lazy loading, and production optimizations Ensure design fidelity: Translating Figma designs into pixel-perfect implementations Handle responsive design: Creating seamless experiences across all device sizes The project demonstrates proficiency in:\nModern JavaScript frameworks (Vue 3) Build tools and asset compilation (Laravel Mix, Webpack) CSS architecture and methodologies (SCSS, BEM) Form validation and user experience Component-based development Design system implementation The integration with WordPress/Themosis backend required careful consideration of server-side rendering, API endpoints, and content management workflows, making this a full-stack frontend implementation.\nLive website: https://chilenativo.travel/\nFigma prototype: https://www.figma.com/proto/ywHPhSP1UfYUAE8eWVQv4L/Dise%C3%B1o-Desktop---Chile-Nativo?node-id=289-3912\u0026m=dev\u0026scaling=min-zoom\u0026content-scaling=fixed\u0026page-id=289%3A3911\u0026starting-point-node-id=289%3A3912\n","image":"//localhost:1313/images/project/chile-nativo/home.png","permalink":"//localhost:1313/projects/chile-nativo-patagonia-travel-website/","tags":["Vue 3","Laravel Mix","WordPress","Themosis","SCSS","JavaScript","Figma"],"title":"Chile Nativo: Patagonia Travel Website"},{"categories":["Projects"],"contents":"Rutieri is a SaaS platform built with Strapi, React Native, Typescript and other technologies.\nOutline The idea Platform features The stack The API The frontend The mobile app Conclusion Landing Page The idea Before starting to write a single line of code, it is generally a good idea to think about the problem, it\u0026rsquo;s limitations and whether or not it has already been solved by someone else (AKA competitors).\nThe problem I was looking into had to do with the way in which public and private transportation companies manage their routes, drivers and users. This process is generally carried out on paper, e.g. not digital, hence this could be problematic in case of new drivers joining the organization or in case of restricting access to data to only specific users.\nAfter a little bit of research, I could only find one platform that provides a similiar solution but for their own company.\nPlatform features and user stories The following user stories illustrates the desired features the platform should have in order to solve the aforementioned problems.\nAs an administrator user, I want to: login in the admin panel. create an organization. create routes in the organization. invite drivers and users to the organization. manage requests to join the organization. assign routes to drivers in the organization. see in real time the drivers and users currently active in the map of the different routes. As a driver, I want to: login in the mobile app. join an organization by entering the code in the search bar. see my route on the map. become visible to passengers on the road. see the passengers waiting on the road. remove my visibility and finish my run. As a passenger, I want to: login in the mobile app. join an organization by entering the code in the search bar. see the different routes of my organization in the map. search for a destination and get the available routes that pass nearby. see the drivers currently active on the routes in real time. become visible to drivers of a route. The requirements The backend requires to handle user authentication, permissions, different data structures as content types and define relations between them. It\u0026rsquo;s also necessary to synchronise passengers and drivers and view them on a map real time in the administration panel as well as in the mobile app.\nThe administration panel is a web page that fetches data from the backend as well as from the real time data provider and it\u0026rsquo;s goal is to provide a way for administrators to manage their organization and users. We\u0026rsquo;re talking about a Single Page Application built in React.\nAs for the mobile application, there isn\u0026rsquo;t a better choice nowadays than React Native and it works just fine in this case.\nThe API Since all of the features involve authentication, permissions and roles, and because there is no need to reinvent the wheel, I chose to use Strapi to build the backend for it\u0026rsquo;s simplicity, ease of use and great developer experience, whereas for realtime data, I used Firebase.\nThe instance of Strapi and the Postgres database it requires was deployed in the cloud hosting platform https://fly.io.\nStrapi is good for managing users, content that\u0026rsquo;s typically updated and fetched via CRUD API, and relations between content types.\nThe platform needs the following content types:\nOrganizations to group routes, drivers and users Routes Two user roles: drivers and users (passengers) Below are some screenshots of the overview of these content types\nAs I said before, Strapi makes the creation of these content types and the relationships between them really straightforward.\nHowever, not everything related to the API can be provided by Strapi. Some realtime features need to be addressed with other solutions, such as geolocation data in real time for drivers and users to synchronise each other, maps and the ability to search for places. Such features were implemented using Firebase, Google Maps and Google Places.\nThe frontend The platform where users are able to login as administrators and manage their organizations and users is a single page web application built in React. Among the features of this project that I think stand out are:\nState managed by Context API Interface styled with Bootstrap React Router for pages Leaflet to display the map GeoFire library to synchronise geolocation data in real time with Firebase Use of localStorage to save user session Below are some sample screenshots of how this app looks like\nThe mobile application This one is by far the most complex part of this project.\nThe project was bootstraped with Infinitered\u0026rsquo;s Ignite, which provides a great boilerplate and surely saved me of what would have been between 1-2 months of work.\nIgnite\u0026rsquo;s boilerplate includes many features out of the box, including:\nReact Native and Typescript (of course) React Navigation MobX-State-Tree for state management Expo SDK for developer experience AsyncStorage for persistence apisauce as REST client And some other libraries and features that make React Native apps super powerful and a joy to work on.\nIt consists of three screens:\nWelcome screen Login screen Map screen In the welcome screen, users are able to go to the login screen if not logged in. Otherwise, if they\u0026rsquo;re in an organisation, it shows their role and org\u0026rsquo;s information, and if they\u0026rsquo;re not, they are able to enter the organisation code and request to join as driver or as passenger.\nWelcome screens Login screens If the user is a driver in an organisation, the welcome screen also shows the route assigned to them. By tapping on it, it takes them to the map, where they can see themselves and start the tour, becoming visible to passengers on the road but being able to see passengers on the road as well.\nDrivers can finish the tour at any time by pressing the button stop.\nIf the user is a passenger in an organisation, the welcome screen shows the different routes available in the organisation. By tapping on them, they are taken to the map where they can see themselves, the route and the drivers on the road.\nPassengers are able to navigate between the available routes and search for the location they want to go to by using the search bar at the top of the map screen, filtering out the routes that pass nearby (less than 200 meters), if there are. Google Places API and turf library work together in this search process.\nPassengers become visible to drivers on the road by pressing the button wait and if they press the button again, they stop waiting and are removed from the driver\u0026rsquo;s map.\nMap screens The start/wait and finish buttons dispatch actions that update their location in firebase, so that passengers are able to see the bus on the map as it moves in real time and viceversa.\nAs for the state management, the project consists of two models and three stores from Mobx-State-Tree library: User and Route models, user-status, route-store and root-store stores.\nUser model Located in /app/models/user/user.ts\nconst OrganizationModel = types.model({ name: types.string, code: types.string, id: types.identifierNumber, drivers: types.number, rutas: types.array(RouteModel) }) const UserModel = types .model(\u0026#34;User\u0026#34;) .props({ id: types.identifierNumber, username: types.string, email: types.string, token: types.string, role: types.union(types.literal(\u0026#34;passenger\u0026#34;), types.literal(\u0026#34;driver\u0026#34;)), ruta: types.maybeNull(RouteModel), organization: types.maybeNull(OrganizationModel), pending_request: types.maybeNull(OrganizationModel), }) Route model Located in /app/models/route/route.ts\nThis model follows the GeoJSON format for routes.\nconst RouteModel = types .model(\u0026#34;Ruta\u0026#34;) .props({ id: types.identifierNumber, name: types.string, latlong: types.maybeNull(types.model({ lat: types.number, longt: types.number })), coords: types.model({ type: FeatureTypes, features: types.array(types.model({ type: types.string, geometry: types.model({ type: types.string, coordinates: types.union(types.array(types.number), types.array(types.array(types.number))) }), properties: types.model({ name: types.string }) })) }) }) user-status store Located in /app/models/user-status/user-status.ts\nThis store is responsible for managing the state of the user. It stores the user once it\u0026rsquo;s logged in and removes it when the user logs out. It also has some views to get the user key for firebase purposes, get the role and get the route in case of a driver.\nThis store has some methods that get the user location from the device\u0026rsquo;s GPS, displays the user icon on the map and sends it to firebase.\nconst UserStatusModel = types .model(\u0026#34;UserStatus\u0026#34;) .extend(withEnvironment) .props({ user: types.maybeNull(UserModel), location: types.maybeNull( types.model({latitude: types.number, longitude: types.number}) ), visibility: types.maybeNull(types.number) }) route-store store Located in /app/models/route-store/route-store.ts\nThis store is responsible for managing the state of the available routes. It stores the routes, drivers and passengers on the different routes. It also has some view methods to filter the routes that pass nearby a destination specified by the user, get passengers waiting on a given route and get drivers active in a specific route.\nThis store initializes a GeoQuery from Geofire library and listens for events to set, update and remove drivers and passengers from the map as they move.\nconst RouteStoreModel = types .model(\u0026#34;RouteStore\u0026#34;) .props({ routes: types.array(RouteModel), passengers: types.map(types.model({ key: types.identifier, location: types.array(types.number) })), drivers: types.map(types.model({ key: types.identifier, location: types.array(types.number) })), destinationAddress: types.maybeNull(types.model({ name: types.string, coords: types.array(types.number) })) }) Conclusion and final thoughts Using a CMS as the backend can make the development a lot faster than building the API from scratch and with Strapi this is specially true. On the other hand, Strapi doesn\u0026rsquo;t really make a good fit for real time applications, therefore, Firebase is the way to go in this case.\nAs of the client side, React always works very good for pretty much any kind of application, and because React Native uses React under the hood, it is so convenient for us React developers and ir works pretty good for almost any kind of application as well.\nHowever, one thing that I didn\u0026rsquo;t mention in this post was the use of Typescript; I find this quote by Brice Wilson pretty good to point out the whole purpose and motivation to learn and use (well) this powerful language and tool ecosystem:\n\u0026ldquo;You won\u0026rsquo;t have to wait for a frustrated user to report the error. All of this means that you provide value to your users faster, and that\u0026rsquo;s really what it\u0026rsquo;s all about.\u0026rdquo;\nAll in all, I got a lot of learning by building this project, both in languages/frameworks used and production stuff such as infrastructure, cloud hosting and cloud-based APIs.\nProject landing page: https://rutieri.netlify.app\n","image":"//localhost:1313/images/project/rutieri/landing/homepage.webp","permalink":"//localhost:1313/projects/saas-platform-rutieri/","tags":["Strapi","React Native","React","Typescript","Firebase"],"title":"SaaS platform: Rutieri"},{"categories":["Tutorial"],"contents":"Enable comments in a Strapi application and display them in the frontend with React\nOutline Introduction Prerequisites What is Strapi Comment Manager? Installation Configuration Display comments on the frontend Installation of Strapi Comments Client Usage of Strapi Comments Client Plugin settings Manage comments Full source code of the frontend Conclusion Introduction A comment system comes in very handy for pretty much any kind of website. In the JAMstack ecosystem, while it\u0026rsquo;s ok to rely on third party solutions hosted on their own platform such as Disqus to enable comments, you usually want to keep your content and all the stuff related to it in the same admin dashboard.\nIn this article, I\u0026rsquo;ll show you how to enable and manage comments for your content very easily using the Comment Manager plugin, and display them in your frontend application.\nPrerequisites You should have a basic understanding of the following.\nBasic knowledge of JavaScript Basic knowledge of React (OPTIONAL) Basic understanding of Strapi - get started here. Your Strapi V4 project setup What is Strapi Comment Manager? Strapi Comment Manager is a plugin that enables comments for pretty much any kind of content. It allows your users to post comments and anyone can get the comments associated with a given slug.\nWith this plugin, admin users can view and manage very easily all the comments from the Strapi administration dashboard. Within the dashboard, you will be able to delete comments and subcomments and leave replies on comments.\nInstallation Once into the Strapi project root, you can install the plugin by running the following command:\nnpm install strapi-plugin-comment-manager Next, build the project to see the new plugin in the dashboard with the following command:\nnpm run build And that\u0026rsquo;s it! If everything runs correctly, the plugin should now be installed.\nConfiguration Now you need to enable some permissions so that the frontend can access the endpoints to post and fetch comments.\nIn your Strapi admin dashboard, head over to Settings, then over to Roles under Users \u0026amp; Permissions Plugin.\nLet\u0026rsquo;s first setup the Public API; click on Public and hit the dropdown button of Comment Manager. Now check count, find and getPageSize, then hit the Save button. Below is a screenshot of a proper configuration:\nNow let\u0026rsquo;s setup the Authenticated API. Go back to Roles and click on Authenticated. Open the dropdown for Comment Manager and mark as checked the option create on both Comment and Subcomment. Below is a screenshot of a proper configuration:\nWith this configuration, the frontend should now be able to make requests to get and post comments.\nDisplay comments on the frontend The plugin exposes an API to get and post comments if you want to have fine-grained control over the workflow of your comments system and you can check the documentation on the package page, but this plugin also comes with a purpose-built React component library that makes it super easy to get up and running without getting your hands dirty.\nThis components library is called strapi-comments-client, fully supports typescript and it handles for you all of the complexity of fetching and posting comments and subcomments for every content ID that you pass to it.\nInstallation of Strapi Comments Client You will need to have installed react ^17.0.2, react-dom ^17.0.2 and react-router-dom ^5.2.0.\nInside of your React project, run this command:\nnpm install strapi-comments-client --save Usage of Strapi Comments Client Using this library is very easy!\nThis library exports three main components:\nCommentsProvider Comments CommentForm And you can import them this way:\nimport { CommentsProvider, Comments, CommentForm } from \u0026#34;strapi-comments-client\u0026#34; All you have to do is wrap your App component into the CommentsProvider component. Then you will be able to place anywhere in your app the Comments component to render a list of comments for a given content ID and the CommentForm component to render a form to post comments.\nFor example, this could be your index.js or main.js file:\nimport React from \u0026#39;react\u0026#39; import ReactDOM from \u0026#39;react-dom\u0026#39; // The address of your strapi backend instance const STRAPI = \u0026#34;http://localhost:1337\u0026#34; ReactDOM.render( \u0026lt;React.StrictMode\u0026gt; \u0026lt;CommentsProvider apiURL={STRAPI}\u0026gt; \u0026lt;App /\u0026gt; \u0026lt;/CommentsProvider\u0026gt; \u0026lt;/React.StrictMode\u0026gt;, document.getElementById(\u0026#39;root\u0026#39;) ) Where apiURL is the URL of your running Strapi application, and this property is required.\nThis way, the comments provider will do all the magic of fetching and posting comments for you!\nThis library also exports an utility React.Context to update some of the parameters for fetching and posting comments:\nimport { CommentsConfigContext } from \u0026#34;strapi-comments-client\u0026#34; This CommentsConfigContext exposes two setter functions: setUser and setContentID\nWith setContentID you can load the comments for a given content and post comments to it. It receives a single parameter of type string and must be URLized, i.e. no spaces.\nWith setUser you can set the credentials of a given user to authorize the posting of comments. It receives a single parameter of type IUser, with the following Typescript interface:\ninterface IUser { username: string, email: string, id: string, token: string // This is a JWT } It\u0026rsquo;s a little confusing but we\u0026rsquo;ll see how to use it in a component:\nconst App = () =\u0026gt; { const { setUser, setContentID } = useContext(CommentsConfigContext) // The following data should come from Strapi Users and Permissions Plugin // for authenticated requests const user = { username: \u0026#34;John Doe\u0026#34;, email: \u0026#34;jhohndoe@gmail.com\u0026#34;, id: 5, token: \u0026#34;this_should_be_a_JWT\u0026#34; } if (user) { setUser(user) } setContentID(\u0026#34;sample-content-1\u0026#34;) // Load comments for this content return ( \u0026lt;\u0026gt; { !user \u0026amp;\u0026amp; \u0026lt;Login /\u0026gt; } \u0026lt;CommentForm /\u0026gt; \u0026lt;Comments /\u0026gt; \u0026lt;/\u0026gt; ) } And that\u0026rsquo;s it!\nAfter setting the content ID through setContentID, CommentsProvider will start loading the comments for the given content ID and the CommentForm will render an input to post comments related to the given content ID if there is a user. Otherwise, it will display the message Login to post a comment.\nHere\u0026rsquo;s how the interface looks like so far:\nThere\u0026rsquo;s also a button to Leave a reply, which will open a form to post a subcomment associated with the parent comment.\nThis library exports one more component: ErrorBox\nimport { ErrorBox } from \u0026#34;strapi-comments-client\u0026#34; .It\u0026rsquo;s useful if you\u0026rsquo;d like to display error messages when things go wrong fetching or posting comments.\nYou can place this component wherever you want, for example in between the CommentForm and the Comments components.\nIf you\u0026rsquo;re wondering how this error box looks like, here you have a sample:\nGeneral settings You can customize the page size, i.e. specify how many comments are returned at once.\nIn the Strapi admin panel, head over to Settings, then select Pagination under Comment Manager Plugin.\nHere you\u0026rsquo;ll find an input to set the page size, which defaults to 10.\nManage comments Once you\u0026rsquo;ve got the plugin up an running, as users start to post comments, you can manage and reply to them as admin from the Comment Manager section of the left sidebar in the Strapi admin dashboard.\nHere you can see two tabs: one for the latest comments and one for comments grouped by content ID.\nIn both of them you can delete comments and subcomments as well as leave replies.\nExample project You can find a full working example of a React App using the Strapi Comments Client Library in this repo\nConclusion With this plugin you can enable and manage comments for any content with little effort and even use a component library to display the comments in your frontend application made with React.\nAnd that\u0026rsquo;s it! The features are pretty basic at the moment but if there\u0026rsquo;s interest, I\u0026rsquo;m willing to work on more features as well as improve the UI/UX.\n","image":"//localhost:1313/images/post/strapilogo.jpg","permalink":"//localhost:1313/blogs/how-to-enable-and-manage-comments-in-your-strapi-application/","tags":["Strapi","Strapi tutorials"],"title":"How To Enable And Manage Comments In Your Strapi Application."},{"categories":["Documentation"],"contents":"Comment Manager is a Strapi plugin to allow your users to post comments.\nWith this plugin you can enable and manage comments for your content very easily!\nRequirements You should have installed an instance of Strapi v4.x.x\nInstallation Run the following command in your project root:\nnpm install strapi-plugin-comment-manager Configurarion For your frontend to have access to the API, enable the following permissions for Comment Manager from Users \u0026amp; Permissions Plugin on your project settings:\nFor public, enable: count, find and getPageSize.\nFor authenticated, enable create on both Comment and Subcomment.\nDisplay comments on the frontend Comments can be displayed in the frontend in two ways:\nUsing the React components library strapi-comments-client (recommended) Build your custom frontend using the API API There are some Typescript interfaces that will help to get an idea of the data structures.\nComments: interface IComment { id: string, from_admin: boolean, createdAt: string, content: string, author: IAuthor | null, subcomments?: ISubcomment[] } Subcomments: interface ISubcomment { id: string, from_admin: boolean, createdAt: string, content: string, author: IAuthor | null, } Authors: IAuthor { username: string, email: string, id: string } The following endpoints are exposed to fetch and post comments and subcomments:\nGet comments for a content ID Method: GET\nPath: /api/comment-manager/comments/:slug\nOptional query parameters: start, ignoreCount\nReturns:\n{ commentsCount?: Number, comments: IComment[] } The parameter start indicates how many comments to skip. This is for pagination purposes.\nThe parameter ignoreCount indicates whether or not to return the total number of comments associated with the given slug.\nGet the number of comments associated with a given content ID Method: GET\nPath: /api/comment-manager/comments/:slug/count\nReturns:\n{ count: Number } Post a comment Method: POST\nPath: /api/comment-manager/comments/:slug\nAuthentication: Bearer token\nPayload:\n{ content: string } Returns:\n{ id: Number } Post a subcomment Method: POST\nPath: /api/comment-manager/subcomments/:parent-id\nAuthentication: Bearer token\nPayload:\n{ content: string } Returns:\n{ id: Number } Get the page size Method: GET\nPath: /api/comment-manager/page-size\nReturns:\n{ pageSize: Number } General settings The plugin allows to set how many comments are returned per page by going to the Pagination section under Comment Manager Plugin on the Settings section.\nThe default page size is 10.\nManagement of comments Admin users are able to delete comments and subcomments as well as leave replies as admins from within the plugin page of the Strapi admin dashboard.\nThe plugin interface has two tabs: one for the latest comments and one for comments by content ID.\nRoadmap and future plans The plugin is pretty basic but it can be improved with more features and a better UI/UX. Collaborations and suggestions are very welcome.\n","image":"//localhost:1313/images/post/strapilogo.jpg","permalink":"//localhost:1313/blogs/strapi-plugin-comment-manager/","tags":["Strapi","Strapi plugins"],"title":"Strapi Plugin Comment Manager"},{"categories":["Projects"],"contents":"In this post I’m going to share my experience on building a SaaS using the headless CMS Strapi as the Backend, React Native and other technologies.\nOutline Introduction What is SaaS? The problem What is Strapi? Developing features in Strapi The frontend: How to get content Conclusion Landing Page Introduction Very often, developers, product and project managers, testers and pretty much the entire team share their ideas to decide what language and which framework they\u0026rsquo;ll use to build their next project. Some considerations must be taken into account, from which in my opinion there are three that are the most important:\nDeveloper experience and ease of use Does the language and framework chosen provide a good developer experience? Is the langauge the same for the backend and frontend?\nDeadlines Is there a deadline to finish the project? if so, there is a good chance to finish the project on time if the team chooses the language they have more experience in.\nMaintainability As there will be usually more than one person working on the same part at the same time, if everything is kept organised, the whole development process will be frictionless.\nWith that in mind, developers and project managers will have a better insight on which language/framework to use.\nOther aspects should also be considered such as what the data structure will look like.\nIn my case, as it is usual, the backend of my project needs a database for users and their roles among other entities and their relations and a dashboard to allow admins to manage the data, and I was lucky to find out Strapi, as it includes a lot of these features out of the box with one single line of command to get started.\nWhat is SaaS? SaaS stands for Software-as-a-Service and it just means that a software is provided as a service in the cloud and it gives a solution to a specific problem, for which the users are willing to pay either monthly or annual subscription.\nThe problem Before starting to write a single line of code, it is generally a good idea to think about the problem, it\u0026rsquo;s limitations and whether or not it has already been solved by someone else (AKA competitors).\nThe problem I was looking into had to do with the way in which public and private transportation companies manage their routes, drivers and users. After a little bit of research, I could only find one platform that provides a similiar solution but for their own company.\nSo the platform I built needed the following content types:\nOrganizations to group routes, drivers and users Routes Two user roles: drivers and users (passengers) As I said before, Strapi makes the creation of these content types and the relationships between them really easy, but let\u0026rsquo;s first see what is Strapi and how it turns the API development into a satisfactory and fun experience.\nWhat is Strapi? Strapi is an open source headless CMS that allows developers to build complete RESTful APIs in just a couple of days instead of months. It includes a lot of useful features as plugins out of the box. Users and Roles management, Media library and an interface to create, view, edit and delete content are just some of them.\nRegarding the API, how does it makes the development faster?\nFirst of all, it enforces a specific folder structure, which helps to keep everything well organised and clean.\nSecondly, all database schemas are generated automatically and queries are made in JSON format, which really saves a lot of time.\nLastly, we can add more features to our Strapi application very easily via plugins from the marketplace.\nIt\u0026rsquo;s also worth noting that Strapi is a self-hosted CMS, which means that we can host it in whatever cloud platform we want, as well as test it locally in our computers before deploying it to the cloud.\nDeveloping features in Strapi Creating and configuring endpoints in Strapi is as straightforward as declaring a JSON in a single file:\nCreating controllers is straightforward as well:\nEvery controller gets all the data related to the request in the ctx parameter and it\u0026rsquo;s also used to send the response. This keeps everything in one place and really helps to improve the readability.\nOnce the API endpoints are defined, the next step is to enable the permissions for the specific user roles to have access to these endpoints:\nThe frontend: how to get content Since Strapi is a headless CMS, it\u0026rsquo;ll only provide content through the API. That means that the content can be consumed from anywhere. In our case, this content will be used in two applications: one for the organization owners and one for the users and drivers.\nThe application for the organization owners is a dashboard where administrators can create organizations, routes, accept drivers and users in the organization and assign routes to drivers. This is just a React Application:\nThe application for drivers and users is a mobile application built in React Native. Firebase was used to synchronise geolocation data in real time between drivers and users and display this information in a Map from Google Maps:\nConclusion Using a CMS as the backend can make the development a lot faster than building the API from scratch and with Strapi this is specially true. Furthermore, this becomes more important when building a brand-new product, as it\u0026rsquo;s usually recommended to launch as soon as possible to gather feedback from the users and validate the idea.\nProject landing page: https://rutieri.netlify.app\n","image":"//localhost:1313/images/post/03.webp","permalink":"//localhost:1313/blogs/how-i-built-a-saas-on-top-of-strapi-and-why-you-should-too/","tags":["Strapi","React Native","Typescript"],"title":"How I Built A SaaS On Top Of Strapi, And Why You Should Too"},{"categories":["Tutorial"],"contents":"Enable User Reviews in a Strapi application and display them in the frontend with React\nOutline Introduction Prerequisites What is Strapi Ratings? Installation Configuration Display user reviews on the frontend Plugin settings Manage user reviews Full source code of the frontend Conclusion Introduction Ratings systems have become a crucial part of any website with ecommerce capabilites, as they allow the users to post reviews on the items they purchase and publish their opinion to the public. A couple of reviews can make the difference between pressing the “Buy” button and moving on to the next website in the Google search results.\nIn this article, I\u0026rsquo;ll show you how to enable and manage user reviews for your content very easily using the Ratings plugin, and display them in your frontend application.\nPrerequisites First of all, you need to have a basic understanding of the following.\nBasic knowledge of JavaScript Basic knowledge of React (OPTIONAL) Basic understanding of Strapi - get started here. Your Strapi V4 project setup What is Strapi Ratings? Strapi Ratings is a plugin that gives your Strapi application the ability to manage ratings for pretty much any kind of content. It allows your users to post reviews and anyone can get the reviews associated with a given slug.\nWith this plugin, admin users can view and manage very easily all the reviews from the Strapi administration dashboard. Within the dashboard, you will be able to see reviews related to content slugs as well as delete reviews.\nInstallation Once into the Strapi project root, you can install the plugin by running the following command:\nnpm install strapi-plugin-ratings Next, build the project to see the new plugin in the dashboard with the following command:\nnpm run build And that\u0026rsquo;s it! If everything runs correctly, the plugin should now be installed.\nConfiguration Now you need to enable some permissions so that the frontend can access the endpoints to post and fetch reviews.\nIn your Strapi admin dashboard, head over to Settings, then over to Roles under Users \u0026amp; Permissions Plugin.\nLet\u0026rsquo;s first setup the Public API; click on Public and hit the dropdown button of Ratings. Now check count, find, getPageSize and getStats, then hit the Save button. Below is a screenshot of a proper configuration:\nNow let\u0026rsquo;s setup the Authenticated API. Go back to Roles and click on Authenticated. Open the dropdown for Ratings and mark as checked the options create, find and getUserReview. Below is a screenshot of a proper configuration:\nWith this configuration, the frontend should now be able to make requests to get and post user reviews.\nDisplay use reviews on the frontend The plugin exposes an API to get and post reviews if you want to have fine-grained control over the workflow of your ratings system and you can check the documentation on the package page, but this plugin also comes with a purpose-built React component library that makes it super easy to get up and running without getting your hands dirty.\nThis components library is called strapi-ratings-client, fully supports typescript and it takes care of all the complexity of fetching and posting user reviews for every content ID that you pass to it.\nInstallation of Strapi Ratings Client You will need to have installed react ^17.0.2, react-dom ^17.0.2, bootstrap ^5.1.3 and @popperjs/core^2.11.2\nInside of your React project, run this command:\nnpm install strapi-ratings-client --save Usage of Strapi Ratings Client Using this library is very easy!\nThis library exports three main components:\nReviewsProvider Reviews ReviewForm And you can import them this way:\nimport { ReviewsProvider, Reviews, ReviewForm } from \u0026#34;strapi-ratings-client\u0026#34; All you have to do is wrap your App component into the ReviewsProvider component. Then you will be able to place anywhere in your app the Reviews component to render a list of user reviews for a given content ID and the ReviewForm component to render a form to allow your users to post reviews.\nFor example, this could be your index.js or main.js file:\nimport React from \u0026#39;react\u0026#39; import ReactDOM from \u0026#39;react-dom\u0026#39; // The address of your strapi backend instance const STRAPI = \u0026#34;http://localhost:1337\u0026#34; ReactDOM.render( \u0026lt;React.StrictMode\u0026gt; \u0026lt;ReviewsProvider apiURL={STRAPI}\u0026gt; \u0026lt;App /\u0026gt; \u0026lt;/ReviewsProvider\u0026gt; \u0026lt;/React.StrictMode\u0026gt;, document.getElementById(\u0026#39;root\u0026#39;) ) Where apiURL is the URL of your running Strapi application, and this property is required.\nThis way, the ratings provider will do all the magic of fetching and posting comments for you!\nThis library also exports an utility React.Context to update some of the parameters for fetching and posting reviews:\nimport { ReviewsConfigContext } from \u0026#34;strapi-ratings-client\u0026#34; This ReviewsConfigContext exposes three setter functions: setUser, setContentID and setCanPostReview.\nWith setContentID you can load the ratings for a given content and post reviews to it. It receives a single parameter of type string and must be URLized, i.e. no spaces.\nWith setUser you can set the credentials of a given user to authorize the posting of reviews. It receives a single parameter of type IUser, with the following Typescript interface:\ninterface IUser { username: string, email: string, id: string, token: string // This is a JWT } With setCanPostReview, you can enable the user to post a review on the given content. This is useful for when you only allow a user to post a review after they purchase the product.\nIt\u0026rsquo;s a little confusing but we\u0026rsquo;ll see how to use it in a component:\nconst App = () =\u0026gt; { const { setUser, setContentID, setCanPostReview } = useContext(ReviewsConfigContext) // The following data should come from Strapi Users and Permissions Plugin // for authenticated requests. const user = { username: \u0026#34;John Doe\u0026#34;, email: \u0026#34;jhohndoe@gmail.com\u0026#34;, id: 5, token: \u0026#34;this_should_be_a_JWT\u0026#34; } if (user) { setUser(user) } setContentID(\u0026#34;sample-content-1\u0026#34;) // Load reviews for this content setCanPostReview(true) // Allow this user to post a review return ( \u0026lt;\u0026gt; { !user \u0026amp;\u0026amp; \u0026lt;Login /\u0026gt; } \u0026lt;ReviewForm /\u0026gt; \u0026lt;Reviews /\u0026gt; \u0026lt;/\u0026gt; ) } And that\u0026rsquo;s it!\nAfter setting the content ID through setContentID, ReviewsProvider will start loading the reviews for the given content ID and the ReviewForm will render an input to post a user review related to the given content ID if there is a user and he’s allowed to post a review. Otherwise, it will display the message Login to post a review or nothing at all if the user is not allowed to post a review.\nHere\u0026rsquo;s how the interface looks like so far:\nThis library exports one more component: ErrorBox\nimport { ErrorBox } from \u0026#34;strapi-ratings-client\u0026#34; .It\u0026rsquo;s useful for when you\u0026rsquo;d like to display error messages when things go wrong fetching or posting reviews.\nYou can place this component wherever you want, for example in between the ReviewForm and the Reviews components.\nIf you\u0026rsquo;re wondering how this error box looks like, here‘s a screenshot:\nGeneral settings You can customize the page size, i.e. specify how many user reviews are showed at once.\nIn the Strapi admin panel, head over to Settings, then select Pagination under Ratings Plugin.\nHere you\u0026rsquo;ll find an input to set the page size, which defaults to 10.\nManage reviews Once you\u0026rsquo;ve got the plugin up an running, as users start to post reviews, you can view them from within the Ratings section of the left sidebar in the Strapi admin dashboard.\nHere you can see two tabs: one for the latest reviews and one for reviews grouped by content ID.\nIn both of them you can delete unwanted reviews.\nExample project You can find a full working example of a React App using the Strapi Ratings Client Library in this repo: https://github.com/luisguve/strapi-ratings-client-example\nConclusion With this plugin you can enable and manage user reviews for any content with little effort and even use a library of components styled with Bootstrap to display the user reviews in your frontend.\nAnd that\u0026rsquo;s it! The features are pretty basic at the moment but if there\u0026rsquo;s interest, I\u0026rsquo;m willing to work on more features as well as improve the UI/UX.\n","image":"//localhost:1313/images/post/tutorial-ratings.webp","permalink":"//localhost:1313/blogs/how-to-enable-and-manage-user-reviews-in-your-strapi-application/","tags":["Strapi","Strapi tutorials"],"title":"How To Enable And Manage User Reviews In Your Strapi Application"},{"categories":["Documentation"],"contents":"Ratings is a Strapi plugin that allows your users to post reviews.\nEnable and manage user reviews for your content very easily!\nRequirements You should have installed an instance of Strapi v4.x.x\nInstallation Run the following command in your project root:\nnpm install strapi-plugin-ratings Then, rebuild the admin dashboard using the following command\nnpm run build Configurarion For your frontend to have access to the API, enable the following permissions for Ratings from Users \u0026amp; Permissions Plugin on your project settings:\nFor public, enable: count, find, getPageSize and getStats.\nFor authenticated, enable create, find and getUserReview.\nDisplay user reviews on the frontend Reviews can be displayed in the frontend in two ways:\nUsing the React components library strapi-ratings-client (recommended) Build your custom frontend using the API endpoints, described as follows: API There are some Typescript interfaces that will help to get an idea of the data structures.\nReviews: interface IReview { id: number, createdAt: string, comment: string | null, author: IAuthor | null, score: number, } Authors: interface IAuthor { username: string, email: string, id: number } Content Stats interface IStats { averageScore: number; reviewsCount: number | null; } The following endpoints are exposed to fetch and post reviews:\nGet reviews for a content ID Method: GET\nPath: /api/ratings/reviews/:slug\nOptional query parameters: start, ignoreCount\nReturns:\n{ reviewsCount: number, averageScore: number, userReview: IReview | null, reviews: IReview[] } The parameter start indicates how many reviews to skip. This is for pagination purposes.\nThe parameter ignoreCount indicates whether or not to return the total number of reviews associated with the given slug.\nGet review stats for a content ID Method: GET\nPath: /api/ratings/reviews/:slug/stats\nReturns:\n{ averageScore: number, reviewsCount: number | null } Get the number of reviews associated with a given content ID Method: GET\nPath: /api/ratings/reviews/:slug/count\nReturns:\n{ count: number } Post a review Method: POST\nPath: /api/ratings/reviews/:slug\nAuthentication: Bearer token\nPayload:\n{ content: string } Returns:\n{ id: number } By default, every authenticated user can post reviews on any content.\nIn order to customize this behavior, e.g. allowing or disallowing a user from posting reviews, you must extend the service userCanPostReview from whithin register function in ./src/index.js. For example:\nstrapi.service(\u0026#34;plugin::ratings.review\u0026#34;).userCanPostReview = async (user, slug) =\u0026gt; { /* Here you will check whether or not the user is allowed to post a review on this content ID and return either true or false. */ return true } Notice that userCanPostReview will receive two parameters: the user from Users \u0026amp; Permissions Plugin, containing it\u0026rsquo;s id, username, confirmed, etc., and the slug, which is a string and refers to the content ID which the review is being posted on.\nIn case this function returns false, the response of the endpoint will be 403 (forbidden) with the text User cannot post a review on this content.\nGet the page size Method: GET\nPath: /api/ratings/page-size\nReturns:\n{ pageSize: number } General settings The plugin allows to set how many reviews are returned per page by going to the Pagination section under Ratings Plugin of the Settings section.\nThe default page size is 10.\nManagement of reviews Admin users are able to delete reviews from within the plugin page of the Strapi admin dashboard.\nThe plugin interface has two tabs: one for the latest reviews and one for reviews by content ID.\nRoadmap and future plans The plugin is pretty basic but it can be improved with more features and a better UI/UX. Collaborations and suggestions are very welcome.\n","image":"//localhost:1313/images/post/ratings.webp","permalink":"//localhost:1313/blogs/strapi-plugin-ratings/","tags":["Strapi","Strapi plugins"],"title":"Strapi Plugin Ratings"},{"categories":["Projects"],"contents":"ManyLMS is an e-learning platform built on top of Strapi, React Router 7, Typescript and other technologies.\nOutline The idea Platform features The stack The API The frontend Conclusion Landing Page The idea This project doesn\u0026rsquo;t necessarily bring a huge amount of innovation on the e-learning platforms that already exists, but it\u0026rsquo;s just another way of doing this type of application.\nThe main idea is to apply a JAMstack approach in this application, where the platform is a static website, and the backend is just an API that serves static content only once to build the website and just adds the dynamism that\u0026rsquo;s necessary to allow users to authenticate, create orders, confirm payments and take courses.\nIf we compare this approach to a WordPress website, we are taking out most of the overhead that implies rendering the pages everytime a user visits them. Despite that there are plugins for caching that may improve the performance, it\u0026rsquo;s still never going to be faster and more efficient than just static content served by a CDN. That\u0026rsquo;s why React Router 7 and Headless CMSs are so popular right now.\nPlatform features and user stories The following user stories illustrates the desired features the platform should have.\nAs an administrator, I want to: login in the admin panel. create categories. create courses. upload lectures. organise courses into categories. assign lectures to courses. As a student, I want to: login in the platform. view the available courses. add courses to the shopping cart. review the shopping cart. create an order. pay with credit card or paypal. view the courses i\u0026rsquo;ve purchased in my learning page. go to the course page from my learning page and watch the videos. mark lectures as seen. come back later and resume where I left. The requirements The backend requires to handle user authentication, permissions, different data structures as content types and define relationships between them. It also requires to allow uploading videos to some third party platform that supports streaming on demand.\nThe frontend is a web platform where users can register and login, view and buy courses, leave comments and reviews and take courses.\nThe API Since all of the features involve authentication, permissions and roles, and because there is no need to reinvent the wheel, I chose to use Strapi to build the backend for it\u0026rsquo;s simplicity, ease of use and great developer experience, whereas for streaming videos on demand, I chose to use Mux.com.\nThe instance of Strapi and the Postgres database it requires was deployed in the cloud hosting platform https://fly.io.\nStrapi is good for managing users, content that\u0026rsquo;s typically updated and fetched via CRUD API, and setting up relations between content types.\nThe platform needs the following content types:\nCategory to group courses Course Lecture Module to group lectures Order Student: has many courses Student-Course: stores a student\u0026rsquo;s current lecture of a course Video Strapi makes the creation of these content types and setting up relationships between them really straightforward.\nBelow are some screenshots of these content types and the relationships between them:\nThe frontend The platform where users are able to login, view, buy and view courses is a web application built with React Router 7. Among the features of this application are:\nState managed by Context API Interface styled with Bootstrap Play streaming videos with @mux/mux-player-react library Use of localStorage to save user session Below are some sample screenshots of how this app looks like\nConclusion and final thoughts While building this project, I learned:\nHow streaming on demand works and how to use a streaming provider How to statically build websites with React Router 7 and Strapi How to setup dynamic pages in React Router 7 How to process payments with Stripe and Paypal How to build custom plugins in Strapi How to publish packages to NPM Project source codes: https://github.com/luisguve/maestro-backend\nhttps://github.com/luisguve/new-lms-remix\n","image":"//localhost:1313/images/project/manylms/frontend/course_overview.png","permalink":"//localhost:1313/projects/e-learning-platform-maestro-lms/","tags":["Strapi","React","React Router 7","Typescript","Mux"],"title":"ManyLMS: E-Learning platform"},{"categories":["Projects"],"contents":"Chile Nativo is a travel tour website for Patagonia experiences, built on top of WordPress with the Themosis framework, featuring a modern frontend implementation based on a Figma design using Vue 3, Laravel Mix, and a comprehensive SCSS architecture.\nOutline The project Design implementation The stack Frontend architecture Key features Conclusion Live website The project Chile Nativo is a travel company specializing in Patagonia tours, offering experiences in destinations like Torres del Paine, Tierra del Fuego, and Isla Navarino. The website serves as the primary platform for showcasing tours, managing bookings, and providing information about their travel experiences.\nThe frontend development was based on a comprehensive Figma design, requiring pixel-perfect implementation of complex UI components, interactive forms, filtering systems, and responsive layouts that work seamlessly across all devices.\nDesign implementation The entire frontend was built from a detailed Figma design, ensuring:\nPixel-perfect accuracy: Matching the design specifications precisely Responsive design: Implementing breakpoints and mobile-first approach Component consistency: Maintaining design system patterns throughout Interactive elements: Translating static designs into dynamic, interactive components Animation and transitions: Implementing smooth user experience enhancements The stack The frontend stack consists of:\nVue 3.2.4: Modern reactive framework for building interactive components Laravel Mix 6.0: Asset compilation and bundling SCSS: Advanced styling with a well-organized architecture Pinia 2.3.1: State management for Vue applications Vee-Validate 4.15.0: Form validation with Yup schemas Axios 1.6.8: HTTP client for API requests Splide.js 4.1.4: Modern carousel and slider components Headroom.js: Header behavior on scroll Plyr 3.7.8: Video player implementation SweetAlert2: Modern alert dialogs jQuery 3.7.1: Legacy support and DOM manipulation utilities Frontend architecture Vue components The application features a comprehensive set of Vue 3 components organized by functionality:\nFiltering and Search Components:\nToursFilter.vue: Advanced tour filtering with multiple criteria TourDatesFilter.vue: Date-based filtering for tour availability ToursFilterDropdown.vue \u0026amp; ToursFilterDropdownMobile.vue: Responsive filter dropdowns TestimonialsFilter.vue: Filtering system for customer testimonials NewsFilter.vue: Blog and news filtering SearchResults.vue: Search results display with pagination Form Components:\nPersonalizedTripForm.vue: Multi-step form for custom trip requests with validation ContactFormSimple.vue: Contact form with reCAPTCHA integration FormHelp.vue: Help center form FormGiftCard.vue: Gift card purchase form FormCareers.vue: Job application form NewsletterForm.vue: Newsletter subscription Card Components:\nTour.vue \u0026amp; TourLoading.vue: Tour card display with loading states TourDate.vue \u0026amp; TourDateLoading.vue: Tour date selection cards Testimonial.vue \u0026amp; TestimonialLoading.vue: Customer testimonial cards Blog.vue \u0026amp; BlogLoading.vue: Blog post cards Team.vue \u0026amp; TeamLoading.vue: Team member cards ResourceCard.vue \u0026amp; ResourceLoading.vue: Resource display cards Utility Components:\nPagination.vue: Reusable pagination component Select.vue: Custom select dropdown with search Loader.vue \u0026amp; LoaderFullScreen.vue: Loading indicators EmptyState.vue: Empty state displays ContentResources.vue: Resource content management TeamTabsFilter.vue: Tabbed team member filtering SCSS architecture The styling follows a well-organized SCSS architecture:\nscss/ ├── abstracts/ # Variables, mixins, functions │ ├── _functions.scss │ ├── _mixins.scss │ ├── _variables.scss │ ├── _mq.scss # Media query mixins │ └── _keyframes.scss ├── base/ # Base styles and typography │ ├── _typography.scss │ ├── _colors.scss │ ├── _fonts.scss │ └── _reset.scss └── components/ # Component-specific styles └── [125 component files] Key SCSS features:\nBEM methodology: Consistent naming convention throughout Media query mixins: Using sass-mq for responsive design Modular architecture: Each component has its own SCSS file Abstract layer: Reusable variables, mixins, and functions Vue transitions: Custom transition styles for Vue components JavaScript architecture The JavaScript is organized into two main entry points:\nMain application (app.js):\nInitializes core application functionality Sets up jQuery plugins and utilities Handles legacy browser support Vue application (vue/main.js):\nConfigures Vue 3 app with Pinia for state management Registers global Vue components Sets up Vee-Validate configuration Integrates third-party Vue plugins (VueTelInput, etc.) Component utilities (app/components/):\nheader.js: Header behavior and navigation footer.js: Footer functionality splide.js: Carousel initialization slick.js: Legacy carousel support accordions.js: Accordion interactions tabs.js: Tab functionality scrollTrigger.js: Scroll-based animations video.js: Video player setup sticky-sidebar.js: Sticky sidebar behavior Key features Multi-step forms The PersonalizedTripForm.vue component implements a sophisticated multi-step form with:\nStep-by-step navigation with progress indicators Form validation using Vee-Validate and Yup schemas Dynamic form fields based on user selections Phone number input with international support (VueTelInput) reCAPTCHA integration for spam protection Loading states and error handling Advanced filtering system The tour filtering system (ToursFilter.vue) provides:\nMultiple filter criteria (destination, activity type, trip type, month) Real-time filtering with URL parameter synchronization Responsive design with mobile accordion interface Custom select components with search functionality Empty states and loading indicators Integration with WordPress backend via Axios Responsive design The entire website is fully responsive with:\nMobile-first approach Breakpoint management using sass-mq Touch-friendly interactions Optimized images and assets Performance optimizations for mobile devices Performance optimizations Code splitting: Laravel Mix extracts vendor libraries Asset versioning: Automatic cache busting Image optimization: Lazy loading and responsive images Minification: Production builds are minified and optimized Tree shaking: Unused code elimination in production Accessibility Semantic HTML structure ARIA labels where appropriate Keyboard navigation support Focus management in forms Screen reader considerations Development workflow The project uses Laravel Mix for asset compilation:\n// Development npm run dev // Compile assets npm run watch // Watch for changes npm run hot // Hot module replacement // Production npm run production // Optimized production build BrowserSync integration provides:\nLive reloading during development Synchronized browser testing Proxy configuration for WordPress development Conclusion and final thoughts Building the Chile Nativo frontend from a Figma design was an excellent opportunity to:\nMaster Vue 3: Working with the Composition API, reactive systems, and modern Vue patterns Implement complex forms: Multi-step forms with validation, international phone inputs, and reCAPTCHA Build scalable architecture: Organizing 40+ Vue components and 125+ SCSS files in a maintainable structure Optimize performance: Implementing code splitting, lazy loading, and production optimizations Ensure design fidelity: Translating Figma designs into pixel-perfect implementations Handle responsive design: Creating seamless experiences across all device sizes The project demonstrates proficiency in:\nModern JavaScript frameworks (Vue 3) Build tools and asset compilation (Laravel Mix, Webpack) CSS architecture and methodologies (SCSS, BEM) Form validation and user experience Component-based development Design system implementation The integration with WordPress/Themosis backend required careful consideration of server-side rendering, API endpoints, and content management workflows, making this a full-stack frontend implementation.\nLive website: https://chilenativo.travel/\nFigma prototype: https://www.figma.com/proto/ywHPhSP1UfYUAE8eWVQv4L/Dise%C3%B1o-Desktop---Chile-Nativo?node-id=289-3912\u0026m=dev\u0026scaling=min-zoom\u0026content-scaling=fixed\u0026page-id=289%3A3911\u0026starting-point-node-id=289%3A3912\n","image":"//localhost:1313/images/project/chile-nativo/home.png","permalink":"//localhost:1313/projects/chile-nativo-patagonia-travel-website/","tags":["Vue 3","Laravel Mix","WordPress","Themosis","SCSS","JavaScript","Figma"],"title":"Chile Nativo: Patagonia Travel Website"},{"categories":["Projects"],"contents":"Rutieri is a SaaS platform built with Strapi, React Native, Typescript and other technologies.\nOutline The idea Platform features The stack The API The frontend The mobile app Conclusion Landing Page The idea Before starting to write a single line of code, it is generally a good idea to think about the problem, it\u0026rsquo;s limitations and whether or not it has already been solved by someone else (AKA competitors).\nThe problem I was looking into had to do with the way in which public and private transportation companies manage their routes, drivers and users. This process is generally carried out on paper, e.g. not digital, hence this could be problematic in case of new drivers joining the organization or in case of restricting access to data to only specific users.\nAfter a little bit of research, I could only find one platform that provides a similiar solution but for their own company.\nPlatform features and user stories The following user stories illustrates the desired features the platform should have in order to solve the aforementioned problems.\nAs an administrator user, I want to: login in the admin panel. create an organization. create routes in the organization. invite drivers and users to the organization. manage requests to join the organization. assign routes to drivers in the organization. see in real time the drivers and users currently active in the map of the different routes. As a driver, I want to: login in the mobile app. join an organization by entering the code in the search bar. see my route on the map. become visible to passengers on the road. see the passengers waiting on the road. remove my visibility and finish my run. As a passenger, I want to: login in the mobile app. join an organization by entering the code in the search bar. see the different routes of my organization in the map. search for a destination and get the available routes that pass nearby. see the drivers currently active on the routes in real time. become visible to drivers of a route. The requirements The backend requires to handle user authentication, permissions, different data structures as content types and define relations between them. It\u0026rsquo;s also necessary to synchronise passengers and drivers and view them on a map real time in the administration panel as well as in the mobile app.\nThe administration panel is a web page that fetches data from the backend as well as from the real time data provider and it\u0026rsquo;s goal is to provide a way for administrators to manage their organization and users. We\u0026rsquo;re talking about a Single Page Application built in React.\nAs for the mobile application, there isn\u0026rsquo;t a better choice nowadays than React Native and it works just fine in this case.\nThe API Since all of the features involve authentication, permissions and roles, and because there is no need to reinvent the wheel, I chose to use Strapi to build the backend for it\u0026rsquo;s simplicity, ease of use and great developer experience, whereas for realtime data, I used Firebase.\nThe instance of Strapi and the Postgres database it requires was deployed in the cloud hosting platform https://fly.io.\nStrapi is good for managing users, content that\u0026rsquo;s typically updated and fetched via CRUD API, and relations between content types.\nThe platform needs the following content types:\nOrganizations to group routes, drivers and users Routes Two user roles: drivers and users (passengers) Below are some screenshots of the overview of these content types\nAs I said before, Strapi makes the creation of these content types and the relationships between them really straightforward.\nHowever, not everything related to the API can be provided by Strapi. Some realtime features need to be addressed with other solutions, such as geolocation data in real time for drivers and users to synchronise each other, maps and the ability to search for places. Such features were implemented using Firebase, Google Maps and Google Places.\nThe frontend The platform where users are able to login as administrators and manage their organizations and users is a single page web application built in React. Among the features of this project that I think stand out are:\nState managed by Context API Interface styled with Bootstrap React Router for pages Leaflet to display the map GeoFire library to synchronise geolocation data in real time with Firebase Use of localStorage to save user session Below are some sample screenshots of how this app looks like\nThe mobile application This one is by far the most complex part of this project.\nThe project was bootstraped with Infinitered\u0026rsquo;s Ignite, which provides a great boilerplate and surely saved me of what would have been between 1-2 months of work.\nIgnite\u0026rsquo;s boilerplate includes many features out of the box, including:\nReact Native and Typescript (of course) React Navigation MobX-State-Tree for state management Expo SDK for developer experience AsyncStorage for persistence apisauce as REST client And some other libraries and features that make React Native apps super powerful and a joy to work on.\nIt consists of three screens:\nWelcome screen Login screen Map screen In the welcome screen, users are able to go to the login screen if not logged in. Otherwise, if they\u0026rsquo;re in an organisation, it shows their role and org\u0026rsquo;s information, and if they\u0026rsquo;re not, they are able to enter the organisation code and request to join as driver or as passenger.\nWelcome screens Login screens If the user is a driver in an organisation, the welcome screen also shows the route assigned to them. By tapping on it, it takes them to the map, where they can see themselves and start the tour, becoming visible to passengers on the road but being able to see passengers on the road as well.\nDrivers can finish the tour at any time by pressing the button stop.\nIf the user is a passenger in an organisation, the welcome screen shows the different routes available in the organisation. By tapping on them, they are taken to the map where they can see themselves, the route and the drivers on the road.\nPassengers are able to navigate between the available routes and search for the location they want to go to by using the search bar at the top of the map screen, filtering out the routes that pass nearby (less than 200 meters), if there are. Google Places API and turf library work together in this search process.\nPassengers become visible to drivers on the road by pressing the button wait and if they press the button again, they stop waiting and are removed from the driver\u0026rsquo;s map.\nMap screens The start/wait and finish buttons dispatch actions that update their location in firebase, so that passengers are able to see the bus on the map as it moves in real time and viceversa.\nAs for the state management, the project consists of two models and three stores from Mobx-State-Tree library: User and Route models, user-status, route-store and root-store stores.\nUser model Located in /app/models/user/user.ts\nconst OrganizationModel = types.model({ name: types.string, code: types.string, id: types.identifierNumber, drivers: types.number, rutas: types.array(RouteModel) }) const UserModel = types .model(\u0026#34;User\u0026#34;) .props({ id: types.identifierNumber, username: types.string, email: types.string, token: types.string, role: types.union(types.literal(\u0026#34;passenger\u0026#34;), types.literal(\u0026#34;driver\u0026#34;)), ruta: types.maybeNull(RouteModel), organization: types.maybeNull(OrganizationModel), pending_request: types.maybeNull(OrganizationModel), }) Route model Located in /app/models/route/route.ts\nThis model follows the GeoJSON format for routes.\nconst RouteModel = types .model(\u0026#34;Ruta\u0026#34;) .props({ id: types.identifierNumber, name: types.string, latlong: types.maybeNull(types.model({ lat: types.number, longt: types.number })), coords: types.model({ type: FeatureTypes, features: types.array(types.model({ type: types.string, geometry: types.model({ type: types.string, coordinates: types.union(types.array(types.number), types.array(types.array(types.number))) }), properties: types.model({ name: types.string }) })) }) }) user-status store Located in /app/models/user-status/user-status.ts\nThis store is responsible for managing the state of the user. It stores the user once it\u0026rsquo;s logged in and removes it when the user logs out. It also has some views to get the user key for firebase purposes, get the role and get the route in case of a driver.\nThis store has some methods that get the user location from the device\u0026rsquo;s GPS, displays the user icon on the map and sends it to firebase.\nconst UserStatusModel = types .model(\u0026#34;UserStatus\u0026#34;) .extend(withEnvironment) .props({ user: types.maybeNull(UserModel), location: types.maybeNull( types.model({latitude: types.number, longitude: types.number}) ), visibility: types.maybeNull(types.number) }) route-store store Located in /app/models/route-store/route-store.ts\nThis store is responsible for managing the state of the available routes. It stores the routes, drivers and passengers on the different routes. It also has some view methods to filter the routes that pass nearby a destination specified by the user, get passengers waiting on a given route and get drivers active in a specific route.\nThis store initializes a GeoQuery from Geofire library and listens for events to set, update and remove drivers and passengers from the map as they move.\nconst RouteStoreModel = types .model(\u0026#34;RouteStore\u0026#34;) .props({ routes: types.array(RouteModel), passengers: types.map(types.model({ key: types.identifier, location: types.array(types.number) })), drivers: types.map(types.model({ key: types.identifier, location: types.array(types.number) })), destinationAddress: types.maybeNull(types.model({ name: types.string, coords: types.array(types.number) })) }) Conclusion and final thoughts Using a CMS as the backend can make the development a lot faster than building the API from scratch and with Strapi this is specially true. On the other hand, Strapi doesn\u0026rsquo;t really make a good fit for real time applications, therefore, Firebase is the way to go in this case.\nAs of the client side, React always works very good for pretty much any kind of application, and because React Native uses React under the hood, it is so convenient for us React developers and ir works pretty good for almost any kind of application as well.\nHowever, one thing that I didn\u0026rsquo;t mention in this post was the use of Typescript; I find this quote by Brice Wilson pretty good to point out the whole purpose and motivation to learn and use (well) this powerful language and tool ecosystem:\n\u0026ldquo;You won\u0026rsquo;t have to wait for a frustrated user to report the error. All of this means that you provide value to your users faster, and that\u0026rsquo;s really what it\u0026rsquo;s all about.\u0026rdquo;\nAll in all, I got a lot of learning by building this project, both in languages/frameworks used and production stuff such as infrastructure, cloud hosting and cloud-based APIs.\nProject landing page: https://rutieri.netlify.app\n","image":"//localhost:1313/images/project/rutieri/landing/homepage.webp","permalink":"//localhost:1313/projects/saas-platform-rutieri/","tags":["Strapi","React Native","React","Typescript","Firebase"],"title":"SaaS platform: Rutieri"},{"categories":["Tutorial"],"contents":"Enable comments in a Strapi application and display them in the frontend with React\nOutline Introduction Prerequisites What is Strapi Comment Manager? Installation Configuration Display comments on the frontend Installation of Strapi Comments Client Usage of Strapi Comments Client Plugin settings Manage comments Full source code of the frontend Conclusion Introduction A comment system comes in very handy for pretty much any kind of website. In the JAMstack ecosystem, while it\u0026rsquo;s ok to rely on third party solutions hosted on their own platform such as Disqus to enable comments, you usually want to keep your content and all the stuff related to it in the same admin dashboard.\nIn this article, I\u0026rsquo;ll show you how to enable and manage comments for your content very easily using the Comment Manager plugin, and display them in your frontend application.\nPrerequisites You should have a basic understanding of the following.\nBasic knowledge of JavaScript Basic knowledge of React (OPTIONAL) Basic understanding of Strapi - get started here. Your Strapi V4 project setup What is Strapi Comment Manager? Strapi Comment Manager is a plugin that enables comments for pretty much any kind of content. It allows your users to post comments and anyone can get the comments associated with a given slug.\nWith this plugin, admin users can view and manage very easily all the comments from the Strapi administration dashboard. Within the dashboard, you will be able to delete comments and subcomments and leave replies on comments.\nInstallation Once into the Strapi project root, you can install the plugin by running the following command:\nnpm install strapi-plugin-comment-manager Next, build the project to see the new plugin in the dashboard with the following command:\nnpm run build And that\u0026rsquo;s it! If everything runs correctly, the plugin should now be installed.\nConfiguration Now you need to enable some permissions so that the frontend can access the endpoints to post and fetch comments.\nIn your Strapi admin dashboard, head over to Settings, then over to Roles under Users \u0026amp; Permissions Plugin.\nLet\u0026rsquo;s first setup the Public API; click on Public and hit the dropdown button of Comment Manager. Now check count, find and getPageSize, then hit the Save button. Below is a screenshot of a proper configuration:\nNow let\u0026rsquo;s setup the Authenticated API. Go back to Roles and click on Authenticated. Open the dropdown for Comment Manager and mark as checked the option create on both Comment and Subcomment. Below is a screenshot of a proper configuration:\nWith this configuration, the frontend should now be able to make requests to get and post comments.\nDisplay comments on the frontend The plugin exposes an API to get and post comments if you want to have fine-grained control over the workflow of your comments system and you can check the documentation on the package page, but this plugin also comes with a purpose-built React component library that makes it super easy to get up and running without getting your hands dirty.\nThis components library is called strapi-comments-client, fully supports typescript and it handles for you all of the complexity of fetching and posting comments and subcomments for every content ID that you pass to it.\nInstallation of Strapi Comments Client You will need to have installed react ^17.0.2, react-dom ^17.0.2 and react-router-dom ^5.2.0.\nInside of your React project, run this command:\nnpm install strapi-comments-client --save Usage of Strapi Comments Client Using this library is very easy!\nThis library exports three main components:\nCommentsProvider Comments CommentForm And you can import them this way:\nimport { CommentsProvider, Comments, CommentForm } from \u0026#34;strapi-comments-client\u0026#34; All you have to do is wrap your App component into the CommentsProvider component. Then you will be able to place anywhere in your app the Comments component to render a list of comments for a given content ID and the CommentForm component to render a form to post comments.\nFor example, this could be your index.js or main.js file:\nimport React from \u0026#39;react\u0026#39; import ReactDOM from \u0026#39;react-dom\u0026#39; // The address of your strapi backend instance const STRAPI = \u0026#34;http://localhost:1337\u0026#34; ReactDOM.render( \u0026lt;React.StrictMode\u0026gt; \u0026lt;CommentsProvider apiURL={STRAPI}\u0026gt; \u0026lt;App /\u0026gt; \u0026lt;/CommentsProvider\u0026gt; \u0026lt;/React.StrictMode\u0026gt;, document.getElementById(\u0026#39;root\u0026#39;) ) Where apiURL is the URL of your running Strapi application, and this property is required.\nThis way, the comments provider will do all the magic of fetching and posting comments for you!\nThis library also exports an utility React.Context to update some of the parameters for fetching and posting comments:\nimport { CommentsConfigContext } from \u0026#34;strapi-comments-client\u0026#34; This CommentsConfigContext exposes two setter functions: setUser and setContentID\nWith setContentID you can load the comments for a given content and post comments to it. It receives a single parameter of type string and must be URLized, i.e. no spaces.\nWith setUser you can set the credentials of a given user to authorize the posting of comments. It receives a single parameter of type IUser, with the following Typescript interface:\ninterface IUser { username: string, email: string, id: string, token: string // This is a JWT } It\u0026rsquo;s a little confusing but we\u0026rsquo;ll see how to use it in a component:\nconst App = () =\u0026gt; { const { setUser, setContentID } = useContext(CommentsConfigContext) // The following data should come from Strapi Users and Permissions Plugin // for authenticated requests const user = { username: \u0026#34;John Doe\u0026#34;, email: \u0026#34;jhohndoe@gmail.com\u0026#34;, id: 5, token: \u0026#34;this_should_be_a_JWT\u0026#34; } if (user) { setUser(user) } setContentID(\u0026#34;sample-content-1\u0026#34;) // Load comments for this content return ( \u0026lt;\u0026gt; { !user \u0026amp;\u0026amp; \u0026lt;Login /\u0026gt; } \u0026lt;CommentForm /\u0026gt; \u0026lt;Comments /\u0026gt; \u0026lt;/\u0026gt; ) } And that\u0026rsquo;s it!\nAfter setting the content ID through setContentID, CommentsProvider will start loading the comments for the given content ID and the CommentForm will render an input to post comments related to the given content ID if there is a user. Otherwise, it will display the message Login to post a comment.\nHere\u0026rsquo;s how the interface looks like so far:\nThere\u0026rsquo;s also a button to Leave a reply, which will open a form to post a subcomment associated with the parent comment.\nThis library exports one more component: ErrorBox\nimport { ErrorBox } from \u0026#34;strapi-comments-client\u0026#34; .It\u0026rsquo;s useful if you\u0026rsquo;d like to display error messages when things go wrong fetching or posting comments.\nYou can place this component wherever you want, for example in between the CommentForm and the Comments components.\nIf you\u0026rsquo;re wondering how this error box looks like, here you have a sample:\nGeneral settings You can customize the page size, i.e. specify how many comments are returned at once.\nIn the Strapi admin panel, head over to Settings, then select Pagination under Comment Manager Plugin.\nHere you\u0026rsquo;ll find an input to set the page size, which defaults to 10.\nManage comments Once you\u0026rsquo;ve got the plugin up an running, as users start to post comments, you can manage and reply to them as admin from the Comment Manager section of the left sidebar in the Strapi admin dashboard.\nHere you can see two tabs: one for the latest comments and one for comments grouped by content ID.\nIn both of them you can delete comments and subcomments as well as leave replies.\nExample project You can find a full working example of a React App using the Strapi Comments Client Library in this repo\nConclusion With this plugin you can enable and manage comments for any content with little effort and even use a component library to display the comments in your frontend application made with React.\nAnd that\u0026rsquo;s it! The features are pretty basic at the moment but if there\u0026rsquo;s interest, I\u0026rsquo;m willing to work on more features as well as improve the UI/UX.\n","image":"//localhost:1313/images/post/strapilogo.jpg","permalink":"//localhost:1313/blogs/how-to-enable-and-manage-comments-in-your-strapi-application/","tags":["Strapi","Strapi tutorials"],"title":"How To Enable And Manage Comments In Your Strapi Application."},{"categories":["Documentation"],"contents":"Comment Manager is a Strapi plugin to allow your users to post comments.\nWith this plugin you can enable and manage comments for your content very easily!\nRequirements You should have installed an instance of Strapi v4.x.x\nInstallation Run the following command in your project root:\nnpm install strapi-plugin-comment-manager Configurarion For your frontend to have access to the API, enable the following permissions for Comment Manager from Users \u0026amp; Permissions Plugin on your project settings:\nFor public, enable: count, find and getPageSize.\nFor authenticated, enable create on both Comment and Subcomment.\nDisplay comments on the frontend Comments can be displayed in the frontend in two ways:\nUsing the React components library strapi-comments-client (recommended) Build your custom frontend using the API API There are some Typescript interfaces that will help to get an idea of the data structures.\nComments: interface IComment { id: string, from_admin: boolean, createdAt: string, content: string, author: IAuthor | null, subcomments?: ISubcomment[] } Subcomments: interface ISubcomment { id: string, from_admin: boolean, createdAt: string, content: string, author: IAuthor | null, } Authors: IAuthor { username: string, email: string, id: string } The following endpoints are exposed to fetch and post comments and subcomments:\nGet comments for a content ID Method: GET\nPath: /api/comment-manager/comments/:slug\nOptional query parameters: start, ignoreCount\nReturns:\n{ commentsCount?: Number, comments: IComment[] } The parameter start indicates how many comments to skip. This is for pagination purposes.\nThe parameter ignoreCount indicates whether or not to return the total number of comments associated with the given slug.\nGet the number of comments associated with a given content ID Method: GET\nPath: /api/comment-manager/comments/:slug/count\nReturns:\n{ count: Number } Post a comment Method: POST\nPath: /api/comment-manager/comments/:slug\nAuthentication: Bearer token\nPayload:\n{ content: string } Returns:\n{ id: Number } Post a subcomment Method: POST\nPath: /api/comment-manager/subcomments/:parent-id\nAuthentication: Bearer token\nPayload:\n{ content: string } Returns:\n{ id: Number } Get the page size Method: GET\nPath: /api/comment-manager/page-size\nReturns:\n{ pageSize: Number } General settings The plugin allows to set how many comments are returned per page by going to the Pagination section under Comment Manager Plugin on the Settings section.\nThe default page size is 10.\nManagement of comments Admin users are able to delete comments and subcomments as well as leave replies as admins from within the plugin page of the Strapi admin dashboard.\nThe plugin interface has two tabs: one for the latest comments and one for comments by content ID.\nRoadmap and future plans The plugin is pretty basic but it can be improved with more features and a better UI/UX. Collaborations and suggestions are very welcome.\n","image":"//localhost:1313/images/post/strapilogo.jpg","permalink":"//localhost:1313/blogs/strapi-plugin-comment-manager/","tags":["Strapi","Strapi plugins"],"title":"Strapi Plugin Comment Manager"},{"categories":["Projects"],"contents":"In this post I’m going to share my experience on building a SaaS using the headless CMS Strapi as the Backend, React Native and other technologies.\nOutline Introduction What is SaaS? The problem What is Strapi? Developing features in Strapi The frontend: How to get content Conclusion Landing Page Introduction Very often, developers, product and project managers, testers and pretty much the entire team share their ideas to decide what language and which framework they\u0026rsquo;ll use to build their next project. Some considerations must be taken into account, from which in my opinion there are three that are the most important:\nDeveloper experience and ease of use Does the language and framework chosen provide a good developer experience? Is the langauge the same for the backend and frontend?\nDeadlines Is there a deadline to finish the project? if so, there is a good chance to finish the project on time if the team chooses the language they have more experience in.\nMaintainability As there will be usually more than one person working on the same part at the same time, if everything is kept organised, the whole development process will be frictionless.\nWith that in mind, developers and project managers will have a better insight on which language/framework to use.\nOther aspects should also be considered such as what the data structure will look like.\nIn my case, as it is usual, the backend of my project needs a database for users and their roles among other entities and their relations and a dashboard to allow admins to manage the data, and I was lucky to find out Strapi, as it includes a lot of these features out of the box with one single line of command to get started.\nWhat is SaaS? SaaS stands for Software-as-a-Service and it just means that a software is provided as a service in the cloud and it gives a solution to a specific problem, for which the users are willing to pay either monthly or annual subscription.\nThe problem Before starting to write a single line of code, it is generally a good idea to think about the problem, it\u0026rsquo;s limitations and whether or not it has already been solved by someone else (AKA competitors).\nThe problem I was looking into had to do with the way in which public and private transportation companies manage their routes, drivers and users. After a little bit of research, I could only find one platform that provides a similiar solution but for their own company.\nSo the platform I built needed the following content types:\nOrganizations to group routes, drivers and users Routes Two user roles: drivers and users (passengers) As I said before, Strapi makes the creation of these content types and the relationships between them really easy, but let\u0026rsquo;s first see what is Strapi and how it turns the API development into a satisfactory and fun experience.\nWhat is Strapi? Strapi is an open source headless CMS that allows developers to build complete RESTful APIs in just a couple of days instead of months. It includes a lot of useful features as plugins out of the box. Users and Roles management, Media library and an interface to create, view, edit and delete content are just some of them.\nRegarding the API, how does it makes the development faster?\nFirst of all, it enforces a specific folder structure, which helps to keep everything well organised and clean.\nSecondly, all database schemas are generated automatically and queries are made in JSON format, which really saves a lot of time.\nLastly, we can add more features to our Strapi application very easily via plugins from the marketplace.\nIt\u0026rsquo;s also worth noting that Strapi is a self-hosted CMS, which means that we can host it in whatever cloud platform we want, as well as test it locally in our computers before deploying it to the cloud.\nDeveloping features in Strapi Creating and configuring endpoints in Strapi is as straightforward as declaring a JSON in a single file:\nCreating controllers is straightforward as well:\nEvery controller gets all the data related to the request in the ctx parameter and it\u0026rsquo;s also used to send the response. This keeps everything in one place and really helps to improve the readability.\nOnce the API endpoints are defined, the next step is to enable the permissions for the specific user roles to have access to these endpoints:\nThe frontend: how to get content Since Strapi is a headless CMS, it\u0026rsquo;ll only provide content through the API. That means that the content can be consumed from anywhere. In our case, this content will be used in two applications: one for the organization owners and one for the users and drivers.\nThe application for the organization owners is a dashboard where administrators can create organizations, routes, accept drivers and users in the organization and assign routes to drivers. This is just a React Application:\nThe application for drivers and users is a mobile application built in React Native. Firebase was used to synchronise geolocation data in real time between drivers and users and display this information in a Map from Google Maps:\nConclusion Using a CMS as the backend can make the development a lot faster than building the API from scratch and with Strapi this is specially true. Furthermore, this becomes more important when building a brand-new product, as it\u0026rsquo;s usually recommended to launch as soon as possible to gather feedback from the users and validate the idea.\nProject landing page: https://rutieri.netlify.app\n","image":"//localhost:1313/images/post/03.webp","permalink":"//localhost:1313/blogs/how-i-built-a-saas-on-top-of-strapi-and-why-you-should-too/","tags":["Strapi","React Native","Typescript"],"title":"How I Built A SaaS On Top Of Strapi, And Why You Should Too"},{"categories":["Tutorial"],"contents":"Enable User Reviews in a Strapi application and display them in the frontend with React\nOutline Introduction Prerequisites What is Strapi Ratings? Installation Configuration Display user reviews on the frontend Plugin settings Manage user reviews Full source code of the frontend Conclusion Introduction Ratings systems have become a crucial part of any website with ecommerce capabilites, as they allow the users to post reviews on the items they purchase and publish their opinion to the public. A couple of reviews can make the difference between pressing the “Buy” button and moving on to the next website in the Google search results.\nIn this article, I\u0026rsquo;ll show you how to enable and manage user reviews for your content very easily using the Ratings plugin, and display them in your frontend application.\nPrerequisites First of all, you need to have a basic understanding of the following.\nBasic knowledge of JavaScript Basic knowledge of React (OPTIONAL) Basic understanding of Strapi - get started here. Your Strapi V4 project setup What is Strapi Ratings? Strapi Ratings is a plugin that gives your Strapi application the ability to manage ratings for pretty much any kind of content. It allows your users to post reviews and anyone can get the reviews associated with a given slug.\nWith this plugin, admin users can view and manage very easily all the reviews from the Strapi administration dashboard. Within the dashboard, you will be able to see reviews related to content slugs as well as delete reviews.\nInstallation Once into the Strapi project root, you can install the plugin by running the following command:\nnpm install strapi-plugin-ratings Next, build the project to see the new plugin in the dashboard with the following command:\nnpm run build And that\u0026rsquo;s it! If everything runs correctly, the plugin should now be installed.\nConfiguration Now you need to enable some permissions so that the frontend can access the endpoints to post and fetch reviews.\nIn your Strapi admin dashboard, head over to Settings, then over to Roles under Users \u0026amp; Permissions Plugin.\nLet\u0026rsquo;s first setup the Public API; click on Public and hit the dropdown button of Ratings. Now check count, find, getPageSize and getStats, then hit the Save button. Below is a screenshot of a proper configuration:\nNow let\u0026rsquo;s setup the Authenticated API. Go back to Roles and click on Authenticated. Open the dropdown for Ratings and mark as checked the options create, find and getUserReview. Below is a screenshot of a proper configuration:\nWith this configuration, the frontend should now be able to make requests to get and post user reviews.\nDisplay use reviews on the frontend The plugin exposes an API to get and post reviews if you want to have fine-grained control over the workflow of your ratings system and you can check the documentation on the package page, but this plugin also comes with a purpose-built React component library that makes it super easy to get up and running without getting your hands dirty.\nThis components library is called strapi-ratings-client, fully supports typescript and it takes care of all the complexity of fetching and posting user reviews for every content ID that you pass to it.\nInstallation of Strapi Ratings Client You will need to have installed react ^17.0.2, react-dom ^17.0.2, bootstrap ^5.1.3 and @popperjs/core^2.11.2\nInside of your React project, run this command:\nnpm install strapi-ratings-client --save Usage of Strapi Ratings Client Using this library is very easy!\nThis library exports three main components:\nReviewsProvider Reviews ReviewForm And you can import them this way:\nimport { ReviewsProvider, Reviews, ReviewForm } from \u0026#34;strapi-ratings-client\u0026#34; All you have to do is wrap your App component into the ReviewsProvider component. Then you will be able to place anywhere in your app the Reviews component to render a list of user reviews for a given content ID and the ReviewForm component to render a form to allow your users to post reviews.\nFor example, this could be your index.js or main.js file:\nimport React from \u0026#39;react\u0026#39; import ReactDOM from \u0026#39;react-dom\u0026#39; // The address of your strapi backend instance const STRAPI = \u0026#34;http://localhost:1337\u0026#34; ReactDOM.render( \u0026lt;React.StrictMode\u0026gt; \u0026lt;ReviewsProvider apiURL={STRAPI}\u0026gt; \u0026lt;App /\u0026gt; \u0026lt;/ReviewsProvider\u0026gt; \u0026lt;/React.StrictMode\u0026gt;, document.getElementById(\u0026#39;root\u0026#39;) ) Where apiURL is the URL of your running Strapi application, and this property is required.\nThis way, the ratings provider will do all the magic of fetching and posting comments for you!\nThis library also exports an utility React.Context to update some of the parameters for fetching and posting reviews:\nimport { ReviewsConfigContext } from \u0026#34;strapi-ratings-client\u0026#34; This ReviewsConfigContext exposes three setter functions: setUser, setContentID and setCanPostReview.\nWith setContentID you can load the ratings for a given content and post reviews to it. It receives a single parameter of type string and must be URLized, i.e. no spaces.\nWith setUser you can set the credentials of a given user to authorize the posting of reviews. It receives a single parameter of type IUser, with the following Typescript interface:\ninterface IUser { username: string, email: string, id: string, token: string // This is a JWT } With setCanPostReview, you can enable the user to post a review on the given content. This is useful for when you only allow a user to post a review after they purchase the product.\nIt\u0026rsquo;s a little confusing but we\u0026rsquo;ll see how to use it in a component:\nconst App = () =\u0026gt; { const { setUser, setContentID, setCanPostReview } = useContext(ReviewsConfigContext) // The following data should come from Strapi Users and Permissions Plugin // for authenticated requests. const user = { username: \u0026#34;John Doe\u0026#34;, email: \u0026#34;jhohndoe@gmail.com\u0026#34;, id: 5, token: \u0026#34;this_should_be_a_JWT\u0026#34; } if (user) { setUser(user) } setContentID(\u0026#34;sample-content-1\u0026#34;) // Load reviews for this content setCanPostReview(true) // Allow this user to post a review return ( \u0026lt;\u0026gt; { !user \u0026amp;\u0026amp; \u0026lt;Login /\u0026gt; } \u0026lt;ReviewForm /\u0026gt; \u0026lt;Reviews /\u0026gt; \u0026lt;/\u0026gt; ) } And that\u0026rsquo;s it!\nAfter setting the content ID through setContentID, ReviewsProvider will start loading the reviews for the given content ID and the ReviewForm will render an input to post a user review related to the given content ID if there is a user and he’s allowed to post a review. Otherwise, it will display the message Login to post a review or nothing at all if the user is not allowed to post a review.\nHere\u0026rsquo;s how the interface looks like so far:\nThis library exports one more component: ErrorBox\nimport { ErrorBox } from \u0026#34;strapi-ratings-client\u0026#34; .It\u0026rsquo;s useful for when you\u0026rsquo;d like to display error messages when things go wrong fetching or posting reviews.\nYou can place this component wherever you want, for example in between the ReviewForm and the Reviews components.\nIf you\u0026rsquo;re wondering how this error box looks like, here‘s a screenshot:\nGeneral settings You can customize the page size, i.e. specify how many user reviews are showed at once.\nIn the Strapi admin panel, head over to Settings, then select Pagination under Ratings Plugin.\nHere you\u0026rsquo;ll find an input to set the page size, which defaults to 10.\nManage reviews Once you\u0026rsquo;ve got the plugin up an running, as users start to post reviews, you can view them from within the Ratings section of the left sidebar in the Strapi admin dashboard.\nHere you can see two tabs: one for the latest reviews and one for reviews grouped by content ID.\nIn both of them you can delete unwanted reviews.\nExample project You can find a full working example of a React App using the Strapi Ratings Client Library in this repo: https://github.com/luisguve/strapi-ratings-client-example\nConclusion With this plugin you can enable and manage user reviews for any content with little effort and even use a library of components styled with Bootstrap to display the user reviews in your frontend.\nAnd that\u0026rsquo;s it! The features are pretty basic at the moment but if there\u0026rsquo;s interest, I\u0026rsquo;m willing to work on more features as well as improve the UI/UX.\n","image":"//localhost:1313/images/post/tutorial-ratings.webp","permalink":"//localhost:1313/blogs/how-to-enable-and-manage-user-reviews-in-your-strapi-application/","tags":["Strapi","Strapi tutorials"],"title":"How To Enable And Manage User Reviews In Your Strapi Application"},{"categories":["Documentation"],"contents":"Ratings is a Strapi plugin that allows your users to post reviews.\nEnable and manage user reviews for your content very easily!\nRequirements You should have installed an instance of Strapi v4.x.x\nInstallation Run the following command in your project root:\nnpm install strapi-plugin-ratings Then, rebuild the admin dashboard using the following command\nnpm run build Configurarion For your frontend to have access to the API, enable the following permissions for Ratings from Users \u0026amp; Permissions Plugin on your project settings:\nFor public, enable: count, find, getPageSize and getStats.\nFor authenticated, enable create, find and getUserReview.\nDisplay user reviews on the frontend Reviews can be displayed in the frontend in two ways:\nUsing the React components library strapi-ratings-client (recommended) Build your custom frontend using the API endpoints, described as follows: API There are some Typescript interfaces that will help to get an idea of the data structures.\nReviews: interface IReview { id: number, createdAt: string, comment: string | null, author: IAuthor | null, score: number, } Authors: interface IAuthor { username: string, email: string, id: number } Content Stats interface IStats { averageScore: number; reviewsCount: number | null; } The following endpoints are exposed to fetch and post reviews:\nGet reviews for a content ID Method: GET\nPath: /api/ratings/reviews/:slug\nOptional query parameters: start, ignoreCount\nReturns:\n{ reviewsCount: number, averageScore: number, userReview: IReview | null, reviews: IReview[] } The parameter start indicates how many reviews to skip. This is for pagination purposes.\nThe parameter ignoreCount indicates whether or not to return the total number of reviews associated with the given slug.\nGet review stats for a content ID Method: GET\nPath: /api/ratings/reviews/:slug/stats\nReturns:\n{ averageScore: number, reviewsCount: number | null } Get the number of reviews associated with a given content ID Method: GET\nPath: /api/ratings/reviews/:slug/count\nReturns:\n{ count: number } Post a review Method: POST\nPath: /api/ratings/reviews/:slug\nAuthentication: Bearer token\nPayload:\n{ content: string } Returns:\n{ id: number } By default, every authenticated user can post reviews on any content.\nIn order to customize this behavior, e.g. allowing or disallowing a user from posting reviews, you must extend the service userCanPostReview from whithin register function in ./src/index.js. For example:\nstrapi.service(\u0026#34;plugin::ratings.review\u0026#34;).userCanPostReview = async (user, slug) =\u0026gt; { /* Here you will check whether or not the user is allowed to post a review on this content ID and return either true or false. */ return true } Notice that userCanPostReview will receive two parameters: the user from Users \u0026amp; Permissions Plugin, containing it\u0026rsquo;s id, username, confirmed, etc., and the slug, which is a string and refers to the content ID which the review is being posted on.\nIn case this function returns false, the response of the endpoint will be 403 (forbidden) with the text User cannot post a review on this content.\nGet the page size Method: GET\nPath: /api/ratings/page-size\nReturns:\n{ pageSize: number } General settings The plugin allows to set how many reviews are returned per page by going to the Pagination section under Ratings Plugin of the Settings section.\nThe default page size is 10.\nManagement of reviews Admin users are able to delete reviews from within the plugin page of the Strapi admin dashboard.\nThe plugin interface has two tabs: one for the latest reviews and one for reviews by content ID.\nRoadmap and future plans The plugin is pretty basic but it can be improved with more features and a better UI/UX. Collaborations and suggestions are very welcome.\n","image":"//localhost:1313/images/post/ratings.webp","permalink":"//localhost:1313/blogs/strapi-plugin-ratings/","tags":["Strapi","Strapi plugins"],"title":"Strapi Plugin Ratings"},{"categories":["Projects"],"contents":"ManyLMS is an e-learning platform built on top of Strapi, React Router 7, Typescript and other technologies.\nOutline The idea Platform features The stack The API The frontend Conclusion Landing Page The idea This project doesn\u0026rsquo;t necessarily bring a huge amount of innovation on the e-learning platforms that already exists, but it\u0026rsquo;s just another way of doing this type of application.\nThe main idea is to apply a JAMstack approach in this application, where the platform is a static website, and the backend is just an API that serves static content only once to build the website and just adds the dynamism that\u0026rsquo;s necessary to allow users to authenticate, create orders, confirm payments and take courses.\nIf we compare this approach to a WordPress website, we are taking out most of the overhead that implies rendering the pages everytime a user visits them. Despite that there are plugins for caching that may improve the performance, it\u0026rsquo;s still never going to be faster and more efficient than just static content served by a CDN. That\u0026rsquo;s why React Router 7 and Headless CMSs are so popular right now.\nPlatform features and user stories The following user stories illustrates the desired features the platform should have.\nAs an administrator, I want to: login in the admin panel. create categories. create courses. upload lectures. organise courses into categories. assign lectures to courses. As a student, I want to: login in the platform. view the available courses. add courses to the shopping cart. review the shopping cart. create an order. pay with credit card or paypal. view the courses i\u0026rsquo;ve purchased in my learning page. go to the course page from my learning page and watch the videos. mark lectures as seen. come back later and resume where I left. The requirements The backend requires to handle user authentication, permissions, different data structures as content types and define relationships between them. It also requires to allow uploading videos to some third party platform that supports streaming on demand.\nThe frontend is a web platform where users can register and login, view and buy courses, leave comments and reviews and take courses.\nThe API Since all of the features involve authentication, permissions and roles, and because there is no need to reinvent the wheel, I chose to use Strapi to build the backend for it\u0026rsquo;s simplicity, ease of use and great developer experience, whereas for streaming videos on demand, I chose to use Mux.com.\nThe instance of Strapi and the Postgres database it requires was deployed in the cloud hosting platform https://fly.io.\nStrapi is good for managing users, content that\u0026rsquo;s typically updated and fetched via CRUD API, and setting up relations between content types.\nThe platform needs the following content types:\nCategory to group courses Course Lecture Module to group lectures Order Student: has many courses Student-Course: stores a student\u0026rsquo;s current lecture of a course Video Strapi makes the creation of these content types and setting up relationships between them really straightforward.\nBelow are some screenshots of these content types and the relationships between them:\nThe frontend The platform where users are able to login, view, buy and view courses is a web application built with React Router 7. Among the features of this application are:\nState managed by Context API Interface styled with Bootstrap Play streaming videos with @mux/mux-player-react library Use of localStorage to save user session Below are some sample screenshots of how this app looks like\nConclusion and final thoughts While building this project, I learned:\nHow streaming on demand works and how to use a streaming provider How to statically build websites with React Router 7 and Strapi How to setup dynamic pages in React Router 7 How to process payments with Stripe and Paypal How to build custom plugins in Strapi How to publish packages to NPM Project source codes: https://github.com/luisguve/maestro-backend\nhttps://github.com/luisguve/new-lms-remix\n","image":"//localhost:1313/images/project/manylms/frontend/course_overview.png","permalink":"//localhost:1313/projects/e-learning-platform-maestro-lms/","tags":["Strapi","React","React Router 7","Typescript","Mux"],"title":"ManyLMS: E-Learning platform"},{"categories":["Projects"],"contents":"ETMday (Emprende tu Mente) is a large-scale entrepreneurship event website built on top of WordPress with the Themosis framework, featuring an interactive SVG map, real-time countdown timers, advanced search functionality, and comprehensive content management using Vue 3, Laravel Mix, and modern frontend technologies.\nOutline The project Key features The stack Frontend architecture Interactive components Conclusion Live website The project ETMday is Chile\u0026rsquo;s premier entrepreneurship event, bringing together thousands of entrepreneurs, startups, corporates, and strategic partners. The website serves as the central hub for event information, featuring speakers, activities, stands, program schedules, and an interactive event map.\nThe frontend development required implementing complex interactive features including an SVG-based interactive map with tooltips, real-time countdown timers, advanced filtering and search systems, and dynamic content displays that handle thousands of attendees and hundreds of activities.\nKey features The website includes several sophisticated features:\nInteractive SVG Map: Custom-built interactive map with clickable zones, tooltips, and dynamic content display Real-time Countdown: Event countdown timer with automatic updates and mobile optimization Advanced Search: Multi-category search across activities, speakers, stands, and content Dynamic Filtering: Complex filtering system with tabs, favorites, and downloadable resources Animated Statistics: Odometer animations for displaying event metrics Content Management: Comprehensive card components for activities, speakers, stands, and blog posts Form Handling: Multi-step forms with validation using Vee-Validate Lightbox Galleries: Image galleries with LightGallery integration Responsive Design: Fully responsive design optimized for all devices The stack The frontend stack consists of:\nVue 3.2.4: Modern reactive framework for building interactive components Laravel Mix 6.0: Asset compilation and bundling SCSS: Advanced styling with organized architecture Vee-Validate 4.15.0: Form validation with Yup schemas Axios 1.6.8: HTTP client for API requests Splide.js 4.1.4: Modern carousel and slider components LightGallery 2.8.3: Lightbox gallery functionality Odometer 0.4.8: Animated number counting Headroom.js: Header behavior on scroll jQuery 3.7.1: DOM manipulation and legacy support SweetAlert2: Modern alert dialogs GLightbox 3.3.1: Alternative lightbox solution Frontend architecture Vue components The application features a comprehensive set of Vue 3 components:\nCard Components:\ncards/activities.vue: Activity cards with favorites functionality cards/speakers.vue: Speaker cards with modal details cards/stands.vue: Stand/exhibitor cards cards/blog.vue: Blog post cards cards/shortcut.vue: Quick access shortcut cards Functional Components:\nSectionCards.vue: Main section component with tabs, filtering, and card display Search.vue: Advanced search component with multi-category results Form.vue: Dynamic form component with validation FormCalendar.vue: Calendar form component CustomFilter.vue: Reusable filter component CustomSelect.vue: Custom select dropdown Pagination.vue: Pagination component JavaScript components The application includes 17 specialized JavaScript components:\nInteractive Features:\ninteractiveMap.js: SVG map interaction with tooltips, zones, and dynamic content countdown.js: Real-time countdown timer with automatic updates odometer.js: Animated number counting with scroll triggers map.js: Map zone interactions and modal displays UI Components:\nheader.js: Header functionality and navigation headroom.js: Header hide/show on scroll accordion.js: Accordion interactions tabs.js: Tab functionality cards.js: Card interactions and modals siteModals.js: Modal management system UI.js: General UI utilities Media Components:\nvideo.js: Video player setup lightgallery.js: Lightbox gallery initialization splide.js: Carousel initialization slick.js: Legacy carousel support Utilities:\nscrollTrigger.js: Scroll-based animations imgToSvg.js: SVG image conversion utility SCSS architecture The styling follows a well-organized SCSS architecture:\nscss/ ├── abstracts/ # Variables, mixins, functions │ ├── _functions.scss │ ├── _mixins.scss │ ├── _variables.scss │ ├── _mq.scss # Media query mixins │ └── _keyframes.scss ├── base/ # Base styles and typography │ ├── _typography.scss │ ├── _container.scss │ └── _reset.scss └── components/ # Component-specific styles └── [52 component files] Key SCSS features:\nBEM methodology: Consistent naming convention Media query mixins: Using sass-mq for responsive design Modular architecture: Each component has its own SCSS file Component organization: 52 component-specific SCSS files Interactive components Interactive SVG Map The interactiveMap.js component implements a sophisticated SVG-based interactive map:\nFeatures:\nSVG Tooltips: Dynamically generated tooltips with text wrapping Zone Interactions: Clickable zones with modal displays Point Markers: Interactive points with icons and labels Dynamic Content: Content loaded based on zone/point selection Responsive Design: Optimized for mobile and desktop Technical Implementation:\nSVG namespace manipulation for tooltip creation Text wrapping algorithm for tooltip content Path generation for tooltip shapes with rounded corners Event delegation for zone and point interactions Smooth animations and transitions Real-time Countdown The countdown.js component provides a real-time countdown timer:\nFeatures:\nAutomatic Updates: Updates every second Multi-unit Display: Days, hours, minutes, and seconds Pluralization: Proper Spanish pluralization (Día/Días, Hora/Horas) Mobile Optimization: Simplified display on mobile devices End State Handling: Automatic transition when countdown ends Advanced Search System The Search.vue component implements a comprehensive search system:\nFeatures:\nMulti-category Search: Searches across activities, speakers, stands, and other content Category Tabs: Quick navigation between result categories Result Counts: Dynamic result counts per category Scroll Navigation: Smooth scrolling to category sections Carousel Display: Splide carousels for result display Loading States: Loading indicators during search Empty States: User-friendly empty state messages Dynamic Filtering System The SectionCards.vue component provides advanced filtering:\nFeatures:\nTab Navigation: Multiple filter tabs Favorites System: Save and filter favorite items Search Integration: Inline search within filters Reset Functionality: Clear all filters with one click Downloadable Resources: Download buttons for resources URL Synchronization: Filter state in URL parameters Responsive Design: Mobile accordion interface Animated Statistics The odometer.js component provides animated number counting:\nFeatures:\nScroll-triggered: Animations trigger on scroll Prefix/Suffix Support: Handles formatted numbers (e.g., \u0026ldquo;56,000+\u0026rdquo;) Mobile Optimization: Static display on mobile Smooth Animations: Odometer theme integration Development workflow The project uses Laravel Mix for asset compilation:\n// Development npm run dev // Compile assets npm run watch // Watch for changes npm run hot // Hot module replacement // Production npm run production // Optimized production build BrowserSync integration provides:\nLive reloading during development Synchronized browser testing Proxy configuration for WordPress development Performance optimizations Code splitting: Laravel Mix extracts vendor libraries Asset versioning: Automatic cache busting Image optimization: Lazy loading and responsive images Minification: Production builds are minified and optimized Tree shaking: Unused code elimination in production SVG optimization: Efficient SVG manipulation and rendering Accessibility Semantic HTML structure ARIA labels for interactive elements Keyboard navigation support Focus management in forms and modals Screen reader considerations Proper alt text for images Conclusion and final thoughts Building the ETMday frontend was an excellent opportunity to:\nMaster SVG interactions: Creating complex interactive SVG maps with dynamic tooltips and zones Implement real-time features: Building countdown timers and live updates Build advanced search: Multi-category search with filtering and categorization Handle complex state: Managing filters, favorites, and dynamic content Optimize performance: Implementing efficient animations and lazy loading Ensure scalability: Building components that handle large datasets (thousands of attendees, hundreds of activities) The project demonstrates proficiency in:\nModern JavaScript frameworks (Vue 3) SVG manipulation and interaction Real-time UI updates Advanced filtering and search systems Build tools and asset compilation (Laravel Mix, Webpack) CSS architecture and methodologies (SCSS, BEM) Component-based development Event-driven architecture The integration with WordPress/Themosis backend required careful consideration of server-side rendering, API endpoints, and content management workflows, making this a full-stack frontend implementation for a large-scale event.\nLive website: https://etmday.org/\n","image":"//localhost:1313/images/project/etm/homepage.webp","permalink":"//localhost:1313/projects/etmday-entrepreneurship-event-website/","tags":["Vue 3","Laravel Mix","WordPress","Themosis","SCSS","JavaScript","Interactive Map","SVG"],"title":"ETMday: Entrepreneurship Event Website"},{"categories":["Projects"],"contents":"Chile Nativo is a travel tour website for Patagonia experiences, built on top of WordPress with the Themosis framework, featuring a modern frontend implementation based on a Figma design using Vue 3, Laravel Mix, and a comprehensive SCSS architecture.\nOutline The project Design implementation The stack Frontend architecture Key features Conclusion Live website The project Chile Nativo is a travel company specializing in Patagonia tours, offering experiences in destinations like Torres del Paine, Tierra del Fuego, and Isla Navarino. The website serves as the primary platform for showcasing tours, managing bookings, and providing information about their travel experiences.\nThe frontend development was based on a comprehensive Figma design, requiring pixel-perfect implementation of complex UI components, interactive forms, filtering systems, and responsive layouts that work seamlessly across all devices.\nDesign implementation The entire frontend was built from a detailed Figma design, ensuring:\nPixel-perfect accuracy: Matching the design specifications precisely Responsive design: Implementing breakpoints and mobile-first approach Component consistency: Maintaining design system patterns throughout Interactive elements: Translating static designs into dynamic, interactive components Animation and transitions: Implementing smooth user experience enhancements The stack The frontend stack consists of:\nVue 3.2.4: Modern reactive framework for building interactive components Laravel Mix 6.0: Asset compilation and bundling SCSS: Advanced styling with a well-organized architecture Pinia 2.3.1: State management for Vue applications Vee-Validate 4.15.0: Form validation with Yup schemas Axios 1.6.8: HTTP client for API requests Splide.js 4.1.4: Modern carousel and slider components Headroom.js: Header behavior on scroll Plyr 3.7.8: Video player implementation SweetAlert2: Modern alert dialogs jQuery 3.7.1: Legacy support and DOM manipulation utilities Frontend architecture Vue components The application features a comprehensive set of Vue 3 components organized by functionality:\nFiltering and Search Components:\nToursFilter.vue: Advanced tour filtering with multiple criteria TourDatesFilter.vue: Date-based filtering for tour availability ToursFilterDropdown.vue \u0026amp; ToursFilterDropdownMobile.vue: Responsive filter dropdowns TestimonialsFilter.vue: Filtering system for customer testimonials NewsFilter.vue: Blog and news filtering SearchResults.vue: Search results display with pagination Form Components:\nPersonalizedTripForm.vue: Multi-step form for custom trip requests with validation ContactFormSimple.vue: Contact form with reCAPTCHA integration FormHelp.vue: Help center form FormGiftCard.vue: Gift card purchase form FormCareers.vue: Job application form NewsletterForm.vue: Newsletter subscription Card Components:\nTour.vue \u0026amp; TourLoading.vue: Tour card display with loading states TourDate.vue \u0026amp; TourDateLoading.vue: Tour date selection cards Testimonial.vue \u0026amp; TestimonialLoading.vue: Customer testimonial cards Blog.vue \u0026amp; BlogLoading.vue: Blog post cards Team.vue \u0026amp; TeamLoading.vue: Team member cards ResourceCard.vue \u0026amp; ResourceLoading.vue: Resource display cards Utility Components:\nPagination.vue: Reusable pagination component Select.vue: Custom select dropdown with search Loader.vue \u0026amp; LoaderFullScreen.vue: Loading indicators EmptyState.vue: Empty state displays ContentResources.vue: Resource content management TeamTabsFilter.vue: Tabbed team member filtering SCSS architecture The styling follows a well-organized SCSS architecture:\nscss/ ├── abstracts/ # Variables, mixins, functions │ ├── _functions.scss │ ├── _mixins.scss │ ├── _variables.scss │ ├── _mq.scss # Media query mixins │ └── _keyframes.scss ├── base/ # Base styles and typography │ ├── _typography.scss │ ├── _colors.scss │ ├── _fonts.scss │ └── _reset.scss └── components/ # Component-specific styles └── [125 component files] Key SCSS features:\nBEM methodology: Consistent naming convention throughout Media query mixins: Using sass-mq for responsive design Modular architecture: Each component has its own SCSS file Abstract layer: Reusable variables, mixins, and functions Vue transitions: Custom transition styles for Vue components JavaScript architecture The JavaScript is organized into two main entry points:\nMain application (app.js):\nInitializes core application functionality Sets up jQuery plugins and utilities Handles legacy browser support Vue application (vue/main.js):\nConfigures Vue 3 app with Pinia for state management Registers global Vue components Sets up Vee-Validate configuration Integrates third-party Vue plugins (VueTelInput, etc.) Component utilities (app/components/):\nheader.js: Header behavior and navigation footer.js: Footer functionality splide.js: Carousel initialization slick.js: Legacy carousel support accordions.js: Accordion interactions tabs.js: Tab functionality scrollTrigger.js: Scroll-based animations video.js: Video player setup sticky-sidebar.js: Sticky sidebar behavior Key features Multi-step forms The PersonalizedTripForm.vue component implements a sophisticated multi-step form with:\nStep-by-step navigation with progress indicators Form validation using Vee-Validate and Yup schemas Dynamic form fields based on user selections Phone number input with international support (VueTelInput) reCAPTCHA integration for spam protection Loading states and error handling Advanced filtering system The tour filtering system (ToursFilter.vue) provides:\nMultiple filter criteria (destination, activity type, trip type, month) Real-time filtering with URL parameter synchronization Responsive design with mobile accordion interface Custom select components with search functionality Empty states and loading indicators Integration with WordPress backend via Axios Responsive design The entire website is fully responsive with:\nMobile-first approach Breakpoint management using sass-mq Touch-friendly interactions Optimized images and assets Performance optimizations for mobile devices Performance optimizations Code splitting: Laravel Mix extracts vendor libraries Asset versioning: Automatic cache busting Image optimization: Lazy loading and responsive images Minification: Production builds are minified and optimized Tree shaking: Unused code elimination in production Accessibility Semantic HTML structure ARIA labels where appropriate Keyboard navigation support Focus management in forms Screen reader considerations Development workflow The project uses Laravel Mix for asset compilation:\n// Development npm run dev // Compile assets npm run watch // Watch for changes npm run hot // Hot module replacement // Production npm run production // Optimized production build BrowserSync integration provides:\nLive reloading during development Synchronized browser testing Proxy configuration for WordPress development Conclusion and final thoughts Building the Chile Nativo frontend from a Figma design was an excellent opportunity to:\nMaster Vue 3: Working with the Composition API, reactive systems, and modern Vue patterns Implement complex forms: Multi-step forms with validation, international phone inputs, and reCAPTCHA Build scalable architecture: Organizing 40+ Vue components and 125+ SCSS files in a maintainable structure Optimize performance: Implementing code splitting, lazy loading, and production optimizations Ensure design fidelity: Translating Figma designs into pixel-perfect implementations Handle responsive design: Creating seamless experiences across all device sizes The project demonstrates proficiency in:\nModern JavaScript frameworks (Vue 3) Build tools and asset compilation (Laravel Mix, Webpack) CSS architecture and methodologies (SCSS, BEM) Form validation and user experience Component-based development Design system implementation The integration with WordPress/Themosis backend required careful consideration of server-side rendering, API endpoints, and content management workflows, making this a full-stack frontend implementation.\nLive website: https://chilenativo.travel/\nFigma prototype: https://www.figma.com/proto/ywHPhSP1UfYUAE8eWVQv4L/Dise%C3%B1o-Desktop---Chile-Nativo?node-id=289-3912\u0026m=dev\u0026scaling=min-zoom\u0026content-scaling=fixed\u0026page-id=289%3A3911\u0026starting-point-node-id=289%3A3912\n","image":"//localhost:1313/images/project/chile-nativo/home.png","permalink":"//localhost:1313/projects/chile-nativo-patagonia-travel-website/","tags":["Vue 3","Laravel Mix","WordPress","Themosis","SCSS","JavaScript","Figma"],"title":"Chile Nativo: Patagonia Travel Website"},{"categories":["Projects"],"contents":"Rutieri is a SaaS platform built with Strapi, React Native, Typescript and other technologies.\nOutline The idea Platform features The stack The API The frontend The mobile app Conclusion Landing Page The idea Before starting to write a single line of code, it is generally a good idea to think about the problem, it\u0026rsquo;s limitations and whether or not it has already been solved by someone else (AKA competitors).\nThe problem I was looking into had to do with the way in which public and private transportation companies manage their routes, drivers and users. This process is generally carried out on paper, e.g. not digital, hence this could be problematic in case of new drivers joining the organization or in case of restricting access to data to only specific users.\nAfter a little bit of research, I could only find one platform that provides a similiar solution but for their own company.\nPlatform features and user stories The following user stories illustrates the desired features the platform should have in order to solve the aforementioned problems.\nAs an administrator user, I want to: login in the admin panel. create an organization. create routes in the organization. invite drivers and users to the organization. manage requests to join the organization. assign routes to drivers in the organization. see in real time the drivers and users currently active in the map of the different routes. As a driver, I want to: login in the mobile app. join an organization by entering the code in the search bar. see my route on the map. become visible to passengers on the road. see the passengers waiting on the road. remove my visibility and finish my run. As a passenger, I want to: login in the mobile app. join an organization by entering the code in the search bar. see the different routes of my organization in the map. search for a destination and get the available routes that pass nearby. see the drivers currently active on the routes in real time. become visible to drivers of a route. The requirements The backend requires to handle user authentication, permissions, different data structures as content types and define relations between them. It\u0026rsquo;s also necessary to synchronise passengers and drivers and view them on a map real time in the administration panel as well as in the mobile app.\nThe administration panel is a web page that fetches data from the backend as well as from the real time data provider and it\u0026rsquo;s goal is to provide a way for administrators to manage their organization and users. We\u0026rsquo;re talking about a Single Page Application built in React.\nAs for the mobile application, there isn\u0026rsquo;t a better choice nowadays than React Native and it works just fine in this case.\nThe API Since all of the features involve authentication, permissions and roles, and because there is no need to reinvent the wheel, I chose to use Strapi to build the backend for it\u0026rsquo;s simplicity, ease of use and great developer experience, whereas for realtime data, I used Firebase.\nThe instance of Strapi and the Postgres database it requires was deployed in the cloud hosting platform https://fly.io.\nStrapi is good for managing users, content that\u0026rsquo;s typically updated and fetched via CRUD API, and relations between content types.\nThe platform needs the following content types:\nOrganizations to group routes, drivers and users Routes Two user roles: drivers and users (passengers) Below are some screenshots of the overview of these content types\nAs I said before, Strapi makes the creation of these content types and the relationships between them really straightforward.\nHowever, not everything related to the API can be provided by Strapi. Some realtime features need to be addressed with other solutions, such as geolocation data in real time for drivers and users to synchronise each other, maps and the ability to search for places. Such features were implemented using Firebase, Google Maps and Google Places.\nThe frontend The platform where users are able to login as administrators and manage their organizations and users is a single page web application built in React. Among the features of this project that I think stand out are:\nState managed by Context API Interface styled with Bootstrap React Router for pages Leaflet to display the map GeoFire library to synchronise geolocation data in real time with Firebase Use of localStorage to save user session Below are some sample screenshots of how this app looks like\nThe mobile application This one is by far the most complex part of this project.\nThe project was bootstraped with Infinitered\u0026rsquo;s Ignite, which provides a great boilerplate and surely saved me of what would have been between 1-2 months of work.\nIgnite\u0026rsquo;s boilerplate includes many features out of the box, including:\nReact Native and Typescript (of course) React Navigation MobX-State-Tree for state management Expo SDK for developer experience AsyncStorage for persistence apisauce as REST client And some other libraries and features that make React Native apps super powerful and a joy to work on.\nIt consists of three screens:\nWelcome screen Login screen Map screen In the welcome screen, users are able to go to the login screen if not logged in. Otherwise, if they\u0026rsquo;re in an organisation, it shows their role and org\u0026rsquo;s information, and if they\u0026rsquo;re not, they are able to enter the organisation code and request to join as driver or as passenger.\nWelcome screens Login screens If the user is a driver in an organisation, the welcome screen also shows the route assigned to them. By tapping on it, it takes them to the map, where they can see themselves and start the tour, becoming visible to passengers on the road but being able to see passengers on the road as well.\nDrivers can finish the tour at any time by pressing the button stop.\nIf the user is a passenger in an organisation, the welcome screen shows the different routes available in the organisation. By tapping on them, they are taken to the map where they can see themselves, the route and the drivers on the road.\nPassengers are able to navigate between the available routes and search for the location they want to go to by using the search bar at the top of the map screen, filtering out the routes that pass nearby (less than 200 meters), if there are. Google Places API and turf library work together in this search process.\nPassengers become visible to drivers on the road by pressing the button wait and if they press the button again, they stop waiting and are removed from the driver\u0026rsquo;s map.\nMap screens The start/wait and finish buttons dispatch actions that update their location in firebase, so that passengers are able to see the bus on the map as it moves in real time and viceversa.\nAs for the state management, the project consists of two models and three stores from Mobx-State-Tree library: User and Route models, user-status, route-store and root-store stores.\nUser model Located in /app/models/user/user.ts\nconst OrganizationModel = types.model({ name: types.string, code: types.string, id: types.identifierNumber, drivers: types.number, rutas: types.array(RouteModel) }) const UserModel = types .model(\u0026#34;User\u0026#34;) .props({ id: types.identifierNumber, username: types.string, email: types.string, token: types.string, role: types.union(types.literal(\u0026#34;passenger\u0026#34;), types.literal(\u0026#34;driver\u0026#34;)), ruta: types.maybeNull(RouteModel), organization: types.maybeNull(OrganizationModel), pending_request: types.maybeNull(OrganizationModel), }) Route model Located in /app/models/route/route.ts\nThis model follows the GeoJSON format for routes.\nconst RouteModel = types .model(\u0026#34;Ruta\u0026#34;) .props({ id: types.identifierNumber, name: types.string, latlong: types.maybeNull(types.model({ lat: types.number, longt: types.number })), coords: types.model({ type: FeatureTypes, features: types.array(types.model({ type: types.string, geometry: types.model({ type: types.string, coordinates: types.union(types.array(types.number), types.array(types.array(types.number))) }), properties: types.model({ name: types.string }) })) }) }) user-status store Located in /app/models/user-status/user-status.ts\nThis store is responsible for managing the state of the user. It stores the user once it\u0026rsquo;s logged in and removes it when the user logs out. It also has some views to get the user key for firebase purposes, get the role and get the route in case of a driver.\nThis store has some methods that get the user location from the device\u0026rsquo;s GPS, displays the user icon on the map and sends it to firebase.\nconst UserStatusModel = types .model(\u0026#34;UserStatus\u0026#34;) .extend(withEnvironment) .props({ user: types.maybeNull(UserModel), location: types.maybeNull( types.model({latitude: types.number, longitude: types.number}) ), visibility: types.maybeNull(types.number) }) route-store store Located in /app/models/route-store/route-store.ts\nThis store is responsible for managing the state of the available routes. It stores the routes, drivers and passengers on the different routes. It also has some view methods to filter the routes that pass nearby a destination specified by the user, get passengers waiting on a given route and get drivers active in a specific route.\nThis store initializes a GeoQuery from Geofire library and listens for events to set, update and remove drivers and passengers from the map as they move.\nconst RouteStoreModel = types .model(\u0026#34;RouteStore\u0026#34;) .props({ routes: types.array(RouteModel), passengers: types.map(types.model({ key: types.identifier, location: types.array(types.number) })), drivers: types.map(types.model({ key: types.identifier, location: types.array(types.number) })), destinationAddress: types.maybeNull(types.model({ name: types.string, coords: types.array(types.number) })) }) Conclusion and final thoughts Using a CMS as the backend can make the development a lot faster than building the API from scratch and with Strapi this is specially true. On the other hand, Strapi doesn\u0026rsquo;t really make a good fit for real time applications, therefore, Firebase is the way to go in this case.\nAs of the client side, React always works very good for pretty much any kind of application, and because React Native uses React under the hood, it is so convenient for us React developers and ir works pretty good for almost any kind of application as well.\nHowever, one thing that I didn\u0026rsquo;t mention in this post was the use of Typescript; I find this quote by Brice Wilson pretty good to point out the whole purpose and motivation to learn and use (well) this powerful language and tool ecosystem:\n\u0026ldquo;You won\u0026rsquo;t have to wait for a frustrated user to report the error. All of this means that you provide value to your users faster, and that\u0026rsquo;s really what it\u0026rsquo;s all about.\u0026rdquo;\nAll in all, I got a lot of learning by building this project, both in languages/frameworks used and production stuff such as infrastructure, cloud hosting and cloud-based APIs.\nProject landing page: https://rutieri.netlify.app\n","image":"//localhost:1313/images/project/rutieri/landing/homepage.webp","permalink":"//localhost:1313/projects/saas-platform-rutieri/","tags":["Strapi","React Native","React","Typescript","Firebase"],"title":"SaaS platform: Rutieri"},{"categories":["Tutorial"],"contents":"Enable comments in a Strapi application and display them in the frontend with React\nOutline Introduction Prerequisites What is Strapi Comment Manager? Installation Configuration Display comments on the frontend Installation of Strapi Comments Client Usage of Strapi Comments Client Plugin settings Manage comments Full source code of the frontend Conclusion Introduction A comment system comes in very handy for pretty much any kind of website. In the JAMstack ecosystem, while it\u0026rsquo;s ok to rely on third party solutions hosted on their own platform such as Disqus to enable comments, you usually want to keep your content and all the stuff related to it in the same admin dashboard.\nIn this article, I\u0026rsquo;ll show you how to enable and manage comments for your content very easily using the Comment Manager plugin, and display them in your frontend application.\nPrerequisites You should have a basic understanding of the following.\nBasic knowledge of JavaScript Basic knowledge of React (OPTIONAL) Basic understanding of Strapi - get started here. Your Strapi V4 project setup What is Strapi Comment Manager? Strapi Comment Manager is a plugin that enables comments for pretty much any kind of content. It allows your users to post comments and anyone can get the comments associated with a given slug.\nWith this plugin, admin users can view and manage very easily all the comments from the Strapi administration dashboard. Within the dashboard, you will be able to delete comments and subcomments and leave replies on comments.\nInstallation Once into the Strapi project root, you can install the plugin by running the following command:\nnpm install strapi-plugin-comment-manager Next, build the project to see the new plugin in the dashboard with the following command:\nnpm run build And that\u0026rsquo;s it! If everything runs correctly, the plugin should now be installed.\nConfiguration Now you need to enable some permissions so that the frontend can access the endpoints to post and fetch comments.\nIn your Strapi admin dashboard, head over to Settings, then over to Roles under Users \u0026amp; Permissions Plugin.\nLet\u0026rsquo;s first setup the Public API; click on Public and hit the dropdown button of Comment Manager. Now check count, find and getPageSize, then hit the Save button. Below is a screenshot of a proper configuration:\nNow let\u0026rsquo;s setup the Authenticated API. Go back to Roles and click on Authenticated. Open the dropdown for Comment Manager and mark as checked the option create on both Comment and Subcomment. Below is a screenshot of a proper configuration:\nWith this configuration, the frontend should now be able to make requests to get and post comments.\nDisplay comments on the frontend The plugin exposes an API to get and post comments if you want to have fine-grained control over the workflow of your comments system and you can check the documentation on the package page, but this plugin also comes with a purpose-built React component library that makes it super easy to get up and running without getting your hands dirty.\nThis components library is called strapi-comments-client, fully supports typescript and it handles for you all of the complexity of fetching and posting comments and subcomments for every content ID that you pass to it.\nInstallation of Strapi Comments Client You will need to have installed react ^17.0.2, react-dom ^17.0.2 and react-router-dom ^5.2.0.\nInside of your React project, run this command:\nnpm install strapi-comments-client --save Usage of Strapi Comments Client Using this library is very easy!\nThis library exports three main components:\nCommentsProvider Comments CommentForm And you can import them this way:\nimport { CommentsProvider, Comments, CommentForm } from \u0026#34;strapi-comments-client\u0026#34; All you have to do is wrap your App component into the CommentsProvider component. Then you will be able to place anywhere in your app the Comments component to render a list of comments for a given content ID and the CommentForm component to render a form to post comments.\nFor example, this could be your index.js or main.js file:\nimport React from \u0026#39;react\u0026#39; import ReactDOM from \u0026#39;react-dom\u0026#39; // The address of your strapi backend instance const STRAPI = \u0026#34;http://localhost:1337\u0026#34; ReactDOM.render( \u0026lt;React.StrictMode\u0026gt; \u0026lt;CommentsProvider apiURL={STRAPI}\u0026gt; \u0026lt;App /\u0026gt; \u0026lt;/CommentsProvider\u0026gt; \u0026lt;/React.StrictMode\u0026gt;, document.getElementById(\u0026#39;root\u0026#39;) ) Where apiURL is the URL of your running Strapi application, and this property is required.\nThis way, the comments provider will do all the magic of fetching and posting comments for you!\nThis library also exports an utility React.Context to update some of the parameters for fetching and posting comments:\nimport { CommentsConfigContext } from \u0026#34;strapi-comments-client\u0026#34; This CommentsConfigContext exposes two setter functions: setUser and setContentID\nWith setContentID you can load the comments for a given content and post comments to it. It receives a single parameter of type string and must be URLized, i.e. no spaces.\nWith setUser you can set the credentials of a given user to authorize the posting of comments. It receives a single parameter of type IUser, with the following Typescript interface:\ninterface IUser { username: string, email: string, id: string, token: string // This is a JWT } It\u0026rsquo;s a little confusing but we\u0026rsquo;ll see how to use it in a component:\nconst App = () =\u0026gt; { const { setUser, setContentID } = useContext(CommentsConfigContext) // The following data should come from Strapi Users and Permissions Plugin // for authenticated requests const user = { username: \u0026#34;John Doe\u0026#34;, email: \u0026#34;jhohndoe@gmail.com\u0026#34;, id: 5, token: \u0026#34;this_should_be_a_JWT\u0026#34; } if (user) { setUser(user) } setContentID(\u0026#34;sample-content-1\u0026#34;) // Load comments for this content return ( \u0026lt;\u0026gt; { !user \u0026amp;\u0026amp; \u0026lt;Login /\u0026gt; } \u0026lt;CommentForm /\u0026gt; \u0026lt;Comments /\u0026gt; \u0026lt;/\u0026gt; ) } And that\u0026rsquo;s it!\nAfter setting the content ID through setContentID, CommentsProvider will start loading the comments for the given content ID and the CommentForm will render an input to post comments related to the given content ID if there is a user. Otherwise, it will display the message Login to post a comment.\nHere\u0026rsquo;s how the interface looks like so far:\nThere\u0026rsquo;s also a button to Leave a reply, which will open a form to post a subcomment associated with the parent comment.\nThis library exports one more component: ErrorBox\nimport { ErrorBox } from \u0026#34;strapi-comments-client\u0026#34; .It\u0026rsquo;s useful if you\u0026rsquo;d like to display error messages when things go wrong fetching or posting comments.\nYou can place this component wherever you want, for example in between the CommentForm and the Comments components.\nIf you\u0026rsquo;re wondering how this error box looks like, here you have a sample:\nGeneral settings You can customize the page size, i.e. specify how many comments are returned at once.\nIn the Strapi admin panel, head over to Settings, then select Pagination under Comment Manager Plugin.\nHere you\u0026rsquo;ll find an input to set the page size, which defaults to 10.\nManage comments Once you\u0026rsquo;ve got the plugin up an running, as users start to post comments, you can manage and reply to them as admin from the Comment Manager section of the left sidebar in the Strapi admin dashboard.\nHere you can see two tabs: one for the latest comments and one for comments grouped by content ID.\nIn both of them you can delete comments and subcomments as well as leave replies.\nExample project You can find a full working example of a React App using the Strapi Comments Client Library in this repo\nConclusion With this plugin you can enable and manage comments for any content with little effort and even use a component library to display the comments in your frontend application made with React.\nAnd that\u0026rsquo;s it! The features are pretty basic at the moment but if there\u0026rsquo;s interest, I\u0026rsquo;m willing to work on more features as well as improve the UI/UX.\n","image":"//localhost:1313/images/post/strapilogo.jpg","permalink":"//localhost:1313/blogs/how-to-enable-and-manage-comments-in-your-strapi-application/","tags":["Strapi","Strapi tutorials"],"title":"How To Enable And Manage Comments In Your Strapi Application."},{"categories":["Documentation"],"contents":"Comment Manager is a Strapi plugin to allow your users to post comments.\nWith this plugin you can enable and manage comments for your content very easily!\nRequirements You should have installed an instance of Strapi v4.x.x\nInstallation Run the following command in your project root:\nnpm install strapi-plugin-comment-manager Configurarion For your frontend to have access to the API, enable the following permissions for Comment Manager from Users \u0026amp; Permissions Plugin on your project settings:\nFor public, enable: count, find and getPageSize.\nFor authenticated, enable create on both Comment and Subcomment.\nDisplay comments on the frontend Comments can be displayed in the frontend in two ways:\nUsing the React components library strapi-comments-client (recommended) Build your custom frontend using the API API There are some Typescript interfaces that will help to get an idea of the data structures.\nComments: interface IComment { id: string, from_admin: boolean, createdAt: string, content: string, author: IAuthor | null, subcomments?: ISubcomment[] } Subcomments: interface ISubcomment { id: string, from_admin: boolean, createdAt: string, content: string, author: IAuthor | null, } Authors: IAuthor { username: string, email: string, id: string } The following endpoints are exposed to fetch and post comments and subcomments:\nGet comments for a content ID Method: GET\nPath: /api/comment-manager/comments/:slug\nOptional query parameters: start, ignoreCount\nReturns:\n{ commentsCount?: Number, comments: IComment[] } The parameter start indicates how many comments to skip. This is for pagination purposes.\nThe parameter ignoreCount indicates whether or not to return the total number of comments associated with the given slug.\nGet the number of comments associated with a given content ID Method: GET\nPath: /api/comment-manager/comments/:slug/count\nReturns:\n{ count: Number } Post a comment Method: POST\nPath: /api/comment-manager/comments/:slug\nAuthentication: Bearer token\nPayload:\n{ content: string } Returns:\n{ id: Number } Post a subcomment Method: POST\nPath: /api/comment-manager/subcomments/:parent-id\nAuthentication: Bearer token\nPayload:\n{ content: string } Returns:\n{ id: Number } Get the page size Method: GET\nPath: /api/comment-manager/page-size\nReturns:\n{ pageSize: Number } General settings The plugin allows to set how many comments are returned per page by going to the Pagination section under Comment Manager Plugin on the Settings section.\nThe default page size is 10.\nManagement of comments Admin users are able to delete comments and subcomments as well as leave replies as admins from within the plugin page of the Strapi admin dashboard.\nThe plugin interface has two tabs: one for the latest comments and one for comments by content ID.\nRoadmap and future plans The plugin is pretty basic but it can be improved with more features and a better UI/UX. Collaborations and suggestions are very welcome.\n","image":"//localhost:1313/images/post/strapilogo.jpg","permalink":"//localhost:1313/blogs/strapi-plugin-comment-manager/","tags":["Strapi","Strapi plugins"],"title":"Strapi Plugin Comment Manager"},{"categories":["Projects"],"contents":"In this post I’m going to share my experience on building a SaaS using the headless CMS Strapi as the Backend, React Native and other technologies.\nOutline Introduction What is SaaS? The problem What is Strapi? Developing features in Strapi The frontend: How to get content Conclusion Landing Page Introduction Very often, developers, product and project managers, testers and pretty much the entire team share their ideas to decide what language and which framework they\u0026rsquo;ll use to build their next project. Some considerations must be taken into account, from which in my opinion there are three that are the most important:\nDeveloper experience and ease of use Does the language and framework chosen provide a good developer experience? Is the langauge the same for the backend and frontend?\nDeadlines Is there a deadline to finish the project? if so, there is a good chance to finish the project on time if the team chooses the language they have more experience in.\nMaintainability As there will be usually more than one person working on the same part at the same time, if everything is kept organised, the whole development process will be frictionless.\nWith that in mind, developers and project managers will have a better insight on which language/framework to use.\nOther aspects should also be considered such as what the data structure will look like.\nIn my case, as it is usual, the backend of my project needs a database for users and their roles among other entities and their relations and a dashboard to allow admins to manage the data, and I was lucky to find out Strapi, as it includes a lot of these features out of the box with one single line of command to get started.\nWhat is SaaS? SaaS stands for Software-as-a-Service and it just means that a software is provided as a service in the cloud and it gives a solution to a specific problem, for which the users are willing to pay either monthly or annual subscription.\nThe problem Before starting to write a single line of code, it is generally a good idea to think about the problem, it\u0026rsquo;s limitations and whether or not it has already been solved by someone else (AKA competitors).\nThe problem I was looking into had to do with the way in which public and private transportation companies manage their routes, drivers and users. After a little bit of research, I could only find one platform that provides a similiar solution but for their own company.\nSo the platform I built needed the following content types:\nOrganizations to group routes, drivers and users Routes Two user roles: drivers and users (passengers) As I said before, Strapi makes the creation of these content types and the relationships between them really easy, but let\u0026rsquo;s first see what is Strapi and how it turns the API development into a satisfactory and fun experience.\nWhat is Strapi? Strapi is an open source headless CMS that allows developers to build complete RESTful APIs in just a couple of days instead of months. It includes a lot of useful features as plugins out of the box. Users and Roles management, Media library and an interface to create, view, edit and delete content are just some of them.\nRegarding the API, how does it makes the development faster?\nFirst of all, it enforces a specific folder structure, which helps to keep everything well organised and clean.\nSecondly, all database schemas are generated automatically and queries are made in JSON format, which really saves a lot of time.\nLastly, we can add more features to our Strapi application very easily via plugins from the marketplace.\nIt\u0026rsquo;s also worth noting that Strapi is a self-hosted CMS, which means that we can host it in whatever cloud platform we want, as well as test it locally in our computers before deploying it to the cloud.\nDeveloping features in Strapi Creating and configuring endpoints in Strapi is as straightforward as declaring a JSON in a single file:\nCreating controllers is straightforward as well:\nEvery controller gets all the data related to the request in the ctx parameter and it\u0026rsquo;s also used to send the response. This keeps everything in one place and really helps to improve the readability.\nOnce the API endpoints are defined, the next step is to enable the permissions for the specific user roles to have access to these endpoints:\nThe frontend: how to get content Since Strapi is a headless CMS, it\u0026rsquo;ll only provide content through the API. That means that the content can be consumed from anywhere. In our case, this content will be used in two applications: one for the organization owners and one for the users and drivers.\nThe application for the organization owners is a dashboard where administrators can create organizations, routes, accept drivers and users in the organization and assign routes to drivers. This is just a React Application:\nThe application for drivers and users is a mobile application built in React Native. Firebase was used to synchronise geolocation data in real time between drivers and users and display this information in a Map from Google Maps:\nConclusion Using a CMS as the backend can make the development a lot faster than building the API from scratch and with Strapi this is specially true. Furthermore, this becomes more important when building a brand-new product, as it\u0026rsquo;s usually recommended to launch as soon as possible to gather feedback from the users and validate the idea.\nProject landing page: https://rutieri.netlify.app\n","image":"//localhost:1313/images/post/03.webp","permalink":"//localhost:1313/blogs/how-i-built-a-saas-on-top-of-strapi-and-why-you-should-too/","tags":["Strapi","React Native","Typescript"],"title":"How I Built A SaaS On Top Of Strapi, And Why You Should Too"},{"categories":["Tutorial"],"contents":"Enable User Reviews in a Strapi application and display them in the frontend with React\nOutline Introduction Prerequisites What is Strapi Ratings? Installation Configuration Display user reviews on the frontend Plugin settings Manage user reviews Full source code of the frontend Conclusion Introduction Ratings systems have become a crucial part of any website with ecommerce capabilites, as they allow the users to post reviews on the items they purchase and publish their opinion to the public. A couple of reviews can make the difference between pressing the “Buy” button and moving on to the next website in the Google search results.\nIn this article, I\u0026rsquo;ll show you how to enable and manage user reviews for your content very easily using the Ratings plugin, and display them in your frontend application.\nPrerequisites First of all, you need to have a basic understanding of the following.\nBasic knowledge of JavaScript Basic knowledge of React (OPTIONAL) Basic understanding of Strapi - get started here. Your Strapi V4 project setup What is Strapi Ratings? Strapi Ratings is a plugin that gives your Strapi application the ability to manage ratings for pretty much any kind of content. It allows your users to post reviews and anyone can get the reviews associated with a given slug.\nWith this plugin, admin users can view and manage very easily all the reviews from the Strapi administration dashboard. Within the dashboard, you will be able to see reviews related to content slugs as well as delete reviews.\nInstallation Once into the Strapi project root, you can install the plugin by running the following command:\nnpm install strapi-plugin-ratings Next, build the project to see the new plugin in the dashboard with the following command:\nnpm run build And that\u0026rsquo;s it! If everything runs correctly, the plugin should now be installed.\nConfiguration Now you need to enable some permissions so that the frontend can access the endpoints to post and fetch reviews.\nIn your Strapi admin dashboard, head over to Settings, then over to Roles under Users \u0026amp; Permissions Plugin.\nLet\u0026rsquo;s first setup the Public API; click on Public and hit the dropdown button of Ratings. Now check count, find, getPageSize and getStats, then hit the Save button. Below is a screenshot of a proper configuration:\nNow let\u0026rsquo;s setup the Authenticated API. Go back to Roles and click on Authenticated. Open the dropdown for Ratings and mark as checked the options create, find and getUserReview. Below is a screenshot of a proper configuration:\nWith this configuration, the frontend should now be able to make requests to get and post user reviews.\nDisplay use reviews on the frontend The plugin exposes an API to get and post reviews if you want to have fine-grained control over the workflow of your ratings system and you can check the documentation on the package page, but this plugin also comes with a purpose-built React component library that makes it super easy to get up and running without getting your hands dirty.\nThis components library is called strapi-ratings-client, fully supports typescript and it takes care of all the complexity of fetching and posting user reviews for every content ID that you pass to it.\nInstallation of Strapi Ratings Client You will need to have installed react ^17.0.2, react-dom ^17.0.2, bootstrap ^5.1.3 and @popperjs/core^2.11.2\nInside of your React project, run this command:\nnpm install strapi-ratings-client --save Usage of Strapi Ratings Client Using this library is very easy!\nThis library exports three main components:\nReviewsProvider Reviews ReviewForm And you can import them this way:\nimport { ReviewsProvider, Reviews, ReviewForm } from \u0026#34;strapi-ratings-client\u0026#34; All you have to do is wrap your App component into the ReviewsProvider component. Then you will be able to place anywhere in your app the Reviews component to render a list of user reviews for a given content ID and the ReviewForm component to render a form to allow your users to post reviews.\nFor example, this could be your index.js or main.js file:\nimport React from \u0026#39;react\u0026#39; import ReactDOM from \u0026#39;react-dom\u0026#39; // The address of your strapi backend instance const STRAPI = \u0026#34;http://localhost:1337\u0026#34; ReactDOM.render( \u0026lt;React.StrictMode\u0026gt; \u0026lt;ReviewsProvider apiURL={STRAPI}\u0026gt; \u0026lt;App /\u0026gt; \u0026lt;/ReviewsProvider\u0026gt; \u0026lt;/React.StrictMode\u0026gt;, document.getElementById(\u0026#39;root\u0026#39;) ) Where apiURL is the URL of your running Strapi application, and this property is required.\nThis way, the ratings provider will do all the magic of fetching and posting comments for you!\nThis library also exports an utility React.Context to update some of the parameters for fetching and posting reviews:\nimport { ReviewsConfigContext } from \u0026#34;strapi-ratings-client\u0026#34; This ReviewsConfigContext exposes three setter functions: setUser, setContentID and setCanPostReview.\nWith setContentID you can load the ratings for a given content and post reviews to it. It receives a single parameter of type string and must be URLized, i.e. no spaces.\nWith setUser you can set the credentials of a given user to authorize the posting of reviews. It receives a single parameter of type IUser, with the following Typescript interface:\ninterface IUser { username: string, email: string, id: string, token: string // This is a JWT } With setCanPostReview, you can enable the user to post a review on the given content. This is useful for when you only allow a user to post a review after they purchase the product.\nIt\u0026rsquo;s a little confusing but we\u0026rsquo;ll see how to use it in a component:\nconst App = () =\u0026gt; { const { setUser, setContentID, setCanPostReview } = useContext(ReviewsConfigContext) // The following data should come from Strapi Users and Permissions Plugin // for authenticated requests. const user = { username: \u0026#34;John Doe\u0026#34;, email: \u0026#34;jhohndoe@gmail.com\u0026#34;, id: 5, token: \u0026#34;this_should_be_a_JWT\u0026#34; } if (user) { setUser(user) } setContentID(\u0026#34;sample-content-1\u0026#34;) // Load reviews for this content setCanPostReview(true) // Allow this user to post a review return ( \u0026lt;\u0026gt; { !user \u0026amp;\u0026amp; \u0026lt;Login /\u0026gt; } \u0026lt;ReviewForm /\u0026gt; \u0026lt;Reviews /\u0026gt; \u0026lt;/\u0026gt; ) } And that\u0026rsquo;s it!\nAfter setting the content ID through setContentID, ReviewsProvider will start loading the reviews for the given content ID and the ReviewForm will render an input to post a user review related to the given content ID if there is a user and he’s allowed to post a review. Otherwise, it will display the message Login to post a review or nothing at all if the user is not allowed to post a review.\nHere\u0026rsquo;s how the interface looks like so far:\nThis library exports one more component: ErrorBox\nimport { ErrorBox } from \u0026#34;strapi-ratings-client\u0026#34; .It\u0026rsquo;s useful for when you\u0026rsquo;d like to display error messages when things go wrong fetching or posting reviews.\nYou can place this component wherever you want, for example in between the ReviewForm and the Reviews components.\nIf you\u0026rsquo;re wondering how this error box looks like, here‘s a screenshot:\nGeneral settings You can customize the page size, i.e. specify how many user reviews are showed at once.\nIn the Strapi admin panel, head over to Settings, then select Pagination under Ratings Plugin.\nHere you\u0026rsquo;ll find an input to set the page size, which defaults to 10.\nManage reviews Once you\u0026rsquo;ve got the plugin up an running, as users start to post reviews, you can view them from within the Ratings section of the left sidebar in the Strapi admin dashboard.\nHere you can see two tabs: one for the latest reviews and one for reviews grouped by content ID.\nIn both of them you can delete unwanted reviews.\nExample project You can find a full working example of a React App using the Strapi Ratings Client Library in this repo: https://github.com/luisguve/strapi-ratings-client-example\nConclusion With this plugin you can enable and manage user reviews for any content with little effort and even use a library of components styled with Bootstrap to display the user reviews in your frontend.\nAnd that\u0026rsquo;s it! The features are pretty basic at the moment but if there\u0026rsquo;s interest, I\u0026rsquo;m willing to work on more features as well as improve the UI/UX.\n","image":"//localhost:1313/images/post/tutorial-ratings.webp","permalink":"//localhost:1313/blogs/how-to-enable-and-manage-user-reviews-in-your-strapi-application/","tags":["Strapi","Strapi tutorials"],"title":"How To Enable And Manage User Reviews In Your Strapi Application"},{"categories":["Documentation"],"contents":"Ratings is a Strapi plugin that allows your users to post reviews.\nEnable and manage user reviews for your content very easily!\nRequirements You should have installed an instance of Strapi v4.x.x\nInstallation Run the following command in your project root:\nnpm install strapi-plugin-ratings Then, rebuild the admin dashboard using the following command\nnpm run build Configurarion For your frontend to have access to the API, enable the following permissions for Ratings from Users \u0026amp; Permissions Plugin on your project settings:\nFor public, enable: count, find, getPageSize and getStats.\nFor authenticated, enable create, find and getUserReview.\nDisplay user reviews on the frontend Reviews can be displayed in the frontend in two ways:\nUsing the React components library strapi-ratings-client (recommended) Build your custom frontend using the API endpoints, described as follows: API There are some Typescript interfaces that will help to get an idea of the data structures.\nReviews: interface IReview { id: number, createdAt: string, comment: string | null, author: IAuthor | null, score: number, } Authors: interface IAuthor { username: string, email: string, id: number } Content Stats interface IStats { averageScore: number; reviewsCount: number | null; } The following endpoints are exposed to fetch and post reviews:\nGet reviews for a content ID Method: GET\nPath: /api/ratings/reviews/:slug\nOptional query parameters: start, ignoreCount\nReturns:\n{ reviewsCount: number, averageScore: number, userReview: IReview | null, reviews: IReview[] } The parameter start indicates how many reviews to skip. This is for pagination purposes.\nThe parameter ignoreCount indicates whether or not to return the total number of reviews associated with the given slug.\nGet review stats for a content ID Method: GET\nPath: /api/ratings/reviews/:slug/stats\nReturns:\n{ averageScore: number, reviewsCount: number | null } Get the number of reviews associated with a given content ID Method: GET\nPath: /api/ratings/reviews/:slug/count\nReturns:\n{ count: number } Post a review Method: POST\nPath: /api/ratings/reviews/:slug\nAuthentication: Bearer token\nPayload:\n{ content: string } Returns:\n{ id: number } By default, every authenticated user can post reviews on any content.\nIn order to customize this behavior, e.g. allowing or disallowing a user from posting reviews, you must extend the service userCanPostReview from whithin register function in ./src/index.js. For example:\nstrapi.service(\u0026#34;plugin::ratings.review\u0026#34;).userCanPostReview = async (user, slug) =\u0026gt; { /* Here you will check whether or not the user is allowed to post a review on this content ID and return either true or false. */ return true } Notice that userCanPostReview will receive two parameters: the user from Users \u0026amp; Permissions Plugin, containing it\u0026rsquo;s id, username, confirmed, etc., and the slug, which is a string and refers to the content ID which the review is being posted on.\nIn case this function returns false, the response of the endpoint will be 403 (forbidden) with the text User cannot post a review on this content.\nGet the page size Method: GET\nPath: /api/ratings/page-size\nReturns:\n{ pageSize: number } General settings The plugin allows to set how many reviews are returned per page by going to the Pagination section under Ratings Plugin of the Settings section.\nThe default page size is 10.\nManagement of reviews Admin users are able to delete reviews from within the plugin page of the Strapi admin dashboard.\nThe plugin interface has two tabs: one for the latest reviews and one for reviews by content ID.\nRoadmap and future plans The plugin is pretty basic but it can be improved with more features and a better UI/UX. Collaborations and suggestions are very welcome.\n","image":"//localhost:1313/images/post/ratings.webp","permalink":"//localhost:1313/blogs/strapi-plugin-ratings/","tags":["Strapi","Strapi plugins"],"title":"Strapi Plugin Ratings"},{"categories":["Projects"],"contents":"ManyLMS is an e-learning platform built on top of Strapi, React Router 7, Typescript and other technologies.\nOutline The idea Platform features The stack The API The frontend Conclusion Landing Page The idea This project doesn\u0026rsquo;t necessarily bring a huge amount of innovation on the e-learning platforms that already exists, but it\u0026rsquo;s just another way of doing this type of application.\nThe main idea is to apply a JAMstack approach in this application, where the platform is a static website, and the backend is just an API that serves static content only once to build the website and just adds the dynamism that\u0026rsquo;s necessary to allow users to authenticate, create orders, confirm payments and take courses.\nIf we compare this approach to a WordPress website, we are taking out most of the overhead that implies rendering the pages everytime a user visits them. Despite that there are plugins for caching that may improve the performance, it\u0026rsquo;s still never going to be faster and more efficient than just static content served by a CDN. That\u0026rsquo;s why React Router 7 and Headless CMSs are so popular right now.\nPlatform features and user stories The following user stories illustrates the desired features the platform should have.\nAs an administrator, I want to: login in the admin panel. create categories. create courses. upload lectures. organise courses into categories. assign lectures to courses. As a student, I want to: login in the platform. view the available courses. add courses to the shopping cart. review the shopping cart. create an order. pay with credit card or paypal. view the courses i\u0026rsquo;ve purchased in my learning page. go to the course page from my learning page and watch the videos. mark lectures as seen. come back later and resume where I left. The requirements The backend requires to handle user authentication, permissions, different data structures as content types and define relationships between them. It also requires to allow uploading videos to some third party platform that supports streaming on demand.\nThe frontend is a web platform where users can register and login, view and buy courses, leave comments and reviews and take courses.\nThe API Since all of the features involve authentication, permissions and roles, and because there is no need to reinvent the wheel, I chose to use Strapi to build the backend for it\u0026rsquo;s simplicity, ease of use and great developer experience, whereas for streaming videos on demand, I chose to use Mux.com.\nThe instance of Strapi and the Postgres database it requires was deployed in the cloud hosting platform https://fly.io.\nStrapi is good for managing users, content that\u0026rsquo;s typically updated and fetched via CRUD API, and setting up relations between content types.\nThe platform needs the following content types:\nCategory to group courses Course Lecture Module to group lectures Order Student: has many courses Student-Course: stores a student\u0026rsquo;s current lecture of a course Video Strapi makes the creation of these content types and setting up relationships between them really straightforward.\nBelow are some screenshots of these content types and the relationships between them:\nThe frontend The platform where users are able to login, view, buy and view courses is a web application built with React Router 7. Among the features of this application are:\nState managed by Context API Interface styled with Bootstrap Play streaming videos with @mux/mux-player-react library Use of localStorage to save user session Below are some sample screenshots of how this app looks like\nConclusion and final thoughts While building this project, I learned:\nHow streaming on demand works and how to use a streaming provider How to statically build websites with React Router 7 and Strapi How to setup dynamic pages in React Router 7 How to process payments with Stripe and Paypal How to build custom plugins in Strapi How to publish packages to NPM Project source codes: https://github.com/luisguve/maestro-backend\nhttps://github.com/luisguve/new-lms-remix\n","image":"//localhost:1313/images/project/manylms/frontend/course_overview.png","permalink":"//localhost:1313/projects/e-learning-platform-maestro-lms/","tags":["Strapi","React","React Router 7","Typescript","Mux"],"title":"ManyLMS: E-Learning platform"},{"categories":["Projects"],"contents":"ETMday (Emprende tu Mente) is a large-scale entrepreneurship event website built on top of WordPress with the Themosis framework, featuring an interactive SVG map, real-time countdown timers, advanced search functionality, and comprehensive content management using Vue 3, Laravel Mix, and modern frontend technologies.\nOutline The project Key features The stack Frontend architecture Interactive components Conclusion Live website The project ETMday is Chile\u0026rsquo;s premier entrepreneurship event, bringing together thousands of entrepreneurs, startups, corporates, and strategic partners. The website serves as the central hub for event information, featuring speakers, activities, stands, program schedules, and an interactive event map.\nThe frontend development required implementing complex interactive features including an SVG-based interactive map with tooltips, real-time countdown timers, advanced filtering and search systems, and dynamic content displays that handle thousands of attendees and hundreds of activities.\nKey features The website includes several sophisticated features:\nInteractive SVG Map: Custom-built interactive map with clickable zones, tooltips, and dynamic content display Real-time Countdown: Event countdown timer with automatic updates and mobile optimization Advanced Search: Multi-category search across activities, speakers, stands, and content Dynamic Filtering: Complex filtering system with tabs, favorites, and downloadable resources Animated Statistics: Odometer animations for displaying event metrics Content Management: Comprehensive card components for activities, speakers, stands, and blog posts Form Handling: Multi-step forms with validation using Vee-Validate Lightbox Galleries: Image galleries with LightGallery integration Responsive Design: Fully responsive design optimized for all devices The stack The frontend stack consists of:\nVue 3.2.4: Modern reactive framework for building interactive components Laravel Mix 6.0: Asset compilation and bundling SCSS: Advanced styling with organized architecture Vee-Validate 4.15.0: Form validation with Yup schemas Axios 1.6.8: HTTP client for API requests Splide.js 4.1.4: Modern carousel and slider components LightGallery 2.8.3: Lightbox gallery functionality Odometer 0.4.8: Animated number counting Headroom.js: Header behavior on scroll jQuery 3.7.1: DOM manipulation and legacy support SweetAlert2: Modern alert dialogs GLightbox 3.3.1: Alternative lightbox solution Frontend architecture Vue components The application features a comprehensive set of Vue 3 components:\nCard Components:\ncards/activities.vue: Activity cards with favorites functionality cards/speakers.vue: Speaker cards with modal details cards/stands.vue: Stand/exhibitor cards cards/blog.vue: Blog post cards cards/shortcut.vue: Quick access shortcut cards Functional Components:\nSectionCards.vue: Main section component with tabs, filtering, and card display Search.vue: Advanced search component with multi-category results Form.vue: Dynamic form component with validation FormCalendar.vue: Calendar form component CustomFilter.vue: Reusable filter component CustomSelect.vue: Custom select dropdown Pagination.vue: Pagination component JavaScript components The application includes 17 specialized JavaScript components:\nInteractive Features:\ninteractiveMap.js: SVG map interaction with tooltips, zones, and dynamic content countdown.js: Real-time countdown timer with automatic updates odometer.js: Animated number counting with scroll triggers map.js: Map zone interactions and modal displays UI Components:\nheader.js: Header functionality and navigation headroom.js: Header hide/show on scroll accordion.js: Accordion interactions tabs.js: Tab functionality cards.js: Card interactions and modals siteModals.js: Modal management system UI.js: General UI utilities Media Components:\nvideo.js: Video player setup lightgallery.js: Lightbox gallery initialization splide.js: Carousel initialization slick.js: Legacy carousel support Utilities:\nscrollTrigger.js: Scroll-based animations imgToSvg.js: SVG image conversion utility SCSS architecture The styling follows a well-organized SCSS architecture:\nscss/ ├── abstracts/ # Variables, mixins, functions │ ├── _functions.scss │ ├── _mixins.scss │ ├── _variables.scss │ ├── _mq.scss # Media query mixins │ └── _keyframes.scss ├── base/ # Base styles and typography │ ├── _typography.scss │ ├── _container.scss │ └── _reset.scss └── components/ # Component-specific styles └── [52 component files] Key SCSS features:\nBEM methodology: Consistent naming convention Media query mixins: Using sass-mq for responsive design Modular architecture: Each component has its own SCSS file Component organization: 52 component-specific SCSS files Interactive components Interactive SVG Map The interactiveMap.js component implements a sophisticated SVG-based interactive map:\nFeatures:\nSVG Tooltips: Dynamically generated tooltips with text wrapping Zone Interactions: Clickable zones with modal displays Point Markers: Interactive points with icons and labels Dynamic Content: Content loaded based on zone/point selection Responsive Design: Optimized for mobile and desktop Technical Implementation:\nSVG namespace manipulation for tooltip creation Text wrapping algorithm for tooltip content Path generation for tooltip shapes with rounded corners Event delegation for zone and point interactions Smooth animations and transitions Real-time Countdown The countdown.js component provides a real-time countdown timer:\nFeatures:\nAutomatic Updates: Updates every second Multi-unit Display: Days, hours, minutes, and seconds Pluralization: Proper Spanish pluralization (Día/Días, Hora/Horas) Mobile Optimization: Simplified display on mobile devices End State Handling: Automatic transition when countdown ends Advanced Search System The Search.vue component implements a comprehensive search system:\nFeatures:\nMulti-category Search: Searches across activities, speakers, stands, and other content Category Tabs: Quick navigation between result categories Result Counts: Dynamic result counts per category Scroll Navigation: Smooth scrolling to category sections Carousel Display: Splide carousels for result display Loading States: Loading indicators during search Empty States: User-friendly empty state messages Dynamic Filtering System The SectionCards.vue component provides advanced filtering:\nFeatures:\nTab Navigation: Multiple filter tabs Favorites System: Save and filter favorite items Search Integration: Inline search within filters Reset Functionality: Clear all filters with one click Downloadable Resources: Download buttons for resources URL Synchronization: Filter state in URL parameters Responsive Design: Mobile accordion interface Animated Statistics The odometer.js component provides animated number counting:\nFeatures:\nScroll-triggered: Animations trigger on scroll Prefix/Suffix Support: Handles formatted numbers (e.g., \u0026ldquo;56,000+\u0026rdquo;) Mobile Optimization: Static display on mobile Smooth Animations: Odometer theme integration Development workflow The project uses Laravel Mix for asset compilation:\n// Development npm run dev // Compile assets npm run watch // Watch for changes npm run hot // Hot module replacement // Production npm run production // Optimized production build BrowserSync integration provides:\nLive reloading during development Synchronized browser testing Proxy configuration for WordPress development Performance optimizations Code splitting: Laravel Mix extracts vendor libraries Asset versioning: Automatic cache busting Image optimization: Lazy loading and responsive images Minification: Production builds are minified and optimized Tree shaking: Unused code elimination in production SVG optimization: Efficient SVG manipulation and rendering Accessibility Semantic HTML structure ARIA labels for interactive elements Keyboard navigation support Focus management in forms and modals Screen reader considerations Proper alt text for images Conclusion and final thoughts Building the ETMday frontend was an excellent opportunity to:\nMaster SVG interactions: Creating complex interactive SVG maps with dynamic tooltips and zones Implement real-time features: Building countdown timers and live updates Build advanced search: Multi-category search with filtering and categorization Handle complex state: Managing filters, favorites, and dynamic content Optimize performance: Implementing efficient animations and lazy loading Ensure scalability: Building components that handle large datasets (thousands of attendees, hundreds of activities) The project demonstrates proficiency in:\nModern JavaScript frameworks (Vue 3) SVG manipulation and interaction Real-time UI updates Advanced filtering and search systems Build tools and asset compilation (Laravel Mix, Webpack) CSS architecture and methodologies (SCSS, BEM) Component-based development Event-driven architecture The integration with WordPress/Themosis backend required careful consideration of server-side rendering, API endpoints, and content management workflows, making this a full-stack frontend implementation for a large-scale event.\nLive website: https://etmday.org/\n","image":"//localhost:1313/images/project/etm/homepage.webp","permalink":"//localhost:1313/projects/etmday-entrepreneurship-event-website/","tags":["Vue 3","Laravel Mix","WordPress","Themosis","SCSS","JavaScript","Interactive Map","SVG"],"title":"ETMday: Entrepreneurship Event Website"},{"categories":["Projects"],"contents":"Chile Nativo is a travel tour website for Patagonia experiences, built on top of WordPress with the Themosis framework, featuring a modern frontend implementation based on a Figma design using Vue 3, Laravel Mix, and a comprehensive SCSS architecture.\nOutline The project Design implementation The stack Frontend architecture Key features Conclusion Live website The project Chile Nativo is a travel company specializing in Patagonia tours, offering experiences in destinations like Torres del Paine, Tierra del Fuego, and Isla Navarino. The website serves as the primary platform for showcasing tours, managing bookings, and providing information about their travel experiences.\nThe frontend development was based on a comprehensive Figma design, requiring pixel-perfect implementation of complex UI components, interactive forms, filtering systems, and responsive layouts that work seamlessly across all devices.\nDesign implementation The entire frontend was built from a detailed Figma design, ensuring:\nPixel-perfect accuracy: Matching the design specifications precisely Responsive design: Implementing breakpoints and mobile-first approach Component consistency: Maintaining design system patterns throughout Interactive elements: Translating static designs into dynamic, interactive components Animation and transitions: Implementing smooth user experience enhancements The stack The frontend stack consists of:\nVue 3.2.4: Modern reactive framework for building interactive components Laravel Mix 6.0: Asset compilation and bundling SCSS: Advanced styling with a well-organized architecture Pinia 2.3.1: State management for Vue applications Vee-Validate 4.15.0: Form validation with Yup schemas Axios 1.6.8: HTTP client for API requests Splide.js 4.1.4: Modern carousel and slider components Headroom.js: Header behavior on scroll Plyr 3.7.8: Video player implementation SweetAlert2: Modern alert dialogs jQuery 3.7.1: Legacy support and DOM manipulation utilities Frontend architecture Vue components The application features a comprehensive set of Vue 3 components organized by functionality:\nFiltering and Search Components:\nToursFilter.vue: Advanced tour filtering with multiple criteria TourDatesFilter.vue: Date-based filtering for tour availability ToursFilterDropdown.vue \u0026amp; ToursFilterDropdownMobile.vue: Responsive filter dropdowns TestimonialsFilter.vue: Filtering system for customer testimonials NewsFilter.vue: Blog and news filtering SearchResults.vue: Search results display with pagination Form Components:\nPersonalizedTripForm.vue: Multi-step form for custom trip requests with validation ContactFormSimple.vue: Contact form with reCAPTCHA integration FormHelp.vue: Help center form FormGiftCard.vue: Gift card purchase form FormCareers.vue: Job application form NewsletterForm.vue: Newsletter subscription Card Components:\nTour.vue \u0026amp; TourLoading.vue: Tour card display with loading states TourDate.vue \u0026amp; TourDateLoading.vue: Tour date selection cards Testimonial.vue \u0026amp; TestimonialLoading.vue: Customer testimonial cards Blog.vue \u0026amp; BlogLoading.vue: Blog post cards Team.vue \u0026amp; TeamLoading.vue: Team member cards ResourceCard.vue \u0026amp; ResourceLoading.vue: Resource display cards Utility Components:\nPagination.vue: Reusable pagination component Select.vue: Custom select dropdown with search Loader.vue \u0026amp; LoaderFullScreen.vue: Loading indicators EmptyState.vue: Empty state displays ContentResources.vue: Resource content management TeamTabsFilter.vue: Tabbed team member filtering SCSS architecture The styling follows a well-organized SCSS architecture:\nscss/ ├── abstracts/ # Variables, mixins, functions │ ├── _functions.scss │ ├── _mixins.scss │ ├── _variables.scss │ ├── _mq.scss # Media query mixins │ └── _keyframes.scss ├── base/ # Base styles and typography │ ├── _typography.scss │ ├── _colors.scss │ ├── _fonts.scss │ └── _reset.scss └── components/ # Component-specific styles └── [125 component files] Key SCSS features:\nBEM methodology: Consistent naming convention throughout Media query mixins: Using sass-mq for responsive design Modular architecture: Each component has its own SCSS file Abstract layer: Reusable variables, mixins, and functions Vue transitions: Custom transition styles for Vue components JavaScript architecture The JavaScript is organized into two main entry points:\nMain application (app.js):\nInitializes core application functionality Sets up jQuery plugins and utilities Handles legacy browser support Vue application (vue/main.js):\nConfigures Vue 3 app with Pinia for state management Registers global Vue components Sets up Vee-Validate configuration Integrates third-party Vue plugins (VueTelInput, etc.) Component utilities (app/components/):\nheader.js: Header behavior and navigation footer.js: Footer functionality splide.js: Carousel initialization slick.js: Legacy carousel support accordions.js: Accordion interactions tabs.js: Tab functionality scrollTrigger.js: Scroll-based animations video.js: Video player setup sticky-sidebar.js: Sticky sidebar behavior Key features Multi-step forms The PersonalizedTripForm.vue component implements a sophisticated multi-step form with:\nStep-by-step navigation with progress indicators Form validation using Vee-Validate and Yup schemas Dynamic form fields based on user selections Phone number input with international support (VueTelInput) reCAPTCHA integration for spam protection Loading states and error handling Advanced filtering system The tour filtering system (ToursFilter.vue) provides:\nMultiple filter criteria (destination, activity type, trip type, month) Real-time filtering with URL parameter synchronization Responsive design with mobile accordion interface Custom select components with search functionality Empty states and loading indicators Integration with WordPress backend via Axios Responsive design The entire website is fully responsive with:\nMobile-first approach Breakpoint management using sass-mq Touch-friendly interactions Optimized images and assets Performance optimizations for mobile devices Performance optimizations Code splitting: Laravel Mix extracts vendor libraries Asset versioning: Automatic cache busting Image optimization: Lazy loading and responsive images Minification: Production builds are minified and optimized Tree shaking: Unused code elimination in production Accessibility Semantic HTML structure ARIA labels where appropriate Keyboard navigation support Focus management in forms Screen reader considerations Development workflow The project uses Laravel Mix for asset compilation:\n// Development npm run dev // Compile assets npm run watch // Watch for changes npm run hot // Hot module replacement // Production npm run production // Optimized production build BrowserSync integration provides:\nLive reloading during development Synchronized browser testing Proxy configuration for WordPress development Conclusion and final thoughts Building the Chile Nativo frontend from a Figma design was an excellent opportunity to:\nMaster Vue 3: Working with the Composition API, reactive systems, and modern Vue patterns Implement complex forms: Multi-step forms with validation, international phone inputs, and reCAPTCHA Build scalable architecture: Organizing 40+ Vue components and 125+ SCSS files in a maintainable structure Optimize performance: Implementing code splitting, lazy loading, and production optimizations Ensure design fidelity: Translating Figma designs into pixel-perfect implementations Handle responsive design: Creating seamless experiences across all device sizes The project demonstrates proficiency in:\nModern JavaScript frameworks (Vue 3) Build tools and asset compilation (Laravel Mix, Webpack) CSS architecture and methodologies (SCSS, BEM) Form validation and user experience Component-based development Design system implementation The integration with WordPress/Themosis backend required careful consideration of server-side rendering, API endpoints, and content management workflows, making this a full-stack frontend implementation.\nLive website: https://chilenativo.travel/\nFigma prototype: https://www.figma.com/proto/ywHPhSP1UfYUAE8eWVQv4L/Dise%C3%B1o-Desktop---Chile-Nativo?node-id=289-3912\u0026m=dev\u0026scaling=min-zoom\u0026content-scaling=fixed\u0026page-id=289%3A3911\u0026starting-point-node-id=289%3A3912\n","image":"//localhost:1313/images/project/chile-nativo/home.png","permalink":"//localhost:1313/projects/chile-nativo-patagonia-travel-website/","tags":["Vue 3","Laravel Mix","WordPress","Themosis","SCSS","JavaScript","Figma"],"title":"Chile Nativo: Patagonia Travel Website"},{"categories":["Projects"],"contents":"Rutieri is a SaaS platform built with Strapi, React Native, Typescript and other technologies.\nOutline The idea Platform features The stack The API The frontend The mobile app Conclusion Landing Page The idea Before starting to write a single line of code, it is generally a good idea to think about the problem, it\u0026rsquo;s limitations and whether or not it has already been solved by someone else (AKA competitors).\nThe problem I was looking into had to do with the way in which public and private transportation companies manage their routes, drivers and users. This process is generally carried out on paper, e.g. not digital, hence this could be problematic in case of new drivers joining the organization or in case of restricting access to data to only specific users.\nAfter a little bit of research, I could only find one platform that provides a similiar solution but for their own company.\nPlatform features and user stories The following user stories illustrates the desired features the platform should have in order to solve the aforementioned problems.\nAs an administrator user, I want to: login in the admin panel. create an organization. create routes in the organization. invite drivers and users to the organization. manage requests to join the organization. assign routes to drivers in the organization. see in real time the drivers and users currently active in the map of the different routes. As a driver, I want to: login in the mobile app. join an organization by entering the code in the search bar. see my route on the map. become visible to passengers on the road. see the passengers waiting on the road. remove my visibility and finish my run. As a passenger, I want to: login in the mobile app. join an organization by entering the code in the search bar. see the different routes of my organization in the map. search for a destination and get the available routes that pass nearby. see the drivers currently active on the routes in real time. become visible to drivers of a route. The requirements The backend requires to handle user authentication, permissions, different data structures as content types and define relations between them. It\u0026rsquo;s also necessary to synchronise passengers and drivers and view them on a map real time in the administration panel as well as in the mobile app.\nThe administration panel is a web page that fetches data from the backend as well as from the real time data provider and it\u0026rsquo;s goal is to provide a way for administrators to manage their organization and users. We\u0026rsquo;re talking about a Single Page Application built in React.\nAs for the mobile application, there isn\u0026rsquo;t a better choice nowadays than React Native and it works just fine in this case.\nThe API Since all of the features involve authentication, permissions and roles, and because there is no need to reinvent the wheel, I chose to use Strapi to build the backend for it\u0026rsquo;s simplicity, ease of use and great developer experience, whereas for realtime data, I used Firebase.\nThe instance of Strapi and the Postgres database it requires was deployed in the cloud hosting platform https://fly.io.\nStrapi is good for managing users, content that\u0026rsquo;s typically updated and fetched via CRUD API, and relations between content types.\nThe platform needs the following content types:\nOrganizations to group routes, drivers and users Routes Two user roles: drivers and users (passengers) Below are some screenshots of the overview of these content types\nAs I said before, Strapi makes the creation of these content types and the relationships between them really straightforward.\nHowever, not everything related to the API can be provided by Strapi. Some realtime features need to be addressed with other solutions, such as geolocation data in real time for drivers and users to synchronise each other, maps and the ability to search for places. Such features were implemented using Firebase, Google Maps and Google Places.\nThe frontend The platform where users are able to login as administrators and manage their organizations and users is a single page web application built in React. Among the features of this project that I think stand out are:\nState managed by Context API Interface styled with Bootstrap React Router for pages Leaflet to display the map GeoFire library to synchronise geolocation data in real time with Firebase Use of localStorage to save user session Below are some sample screenshots of how this app looks like\nThe mobile application This one is by far the most complex part of this project.\nThe project was bootstraped with Infinitered\u0026rsquo;s Ignite, which provides a great boilerplate and surely saved me of what would have been between 1-2 months of work.\nIgnite\u0026rsquo;s boilerplate includes many features out of the box, including:\nReact Native and Typescript (of course) React Navigation MobX-State-Tree for state management Expo SDK for developer experience AsyncStorage for persistence apisauce as REST client And some other libraries and features that make React Native apps super powerful and a joy to work on.\nIt consists of three screens:\nWelcome screen Login screen Map screen In the welcome screen, users are able to go to the login screen if not logged in. Otherwise, if they\u0026rsquo;re in an organisation, it shows their role and org\u0026rsquo;s information, and if they\u0026rsquo;re not, they are able to enter the organisation code and request to join as driver or as passenger.\nWelcome screens Login screens If the user is a driver in an organisation, the welcome screen also shows the route assigned to them. By tapping on it, it takes them to the map, where they can see themselves and start the tour, becoming visible to passengers on the road but being able to see passengers on the road as well.\nDrivers can finish the tour at any time by pressing the button stop.\nIf the user is a passenger in an organisation, the welcome screen shows the different routes available in the organisation. By tapping on them, they are taken to the map where they can see themselves, the route and the drivers on the road.\nPassengers are able to navigate between the available routes and search for the location they want to go to by using the search bar at the top of the map screen, filtering out the routes that pass nearby (less than 200 meters), if there are. Google Places API and turf library work together in this search process.\nPassengers become visible to drivers on the road by pressing the button wait and if they press the button again, they stop waiting and are removed from the driver\u0026rsquo;s map.\nMap screens The start/wait and finish buttons dispatch actions that update their location in firebase, so that passengers are able to see the bus on the map as it moves in real time and viceversa.\nAs for the state management, the project consists of two models and three stores from Mobx-State-Tree library: User and Route models, user-status, route-store and root-store stores.\nUser model Located in /app/models/user/user.ts\nconst OrganizationModel = types.model({ name: types.string, code: types.string, id: types.identifierNumber, drivers: types.number, rutas: types.array(RouteModel) }) const UserModel = types .model(\u0026#34;User\u0026#34;) .props({ id: types.identifierNumber, username: types.string, email: types.string, token: types.string, role: types.union(types.literal(\u0026#34;passenger\u0026#34;), types.literal(\u0026#34;driver\u0026#34;)), ruta: types.maybeNull(RouteModel), organization: types.maybeNull(OrganizationModel), pending_request: types.maybeNull(OrganizationModel), }) Route model Located in /app/models/route/route.ts\nThis model follows the GeoJSON format for routes.\nconst RouteModel = types .model(\u0026#34;Ruta\u0026#34;) .props({ id: types.identifierNumber, name: types.string, latlong: types.maybeNull(types.model({ lat: types.number, longt: types.number })), coords: types.model({ type: FeatureTypes, features: types.array(types.model({ type: types.string, geometry: types.model({ type: types.string, coordinates: types.union(types.array(types.number), types.array(types.array(types.number))) }), properties: types.model({ name: types.string }) })) }) }) user-status store Located in /app/models/user-status/user-status.ts\nThis store is responsible for managing the state of the user. It stores the user once it\u0026rsquo;s logged in and removes it when the user logs out. It also has some views to get the user key for firebase purposes, get the role and get the route in case of a driver.\nThis store has some methods that get the user location from the device\u0026rsquo;s GPS, displays the user icon on the map and sends it to firebase.\nconst UserStatusModel = types .model(\u0026#34;UserStatus\u0026#34;) .extend(withEnvironment) .props({ user: types.maybeNull(UserModel), location: types.maybeNull( types.model({latitude: types.number, longitude: types.number}) ), visibility: types.maybeNull(types.number) }) route-store store Located in /app/models/route-store/route-store.ts\nThis store is responsible for managing the state of the available routes. It stores the routes, drivers and passengers on the different routes. It also has some view methods to filter the routes that pass nearby a destination specified by the user, get passengers waiting on a given route and get drivers active in a specific route.\nThis store initializes a GeoQuery from Geofire library and listens for events to set, update and remove drivers and passengers from the map as they move.\nconst RouteStoreModel = types .model(\u0026#34;RouteStore\u0026#34;) .props({ routes: types.array(RouteModel), passengers: types.map(types.model({ key: types.identifier, location: types.array(types.number) })), drivers: types.map(types.model({ key: types.identifier, location: types.array(types.number) })), destinationAddress: types.maybeNull(types.model({ name: types.string, coords: types.array(types.number) })) }) Conclusion and final thoughts Using a CMS as the backend can make the development a lot faster than building the API from scratch and with Strapi this is specially true. On the other hand, Strapi doesn\u0026rsquo;t really make a good fit for real time applications, therefore, Firebase is the way to go in this case.\nAs of the client side, React always works very good for pretty much any kind of application, and because React Native uses React under the hood, it is so convenient for us React developers and ir works pretty good for almost any kind of application as well.\nHowever, one thing that I didn\u0026rsquo;t mention in this post was the use of Typescript; I find this quote by Brice Wilson pretty good to point out the whole purpose and motivation to learn and use (well) this powerful language and tool ecosystem:\n\u0026ldquo;You won\u0026rsquo;t have to wait for a frustrated user to report the error. All of this means that you provide value to your users faster, and that\u0026rsquo;s really what it\u0026rsquo;s all about.\u0026rdquo;\nAll in all, I got a lot of learning by building this project, both in languages/frameworks used and production stuff such as infrastructure, cloud hosting and cloud-based APIs.\nProject landing page: https://rutieri.netlify.app\n","image":"//localhost:1313/images/project/rutieri/landing/homepage.webp","permalink":"//localhost:1313/projects/saas-platform-rutieri/","tags":["Strapi","React Native","React","Typescript","Firebase"],"title":"SaaS platform: Rutieri"},{"categories":["Tutorial"],"contents":"Enable comments in a Strapi application and display them in the frontend with React\nOutline Introduction Prerequisites What is Strapi Comment Manager? Installation Configuration Display comments on the frontend Installation of Strapi Comments Client Usage of Strapi Comments Client Plugin settings Manage comments Full source code of the frontend Conclusion Introduction A comment system comes in very handy for pretty much any kind of website. In the JAMstack ecosystem, while it\u0026rsquo;s ok to rely on third party solutions hosted on their own platform such as Disqus to enable comments, you usually want to keep your content and all the stuff related to it in the same admin dashboard.\nIn this article, I\u0026rsquo;ll show you how to enable and manage comments for your content very easily using the Comment Manager plugin, and display them in your frontend application.\nPrerequisites You should have a basic understanding of the following.\nBasic knowledge of JavaScript Basic knowledge of React (OPTIONAL) Basic understanding of Strapi - get started here. Your Strapi V4 project setup What is Strapi Comment Manager? Strapi Comment Manager is a plugin that enables comments for pretty much any kind of content. It allows your users to post comments and anyone can get the comments associated with a given slug.\nWith this plugin, admin users can view and manage very easily all the comments from the Strapi administration dashboard. Within the dashboard, you will be able to delete comments and subcomments and leave replies on comments.\nInstallation Once into the Strapi project root, you can install the plugin by running the following command:\nnpm install strapi-plugin-comment-manager Next, build the project to see the new plugin in the dashboard with the following command:\nnpm run build And that\u0026rsquo;s it! If everything runs correctly, the plugin should now be installed.\nConfiguration Now you need to enable some permissions so that the frontend can access the endpoints to post and fetch comments.\nIn your Strapi admin dashboard, head over to Settings, then over to Roles under Users \u0026amp; Permissions Plugin.\nLet\u0026rsquo;s first setup the Public API; click on Public and hit the dropdown button of Comment Manager. Now check count, find and getPageSize, then hit the Save button. Below is a screenshot of a proper configuration:\nNow let\u0026rsquo;s setup the Authenticated API. Go back to Roles and click on Authenticated. Open the dropdown for Comment Manager and mark as checked the option create on both Comment and Subcomment. Below is a screenshot of a proper configuration:\nWith this configuration, the frontend should now be able to make requests to get and post comments.\nDisplay comments on the frontend The plugin exposes an API to get and post comments if you want to have fine-grained control over the workflow of your comments system and you can check the documentation on the package page, but this plugin also comes with a purpose-built React component library that makes it super easy to get up and running without getting your hands dirty.\nThis components library is called strapi-comments-client, fully supports typescript and it handles for you all of the complexity of fetching and posting comments and subcomments for every content ID that you pass to it.\nInstallation of Strapi Comments Client You will need to have installed react ^17.0.2, react-dom ^17.0.2 and react-router-dom ^5.2.0.\nInside of your React project, run this command:\nnpm install strapi-comments-client --save Usage of Strapi Comments Client Using this library is very easy!\nThis library exports three main components:\nCommentsProvider Comments CommentForm And you can import them this way:\nimport { CommentsProvider, Comments, CommentForm } from \u0026#34;strapi-comments-client\u0026#34; All you have to do is wrap your App component into the CommentsProvider component. Then you will be able to place anywhere in your app the Comments component to render a list of comments for a given content ID and the CommentForm component to render a form to post comments.\nFor example, this could be your index.js or main.js file:\nimport React from \u0026#39;react\u0026#39; import ReactDOM from \u0026#39;react-dom\u0026#39; // The address of your strapi backend instance const STRAPI = \u0026#34;http://localhost:1337\u0026#34; ReactDOM.render( \u0026lt;React.StrictMode\u0026gt; \u0026lt;CommentsProvider apiURL={STRAPI}\u0026gt; \u0026lt;App /\u0026gt; \u0026lt;/CommentsProvider\u0026gt; \u0026lt;/React.StrictMode\u0026gt;, document.getElementById(\u0026#39;root\u0026#39;) ) Where apiURL is the URL of your running Strapi application, and this property is required.\nThis way, the comments provider will do all the magic of fetching and posting comments for you!\nThis library also exports an utility React.Context to update some of the parameters for fetching and posting comments:\nimport { CommentsConfigContext } from \u0026#34;strapi-comments-client\u0026#34; This CommentsConfigContext exposes two setter functions: setUser and setContentID\nWith setContentID you can load the comments for a given content and post comments to it. It receives a single parameter of type string and must be URLized, i.e. no spaces.\nWith setUser you can set the credentials of a given user to authorize the posting of comments. It receives a single parameter of type IUser, with the following Typescript interface:\ninterface IUser { username: string, email: string, id: string, token: string // This is a JWT } It\u0026rsquo;s a little confusing but we\u0026rsquo;ll see how to use it in a component:\nconst App = () =\u0026gt; { const { setUser, setContentID } = useContext(CommentsConfigContext) // The following data should come from Strapi Users and Permissions Plugin // for authenticated requests const user = { username: \u0026#34;John Doe\u0026#34;, email: \u0026#34;jhohndoe@gmail.com\u0026#34;, id: 5, token: \u0026#34;this_should_be_a_JWT\u0026#34; } if (user) { setUser(user) } setContentID(\u0026#34;sample-content-1\u0026#34;) // Load comments for this content return ( \u0026lt;\u0026gt; { !user \u0026amp;\u0026amp; \u0026lt;Login /\u0026gt; } \u0026lt;CommentForm /\u0026gt; \u0026lt;Comments /\u0026gt; \u0026lt;/\u0026gt; ) } And that\u0026rsquo;s it!\nAfter setting the content ID through setContentID, CommentsProvider will start loading the comments for the given content ID and the CommentForm will render an input to post comments related to the given content ID if there is a user. Otherwise, it will display the message Login to post a comment.\nHere\u0026rsquo;s how the interface looks like so far:\nThere\u0026rsquo;s also a button to Leave a reply, which will open a form to post a subcomment associated with the parent comment.\nThis library exports one more component: ErrorBox\nimport { ErrorBox } from \u0026#34;strapi-comments-client\u0026#34; .It\u0026rsquo;s useful if you\u0026rsquo;d like to display error messages when things go wrong fetching or posting comments.\nYou can place this component wherever you want, for example in between the CommentForm and the Comments components.\nIf you\u0026rsquo;re wondering how this error box looks like, here you have a sample:\nGeneral settings You can customize the page size, i.e. specify how many comments are returned at once.\nIn the Strapi admin panel, head over to Settings, then select Pagination under Comment Manager Plugin.\nHere you\u0026rsquo;ll find an input to set the page size, which defaults to 10.\nManage comments Once you\u0026rsquo;ve got the plugin up an running, as users start to post comments, you can manage and reply to them as admin from the Comment Manager section of the left sidebar in the Strapi admin dashboard.\nHere you can see two tabs: one for the latest comments and one for comments grouped by content ID.\nIn both of them you can delete comments and subcomments as well as leave replies.\nExample project You can find a full working example of a React App using the Strapi Comments Client Library in this repo\nConclusion With this plugin you can enable and manage comments for any content with little effort and even use a component library to display the comments in your frontend application made with React.\nAnd that\u0026rsquo;s it! The features are pretty basic at the moment but if there\u0026rsquo;s interest, I\u0026rsquo;m willing to work on more features as well as improve the UI/UX.\n","image":"//localhost:1313/images/post/strapilogo.jpg","permalink":"//localhost:1313/blogs/how-to-enable-and-manage-comments-in-your-strapi-application/","tags":["Strapi","Strapi tutorials"],"title":"How To Enable And Manage Comments In Your Strapi Application."},{"categories":["Documentation"],"contents":"Comment Manager is a Strapi plugin to allow your users to post comments.\nWith this plugin you can enable and manage comments for your content very easily!\nRequirements You should have installed an instance of Strapi v4.x.x\nInstallation Run the following command in your project root:\nnpm install strapi-plugin-comment-manager Configurarion For your frontend to have access to the API, enable the following permissions for Comment Manager from Users \u0026amp; Permissions Plugin on your project settings:\nFor public, enable: count, find and getPageSize.\nFor authenticated, enable create on both Comment and Subcomment.\nDisplay comments on the frontend Comments can be displayed in the frontend in two ways:\nUsing the React components library strapi-comments-client (recommended) Build your custom frontend using the API API There are some Typescript interfaces that will help to get an idea of the data structures.\nComments: interface IComment { id: string, from_admin: boolean, createdAt: string, content: string, author: IAuthor | null, subcomments?: ISubcomment[] } Subcomments: interface ISubcomment { id: string, from_admin: boolean, createdAt: string, content: string, author: IAuthor | null, } Authors: IAuthor { username: string, email: string, id: string } The following endpoints are exposed to fetch and post comments and subcomments:\nGet comments for a content ID Method: GET\nPath: /api/comment-manager/comments/:slug\nOptional query parameters: start, ignoreCount\nReturns:\n{ commentsCount?: Number, comments: IComment[] } The parameter start indicates how many comments to skip. This is for pagination purposes.\nThe parameter ignoreCount indicates whether or not to return the total number of comments associated with the given slug.\nGet the number of comments associated with a given content ID Method: GET\nPath: /api/comment-manager/comments/:slug/count\nReturns:\n{ count: Number } Post a comment Method: POST\nPath: /api/comment-manager/comments/:slug\nAuthentication: Bearer token\nPayload:\n{ content: string } Returns:\n{ id: Number } Post a subcomment Method: POST\nPath: /api/comment-manager/subcomments/:parent-id\nAuthentication: Bearer token\nPayload:\n{ content: string } Returns:\n{ id: Number } Get the page size Method: GET\nPath: /api/comment-manager/page-size\nReturns:\n{ pageSize: Number } General settings The plugin allows to set how many comments are returned per page by going to the Pagination section under Comment Manager Plugin on the Settings section.\nThe default page size is 10.\nManagement of comments Admin users are able to delete comments and subcomments as well as leave replies as admins from within the plugin page of the Strapi admin dashboard.\nThe plugin interface has two tabs: one for the latest comments and one for comments by content ID.\nRoadmap and future plans The plugin is pretty basic but it can be improved with more features and a better UI/UX. Collaborations and suggestions are very welcome.\n","image":"//localhost:1313/images/post/strapilogo.jpg","permalink":"//localhost:1313/blogs/strapi-plugin-comment-manager/","tags":["Strapi","Strapi plugins"],"title":"Strapi Plugin Comment Manager"},{"categories":["Projects"],"contents":"In this post I’m going to share my experience on building a SaaS using the headless CMS Strapi as the Backend, React Native and other technologies.\nOutline Introduction What is SaaS? The problem What is Strapi? Developing features in Strapi The frontend: How to get content Conclusion Landing Page Introduction Very often, developers, product and project managers, testers and pretty much the entire team share their ideas to decide what language and which framework they\u0026rsquo;ll use to build their next project. Some considerations must be taken into account, from which in my opinion there are three that are the most important:\nDeveloper experience and ease of use Does the language and framework chosen provide a good developer experience? Is the langauge the same for the backend and frontend?\nDeadlines Is there a deadline to finish the project? if so, there is a good chance to finish the project on time if the team chooses the language they have more experience in.\nMaintainability As there will be usually more than one person working on the same part at the same time, if everything is kept organised, the whole development process will be frictionless.\nWith that in mind, developers and project managers will have a better insight on which language/framework to use.\nOther aspects should also be considered such as what the data structure will look like.\nIn my case, as it is usual, the backend of my project needs a database for users and their roles among other entities and their relations and a dashboard to allow admins to manage the data, and I was lucky to find out Strapi, as it includes a lot of these features out of the box with one single line of command to get started.\nWhat is SaaS? SaaS stands for Software-as-a-Service and it just means that a software is provided as a service in the cloud and it gives a solution to a specific problem, for which the users are willing to pay either monthly or annual subscription.\nThe problem Before starting to write a single line of code, it is generally a good idea to think about the problem, it\u0026rsquo;s limitations and whether or not it has already been solved by someone else (AKA competitors).\nThe problem I was looking into had to do with the way in which public and private transportation companies manage their routes, drivers and users. After a little bit of research, I could only find one platform that provides a similiar solution but for their own company.\nSo the platform I built needed the following content types:\nOrganizations to group routes, drivers and users Routes Two user roles: drivers and users (passengers) As I said before, Strapi makes the creation of these content types and the relationships between them really easy, but let\u0026rsquo;s first see what is Strapi and how it turns the API development into a satisfactory and fun experience.\nWhat is Strapi? Strapi is an open source headless CMS that allows developers to build complete RESTful APIs in just a couple of days instead of months. It includes a lot of useful features as plugins out of the box. Users and Roles management, Media library and an interface to create, view, edit and delete content are just some of them.\nRegarding the API, how does it makes the development faster?\nFirst of all, it enforces a specific folder structure, which helps to keep everything well organised and clean.\nSecondly, all database schemas are generated automatically and queries are made in JSON format, which really saves a lot of time.\nLastly, we can add more features to our Strapi application very easily via plugins from the marketplace.\nIt\u0026rsquo;s also worth noting that Strapi is a self-hosted CMS, which means that we can host it in whatever cloud platform we want, as well as test it locally in our computers before deploying it to the cloud.\nDeveloping features in Strapi Creating and configuring endpoints in Strapi is as straightforward as declaring a JSON in a single file:\nCreating controllers is straightforward as well:\nEvery controller gets all the data related to the request in the ctx parameter and it\u0026rsquo;s also used to send the response. This keeps everything in one place and really helps to improve the readability.\nOnce the API endpoints are defined, the next step is to enable the permissions for the specific user roles to have access to these endpoints:\nThe frontend: how to get content Since Strapi is a headless CMS, it\u0026rsquo;ll only provide content through the API. That means that the content can be consumed from anywhere. In our case, this content will be used in two applications: one for the organization owners and one for the users and drivers.\nThe application for the organization owners is a dashboard where administrators can create organizations, routes, accept drivers and users in the organization and assign routes to drivers. This is just a React Application:\nThe application for drivers and users is a mobile application built in React Native. Firebase was used to synchronise geolocation data in real time between drivers and users and display this information in a Map from Google Maps:\nConclusion Using a CMS as the backend can make the development a lot faster than building the API from scratch and with Strapi this is specially true. Furthermore, this becomes more important when building a brand-new product, as it\u0026rsquo;s usually recommended to launch as soon as possible to gather feedback from the users and validate the idea.\nProject landing page: https://rutieri.netlify.app\n","image":"//localhost:1313/images/post/03.webp","permalink":"//localhost:1313/blogs/how-i-built-a-saas-on-top-of-strapi-and-why-you-should-too/","tags":["Strapi","React Native","Typescript"],"title":"How I Built A SaaS On Top Of Strapi, And Why You Should Too"},{"categories":["Tutorial"],"contents":"Enable User Reviews in a Strapi application and display them in the frontend with React\nOutline Introduction Prerequisites What is Strapi Ratings? Installation Configuration Display user reviews on the frontend Plugin settings Manage user reviews Full source code of the frontend Conclusion Introduction Ratings systems have become a crucial part of any website with ecommerce capabilites, as they allow the users to post reviews on the items they purchase and publish their opinion to the public. A couple of reviews can make the difference between pressing the “Buy” button and moving on to the next website in the Google search results.\nIn this article, I\u0026rsquo;ll show you how to enable and manage user reviews for your content very easily using the Ratings plugin, and display them in your frontend application.\nPrerequisites First of all, you need to have a basic understanding of the following.\nBasic knowledge of JavaScript Basic knowledge of React (OPTIONAL) Basic understanding of Strapi - get started here. Your Strapi V4 project setup What is Strapi Ratings? Strapi Ratings is a plugin that gives your Strapi application the ability to manage ratings for pretty much any kind of content. It allows your users to post reviews and anyone can get the reviews associated with a given slug.\nWith this plugin, admin users can view and manage very easily all the reviews from the Strapi administration dashboard. Within the dashboard, you will be able to see reviews related to content slugs as well as delete reviews.\nInstallation Once into the Strapi project root, you can install the plugin by running the following command:\nnpm install strapi-plugin-ratings Next, build the project to see the new plugin in the dashboard with the following command:\nnpm run build And that\u0026rsquo;s it! If everything runs correctly, the plugin should now be installed.\nConfiguration Now you need to enable some permissions so that the frontend can access the endpoints to post and fetch reviews.\nIn your Strapi admin dashboard, head over to Settings, then over to Roles under Users \u0026amp; Permissions Plugin.\nLet\u0026rsquo;s first setup the Public API; click on Public and hit the dropdown button of Ratings. Now check count, find, getPageSize and getStats, then hit the Save button. Below is a screenshot of a proper configuration:\nNow let\u0026rsquo;s setup the Authenticated API. Go back to Roles and click on Authenticated. Open the dropdown for Ratings and mark as checked the options create, find and getUserReview. Below is a screenshot of a proper configuration:\nWith this configuration, the frontend should now be able to make requests to get and post user reviews.\nDisplay use reviews on the frontend The plugin exposes an API to get and post reviews if you want to have fine-grained control over the workflow of your ratings system and you can check the documentation on the package page, but this plugin also comes with a purpose-built React component library that makes it super easy to get up and running without getting your hands dirty.\nThis components library is called strapi-ratings-client, fully supports typescript and it takes care of all the complexity of fetching and posting user reviews for every content ID that you pass to it.\nInstallation of Strapi Ratings Client You will need to have installed react ^17.0.2, react-dom ^17.0.2, bootstrap ^5.1.3 and @popperjs/core^2.11.2\nInside of your React project, run this command:\nnpm install strapi-ratings-client --save Usage of Strapi Ratings Client Using this library is very easy!\nThis library exports three main components:\nReviewsProvider Reviews ReviewForm And you can import them this way:\nimport { ReviewsProvider, Reviews, ReviewForm } from \u0026#34;strapi-ratings-client\u0026#34; All you have to do is wrap your App component into the ReviewsProvider component. Then you will be able to place anywhere in your app the Reviews component to render a list of user reviews for a given content ID and the ReviewForm component to render a form to allow your users to post reviews.\nFor example, this could be your index.js or main.js file:\nimport React from \u0026#39;react\u0026#39; import ReactDOM from \u0026#39;react-dom\u0026#39; // The address of your strapi backend instance const STRAPI = \u0026#34;http://localhost:1337\u0026#34; ReactDOM.render( \u0026lt;React.StrictMode\u0026gt; \u0026lt;ReviewsProvider apiURL={STRAPI}\u0026gt; \u0026lt;App /\u0026gt; \u0026lt;/ReviewsProvider\u0026gt; \u0026lt;/React.StrictMode\u0026gt;, document.getElementById(\u0026#39;root\u0026#39;) ) Where apiURL is the URL of your running Strapi application, and this property is required.\nThis way, the ratings provider will do all the magic of fetching and posting comments for you!\nThis library also exports an utility React.Context to update some of the parameters for fetching and posting reviews:\nimport { ReviewsConfigContext } from \u0026#34;strapi-ratings-client\u0026#34; This ReviewsConfigContext exposes three setter functions: setUser, setContentID and setCanPostReview.\nWith setContentID you can load the ratings for a given content and post reviews to it. It receives a single parameter of type string and must be URLized, i.e. no spaces.\nWith setUser you can set the credentials of a given user to authorize the posting of reviews. It receives a single parameter of type IUser, with the following Typescript interface:\ninterface IUser { username: string, email: string, id: string, token: string // This is a JWT } With setCanPostReview, you can enable the user to post a review on the given content. This is useful for when you only allow a user to post a review after they purchase the product.\nIt\u0026rsquo;s a little confusing but we\u0026rsquo;ll see how to use it in a component:\nconst App = () =\u0026gt; { const { setUser, setContentID, setCanPostReview } = useContext(ReviewsConfigContext) // The following data should come from Strapi Users and Permissions Plugin // for authenticated requests. const user = { username: \u0026#34;John Doe\u0026#34;, email: \u0026#34;jhohndoe@gmail.com\u0026#34;, id: 5, token: \u0026#34;this_should_be_a_JWT\u0026#34; } if (user) { setUser(user) } setContentID(\u0026#34;sample-content-1\u0026#34;) // Load reviews for this content setCanPostReview(true) // Allow this user to post a review return ( \u0026lt;\u0026gt; { !user \u0026amp;\u0026amp; \u0026lt;Login /\u0026gt; } \u0026lt;ReviewForm /\u0026gt; \u0026lt;Reviews /\u0026gt; \u0026lt;/\u0026gt; ) } And that\u0026rsquo;s it!\nAfter setting the content ID through setContentID, ReviewsProvider will start loading the reviews for the given content ID and the ReviewForm will render an input to post a user review related to the given content ID if there is a user and he’s allowed to post a review. Otherwise, it will display the message Login to post a review or nothing at all if the user is not allowed to post a review.\nHere\u0026rsquo;s how the interface looks like so far:\nThis library exports one more component: ErrorBox\nimport { ErrorBox } from \u0026#34;strapi-ratings-client\u0026#34; .It\u0026rsquo;s useful for when you\u0026rsquo;d like to display error messages when things go wrong fetching or posting reviews.\nYou can place this component wherever you want, for example in between the ReviewForm and the Reviews components.\nIf you\u0026rsquo;re wondering how this error box looks like, here‘s a screenshot:\nGeneral settings You can customize the page size, i.e. specify how many user reviews are showed at once.\nIn the Strapi admin panel, head over to Settings, then select Pagination under Ratings Plugin.\nHere you\u0026rsquo;ll find an input to set the page size, which defaults to 10.\nManage reviews Once you\u0026rsquo;ve got the plugin up an running, as users start to post reviews, you can view them from within the Ratings section of the left sidebar in the Strapi admin dashboard.\nHere you can see two tabs: one for the latest reviews and one for reviews grouped by content ID.\nIn both of them you can delete unwanted reviews.\nExample project You can find a full working example of a React App using the Strapi Ratings Client Library in this repo: https://github.com/luisguve/strapi-ratings-client-example\nConclusion With this plugin you can enable and manage user reviews for any content with little effort and even use a library of components styled with Bootstrap to display the user reviews in your frontend.\nAnd that\u0026rsquo;s it! The features are pretty basic at the moment but if there\u0026rsquo;s interest, I\u0026rsquo;m willing to work on more features as well as improve the UI/UX.\n","image":"//localhost:1313/images/post/tutorial-ratings.webp","permalink":"//localhost:1313/blogs/how-to-enable-and-manage-user-reviews-in-your-strapi-application/","tags":["Strapi","Strapi tutorials"],"title":"How To Enable And Manage User Reviews In Your Strapi Application"},{"categories":["Documentation"],"contents":"Ratings is a Strapi plugin that allows your users to post reviews.\nEnable and manage user reviews for your content very easily!\nRequirements You should have installed an instance of Strapi v4.x.x\nInstallation Run the following command in your project root:\nnpm install strapi-plugin-ratings Then, rebuild the admin dashboard using the following command\nnpm run build Configurarion For your frontend to have access to the API, enable the following permissions for Ratings from Users \u0026amp; Permissions Plugin on your project settings:\nFor public, enable: count, find, getPageSize and getStats.\nFor authenticated, enable create, find and getUserReview.\nDisplay user reviews on the frontend Reviews can be displayed in the frontend in two ways:\nUsing the React components library strapi-ratings-client (recommended) Build your custom frontend using the API endpoints, described as follows: API There are some Typescript interfaces that will help to get an idea of the data structures.\nReviews: interface IReview { id: number, createdAt: string, comment: string | null, author: IAuthor | null, score: number, } Authors: interface IAuthor { username: string, email: string, id: number } Content Stats interface IStats { averageScore: number; reviewsCount: number | null; } The following endpoints are exposed to fetch and post reviews:\nGet reviews for a content ID Method: GET\nPath: /api/ratings/reviews/:slug\nOptional query parameters: start, ignoreCount\nReturns:\n{ reviewsCount: number, averageScore: number, userReview: IReview | null, reviews: IReview[] } The parameter start indicates how many reviews to skip. This is for pagination purposes.\nThe parameter ignoreCount indicates whether or not to return the total number of reviews associated with the given slug.\nGet review stats for a content ID Method: GET\nPath: /api/ratings/reviews/:slug/stats\nReturns:\n{ averageScore: number, reviewsCount: number | null } Get the number of reviews associated with a given content ID Method: GET\nPath: /api/ratings/reviews/:slug/count\nReturns:\n{ count: number } Post a review Method: POST\nPath: /api/ratings/reviews/:slug\nAuthentication: Bearer token\nPayload:\n{ content: string } Returns:\n{ id: number } By default, every authenticated user can post reviews on any content.\nIn order to customize this behavior, e.g. allowing or disallowing a user from posting reviews, you must extend the service userCanPostReview from whithin register function in ./src/index.js. For example:\nstrapi.service(\u0026#34;plugin::ratings.review\u0026#34;).userCanPostReview = async (user, slug) =\u0026gt; { /* Here you will check whether or not the user is allowed to post a review on this content ID and return either true or false. */ return true } Notice that userCanPostReview will receive two parameters: the user from Users \u0026amp; Permissions Plugin, containing it\u0026rsquo;s id, username, confirmed, etc., and the slug, which is a string and refers to the content ID which the review is being posted on.\nIn case this function returns false, the response of the endpoint will be 403 (forbidden) with the text User cannot post a review on this content.\nGet the page size Method: GET\nPath: /api/ratings/page-size\nReturns:\n{ pageSize: number } General settings The plugin allows to set how many reviews are returned per page by going to the Pagination section under Ratings Plugin of the Settings section.\nThe default page size is 10.\nManagement of reviews Admin users are able to delete reviews from within the plugin page of the Strapi admin dashboard.\nThe plugin interface has two tabs: one for the latest reviews and one for reviews by content ID.\nRoadmap and future plans The plugin is pretty basic but it can be improved with more features and a better UI/UX. Collaborations and suggestions are very welcome.\n","image":"//localhost:1313/images/post/ratings.webp","permalink":"//localhost:1313/blogs/strapi-plugin-ratings/","tags":["Strapi","Strapi plugins"],"title":"Strapi Plugin Ratings"},{"categories":["Projects"],"contents":"ManyLMS is an e-learning platform built on top of Strapi, React Router 7, Typescript and other technologies.\nOutline The idea Platform features The stack The API The frontend Conclusion Landing Page The idea This project doesn\u0026rsquo;t necessarily bring a huge amount of innovation on the e-learning platforms that already exists, but it\u0026rsquo;s just another way of doing this type of application.\nThe main idea is to apply a JAMstack approach in this application, where the platform is a static website, and the backend is just an API that serves static content only once to build the website and just adds the dynamism that\u0026rsquo;s necessary to allow users to authenticate, create orders, confirm payments and take courses.\nIf we compare this approach to a WordPress website, we are taking out most of the overhead that implies rendering the pages everytime a user visits them. Despite that there are plugins for caching that may improve the performance, it\u0026rsquo;s still never going to be faster and more efficient than just static content served by a CDN. That\u0026rsquo;s why React Router 7 and Headless CMSs are so popular right now.\nPlatform features and user stories The following user stories illustrates the desired features the platform should have.\nAs an administrator, I want to: login in the admin panel. create categories. create courses. upload lectures. organise courses into categories. assign lectures to courses. As a student, I want to: login in the platform. view the available courses. add courses to the shopping cart. review the shopping cart. create an order. pay with credit card or paypal. view the courses i\u0026rsquo;ve purchased in my learning page. go to the course page from my learning page and watch the videos. mark lectures as seen. come back later and resume where I left. The requirements The backend requires to handle user authentication, permissions, different data structures as content types and define relationships between them. It also requires to allow uploading videos to some third party platform that supports streaming on demand.\nThe frontend is a web platform where users can register and login, view and buy courses, leave comments and reviews and take courses.\nThe API Since all of the features involve authentication, permissions and roles, and because there is no need to reinvent the wheel, I chose to use Strapi to build the backend for it\u0026rsquo;s simplicity, ease of use and great developer experience, whereas for streaming videos on demand, I chose to use Mux.com.\nThe instance of Strapi and the Postgres database it requires was deployed in the cloud hosting platform https://fly.io.\nStrapi is good for managing users, content that\u0026rsquo;s typically updated and fetched via CRUD API, and setting up relations between content types.\nThe platform needs the following content types:\nCategory to group courses Course Lecture Module to group lectures Order Student: has many courses Student-Course: stores a student\u0026rsquo;s current lecture of a course Video Strapi makes the creation of these content types and setting up relationships between them really straightforward.\nBelow are some screenshots of these content types and the relationships between them:\nThe frontend The platform where users are able to login, view, buy and view courses is a web application built with React Router 7. Among the features of this application are:\nState managed by Context API Interface styled with Bootstrap Play streaming videos with @mux/mux-player-react library Use of localStorage to save user session Below are some sample screenshots of how this app looks like\nConclusion and final thoughts While building this project, I learned:\nHow streaming on demand works and how to use a streaming provider How to statically build websites with React Router 7 and Strapi How to setup dynamic pages in React Router 7 How to process payments with Stripe and Paypal How to build custom plugins in Strapi How to publish packages to NPM Project source codes: https://github.com/luisguve/maestro-backend\nhttps://github.com/luisguve/new-lms-remix\n","image":"//localhost:1313/images/project/manylms/frontend/course_overview.png","permalink":"//localhost:1313/projects/e-learning-platform-maestro-lms/","tags":["Strapi","React","React Router 7","Typescript","Mux"],"title":"ManyLMS: E-Learning platform"},{"categories":["Projects"],"contents":"ETMday (Emprende tu Mente) is a large-scale entrepreneurship event website built on top of WordPress with the Themosis framework, featuring an interactive SVG map, real-time countdown timers, advanced search functionality, and comprehensive content management using Vue 3, Laravel Mix, and modern frontend technologies.\nOutline The project Key features The stack Frontend architecture Interactive components Conclusion Live website The project ETMday is Chile\u0026rsquo;s premier entrepreneurship event, bringing together thousands of entrepreneurs, startups, corporates, and strategic partners. The website serves as the central hub for event information, featuring speakers, activities, stands, program schedules, and an interactive event map.\nThe frontend development required implementing complex interactive features including an SVG-based interactive map with tooltips, real-time countdown timers, advanced filtering and search systems, and dynamic content displays that handle thousands of attendees and hundreds of activities.\nKey features The website includes several sophisticated features:\nInteractive SVG Map: Custom-built interactive map with clickable zones, tooltips, and dynamic content display Real-time Countdown: Event countdown timer with automatic updates and mobile optimization Advanced Search: Multi-category search across activities, speakers, stands, and content Dynamic Filtering: Complex filtering system with tabs, favorites, and downloadable resources Animated Statistics: Odometer animations for displaying event metrics Content Management: Comprehensive card components for activities, speakers, stands, and blog posts Form Handling: Multi-step forms with validation using Vee-Validate Lightbox Galleries: Image galleries with LightGallery integration Responsive Design: Fully responsive design optimized for all devices The stack The frontend stack consists of:\nVue 3.2.4: Modern reactive framework for building interactive components Laravel Mix 6.0: Asset compilation and bundling SCSS: Advanced styling with organized architecture Vee-Validate 4.15.0: Form validation with Yup schemas Axios 1.6.8: HTTP client for API requests Splide.js 4.1.4: Modern carousel and slider components LightGallery 2.8.3: Lightbox gallery functionality Odometer 0.4.8: Animated number counting Headroom.js: Header behavior on scroll jQuery 3.7.1: DOM manipulation and legacy support SweetAlert2: Modern alert dialogs GLightbox 3.3.1: Alternative lightbox solution Frontend architecture Vue components The application features a comprehensive set of Vue 3 components:\nCard Components:\ncards/activities.vue: Activity cards with favorites functionality cards/speakers.vue: Speaker cards with modal details cards/stands.vue: Stand/exhibitor cards cards/blog.vue: Blog post cards cards/shortcut.vue: Quick access shortcut cards Functional Components:\nSectionCards.vue: Main section component with tabs, filtering, and card display Search.vue: Advanced search component with multi-category results Form.vue: Dynamic form component with validation FormCalendar.vue: Calendar form component CustomFilter.vue: Reusable filter component CustomSelect.vue: Custom select dropdown Pagination.vue: Pagination component JavaScript components The application includes 17 specialized JavaScript components:\nInteractive Features:\ninteractiveMap.js: SVG map interaction with tooltips, zones, and dynamic content countdown.js: Real-time countdown timer with automatic updates odometer.js: Animated number counting with scroll triggers map.js: Map zone interactions and modal displays UI Components:\nheader.js: Header functionality and navigation headroom.js: Header hide/show on scroll accordion.js: Accordion interactions tabs.js: Tab functionality cards.js: Card interactions and modals siteModals.js: Modal management system UI.js: General UI utilities Media Components:\nvideo.js: Video player setup lightgallery.js: Lightbox gallery initialization splide.js: Carousel initialization slick.js: Legacy carousel support Utilities:\nscrollTrigger.js: Scroll-based animations imgToSvg.js: SVG image conversion utility SCSS architecture The styling follows a well-organized SCSS architecture:\nscss/ ├── abstracts/ # Variables, mixins, functions │ ├── _functions.scss │ ├── _mixins.scss │ ├── _variables.scss │ ├── _mq.scss # Media query mixins │ └── _keyframes.scss ├── base/ # Base styles and typography │ ├── _typography.scss │ ├── _container.scss │ └── _reset.scss └── components/ # Component-specific styles └── [52 component files] Key SCSS features:\nBEM methodology: Consistent naming convention Media query mixins: Using sass-mq for responsive design Modular architecture: Each component has its own SCSS file Component organization: 52 component-specific SCSS files Interactive components Interactive SVG Map The interactiveMap.js component implements a sophisticated SVG-based interactive map:\nFeatures:\nSVG Tooltips: Dynamically generated tooltips with text wrapping Zone Interactions: Clickable zones with modal displays Point Markers: Interactive points with icons and labels Dynamic Content: Content loaded based on zone/point selection Responsive Design: Optimized for mobile and desktop Technical Implementation:\nSVG namespace manipulation for tooltip creation Text wrapping algorithm for tooltip content Path generation for tooltip shapes with rounded corners Event delegation for zone and point interactions Smooth animations and transitions Real-time Countdown The countdown.js component provides a real-time countdown timer:\nFeatures:\nAutomatic Updates: Updates every second Multi-unit Display: Days, hours, minutes, and seconds Pluralization: Proper Spanish pluralization (Día/Días, Hora/Horas) Mobile Optimization: Simplified display on mobile devices End State Handling: Automatic transition when countdown ends Advanced Search System The Search.vue component implements a comprehensive search system:\nFeatures:\nMulti-category Search: Searches across activities, speakers, stands, and other content Category Tabs: Quick navigation between result categories Result Counts: Dynamic result counts per category Scroll Navigation: Smooth scrolling to category sections Carousel Display: Splide carousels for result display Loading States: Loading indicators during search Empty States: User-friendly empty state messages Dynamic Filtering System The SectionCards.vue component provides advanced filtering:\nFeatures:\nTab Navigation: Multiple filter tabs Favorites System: Save and filter favorite items Search Integration: Inline search within filters Reset Functionality: Clear all filters with one click Downloadable Resources: Download buttons for resources URL Synchronization: Filter state in URL parameters Responsive Design: Mobile accordion interface Animated Statistics The odometer.js component provides animated number counting:\nFeatures:\nScroll-triggered: Animations trigger on scroll Prefix/Suffix Support: Handles formatted numbers (e.g., \u0026ldquo;56,000+\u0026rdquo;) Mobile Optimization: Static display on mobile Smooth Animations: Odometer theme integration Development workflow The project uses Laravel Mix for asset compilation:\n// Development npm run dev // Compile assets npm run watch // Watch for changes npm run hot // Hot module replacement // Production npm run production // Optimized production build BrowserSync integration provides:\nLive reloading during development Synchronized browser testing Proxy configuration for WordPress development Performance optimizations Code splitting: Laravel Mix extracts vendor libraries Asset versioning: Automatic cache busting Image optimization: Lazy loading and responsive images Minification: Production builds are minified and optimized Tree shaking: Unused code elimination in production SVG optimization: Efficient SVG manipulation and rendering Accessibility Semantic HTML structure ARIA labels for interactive elements Keyboard navigation support Focus management in forms and modals Screen reader considerations Proper alt text for images Conclusion and final thoughts Building the ETMday frontend was an excellent opportunity to:\nMaster SVG interactions: Creating complex interactive SVG maps with dynamic tooltips and zones Implement real-time features: Building countdown timers and live updates Build advanced search: Multi-category search with filtering and categorization Handle complex state: Managing filters, favorites, and dynamic content Optimize performance: Implementing efficient animations and lazy loading Ensure scalability: Building components that handle large datasets (thousands of attendees, hundreds of activities) The project demonstrates proficiency in:\nModern JavaScript frameworks (Vue 3) SVG manipulation and interaction Real-time UI updates Advanced filtering and search systems Build tools and asset compilation (Laravel Mix, Webpack) CSS architecture and methodologies (SCSS, BEM) Component-based development Event-driven architecture The integration with WordPress/Themosis backend required careful consideration of server-side rendering, API endpoints, and content management workflows, making this a full-stack frontend implementation for a large-scale event.\nLive website: https://etmday.org/\n","image":"//localhost:1313/images/project/etm/homepage.webp","permalink":"//localhost:1313/projects/etmday-entrepreneurship-event-website/","tags":["Vue 3","Laravel Mix","WordPress","Themosis","SCSS","JavaScript","Interactive Map","SVG"],"title":"ETMday: Entrepreneurship Event Website"},{"categories":["Projects"],"contents":"Chile Nativo is a travel tour website for Patagonia experiences, built on top of WordPress with the Themosis framework, featuring a modern frontend implementation based on a Figma design using Vue 3, Laravel Mix, and a comprehensive SCSS architecture.\nOutline The project Design implementation The stack Frontend architecture Key features Conclusion Live website The project Chile Nativo is a travel company specializing in Patagonia tours, offering experiences in destinations like Torres del Paine, Tierra del Fuego, and Isla Navarino. The website serves as the primary platform for showcasing tours, managing bookings, and providing information about their travel experiences.\nThe frontend development was based on a comprehensive Figma design, requiring pixel-perfect implementation of complex UI components, interactive forms, filtering systems, and responsive layouts that work seamlessly across all devices.\nDesign implementation The entire frontend was built from a detailed Figma design, ensuring:\nPixel-perfect accuracy: Matching the design specifications precisely Responsive design: Implementing breakpoints and mobile-first approach Component consistency: Maintaining design system patterns throughout Interactive elements: Translating static designs into dynamic, interactive components Animation and transitions: Implementing smooth user experience enhancements The stack The frontend stack consists of:\nVue 3.2.4: Modern reactive framework for building interactive components Laravel Mix 6.0: Asset compilation and bundling SCSS: Advanced styling with a well-organized architecture Pinia 2.3.1: State management for Vue applications Vee-Validate 4.15.0: Form validation with Yup schemas Axios 1.6.8: HTTP client for API requests Splide.js 4.1.4: Modern carousel and slider components Headroom.js: Header behavior on scroll Plyr 3.7.8: Video player implementation SweetAlert2: Modern alert dialogs jQuery 3.7.1: Legacy support and DOM manipulation utilities Frontend architecture Vue components The application features a comprehensive set of Vue 3 components organized by functionality:\nFiltering and Search Components:\nToursFilter.vue: Advanced tour filtering with multiple criteria TourDatesFilter.vue: Date-based filtering for tour availability ToursFilterDropdown.vue \u0026amp; ToursFilterDropdownMobile.vue: Responsive filter dropdowns TestimonialsFilter.vue: Filtering system for customer testimonials NewsFilter.vue: Blog and news filtering SearchResults.vue: Search results display with pagination Form Components:\nPersonalizedTripForm.vue: Multi-step form for custom trip requests with validation ContactFormSimple.vue: Contact form with reCAPTCHA integration FormHelp.vue: Help center form FormGiftCard.vue: Gift card purchase form FormCareers.vue: Job application form NewsletterForm.vue: Newsletter subscription Card Components:\nTour.vue \u0026amp; TourLoading.vue: Tour card display with loading states TourDate.vue \u0026amp; TourDateLoading.vue: Tour date selection cards Testimonial.vue \u0026amp; TestimonialLoading.vue: Customer testimonial cards Blog.vue \u0026amp; BlogLoading.vue: Blog post cards Team.vue \u0026amp; TeamLoading.vue: Team member cards ResourceCard.vue \u0026amp; ResourceLoading.vue: Resource display cards Utility Components:\nPagination.vue: Reusable pagination component Select.vue: Custom select dropdown with search Loader.vue \u0026amp; LoaderFullScreen.vue: Loading indicators EmptyState.vue: Empty state displays ContentResources.vue: Resource content management TeamTabsFilter.vue: Tabbed team member filtering SCSS architecture The styling follows a well-organized SCSS architecture:\nscss/ ├── abstracts/ # Variables, mixins, functions │ ├── _functions.scss │ ├── _mixins.scss │ ├── _variables.scss │ ├── _mq.scss # Media query mixins │ └── _keyframes.scss ├── base/ # Base styles and typography │ ├── _typography.scss │ ├── _colors.scss │ ├── _fonts.scss │ └── _reset.scss └── components/ # Component-specific styles └── [125 component files] Key SCSS features:\nBEM methodology: Consistent naming convention throughout Media query mixins: Using sass-mq for responsive design Modular architecture: Each component has its own SCSS file Abstract layer: Reusable variables, mixins, and functions Vue transitions: Custom transition styles for Vue components JavaScript architecture The JavaScript is organized into two main entry points:\nMain application (app.js):\nInitializes core application functionality Sets up jQuery plugins and utilities Handles legacy browser support Vue application (vue/main.js):\nConfigures Vue 3 app with Pinia for state management Registers global Vue components Sets up Vee-Validate configuration Integrates third-party Vue plugins (VueTelInput, etc.) Component utilities (app/components/):\nheader.js: Header behavior and navigation footer.js: Footer functionality splide.js: Carousel initialization slick.js: Legacy carousel support accordions.js: Accordion interactions tabs.js: Tab functionality scrollTrigger.js: Scroll-based animations video.js: Video player setup sticky-sidebar.js: Sticky sidebar behavior Key features Multi-step forms The PersonalizedTripForm.vue component implements a sophisticated multi-step form with:\nStep-by-step navigation with progress indicators Form validation using Vee-Validate and Yup schemas Dynamic form fields based on user selections Phone number input with international support (VueTelInput) reCAPTCHA integration for spam protection Loading states and error handling Advanced filtering system The tour filtering system (ToursFilter.vue) provides:\nMultiple filter criteria (destination, activity type, trip type, month) Real-time filtering with URL parameter synchronization Responsive design with mobile accordion interface Custom select components with search functionality Empty states and loading indicators Integration with WordPress backend via Axios Responsive design The entire website is fully responsive with:\nMobile-first approach Breakpoint management using sass-mq Touch-friendly interactions Optimized images and assets Performance optimizations for mobile devices Performance optimizations Code splitting: Laravel Mix extracts vendor libraries Asset versioning: Automatic cache busting Image optimization: Lazy loading and responsive images Minification: Production builds are minified and optimized Tree shaking: Unused code elimination in production Accessibility Semantic HTML structure ARIA labels where appropriate Keyboard navigation support Focus management in forms Screen reader considerations Development workflow The project uses Laravel Mix for asset compilation:\n// Development npm run dev // Compile assets npm run watch // Watch for changes npm run hot // Hot module replacement // Production npm run production // Optimized production build BrowserSync integration provides:\nLive reloading during development Synchronized browser testing Proxy configuration for WordPress development Conclusion and final thoughts Building the Chile Nativo frontend from a Figma design was an excellent opportunity to:\nMaster Vue 3: Working with the Composition API, reactive systems, and modern Vue patterns Implement complex forms: Multi-step forms with validation, international phone inputs, and reCAPTCHA Build scalable architecture: Organizing 40+ Vue components and 125+ SCSS files in a maintainable structure Optimize performance: Implementing code splitting, lazy loading, and production optimizations Ensure design fidelity: Translating Figma designs into pixel-perfect implementations Handle responsive design: Creating seamless experiences across all device sizes The project demonstrates proficiency in:\nModern JavaScript frameworks (Vue 3) Build tools and asset compilation (Laravel Mix, Webpack) CSS architecture and methodologies (SCSS, BEM) Form validation and user experience Component-based development Design system implementation The integration with WordPress/Themosis backend required careful consideration of server-side rendering, API endpoints, and content management workflows, making this a full-stack frontend implementation.\nLive website: https://chilenativo.travel/\nFigma prototype: https://www.figma.com/proto/ywHPhSP1UfYUAE8eWVQv4L/Dise%C3%B1o-Desktop---Chile-Nativo?node-id=289-3912\u0026m=dev\u0026scaling=min-zoom\u0026content-scaling=fixed\u0026page-id=289%3A3911\u0026starting-point-node-id=289%3A3912\n","image":"//localhost:1313/images/project/chile-nativo/home.png","permalink":"//localhost:1313/projects/chile-nativo-patagonia-travel-website/","tags":["Vue 3","Laravel Mix","WordPress","Themosis","SCSS","JavaScript","Figma"],"title":"Chile Nativo: Patagonia Travel Website"},{"categories":["Projects"],"contents":"Rutieri is a SaaS platform built with Strapi, React Native, Typescript and other technologies.\nOutline The idea Platform features The stack The API The frontend The mobile app Conclusion Landing Page The idea Before starting to write a single line of code, it is generally a good idea to think about the problem, it\u0026rsquo;s limitations and whether or not it has already been solved by someone else (AKA competitors).\nThe problem I was looking into had to do with the way in which public and private transportation companies manage their routes, drivers and users. This process is generally carried out on paper, e.g. not digital, hence this could be problematic in case of new drivers joining the organization or in case of restricting access to data to only specific users.\nAfter a little bit of research, I could only find one platform that provides a similiar solution but for their own company.\nPlatform features and user stories The following user stories illustrates the desired features the platform should have in order to solve the aforementioned problems.\nAs an administrator user, I want to: login in the admin panel. create an organization. create routes in the organization. invite drivers and users to the organization. manage requests to join the organization. assign routes to drivers in the organization. see in real time the drivers and users currently active in the map of the different routes. As a driver, I want to: login in the mobile app. join an organization by entering the code in the search bar. see my route on the map. become visible to passengers on the road. see the passengers waiting on the road. remove my visibility and finish my run. As a passenger, I want to: login in the mobile app. join an organization by entering the code in the search bar. see the different routes of my organization in the map. search for a destination and get the available routes that pass nearby. see the drivers currently active on the routes in real time. become visible to drivers of a route. The requirements The backend requires to handle user authentication, permissions, different data structures as content types and define relations between them. It\u0026rsquo;s also necessary to synchronise passengers and drivers and view them on a map real time in the administration panel as well as in the mobile app.\nThe administration panel is a web page that fetches data from the backend as well as from the real time data provider and it\u0026rsquo;s goal is to provide a way for administrators to manage their organization and users. We\u0026rsquo;re talking about a Single Page Application built in React.\nAs for the mobile application, there isn\u0026rsquo;t a better choice nowadays than React Native and it works just fine in this case.\nThe API Since all of the features involve authentication, permissions and roles, and because there is no need to reinvent the wheel, I chose to use Strapi to build the backend for it\u0026rsquo;s simplicity, ease of use and great developer experience, whereas for realtime data, I used Firebase.\nThe instance of Strapi and the Postgres database it requires was deployed in the cloud hosting platform https://fly.io.\nStrapi is good for managing users, content that\u0026rsquo;s typically updated and fetched via CRUD API, and relations between content types.\nThe platform needs the following content types:\nOrganizations to group routes, drivers and users Routes Two user roles: drivers and users (passengers) Below are some screenshots of the overview of these content types\nAs I said before, Strapi makes the creation of these content types and the relationships between them really straightforward.\nHowever, not everything related to the API can be provided by Strapi. Some realtime features need to be addressed with other solutions, such as geolocation data in real time for drivers and users to synchronise each other, maps and the ability to search for places. Such features were implemented using Firebase, Google Maps and Google Places.\nThe frontend The platform where users are able to login as administrators and manage their organizations and users is a single page web application built in React. Among the features of this project that I think stand out are:\nState managed by Context API Interface styled with Bootstrap React Router for pages Leaflet to display the map GeoFire library to synchronise geolocation data in real time with Firebase Use of localStorage to save user session Below are some sample screenshots of how this app looks like\nThe mobile application This one is by far the most complex part of this project.\nThe project was bootstraped with Infinitered\u0026rsquo;s Ignite, which provides a great boilerplate and surely saved me of what would have been between 1-2 months of work.\nIgnite\u0026rsquo;s boilerplate includes many features out of the box, including:\nReact Native and Typescript (of course) React Navigation MobX-State-Tree for state management Expo SDK for developer experience AsyncStorage for persistence apisauce as REST client And some other libraries and features that make React Native apps super powerful and a joy to work on.\nIt consists of three screens:\nWelcome screen Login screen Map screen In the welcome screen, users are able to go to the login screen if not logged in. Otherwise, if they\u0026rsquo;re in an organisation, it shows their role and org\u0026rsquo;s information, and if they\u0026rsquo;re not, they are able to enter the organisation code and request to join as driver or as passenger.\nWelcome screens Login screens If the user is a driver in an organisation, the welcome screen also shows the route assigned to them. By tapping on it, it takes them to the map, where they can see themselves and start the tour, becoming visible to passengers on the road but being able to see passengers on the road as well.\nDrivers can finish the tour at any time by pressing the button stop.\nIf the user is a passenger in an organisation, the welcome screen shows the different routes available in the organisation. By tapping on them, they are taken to the map where they can see themselves, the route and the drivers on the road.\nPassengers are able to navigate between the available routes and search for the location they want to go to by using the search bar at the top of the map screen, filtering out the routes that pass nearby (less than 200 meters), if there are. Google Places API and turf library work together in this search process.\nPassengers become visible to drivers on the road by pressing the button wait and if they press the button again, they stop waiting and are removed from the driver\u0026rsquo;s map.\nMap screens The start/wait and finish buttons dispatch actions that update their location in firebase, so that passengers are able to see the bus on the map as it moves in real time and viceversa.\nAs for the state management, the project consists of two models and three stores from Mobx-State-Tree library: User and Route models, user-status, route-store and root-store stores.\nUser model Located in /app/models/user/user.ts\nconst OrganizationModel = types.model({ name: types.string, code: types.string, id: types.identifierNumber, drivers: types.number, rutas: types.array(RouteModel) }) const UserModel = types .model(\u0026#34;User\u0026#34;) .props({ id: types.identifierNumber, username: types.string, email: types.string, token: types.string, role: types.union(types.literal(\u0026#34;passenger\u0026#34;), types.literal(\u0026#34;driver\u0026#34;)), ruta: types.maybeNull(RouteModel), organization: types.maybeNull(OrganizationModel), pending_request: types.maybeNull(OrganizationModel), }) Route model Located in /app/models/route/route.ts\nThis model follows the GeoJSON format for routes.\nconst RouteModel = types .model(\u0026#34;Ruta\u0026#34;) .props({ id: types.identifierNumber, name: types.string, latlong: types.maybeNull(types.model({ lat: types.number, longt: types.number })), coords: types.model({ type: FeatureTypes, features: types.array(types.model({ type: types.string, geometry: types.model({ type: types.string, coordinates: types.union(types.array(types.number), types.array(types.array(types.number))) }), properties: types.model({ name: types.string }) })) }) }) user-status store Located in /app/models/user-status/user-status.ts\nThis store is responsible for managing the state of the user. It stores the user once it\u0026rsquo;s logged in and removes it when the user logs out. It also has some views to get the user key for firebase purposes, get the role and get the route in case of a driver.\nThis store has some methods that get the user location from the device\u0026rsquo;s GPS, displays the user icon on the map and sends it to firebase.\nconst UserStatusModel = types .model(\u0026#34;UserStatus\u0026#34;) .extend(withEnvironment) .props({ user: types.maybeNull(UserModel), location: types.maybeNull( types.model({latitude: types.number, longitude: types.number}) ), visibility: types.maybeNull(types.number) }) route-store store Located in /app/models/route-store/route-store.ts\nThis store is responsible for managing the state of the available routes. It stores the routes, drivers and passengers on the different routes. It also has some view methods to filter the routes that pass nearby a destination specified by the user, get passengers waiting on a given route and get drivers active in a specific route.\nThis store initializes a GeoQuery from Geofire library and listens for events to set, update and remove drivers and passengers from the map as they move.\nconst RouteStoreModel = types .model(\u0026#34;RouteStore\u0026#34;) .props({ routes: types.array(RouteModel), passengers: types.map(types.model({ key: types.identifier, location: types.array(types.number) })), drivers: types.map(types.model({ key: types.identifier, location: types.array(types.number) })), destinationAddress: types.maybeNull(types.model({ name: types.string, coords: types.array(types.number) })) }) Conclusion and final thoughts Using a CMS as the backend can make the development a lot faster than building the API from scratch and with Strapi this is specially true. On the other hand, Strapi doesn\u0026rsquo;t really make a good fit for real time applications, therefore, Firebase is the way to go in this case.\nAs of the client side, React always works very good for pretty much any kind of application, and because React Native uses React under the hood, it is so convenient for us React developers and ir works pretty good for almost any kind of application as well.\nHowever, one thing that I didn\u0026rsquo;t mention in this post was the use of Typescript; I find this quote by Brice Wilson pretty good to point out the whole purpose and motivation to learn and use (well) this powerful language and tool ecosystem:\n\u0026ldquo;You won\u0026rsquo;t have to wait for a frustrated user to report the error. All of this means that you provide value to your users faster, and that\u0026rsquo;s really what it\u0026rsquo;s all about.\u0026rdquo;\nAll in all, I got a lot of learning by building this project, both in languages/frameworks used and production stuff such as infrastructure, cloud hosting and cloud-based APIs.\nProject landing page: https://rutieri.netlify.app\n","image":"//localhost:1313/images/project/rutieri/landing/homepage.webp","permalink":"//localhost:1313/projects/saas-platform-rutieri/","tags":["Strapi","React Native","React","Typescript","Firebase"],"title":"SaaS platform: Rutieri"},{"categories":["Tutorial"],"contents":"Enable comments in a Strapi application and display them in the frontend with React\nOutline Introduction Prerequisites What is Strapi Comment Manager? Installation Configuration Display comments on the frontend Installation of Strapi Comments Client Usage of Strapi Comments Client Plugin settings Manage comments Full source code of the frontend Conclusion Introduction A comment system comes in very handy for pretty much any kind of website. In the JAMstack ecosystem, while it\u0026rsquo;s ok to rely on third party solutions hosted on their own platform such as Disqus to enable comments, you usually want to keep your content and all the stuff related to it in the same admin dashboard.\nIn this article, I\u0026rsquo;ll show you how to enable and manage comments for your content very easily using the Comment Manager plugin, and display them in your frontend application.\nPrerequisites You should have a basic understanding of the following.\nBasic knowledge of JavaScript Basic knowledge of React (OPTIONAL) Basic understanding of Strapi - get started here. Your Strapi V4 project setup What is Strapi Comment Manager? Strapi Comment Manager is a plugin that enables comments for pretty much any kind of content. It allows your users to post comments and anyone can get the comments associated with a given slug.\nWith this plugin, admin users can view and manage very easily all the comments from the Strapi administration dashboard. Within the dashboard, you will be able to delete comments and subcomments and leave replies on comments.\nInstallation Once into the Strapi project root, you can install the plugin by running the following command:\nnpm install strapi-plugin-comment-manager Next, build the project to see the new plugin in the dashboard with the following command:\nnpm run build And that\u0026rsquo;s it! If everything runs correctly, the plugin should now be installed.\nConfiguration Now you need to enable some permissions so that the frontend can access the endpoints to post and fetch comments.\nIn your Strapi admin dashboard, head over to Settings, then over to Roles under Users \u0026amp; Permissions Plugin.\nLet\u0026rsquo;s first setup the Public API; click on Public and hit the dropdown button of Comment Manager. Now check count, find and getPageSize, then hit the Save button. Below is a screenshot of a proper configuration:\nNow let\u0026rsquo;s setup the Authenticated API. Go back to Roles and click on Authenticated. Open the dropdown for Comment Manager and mark as checked the option create on both Comment and Subcomment. Below is a screenshot of a proper configuration:\nWith this configuration, the frontend should now be able to make requests to get and post comments.\nDisplay comments on the frontend The plugin exposes an API to get and post comments if you want to have fine-grained control over the workflow of your comments system and you can check the documentation on the package page, but this plugin also comes with a purpose-built React component library that makes it super easy to get up and running without getting your hands dirty.\nThis components library is called strapi-comments-client, fully supports typescript and it handles for you all of the complexity of fetching and posting comments and subcomments for every content ID that you pass to it.\nInstallation of Strapi Comments Client You will need to have installed react ^17.0.2, react-dom ^17.0.2 and react-router-dom ^5.2.0.\nInside of your React project, run this command:\nnpm install strapi-comments-client --save Usage of Strapi Comments Client Using this library is very easy!\nThis library exports three main components:\nCommentsProvider Comments CommentForm And you can import them this way:\nimport { CommentsProvider, Comments, CommentForm } from \u0026#34;strapi-comments-client\u0026#34; All you have to do is wrap your App component into the CommentsProvider component. Then you will be able to place anywhere in your app the Comments component to render a list of comments for a given content ID and the CommentForm component to render a form to post comments.\nFor example, this could be your index.js or main.js file:\nimport React from \u0026#39;react\u0026#39; import ReactDOM from \u0026#39;react-dom\u0026#39; // The address of your strapi backend instance const STRAPI = \u0026#34;http://localhost:1337\u0026#34; ReactDOM.render( \u0026lt;React.StrictMode\u0026gt; \u0026lt;CommentsProvider apiURL={STRAPI}\u0026gt; \u0026lt;App /\u0026gt; \u0026lt;/CommentsProvider\u0026gt; \u0026lt;/React.StrictMode\u0026gt;, document.getElementById(\u0026#39;root\u0026#39;) ) Where apiURL is the URL of your running Strapi application, and this property is required.\nThis way, the comments provider will do all the magic of fetching and posting comments for you!\nThis library also exports an utility React.Context to update some of the parameters for fetching and posting comments:\nimport { CommentsConfigContext } from \u0026#34;strapi-comments-client\u0026#34; This CommentsConfigContext exposes two setter functions: setUser and setContentID\nWith setContentID you can load the comments for a given content and post comments to it. It receives a single parameter of type string and must be URLized, i.e. no spaces.\nWith setUser you can set the credentials of a given user to authorize the posting of comments. It receives a single parameter of type IUser, with the following Typescript interface:\ninterface IUser { username: string, email: string, id: string, token: string // This is a JWT } It\u0026rsquo;s a little confusing but we\u0026rsquo;ll see how to use it in a component:\nconst App = () =\u0026gt; { const { setUser, setContentID } = useContext(CommentsConfigContext) // The following data should come from Strapi Users and Permissions Plugin // for authenticated requests const user = { username: \u0026#34;John Doe\u0026#34;, email: \u0026#34;jhohndoe@gmail.com\u0026#34;, id: 5, token: \u0026#34;this_should_be_a_JWT\u0026#34; } if (user) { setUser(user) } setContentID(\u0026#34;sample-content-1\u0026#34;) // Load comments for this content return ( \u0026lt;\u0026gt; { !user \u0026amp;\u0026amp; \u0026lt;Login /\u0026gt; } \u0026lt;CommentForm /\u0026gt; \u0026lt;Comments /\u0026gt; \u0026lt;/\u0026gt; ) } And that\u0026rsquo;s it!\nAfter setting the content ID through setContentID, CommentsProvider will start loading the comments for the given content ID and the CommentForm will render an input to post comments related to the given content ID if there is a user. Otherwise, it will display the message Login to post a comment.\nHere\u0026rsquo;s how the interface looks like so far:\nThere\u0026rsquo;s also a button to Leave a reply, which will open a form to post a subcomment associated with the parent comment.\nThis library exports one more component: ErrorBox\nimport { ErrorBox } from \u0026#34;strapi-comments-client\u0026#34; .It\u0026rsquo;s useful if you\u0026rsquo;d like to display error messages when things go wrong fetching or posting comments.\nYou can place this component wherever you want, for example in between the CommentForm and the Comments components.\nIf you\u0026rsquo;re wondering how this error box looks like, here you have a sample:\nGeneral settings You can customize the page size, i.e. specify how many comments are returned at once.\nIn the Strapi admin panel, head over to Settings, then select Pagination under Comment Manager Plugin.\nHere you\u0026rsquo;ll find an input to set the page size, which defaults to 10.\nManage comments Once you\u0026rsquo;ve got the plugin up an running, as users start to post comments, you can manage and reply to them as admin from the Comment Manager section of the left sidebar in the Strapi admin dashboard.\nHere you can see two tabs: one for the latest comments and one for comments grouped by content ID.\nIn both of them you can delete comments and subcomments as well as leave replies.\nExample project You can find a full working example of a React App using the Strapi Comments Client Library in this repo\nConclusion With this plugin you can enable and manage comments for any content with little effort and even use a component library to display the comments in your frontend application made with React.\nAnd that\u0026rsquo;s it! The features are pretty basic at the moment but if there\u0026rsquo;s interest, I\u0026rsquo;m willing to work on more features as well as improve the UI/UX.\n","image":"//localhost:1313/images/post/strapilogo.jpg","permalink":"//localhost:1313/blogs/how-to-enable-and-manage-comments-in-your-strapi-application/","tags":["Strapi","Strapi tutorials"],"title":"How To Enable And Manage Comments In Your Strapi Application."},{"categories":["Documentation"],"contents":"Comment Manager is a Strapi plugin to allow your users to post comments.\nWith this plugin you can enable and manage comments for your content very easily!\nRequirements You should have installed an instance of Strapi v4.x.x\nInstallation Run the following command in your project root:\nnpm install strapi-plugin-comment-manager Configurarion For your frontend to have access to the API, enable the following permissions for Comment Manager from Users \u0026amp; Permissions Plugin on your project settings:\nFor public, enable: count, find and getPageSize.\nFor authenticated, enable create on both Comment and Subcomment.\nDisplay comments on the frontend Comments can be displayed in the frontend in two ways:\nUsing the React components library strapi-comments-client (recommended) Build your custom frontend using the API API There are some Typescript interfaces that will help to get an idea of the data structures.\nComments: interface IComment { id: string, from_admin: boolean, createdAt: string, content: string, author: IAuthor | null, subcomments?: ISubcomment[] } Subcomments: interface ISubcomment { id: string, from_admin: boolean, createdAt: string, content: string, author: IAuthor | null, } Authors: IAuthor { username: string, email: string, id: string } The following endpoints are exposed to fetch and post comments and subcomments:\nGet comments for a content ID Method: GET\nPath: /api/comment-manager/comments/:slug\nOptional query parameters: start, ignoreCount\nReturns:\n{ commentsCount?: Number, comments: IComment[] } The parameter start indicates how many comments to skip. This is for pagination purposes.\nThe parameter ignoreCount indicates whether or not to return the total number of comments associated with the given slug.\nGet the number of comments associated with a given content ID Method: GET\nPath: /api/comment-manager/comments/:slug/count\nReturns:\n{ count: Number } Post a comment Method: POST\nPath: /api/comment-manager/comments/:slug\nAuthentication: Bearer token\nPayload:\n{ content: string } Returns:\n{ id: Number } Post a subcomment Method: POST\nPath: /api/comment-manager/subcomments/:parent-id\nAuthentication: Bearer token\nPayload:\n{ content: string } Returns:\n{ id: Number } Get the page size Method: GET\nPath: /api/comment-manager/page-size\nReturns:\n{ pageSize: Number } General settings The plugin allows to set how many comments are returned per page by going to the Pagination section under Comment Manager Plugin on the Settings section.\nThe default page size is 10.\nManagement of comments Admin users are able to delete comments and subcomments as well as leave replies as admins from within the plugin page of the Strapi admin dashboard.\nThe plugin interface has two tabs: one for the latest comments and one for comments by content ID.\nRoadmap and future plans The plugin is pretty basic but it can be improved with more features and a better UI/UX. Collaborations and suggestions are very welcome.\n","image":"//localhost:1313/images/post/strapilogo.jpg","permalink":"//localhost:1313/blogs/strapi-plugin-comment-manager/","tags":["Strapi","Strapi plugins"],"title":"Strapi Plugin Comment Manager"},{"categories":["Projects"],"contents":"In this post I’m going to share my experience on building a SaaS using the headless CMS Strapi as the Backend, React Native and other technologies.\nOutline Introduction What is SaaS? The problem What is Strapi? Developing features in Strapi The frontend: How to get content Conclusion Landing Page Introduction Very often, developers, product and project managers, testers and pretty much the entire team share their ideas to decide what language and which framework they\u0026rsquo;ll use to build their next project. Some considerations must be taken into account, from which in my opinion there are three that are the most important:\nDeveloper experience and ease of use Does the language and framework chosen provide a good developer experience? Is the langauge the same for the backend and frontend?\nDeadlines Is there a deadline to finish the project? if so, there is a good chance to finish the project on time if the team chooses the language they have more experience in.\nMaintainability As there will be usually more than one person working on the same part at the same time, if everything is kept organised, the whole development process will be frictionless.\nWith that in mind, developers and project managers will have a better insight on which language/framework to use.\nOther aspects should also be considered such as what the data structure will look like.\nIn my case, as it is usual, the backend of my project needs a database for users and their roles among other entities and their relations and a dashboard to allow admins to manage the data, and I was lucky to find out Strapi, as it includes a lot of these features out of the box with one single line of command to get started.\nWhat is SaaS? SaaS stands for Software-as-a-Service and it just means that a software is provided as a service in the cloud and it gives a solution to a specific problem, for which the users are willing to pay either monthly or annual subscription.\nThe problem Before starting to write a single line of code, it is generally a good idea to think about the problem, it\u0026rsquo;s limitations and whether or not it has already been solved by someone else (AKA competitors).\nThe problem I was looking into had to do with the way in which public and private transportation companies manage their routes, drivers and users. After a little bit of research, I could only find one platform that provides a similiar solution but for their own company.\nSo the platform I built needed the following content types:\nOrganizations to group routes, drivers and users Routes Two user roles: drivers and users (passengers) As I said before, Strapi makes the creation of these content types and the relationships between them really easy, but let\u0026rsquo;s first see what is Strapi and how it turns the API development into a satisfactory and fun experience.\nWhat is Strapi? Strapi is an open source headless CMS that allows developers to build complete RESTful APIs in just a couple of days instead of months. It includes a lot of useful features as plugins out of the box. Users and Roles management, Media library and an interface to create, view, edit and delete content are just some of them.\nRegarding the API, how does it makes the development faster?\nFirst of all, it enforces a specific folder structure, which helps to keep everything well organised and clean.\nSecondly, all database schemas are generated automatically and queries are made in JSON format, which really saves a lot of time.\nLastly, we can add more features to our Strapi application very easily via plugins from the marketplace.\nIt\u0026rsquo;s also worth noting that Strapi is a self-hosted CMS, which means that we can host it in whatever cloud platform we want, as well as test it locally in our computers before deploying it to the cloud.\nDeveloping features in Strapi Creating and configuring endpoints in Strapi is as straightforward as declaring a JSON in a single file:\nCreating controllers is straightforward as well:\nEvery controller gets all the data related to the request in the ctx parameter and it\u0026rsquo;s also used to send the response. This keeps everything in one place and really helps to improve the readability.\nOnce the API endpoints are defined, the next step is to enable the permissions for the specific user roles to have access to these endpoints:\nThe frontend: how to get content Since Strapi is a headless CMS, it\u0026rsquo;ll only provide content through the API. That means that the content can be consumed from anywhere. In our case, this content will be used in two applications: one for the organization owners and one for the users and drivers.\nThe application for the organization owners is a dashboard where administrators can create organizations, routes, accept drivers and users in the organization and assign routes to drivers. This is just a React Application:\nThe application for drivers and users is a mobile application built in React Native. Firebase was used to synchronise geolocation data in real time between drivers and users and display this information in a Map from Google Maps:\nConclusion Using a CMS as the backend can make the development a lot faster than building the API from scratch and with Strapi this is specially true. Furthermore, this becomes more important when building a brand-new product, as it\u0026rsquo;s usually recommended to launch as soon as possible to gather feedback from the users and validate the idea.\nProject landing page: https://rutieri.netlify.app\n","image":"//localhost:1313/images/post/03.webp","permalink":"//localhost:1313/blogs/how-i-built-a-saas-on-top-of-strapi-and-why-you-should-too/","tags":["Strapi","React Native","Typescript"],"title":"How I Built A SaaS On Top Of Strapi, And Why You Should Too"},{"categories":["Tutorial"],"contents":"Enable User Reviews in a Strapi application and display them in the frontend with React\nOutline Introduction Prerequisites What is Strapi Ratings? Installation Configuration Display user reviews on the frontend Plugin settings Manage user reviews Full source code of the frontend Conclusion Introduction Ratings systems have become a crucial part of any website with ecommerce capabilites, as they allow the users to post reviews on the items they purchase and publish their opinion to the public. A couple of reviews can make the difference between pressing the “Buy” button and moving on to the next website in the Google search results.\nIn this article, I\u0026rsquo;ll show you how to enable and manage user reviews for your content very easily using the Ratings plugin, and display them in your frontend application.\nPrerequisites First of all, you need to have a basic understanding of the following.\nBasic knowledge of JavaScript Basic knowledge of React (OPTIONAL) Basic understanding of Strapi - get started here. Your Strapi V4 project setup What is Strapi Ratings? Strapi Ratings is a plugin that gives your Strapi application the ability to manage ratings for pretty much any kind of content. It allows your users to post reviews and anyone can get the reviews associated with a given slug.\nWith this plugin, admin users can view and manage very easily all the reviews from the Strapi administration dashboard. Within the dashboard, you will be able to see reviews related to content slugs as well as delete reviews.\nInstallation Once into the Strapi project root, you can install the plugin by running the following command:\nnpm install strapi-plugin-ratings Next, build the project to see the new plugin in the dashboard with the following command:\nnpm run build And that\u0026rsquo;s it! If everything runs correctly, the plugin should now be installed.\nConfiguration Now you need to enable some permissions so that the frontend can access the endpoints to post and fetch reviews.\nIn your Strapi admin dashboard, head over to Settings, then over to Roles under Users \u0026amp; Permissions Plugin.\nLet\u0026rsquo;s first setup the Public API; click on Public and hit the dropdown button of Ratings. Now check count, find, getPageSize and getStats, then hit the Save button. Below is a screenshot of a proper configuration:\nNow let\u0026rsquo;s setup the Authenticated API. Go back to Roles and click on Authenticated. Open the dropdown for Ratings and mark as checked the options create, find and getUserReview. Below is a screenshot of a proper configuration:\nWith this configuration, the frontend should now be able to make requests to get and post user reviews.\nDisplay use reviews on the frontend The plugin exposes an API to get and post reviews if you want to have fine-grained control over the workflow of your ratings system and you can check the documentation on the package page, but this plugin also comes with a purpose-built React component library that makes it super easy to get up and running without getting your hands dirty.\nThis components library is called strapi-ratings-client, fully supports typescript and it takes care of all the complexity of fetching and posting user reviews for every content ID that you pass to it.\nInstallation of Strapi Ratings Client You will need to have installed react ^17.0.2, react-dom ^17.0.2, bootstrap ^5.1.3 and @popperjs/core^2.11.2\nInside of your React project, run this command:\nnpm install strapi-ratings-client --save Usage of Strapi Ratings Client Using this library is very easy!\nThis library exports three main components:\nReviewsProvider Reviews ReviewForm And you can import them this way:\nimport { ReviewsProvider, Reviews, ReviewForm } from \u0026#34;strapi-ratings-client\u0026#34; All you have to do is wrap your App component into the ReviewsProvider component. Then you will be able to place anywhere in your app the Reviews component to render a list of user reviews for a given content ID and the ReviewForm component to render a form to allow your users to post reviews.\nFor example, this could be your index.js or main.js file:\nimport React from \u0026#39;react\u0026#39; import ReactDOM from \u0026#39;react-dom\u0026#39; // The address of your strapi backend instance const STRAPI = \u0026#34;http://localhost:1337\u0026#34; ReactDOM.render( \u0026lt;React.StrictMode\u0026gt; \u0026lt;ReviewsProvider apiURL={STRAPI}\u0026gt; \u0026lt;App /\u0026gt; \u0026lt;/ReviewsProvider\u0026gt; \u0026lt;/React.StrictMode\u0026gt;, document.getElementById(\u0026#39;root\u0026#39;) ) Where apiURL is the URL of your running Strapi application, and this property is required.\nThis way, the ratings provider will do all the magic of fetching and posting comments for you!\nThis library also exports an utility React.Context to update some of the parameters for fetching and posting reviews:\nimport { ReviewsConfigContext } from \u0026#34;strapi-ratings-client\u0026#34; This ReviewsConfigContext exposes three setter functions: setUser, setContentID and setCanPostReview.\nWith setContentID you can load the ratings for a given content and post reviews to it. It receives a single parameter of type string and must be URLized, i.e. no spaces.\nWith setUser you can set the credentials of a given user to authorize the posting of reviews. It receives a single parameter of type IUser, with the following Typescript interface:\ninterface IUser { username: string, email: string, id: string, token: string // This is a JWT } With setCanPostReview, you can enable the user to post a review on the given content. This is useful for when you only allow a user to post a review after they purchase the product.\nIt\u0026rsquo;s a little confusing but we\u0026rsquo;ll see how to use it in a component:\nconst App = () =\u0026gt; { const { setUser, setContentID, setCanPostReview } = useContext(ReviewsConfigContext) // The following data should come from Strapi Users and Permissions Plugin // for authenticated requests. const user = { username: \u0026#34;John Doe\u0026#34;, email: \u0026#34;jhohndoe@gmail.com\u0026#34;, id: 5, token: \u0026#34;this_should_be_a_JWT\u0026#34; } if (user) { setUser(user) } setContentID(\u0026#34;sample-content-1\u0026#34;) // Load reviews for this content setCanPostReview(true) // Allow this user to post a review return ( \u0026lt;\u0026gt; { !user \u0026amp;\u0026amp; \u0026lt;Login /\u0026gt; } \u0026lt;ReviewForm /\u0026gt; \u0026lt;Reviews /\u0026gt; \u0026lt;/\u0026gt; ) } And that\u0026rsquo;s it!\nAfter setting the content ID through setContentID, ReviewsProvider will start loading the reviews for the given content ID and the ReviewForm will render an input to post a user review related to the given content ID if there is a user and he’s allowed to post a review. Otherwise, it will display the message Login to post a review or nothing at all if the user is not allowed to post a review.\nHere\u0026rsquo;s how the interface looks like so far:\nThis library exports one more component: ErrorBox\nimport { ErrorBox } from \u0026#34;strapi-ratings-client\u0026#34; .It\u0026rsquo;s useful for when you\u0026rsquo;d like to display error messages when things go wrong fetching or posting reviews.\nYou can place this component wherever you want, for example in between the ReviewForm and the Reviews components.\nIf you\u0026rsquo;re wondering how this error box looks like, here‘s a screenshot:\nGeneral settings You can customize the page size, i.e. specify how many user reviews are showed at once.\nIn the Strapi admin panel, head over to Settings, then select Pagination under Ratings Plugin.\nHere you\u0026rsquo;ll find an input to set the page size, which defaults to 10.\nManage reviews Once you\u0026rsquo;ve got the plugin up an running, as users start to post reviews, you can view them from within the Ratings section of the left sidebar in the Strapi admin dashboard.\nHere you can see two tabs: one for the latest reviews and one for reviews grouped by content ID.\nIn both of them you can delete unwanted reviews.\nExample project You can find a full working example of a React App using the Strapi Ratings Client Library in this repo: https://github.com/luisguve/strapi-ratings-client-example\nConclusion With this plugin you can enable and manage user reviews for any content with little effort and even use a library of components styled with Bootstrap to display the user reviews in your frontend.\nAnd that\u0026rsquo;s it! The features are pretty basic at the moment but if there\u0026rsquo;s interest, I\u0026rsquo;m willing to work on more features as well as improve the UI/UX.\n","image":"//localhost:1313/images/post/tutorial-ratings.webp","permalink":"//localhost:1313/blogs/how-to-enable-and-manage-user-reviews-in-your-strapi-application/","tags":["Strapi","Strapi tutorials"],"title":"How To Enable And Manage User Reviews In Your Strapi Application"},{"categories":["Documentation"],"contents":"Ratings is a Strapi plugin that allows your users to post reviews.\nEnable and manage user reviews for your content very easily!\nRequirements You should have installed an instance of Strapi v4.x.x\nInstallation Run the following command in your project root:\nnpm install strapi-plugin-ratings Then, rebuild the admin dashboard using the following command\nnpm run build Configurarion For your frontend to have access to the API, enable the following permissions for Ratings from Users \u0026amp; Permissions Plugin on your project settings:\nFor public, enable: count, find, getPageSize and getStats.\nFor authenticated, enable create, find and getUserReview.\nDisplay user reviews on the frontend Reviews can be displayed in the frontend in two ways:\nUsing the React components library strapi-ratings-client (recommended) Build your custom frontend using the API endpoints, described as follows: API There are some Typescript interfaces that will help to get an idea of the data structures.\nReviews: interface IReview { id: number, createdAt: string, comment: string | null, author: IAuthor | null, score: number, } Authors: interface IAuthor { username: string, email: string, id: number } Content Stats interface IStats { averageScore: number; reviewsCount: number | null; } The following endpoints are exposed to fetch and post reviews:\nGet reviews for a content ID Method: GET\nPath: /api/ratings/reviews/:slug\nOptional query parameters: start, ignoreCount\nReturns:\n{ reviewsCount: number, averageScore: number, userReview: IReview | null, reviews: IReview[] } The parameter start indicates how many reviews to skip. This is for pagination purposes.\nThe parameter ignoreCount indicates whether or not to return the total number of reviews associated with the given slug.\nGet review stats for a content ID Method: GET\nPath: /api/ratings/reviews/:slug/stats\nReturns:\n{ averageScore: number, reviewsCount: number | null } Get the number of reviews associated with a given content ID Method: GET\nPath: /api/ratings/reviews/:slug/count\nReturns:\n{ count: number } Post a review Method: POST\nPath: /api/ratings/reviews/:slug\nAuthentication: Bearer token\nPayload:\n{ content: string } Returns:\n{ id: number } By default, every authenticated user can post reviews on any content.\nIn order to customize this behavior, e.g. allowing or disallowing a user from posting reviews, you must extend the service userCanPostReview from whithin register function in ./src/index.js. For example:\nstrapi.service(\u0026#34;plugin::ratings.review\u0026#34;).userCanPostReview = async (user, slug) =\u0026gt; { /* Here you will check whether or not the user is allowed to post a review on this content ID and return either true or false. */ return true } Notice that userCanPostReview will receive two parameters: the user from Users \u0026amp; Permissions Plugin, containing it\u0026rsquo;s id, username, confirmed, etc., and the slug, which is a string and refers to the content ID which the review is being posted on.\nIn case this function returns false, the response of the endpoint will be 403 (forbidden) with the text User cannot post a review on this content.\nGet the page size Method: GET\nPath: /api/ratings/page-size\nReturns:\n{ pageSize: number } General settings The plugin allows to set how many reviews are returned per page by going to the Pagination section under Ratings Plugin of the Settings section.\nThe default page size is 10.\nManagement of reviews Admin users are able to delete reviews from within the plugin page of the Strapi admin dashboard.\nThe plugin interface has two tabs: one for the latest reviews and one for reviews by content ID.\nRoadmap and future plans The plugin is pretty basic but it can be improved with more features and a better UI/UX. Collaborations and suggestions are very welcome.\n","image":"//localhost:1313/images/post/ratings.webp","permalink":"//localhost:1313/blogs/strapi-plugin-ratings/","tags":["Strapi","Strapi plugins"],"title":"Strapi Plugin Ratings"},{"categories":["Projects"],"contents":"ManyLMS is an e-learning platform built on top of Strapi, React Router 7, Typescript and other technologies.\nOutline The idea Platform features The stack The API The frontend Conclusion Landing Page The idea This project doesn\u0026rsquo;t necessarily bring a huge amount of innovation on the e-learning platforms that already exists, but it\u0026rsquo;s just another way of doing this type of application.\nThe main idea is to apply a JAMstack approach in this application, where the platform is a static website, and the backend is just an API that serves static content only once to build the website and just adds the dynamism that\u0026rsquo;s necessary to allow users to authenticate, create orders, confirm payments and take courses.\nIf we compare this approach to a WordPress website, we are taking out most of the overhead that implies rendering the pages everytime a user visits them. Despite that there are plugins for caching that may improve the performance, it\u0026rsquo;s still never going to be faster and more efficient than just static content served by a CDN. That\u0026rsquo;s why React Router 7 and Headless CMSs are so popular right now.\nPlatform features and user stories The following user stories illustrates the desired features the platform should have.\nAs an administrator, I want to: login in the admin panel. create categories. create courses. upload lectures. organise courses into categories. assign lectures to courses. As a student, I want to: login in the platform. view the available courses. add courses to the shopping cart. review the shopping cart. create an order. pay with credit card or paypal. view the courses i\u0026rsquo;ve purchased in my learning page. go to the course page from my learning page and watch the videos. mark lectures as seen. come back later and resume where I left. The requirements The backend requires to handle user authentication, permissions, different data structures as content types and define relationships between them. It also requires to allow uploading videos to some third party platform that supports streaming on demand.\nThe frontend is a web platform where users can register and login, view and buy courses, leave comments and reviews and take courses.\nThe API Since all of the features involve authentication, permissions and roles, and because there is no need to reinvent the wheel, I chose to use Strapi to build the backend for it\u0026rsquo;s simplicity, ease of use and great developer experience, whereas for streaming videos on demand, I chose to use Mux.com.\nThe instance of Strapi and the Postgres database it requires was deployed in the cloud hosting platform https://fly.io.\nStrapi is good for managing users, content that\u0026rsquo;s typically updated and fetched via CRUD API, and setting up relations between content types.\nThe platform needs the following content types:\nCategory to group courses Course Lecture Module to group lectures Order Student: has many courses Student-Course: stores a student\u0026rsquo;s current lecture of a course Video Strapi makes the creation of these content types and setting up relationships between them really straightforward.\nBelow are some screenshots of these content types and the relationships between them:\nThe frontend The platform where users are able to login, view, buy and view courses is a web application built with React Router 7. Among the features of this application are:\nState managed by Context API Interface styled with Bootstrap Play streaming videos with @mux/mux-player-react library Use of localStorage to save user session Below are some sample screenshots of how this app looks like\nConclusion and final thoughts While building this project, I learned:\nHow streaming on demand works and how to use a streaming provider How to statically build websites with React Router 7 and Strapi How to setup dynamic pages in React Router 7 How to process payments with Stripe and Paypal How to build custom plugins in Strapi How to publish packages to NPM Project source codes: https://github.com/luisguve/maestro-backend\nhttps://github.com/luisguve/new-lms-remix\n","image":"//localhost:1313/images/project/manylms/frontend/course_overview.png","permalink":"//localhost:1313/projects/e-learning-platform-maestro-lms/","tags":["Strapi","React","React Router 7","Typescript","Mux"],"title":"ManyLMS: E-Learning platform"},{"categories":["Projects"],"contents":"ETMday (Emprende tu Mente) is a large-scale entrepreneurship event website built on top of WordPress with the Themosis framework, featuring an interactive SVG map, real-time countdown timers, advanced search functionality, and comprehensive content management using Vue 3, Laravel Mix, and modern frontend technologies.\nOutline The project Key features The stack Frontend architecture Interactive components Conclusion Live website The project ETMday is Chile\u0026rsquo;s premier entrepreneurship event, bringing together thousands of entrepreneurs, startups, corporates, and strategic partners. The website serves as the central hub for event information, featuring speakers, activities, stands, program schedules, and an interactive event map.\nThe frontend development required implementing complex interactive features including an SVG-based interactive map with tooltips, real-time countdown timers, advanced filtering and search systems, and dynamic content displays that handle thousands of attendees and hundreds of activities.\nKey features The website includes several sophisticated features:\nInteractive SVG Map: Custom-built interactive map with clickable zones, tooltips, and dynamic content display Real-time Countdown: Event countdown timer with automatic updates and mobile optimization Advanced Search: Multi-category search across activities, speakers, stands, and content Dynamic Filtering: Complex filtering system with tabs, favorites, and downloadable resources Animated Statistics: Odometer animations for displaying event metrics Content Management: Comprehensive card components for activities, speakers, stands, and blog posts Form Handling: Multi-step forms with validation using Vee-Validate Lightbox Galleries: Image galleries with LightGallery integration Responsive Design: Fully responsive design optimized for all devices The stack The frontend stack consists of:\nVue 3.2.4: Modern reactive framework for building interactive components Laravel Mix 6.0: Asset compilation and bundling SCSS: Advanced styling with organized architecture Vee-Validate 4.15.0: Form validation with Yup schemas Axios 1.6.8: HTTP client for API requests Splide.js 4.1.4: Modern carousel and slider components LightGallery 2.8.3: Lightbox gallery functionality Odometer 0.4.8: Animated number counting Headroom.js: Header behavior on scroll jQuery 3.7.1: DOM manipulation and legacy support SweetAlert2: Modern alert dialogs GLightbox 3.3.1: Alternative lightbox solution Frontend architecture Vue components The application features a comprehensive set of Vue 3 components:\nCard Components:\ncards/activities.vue: Activity cards with favorites functionality cards/speakers.vue: Speaker cards with modal details cards/stands.vue: Stand/exhibitor cards cards/blog.vue: Blog post cards cards/shortcut.vue: Quick access shortcut cards Functional Components:\nSectionCards.vue: Main section component with tabs, filtering, and card display Search.vue: Advanced search component with multi-category results Form.vue: Dynamic form component with validation FormCalendar.vue: Calendar form component CustomFilter.vue: Reusable filter component CustomSelect.vue: Custom select dropdown Pagination.vue: Pagination component JavaScript components The application includes 17 specialized JavaScript components:\nInteractive Features:\ninteractiveMap.js: SVG map interaction with tooltips, zones, and dynamic content countdown.js: Real-time countdown timer with automatic updates odometer.js: Animated number counting with scroll triggers map.js: Map zone interactions and modal displays UI Components:\nheader.js: Header functionality and navigation headroom.js: Header hide/show on scroll accordion.js: Accordion interactions tabs.js: Tab functionality cards.js: Card interactions and modals siteModals.js: Modal management system UI.js: General UI utilities Media Components:\nvideo.js: Video player setup lightgallery.js: Lightbox gallery initialization splide.js: Carousel initialization slick.js: Legacy carousel support Utilities:\nscrollTrigger.js: Scroll-based animations imgToSvg.js: SVG image conversion utility SCSS architecture The styling follows a well-organized SCSS architecture:\nscss/ ├── abstracts/ # Variables, mixins, functions │ ├── _functions.scss │ ├── _mixins.scss │ ├── _variables.scss │ ├── _mq.scss # Media query mixins │ └── _keyframes.scss ├── base/ # Base styles and typography │ ├── _typography.scss │ ├── _container.scss │ └── _reset.scss └── components/ # Component-specific styles └── [52 component files] Key SCSS features:\nBEM methodology: Consistent naming convention Media query mixins: Using sass-mq for responsive design Modular architecture: Each component has its own SCSS file Component organization: 52 component-specific SCSS files Interactive components Interactive SVG Map The interactiveMap.js component implements a sophisticated SVG-based interactive map:\nFeatures:\nSVG Tooltips: Dynamically generated tooltips with text wrapping Zone Interactions: Clickable zones with modal displays Point Markers: Interactive points with icons and labels Dynamic Content: Content loaded based on zone/point selection Responsive Design: Optimized for mobile and desktop Technical Implementation:\nSVG namespace manipulation for tooltip creation Text wrapping algorithm for tooltip content Path generation for tooltip shapes with rounded corners Event delegation for zone and point interactions Smooth animations and transitions Real-time Countdown The countdown.js component provides a real-time countdown timer:\nFeatures:\nAutomatic Updates: Updates every second Multi-unit Display: Days, hours, minutes, and seconds Pluralization: Proper Spanish pluralization (Día/Días, Hora/Horas) Mobile Optimization: Simplified display on mobile devices End State Handling: Automatic transition when countdown ends Advanced Search System The Search.vue component implements a comprehensive search system:\nFeatures:\nMulti-category Search: Searches across activities, speakers, stands, and other content Category Tabs: Quick navigation between result categories Result Counts: Dynamic result counts per category Scroll Navigation: Smooth scrolling to category sections Carousel Display: Splide carousels for result display Loading States: Loading indicators during search Empty States: User-friendly empty state messages Dynamic Filtering System The SectionCards.vue component provides advanced filtering:\nFeatures:\nTab Navigation: Multiple filter tabs Favorites System: Save and filter favorite items Search Integration: Inline search within filters Reset Functionality: Clear all filters with one click Downloadable Resources: Download buttons for resources URL Synchronization: Filter state in URL parameters Responsive Design: Mobile accordion interface Animated Statistics The odometer.js component provides animated number counting:\nFeatures:\nScroll-triggered: Animations trigger on scroll Prefix/Suffix Support: Handles formatted numbers (e.g., \u0026ldquo;56,000+\u0026rdquo;) Mobile Optimization: Static display on mobile Smooth Animations: Odometer theme integration Development workflow The project uses Laravel Mix for asset compilation:\n// Development npm run dev // Compile assets npm run watch // Watch for changes npm run hot // Hot module replacement // Production npm run production // Optimized production build BrowserSync integration provides:\nLive reloading during development Synchronized browser testing Proxy configuration for WordPress development Performance optimizations Code splitting: Laravel Mix extracts vendor libraries Asset versioning: Automatic cache busting Image optimization: Lazy loading and responsive images Minification: Production builds are minified and optimized Tree shaking: Unused code elimination in production SVG optimization: Efficient SVG manipulation and rendering Accessibility Semantic HTML structure ARIA labels for interactive elements Keyboard navigation support Focus management in forms and modals Screen reader considerations Proper alt text for images Conclusion and final thoughts Building the ETMday frontend was an excellent opportunity to:\nMaster SVG interactions: Creating complex interactive SVG maps with dynamic tooltips and zones Implement real-time features: Building countdown timers and live updates Build advanced search: Multi-category search with filtering and categorization Handle complex state: Managing filters, favorites, and dynamic content Optimize performance: Implementing efficient animations and lazy loading Ensure scalability: Building components that handle large datasets (thousands of attendees, hundreds of activities) The project demonstrates proficiency in:\nModern JavaScript frameworks (Vue 3) SVG manipulation and interaction Real-time UI updates Advanced filtering and search systems Build tools and asset compilation (Laravel Mix, Webpack) CSS architecture and methodologies (SCSS, BEM) Component-based development Event-driven architecture The integration with WordPress/Themosis backend required careful consideration of server-side rendering, API endpoints, and content management workflows, making this a full-stack frontend implementation for a large-scale event.\nLive website: https://etmday.org/\n","image":"//localhost:1313/images/project/etm/home.png","permalink":"//localhost:1313/projects/etmday-entrepreneurship-event-website/","tags":["Vue 3","Laravel Mix","WordPress","Themosis","SCSS","JavaScript","Interactive Map","SVG"],"title":"ETMday: Entrepreneurship Event Website"},{"categories":["Projects"],"contents":"Chile Nativo is a travel tour website for Patagonia experiences, built on top of WordPress with the Themosis framework, featuring a modern frontend implementation based on a Figma design using Vue 3, Laravel Mix, and a comprehensive SCSS architecture.\nOutline The project Design implementation The stack Frontend architecture Key features Conclusion Live website The project Chile Nativo is a travel company specializing in Patagonia tours, offering experiences in destinations like Torres del Paine, Tierra del Fuego, and Isla Navarino. The website serves as the primary platform for showcasing tours, managing bookings, and providing information about their travel experiences.\nThe frontend development was based on a comprehensive Figma design, requiring pixel-perfect implementation of complex UI components, interactive forms, filtering systems, and responsive layouts that work seamlessly across all devices.\nDesign implementation The entire frontend was built from a detailed Figma design, ensuring:\nPixel-perfect accuracy: Matching the design specifications precisely Responsive design: Implementing breakpoints and mobile-first approach Component consistency: Maintaining design system patterns throughout Interactive elements: Translating static designs into dynamic, interactive components Animation and transitions: Implementing smooth user experience enhancements The stack The frontend stack consists of:\nVue 3.2.4: Modern reactive framework for building interactive components Laravel Mix 6.0: Asset compilation and bundling SCSS: Advanced styling with a well-organized architecture Pinia 2.3.1: State management for Vue applications Vee-Validate 4.15.0: Form validation with Yup schemas Axios 1.6.8: HTTP client for API requests Splide.js 4.1.4: Modern carousel and slider components Headroom.js: Header behavior on scroll Plyr 3.7.8: Video player implementation SweetAlert2: Modern alert dialogs jQuery 3.7.1: Legacy support and DOM manipulation utilities Frontend architecture Vue components The application features a comprehensive set of Vue 3 components organized by functionality:\nFiltering and Search Components:\nToursFilter.vue: Advanced tour filtering with multiple criteria TourDatesFilter.vue: Date-based filtering for tour availability ToursFilterDropdown.vue \u0026amp; ToursFilterDropdownMobile.vue: Responsive filter dropdowns TestimonialsFilter.vue: Filtering system for customer testimonials NewsFilter.vue: Blog and news filtering SearchResults.vue: Search results display with pagination Form Components:\nPersonalizedTripForm.vue: Multi-step form for custom trip requests with validation ContactFormSimple.vue: Contact form with reCAPTCHA integration FormHelp.vue: Help center form FormGiftCard.vue: Gift card purchase form FormCareers.vue: Job application form NewsletterForm.vue: Newsletter subscription Card Components:\nTour.vue \u0026amp; TourLoading.vue: Tour card display with loading states TourDate.vue \u0026amp; TourDateLoading.vue: Tour date selection cards Testimonial.vue \u0026amp; TestimonialLoading.vue: Customer testimonial cards Blog.vue \u0026amp; BlogLoading.vue: Blog post cards Team.vue \u0026amp; TeamLoading.vue: Team member cards ResourceCard.vue \u0026amp; ResourceLoading.vue: Resource display cards Utility Components:\nPagination.vue: Reusable pagination component Select.vue: Custom select dropdown with search Loader.vue \u0026amp; LoaderFullScreen.vue: Loading indicators EmptyState.vue: Empty state displays ContentResources.vue: Resource content management TeamTabsFilter.vue: Tabbed team member filtering SCSS architecture The styling follows a well-organized SCSS architecture:\nscss/ ├── abstracts/ # Variables, mixins, functions │ ├── _functions.scss │ ├── _mixins.scss │ ├── _variables.scss │ ├── _mq.scss # Media query mixins │ └── _keyframes.scss ├── base/ # Base styles and typography │ ├── _typography.scss │ ├── _colors.scss │ ├── _fonts.scss │ └── _reset.scss └── components/ # Component-specific styles └── [125 component files] Key SCSS features:\nBEM methodology: Consistent naming convention throughout Media query mixins: Using sass-mq for responsive design Modular architecture: Each component has its own SCSS file Abstract layer: Reusable variables, mixins, and functions Vue transitions: Custom transition styles for Vue components JavaScript architecture The JavaScript is organized into two main entry points:\nMain application (app.js):\nInitializes core application functionality Sets up jQuery plugins and utilities Handles legacy browser support Vue application (vue/main.js):\nConfigures Vue 3 app with Pinia for state management Registers global Vue components Sets up Vee-Validate configuration Integrates third-party Vue plugins (VueTelInput, etc.) Component utilities (app/components/):\nheader.js: Header behavior and navigation footer.js: Footer functionality splide.js: Carousel initialization slick.js: Legacy carousel support accordions.js: Accordion interactions tabs.js: Tab functionality scrollTrigger.js: Scroll-based animations video.js: Video player setup sticky-sidebar.js: Sticky sidebar behavior Key features Multi-step forms The PersonalizedTripForm.vue component implements a sophisticated multi-step form with:\nStep-by-step navigation with progress indicators Form validation using Vee-Validate and Yup schemas Dynamic form fields based on user selections Phone number input with international support (VueTelInput) reCAPTCHA integration for spam protection Loading states and error handling Advanced filtering system The tour filtering system (ToursFilter.vue) provides:\nMultiple filter criteria (destination, activity type, trip type, month) Real-time filtering with URL parameter synchronization Responsive design with mobile accordion interface Custom select components with search functionality Empty states and loading indicators Integration with WordPress backend via Axios Responsive design The entire website is fully responsive with:\nMobile-first approach Breakpoint management using sass-mq Touch-friendly interactions Optimized images and assets Performance optimizations for mobile devices Performance optimizations Code splitting: Laravel Mix extracts vendor libraries Asset versioning: Automatic cache busting Image optimization: Lazy loading and responsive images Minification: Production builds are minified and optimized Tree shaking: Unused code elimination in production Accessibility Semantic HTML structure ARIA labels where appropriate Keyboard navigation support Focus management in forms Screen reader considerations Development workflow The project uses Laravel Mix for asset compilation:\n// Development npm run dev // Compile assets npm run watch // Watch for changes npm run hot // Hot module replacement // Production npm run production // Optimized production build BrowserSync integration provides:\nLive reloading during development Synchronized browser testing Proxy configuration for WordPress development Conclusion and final thoughts Building the Chile Nativo frontend from a Figma design was an excellent opportunity to:\nMaster Vue 3: Working with the Composition API, reactive systems, and modern Vue patterns Implement complex forms: Multi-step forms with validation, international phone inputs, and reCAPTCHA Build scalable architecture: Organizing 40+ Vue components and 125+ SCSS files in a maintainable structure Optimize performance: Implementing code splitting, lazy loading, and production optimizations Ensure design fidelity: Translating Figma designs into pixel-perfect implementations Handle responsive design: Creating seamless experiences across all device sizes The project demonstrates proficiency in:\nModern JavaScript frameworks (Vue 3) Build tools and asset compilation (Laravel Mix, Webpack) CSS architecture and methodologies (SCSS, BEM) Form validation and user experience Component-based development Design system implementation The integration with WordPress/Themosis backend required careful consideration of server-side rendering, API endpoints, and content management workflows, making this a full-stack frontend implementation.\nLive website: https://chilenativo.travel/\nFigma prototype: https://www.figma.com/proto/ywHPhSP1UfYUAE8eWVQv4L/Dise%C3%B1o-Desktop---Chile-Nativo?node-id=289-3912\u0026m=dev\u0026scaling=min-zoom\u0026content-scaling=fixed\u0026page-id=289%3A3911\u0026starting-point-node-id=289%3A3912\n","image":"//localhost:1313/images/project/chile-nativo/home.png","permalink":"//localhost:1313/projects/chile-nativo-patagonia-travel-website/","tags":["Vue 3","Laravel Mix","WordPress","Themosis","SCSS","JavaScript","Figma"],"title":"Chile Nativo: Patagonia Travel Website"},{"categories":["Projects"],"contents":"Rutieri is a SaaS platform built with Strapi, React Native, Typescript and other technologies.\nOutline The idea Platform features The stack The API The frontend The mobile app Conclusion Landing Page The idea Before starting to write a single line of code, it is generally a good idea to think about the problem, it\u0026rsquo;s limitations and whether or not it has already been solved by someone else (AKA competitors).\nThe problem I was looking into had to do with the way in which public and private transportation companies manage their routes, drivers and users. This process is generally carried out on paper, e.g. not digital, hence this could be problematic in case of new drivers joining the organization or in case of restricting access to data to only specific users.\nAfter a little bit of research, I could only find one platform that provides a similiar solution but for their own company.\nPlatform features and user stories The following user stories illustrates the desired features the platform should have in order to solve the aforementioned problems.\nAs an administrator user, I want to: login in the admin panel. create an organization. create routes in the organization. invite drivers and users to the organization. manage requests to join the organization. assign routes to drivers in the organization. see in real time the drivers and users currently active in the map of the different routes. As a driver, I want to: login in the mobile app. join an organization by entering the code in the search bar. see my route on the map. become visible to passengers on the road. see the passengers waiting on the road. remove my visibility and finish my run. As a passenger, I want to: login in the mobile app. join an organization by entering the code in the search bar. see the different routes of my organization in the map. search for a destination and get the available routes that pass nearby. see the drivers currently active on the routes in real time. become visible to drivers of a route. The requirements The backend requires to handle user authentication, permissions, different data structures as content types and define relations between them. It\u0026rsquo;s also necessary to synchronise passengers and drivers and view them on a map real time in the administration panel as well as in the mobile app.\nThe administration panel is a web page that fetches data from the backend as well as from the real time data provider and it\u0026rsquo;s goal is to provide a way for administrators to manage their organization and users. We\u0026rsquo;re talking about a Single Page Application built in React.\nAs for the mobile application, there isn\u0026rsquo;t a better choice nowadays than React Native and it works just fine in this case.\nThe API Since all of the features involve authentication, permissions and roles, and because there is no need to reinvent the wheel, I chose to use Strapi to build the backend for it\u0026rsquo;s simplicity, ease of use and great developer experience, whereas for realtime data, I used Firebase.\nThe instance of Strapi and the Postgres database it requires was deployed in the cloud hosting platform https://fly.io.\nStrapi is good for managing users, content that\u0026rsquo;s typically updated and fetched via CRUD API, and relations between content types.\nThe platform needs the following content types:\nOrganizations to group routes, drivers and users Routes Two user roles: drivers and users (passengers) Below are some screenshots of the overview of these content types\nAs I said before, Strapi makes the creation of these content types and the relationships between them really straightforward.\nHowever, not everything related to the API can be provided by Strapi. Some realtime features need to be addressed with other solutions, such as geolocation data in real time for drivers and users to synchronise each other, maps and the ability to search for places. Such features were implemented using Firebase, Google Maps and Google Places.\nThe frontend The platform where users are able to login as administrators and manage their organizations and users is a single page web application built in React. Among the features of this project that I think stand out are:\nState managed by Context API Interface styled with Bootstrap React Router for pages Leaflet to display the map GeoFire library to synchronise geolocation data in real time with Firebase Use of localStorage to save user session Below are some sample screenshots of how this app looks like\nThe mobile application This one is by far the most complex part of this project.\nThe project was bootstraped with Infinitered\u0026rsquo;s Ignite, which provides a great boilerplate and surely saved me of what would have been between 1-2 months of work.\nIgnite\u0026rsquo;s boilerplate includes many features out of the box, including:\nReact Native and Typescript (of course) React Navigation MobX-State-Tree for state management Expo SDK for developer experience AsyncStorage for persistence apisauce as REST client And some other libraries and features that make React Native apps super powerful and a joy to work on.\nIt consists of three screens:\nWelcome screen Login screen Map screen In the welcome screen, users are able to go to the login screen if not logged in. Otherwise, if they\u0026rsquo;re in an organisation, it shows their role and org\u0026rsquo;s information, and if they\u0026rsquo;re not, they are able to enter the organisation code and request to join as driver or as passenger.\nWelcome screens Login screens If the user is a driver in an organisation, the welcome screen also shows the route assigned to them. By tapping on it, it takes them to the map, where they can see themselves and start the tour, becoming visible to passengers on the road but being able to see passengers on the road as well.\nDrivers can finish the tour at any time by pressing the button stop.\nIf the user is a passenger in an organisation, the welcome screen shows the different routes available in the organisation. By tapping on them, they are taken to the map where they can see themselves, the route and the drivers on the road.\nPassengers are able to navigate between the available routes and search for the location they want to go to by using the search bar at the top of the map screen, filtering out the routes that pass nearby (less than 200 meters), if there are. Google Places API and turf library work together in this search process.\nPassengers become visible to drivers on the road by pressing the button wait and if they press the button again, they stop waiting and are removed from the driver\u0026rsquo;s map.\nMap screens The start/wait and finish buttons dispatch actions that update their location in firebase, so that passengers are able to see the bus on the map as it moves in real time and viceversa.\nAs for the state management, the project consists of two models and three stores from Mobx-State-Tree library: User and Route models, user-status, route-store and root-store stores.\nUser model Located in /app/models/user/user.ts\nconst OrganizationModel = types.model({ name: types.string, code: types.string, id: types.identifierNumber, drivers: types.number, rutas: types.array(RouteModel) }) const UserModel = types .model(\u0026#34;User\u0026#34;) .props({ id: types.identifierNumber, username: types.string, email: types.string, token: types.string, role: types.union(types.literal(\u0026#34;passenger\u0026#34;), types.literal(\u0026#34;driver\u0026#34;)), ruta: types.maybeNull(RouteModel), organization: types.maybeNull(OrganizationModel), pending_request: types.maybeNull(OrganizationModel), }) Route model Located in /app/models/route/route.ts\nThis model follows the GeoJSON format for routes.\nconst RouteModel = types .model(\u0026#34;Ruta\u0026#34;) .props({ id: types.identifierNumber, name: types.string, latlong: types.maybeNull(types.model({ lat: types.number, longt: types.number })), coords: types.model({ type: FeatureTypes, features: types.array(types.model({ type: types.string, geometry: types.model({ type: types.string, coordinates: types.union(types.array(types.number), types.array(types.array(types.number))) }), properties: types.model({ name: types.string }) })) }) }) user-status store Located in /app/models/user-status/user-status.ts\nThis store is responsible for managing the state of the user. It stores the user once it\u0026rsquo;s logged in and removes it when the user logs out. It also has some views to get the user key for firebase purposes, get the role and get the route in case of a driver.\nThis store has some methods that get the user location from the device\u0026rsquo;s GPS, displays the user icon on the map and sends it to firebase.\nconst UserStatusModel = types .model(\u0026#34;UserStatus\u0026#34;) .extend(withEnvironment) .props({ user: types.maybeNull(UserModel), location: types.maybeNull( types.model({latitude: types.number, longitude: types.number}) ), visibility: types.maybeNull(types.number) }) route-store store Located in /app/models/route-store/route-store.ts\nThis store is responsible for managing the state of the available routes. It stores the routes, drivers and passengers on the different routes. It also has some view methods to filter the routes that pass nearby a destination specified by the user, get passengers waiting on a given route and get drivers active in a specific route.\nThis store initializes a GeoQuery from Geofire library and listens for events to set, update and remove drivers and passengers from the map as they move.\nconst RouteStoreModel = types .model(\u0026#34;RouteStore\u0026#34;) .props({ routes: types.array(RouteModel), passengers: types.map(types.model({ key: types.identifier, location: types.array(types.number) })), drivers: types.map(types.model({ key: types.identifier, location: types.array(types.number) })), destinationAddress: types.maybeNull(types.model({ name: types.string, coords: types.array(types.number) })) }) Conclusion and final thoughts Using a CMS as the backend can make the development a lot faster than building the API from scratch and with Strapi this is specially true. On the other hand, Strapi doesn\u0026rsquo;t really make a good fit for real time applications, therefore, Firebase is the way to go in this case.\nAs of the client side, React always works very good for pretty much any kind of application, and because React Native uses React under the hood, it is so convenient for us React developers and ir works pretty good for almost any kind of application as well.\nHowever, one thing that I didn\u0026rsquo;t mention in this post was the use of Typescript; I find this quote by Brice Wilson pretty good to point out the whole purpose and motivation to learn and use (well) this powerful language and tool ecosystem:\n\u0026ldquo;You won\u0026rsquo;t have to wait for a frustrated user to report the error. All of this means that you provide value to your users faster, and that\u0026rsquo;s really what it\u0026rsquo;s all about.\u0026rdquo;\nAll in all, I got a lot of learning by building this project, both in languages/frameworks used and production stuff such as infrastructure, cloud hosting and cloud-based APIs.\nProject landing page: https://rutieri.netlify.app\n","image":"//localhost:1313/images/project/rutieri/landing/homepage.webp","permalink":"//localhost:1313/projects/saas-platform-rutieri/","tags":["Strapi","React Native","React","Typescript","Firebase"],"title":"SaaS platform: Rutieri"},{"categories":["Tutorial"],"contents":"Enable comments in a Strapi application and display them in the frontend with React\nOutline Introduction Prerequisites What is Strapi Comment Manager? Installation Configuration Display comments on the frontend Installation of Strapi Comments Client Usage of Strapi Comments Client Plugin settings Manage comments Full source code of the frontend Conclusion Introduction A comment system comes in very handy for pretty much any kind of website. In the JAMstack ecosystem, while it\u0026rsquo;s ok to rely on third party solutions hosted on their own platform such as Disqus to enable comments, you usually want to keep your content and all the stuff related to it in the same admin dashboard.\nIn this article, I\u0026rsquo;ll show you how to enable and manage comments for your content very easily using the Comment Manager plugin, and display them in your frontend application.\nPrerequisites You should have a basic understanding of the following.\nBasic knowledge of JavaScript Basic knowledge of React (OPTIONAL) Basic understanding of Strapi - get started here. Your Strapi V4 project setup What is Strapi Comment Manager? Strapi Comment Manager is a plugin that enables comments for pretty much any kind of content. It allows your users to post comments and anyone can get the comments associated with a given slug.\nWith this plugin, admin users can view and manage very easily all the comments from the Strapi administration dashboard. Within the dashboard, you will be able to delete comments and subcomments and leave replies on comments.\nInstallation Once into the Strapi project root, you can install the plugin by running the following command:\nnpm install strapi-plugin-comment-manager Next, build the project to see the new plugin in the dashboard with the following command:\nnpm run build And that\u0026rsquo;s it! If everything runs correctly, the plugin should now be installed.\nConfiguration Now you need to enable some permissions so that the frontend can access the endpoints to post and fetch comments.\nIn your Strapi admin dashboard, head over to Settings, then over to Roles under Users \u0026amp; Permissions Plugin.\nLet\u0026rsquo;s first setup the Public API; click on Public and hit the dropdown button of Comment Manager. Now check count, find and getPageSize, then hit the Save button. Below is a screenshot of a proper configuration:\nNow let\u0026rsquo;s setup the Authenticated API. Go back to Roles and click on Authenticated. Open the dropdown for Comment Manager and mark as checked the option create on both Comment and Subcomment. Below is a screenshot of a proper configuration:\nWith this configuration, the frontend should now be able to make requests to get and post comments.\nDisplay comments on the frontend The plugin exposes an API to get and post comments if you want to have fine-grained control over the workflow of your comments system and you can check the documentation on the package page, but this plugin also comes with a purpose-built React component library that makes it super easy to get up and running without getting your hands dirty.\nThis components library is called strapi-comments-client, fully supports typescript and it handles for you all of the complexity of fetching and posting comments and subcomments for every content ID that you pass to it.\nInstallation of Strapi Comments Client You will need to have installed react ^17.0.2, react-dom ^17.0.2 and react-router-dom ^5.2.0.\nInside of your React project, run this command:\nnpm install strapi-comments-client --save Usage of Strapi Comments Client Using this library is very easy!\nThis library exports three main components:\nCommentsProvider Comments CommentForm And you can import them this way:\nimport { CommentsProvider, Comments, CommentForm } from \u0026#34;strapi-comments-client\u0026#34; All you have to do is wrap your App component into the CommentsProvider component. Then you will be able to place anywhere in your app the Comments component to render a list of comments for a given content ID and the CommentForm component to render a form to post comments.\nFor example, this could be your index.js or main.js file:\nimport React from \u0026#39;react\u0026#39; import ReactDOM from \u0026#39;react-dom\u0026#39; // The address of your strapi backend instance const STRAPI = \u0026#34;http://localhost:1337\u0026#34; ReactDOM.render( \u0026lt;React.StrictMode\u0026gt; \u0026lt;CommentsProvider apiURL={STRAPI}\u0026gt; \u0026lt;App /\u0026gt; \u0026lt;/CommentsProvider\u0026gt; \u0026lt;/React.StrictMode\u0026gt;, document.getElementById(\u0026#39;root\u0026#39;) ) Where apiURL is the URL of your running Strapi application, and this property is required.\nThis way, the comments provider will do all the magic of fetching and posting comments for you!\nThis library also exports an utility React.Context to update some of the parameters for fetching and posting comments:\nimport { CommentsConfigContext } from \u0026#34;strapi-comments-client\u0026#34; This CommentsConfigContext exposes two setter functions: setUser and setContentID\nWith setContentID you can load the comments for a given content and post comments to it. It receives a single parameter of type string and must be URLized, i.e. no spaces.\nWith setUser you can set the credentials of a given user to authorize the posting of comments. It receives a single parameter of type IUser, with the following Typescript interface:\ninterface IUser { username: string, email: string, id: string, token: string // This is a JWT } It\u0026rsquo;s a little confusing but we\u0026rsquo;ll see how to use it in a component:\nconst App = () =\u0026gt; { const { setUser, setContentID } = useContext(CommentsConfigContext) // The following data should come from Strapi Users and Permissions Plugin // for authenticated requests const user = { username: \u0026#34;John Doe\u0026#34;, email: \u0026#34;jhohndoe@gmail.com\u0026#34;, id: 5, token: \u0026#34;this_should_be_a_JWT\u0026#34; } if (user) { setUser(user) } setContentID(\u0026#34;sample-content-1\u0026#34;) // Load comments for this content return ( \u0026lt;\u0026gt; { !user \u0026amp;\u0026amp; \u0026lt;Login /\u0026gt; } \u0026lt;CommentForm /\u0026gt; \u0026lt;Comments /\u0026gt; \u0026lt;/\u0026gt; ) } And that\u0026rsquo;s it!\nAfter setting the content ID through setContentID, CommentsProvider will start loading the comments for the given content ID and the CommentForm will render an input to post comments related to the given content ID if there is a user. Otherwise, it will display the message Login to post a comment.\nHere\u0026rsquo;s how the interface looks like so far:\nThere\u0026rsquo;s also a button to Leave a reply, which will open a form to post a subcomment associated with the parent comment.\nThis library exports one more component: ErrorBox\nimport { ErrorBox } from \u0026#34;strapi-comments-client\u0026#34; .It\u0026rsquo;s useful if you\u0026rsquo;d like to display error messages when things go wrong fetching or posting comments.\nYou can place this component wherever you want, for example in between the CommentForm and the Comments components.\nIf you\u0026rsquo;re wondering how this error box looks like, here you have a sample:\nGeneral settings You can customize the page size, i.e. specify how many comments are returned at once.\nIn the Strapi admin panel, head over to Settings, then select Pagination under Comment Manager Plugin.\nHere you\u0026rsquo;ll find an input to set the page size, which defaults to 10.\nManage comments Once you\u0026rsquo;ve got the plugin up an running, as users start to post comments, you can manage and reply to them as admin from the Comment Manager section of the left sidebar in the Strapi admin dashboard.\nHere you can see two tabs: one for the latest comments and one for comments grouped by content ID.\nIn both of them you can delete comments and subcomments as well as leave replies.\nExample project You can find a full working example of a React App using the Strapi Comments Client Library in this repo\nConclusion With this plugin you can enable and manage comments for any content with little effort and even use a component library to display the comments in your frontend application made with React.\nAnd that\u0026rsquo;s it! The features are pretty basic at the moment but if there\u0026rsquo;s interest, I\u0026rsquo;m willing to work on more features as well as improve the UI/UX.\n","image":"//localhost:1313/images/post/strapilogo.jpg","permalink":"//localhost:1313/blogs/how-to-enable-and-manage-comments-in-your-strapi-application/","tags":["Strapi","Strapi tutorials"],"title":"How To Enable And Manage Comments In Your Strapi Application."},{"categories":["Documentation"],"contents":"Comment Manager is a Strapi plugin to allow your users to post comments.\nWith this plugin you can enable and manage comments for your content very easily!\nRequirements You should have installed an instance of Strapi v4.x.x\nInstallation Run the following command in your project root:\nnpm install strapi-plugin-comment-manager Configurarion For your frontend to have access to the API, enable the following permissions for Comment Manager from Users \u0026amp; Permissions Plugin on your project settings:\nFor public, enable: count, find and getPageSize.\nFor authenticated, enable create on both Comment and Subcomment.\nDisplay comments on the frontend Comments can be displayed in the frontend in two ways:\nUsing the React components library strapi-comments-client (recommended) Build your custom frontend using the API API There are some Typescript interfaces that will help to get an idea of the data structures.\nComments: interface IComment { id: string, from_admin: boolean, createdAt: string, content: string, author: IAuthor | null, subcomments?: ISubcomment[] } Subcomments: interface ISubcomment { id: string, from_admin: boolean, createdAt: string, content: string, author: IAuthor | null, } Authors: IAuthor { username: string, email: string, id: string } The following endpoints are exposed to fetch and post comments and subcomments:\nGet comments for a content ID Method: GET\nPath: /api/comment-manager/comments/:slug\nOptional query parameters: start, ignoreCount\nReturns:\n{ commentsCount?: Number, comments: IComment[] } The parameter start indicates how many comments to skip. This is for pagination purposes.\nThe parameter ignoreCount indicates whether or not to return the total number of comments associated with the given slug.\nGet the number of comments associated with a given content ID Method: GET\nPath: /api/comment-manager/comments/:slug/count\nReturns:\n{ count: Number } Post a comment Method: POST\nPath: /api/comment-manager/comments/:slug\nAuthentication: Bearer token\nPayload:\n{ content: string } Returns:\n{ id: Number } Post a subcomment Method: POST\nPath: /api/comment-manager/subcomments/:parent-id\nAuthentication: Bearer token\nPayload:\n{ content: string } Returns:\n{ id: Number } Get the page size Method: GET\nPath: /api/comment-manager/page-size\nReturns:\n{ pageSize: Number } General settings The plugin allows to set how many comments are returned per page by going to the Pagination section under Comment Manager Plugin on the Settings section.\nThe default page size is 10.\nManagement of comments Admin users are able to delete comments and subcomments as well as leave replies as admins from within the plugin page of the Strapi admin dashboard.\nThe plugin interface has two tabs: one for the latest comments and one for comments by content ID.\nRoadmap and future plans The plugin is pretty basic but it can be improved with more features and a better UI/UX. Collaborations and suggestions are very welcome.\n","image":"//localhost:1313/images/post/strapilogo.jpg","permalink":"//localhost:1313/blogs/strapi-plugin-comment-manager/","tags":["Strapi","Strapi plugins"],"title":"Strapi Plugin Comment Manager"},{"categories":["Projects"],"contents":"In this post I’m going to share my experience on building a SaaS using the headless CMS Strapi as the Backend, React Native and other technologies.\nOutline Introduction What is SaaS? The problem What is Strapi? Developing features in Strapi The frontend: How to get content Conclusion Landing Page Introduction Very often, developers, product and project managers, testers and pretty much the entire team share their ideas to decide what language and which framework they\u0026rsquo;ll use to build their next project. Some considerations must be taken into account, from which in my opinion there are three that are the most important:\nDeveloper experience and ease of use Does the language and framework chosen provide a good developer experience? Is the langauge the same for the backend and frontend?\nDeadlines Is there a deadline to finish the project? if so, there is a good chance to finish the project on time if the team chooses the language they have more experience in.\nMaintainability As there will be usually more than one person working on the same part at the same time, if everything is kept organised, the whole development process will be frictionless.\nWith that in mind, developers and project managers will have a better insight on which language/framework to use.\nOther aspects should also be considered such as what the data structure will look like.\nIn my case, as it is usual, the backend of my project needs a database for users and their roles among other entities and their relations and a dashboard to allow admins to manage the data, and I was lucky to find out Strapi, as it includes a lot of these features out of the box with one single line of command to get started.\nWhat is SaaS? SaaS stands for Software-as-a-Service and it just means that a software is provided as a service in the cloud and it gives a solution to a specific problem, for which the users are willing to pay either monthly or annual subscription.\nThe problem Before starting to write a single line of code, it is generally a good idea to think about the problem, it\u0026rsquo;s limitations and whether or not it has already been solved by someone else (AKA competitors).\nThe problem I was looking into had to do with the way in which public and private transportation companies manage their routes, drivers and users. After a little bit of research, I could only find one platform that provides a similiar solution but for their own company.\nSo the platform I built needed the following content types:\nOrganizations to group routes, drivers and users Routes Two user roles: drivers and users (passengers) As I said before, Strapi makes the creation of these content types and the relationships between them really easy, but let\u0026rsquo;s first see what is Strapi and how it turns the API development into a satisfactory and fun experience.\nWhat is Strapi? Strapi is an open source headless CMS that allows developers to build complete RESTful APIs in just a couple of days instead of months. It includes a lot of useful features as plugins out of the box. Users and Roles management, Media library and an interface to create, view, edit and delete content are just some of them.\nRegarding the API, how does it makes the development faster?\nFirst of all, it enforces a specific folder structure, which helps to keep everything well organised and clean.\nSecondly, all database schemas are generated automatically and queries are made in JSON format, which really saves a lot of time.\nLastly, we can add more features to our Strapi application very easily via plugins from the marketplace.\nIt\u0026rsquo;s also worth noting that Strapi is a self-hosted CMS, which means that we can host it in whatever cloud platform we want, as well as test it locally in our computers before deploying it to the cloud.\nDeveloping features in Strapi Creating and configuring endpoints in Strapi is as straightforward as declaring a JSON in a single file:\nCreating controllers is straightforward as well:\nEvery controller gets all the data related to the request in the ctx parameter and it\u0026rsquo;s also used to send the response. This keeps everything in one place and really helps to improve the readability.\nOnce the API endpoints are defined, the next step is to enable the permissions for the specific user roles to have access to these endpoints:\nThe frontend: how to get content Since Strapi is a headless CMS, it\u0026rsquo;ll only provide content through the API. That means that the content can be consumed from anywhere. In our case, this content will be used in two applications: one for the organization owners and one for the users and drivers.\nThe application for the organization owners is a dashboard where administrators can create organizations, routes, accept drivers and users in the organization and assign routes to drivers. This is just a React Application:\nThe application for drivers and users is a mobile application built in React Native. Firebase was used to synchronise geolocation data in real time between drivers and users and display this information in a Map from Google Maps:\nConclusion Using a CMS as the backend can make the development a lot faster than building the API from scratch and with Strapi this is specially true. Furthermore, this becomes more important when building a brand-new product, as it\u0026rsquo;s usually recommended to launch as soon as possible to gather feedback from the users and validate the idea.\nProject landing page: https://rutieri.netlify.app\n","image":"//localhost:1313/images/post/03.webp","permalink":"//localhost:1313/blogs/how-i-built-a-saas-on-top-of-strapi-and-why-you-should-too/","tags":["Strapi","React Native","Typescript"],"title":"How I Built A SaaS On Top Of Strapi, And Why You Should Too"},{"categories":["Tutorial"],"contents":"Enable User Reviews in a Strapi application and display them in the frontend with React\nOutline Introduction Prerequisites What is Strapi Ratings? Installation Configuration Display user reviews on the frontend Plugin settings Manage user reviews Full source code of the frontend Conclusion Introduction Ratings systems have become a crucial part of any website with ecommerce capabilites, as they allow the users to post reviews on the items they purchase and publish their opinion to the public. A couple of reviews can make the difference between pressing the “Buy” button and moving on to the next website in the Google search results.\nIn this article, I\u0026rsquo;ll show you how to enable and manage user reviews for your content very easily using the Ratings plugin, and display them in your frontend application.\nPrerequisites First of all, you need to have a basic understanding of the following.\nBasic knowledge of JavaScript Basic knowledge of React (OPTIONAL) Basic understanding of Strapi - get started here. Your Strapi V4 project setup What is Strapi Ratings? Strapi Ratings is a plugin that gives your Strapi application the ability to manage ratings for pretty much any kind of content. It allows your users to post reviews and anyone can get the reviews associated with a given slug.\nWith this plugin, admin users can view and manage very easily all the reviews from the Strapi administration dashboard. Within the dashboard, you will be able to see reviews related to content slugs as well as delete reviews.\nInstallation Once into the Strapi project root, you can install the plugin by running the following command:\nnpm install strapi-plugin-ratings Next, build the project to see the new plugin in the dashboard with the following command:\nnpm run build And that\u0026rsquo;s it! If everything runs correctly, the plugin should now be installed.\nConfiguration Now you need to enable some permissions so that the frontend can access the endpoints to post and fetch reviews.\nIn your Strapi admin dashboard, head over to Settings, then over to Roles under Users \u0026amp; Permissions Plugin.\nLet\u0026rsquo;s first setup the Public API; click on Public and hit the dropdown button of Ratings. Now check count, find, getPageSize and getStats, then hit the Save button. Below is a screenshot of a proper configuration:\nNow let\u0026rsquo;s setup the Authenticated API. Go back to Roles and click on Authenticated. Open the dropdown for Ratings and mark as checked the options create, find and getUserReview. Below is a screenshot of a proper configuration:\nWith this configuration, the frontend should now be able to make requests to get and post user reviews.\nDisplay use reviews on the frontend The plugin exposes an API to get and post reviews if you want to have fine-grained control over the workflow of your ratings system and you can check the documentation on the package page, but this plugin also comes with a purpose-built React component library that makes it super easy to get up and running without getting your hands dirty.\nThis components library is called strapi-ratings-client, fully supports typescript and it takes care of all the complexity of fetching and posting user reviews for every content ID that you pass to it.\nInstallation of Strapi Ratings Client You will need to have installed react ^17.0.2, react-dom ^17.0.2, bootstrap ^5.1.3 and @popperjs/core^2.11.2\nInside of your React project, run this command:\nnpm install strapi-ratings-client --save Usage of Strapi Ratings Client Using this library is very easy!\nThis library exports three main components:\nReviewsProvider Reviews ReviewForm And you can import them this way:\nimport { ReviewsProvider, Reviews, ReviewForm } from \u0026#34;strapi-ratings-client\u0026#34; All you have to do is wrap your App component into the ReviewsProvider component. Then you will be able to place anywhere in your app the Reviews component to render a list of user reviews for a given content ID and the ReviewForm component to render a form to allow your users to post reviews.\nFor example, this could be your index.js or main.js file:\nimport React from \u0026#39;react\u0026#39; import ReactDOM from \u0026#39;react-dom\u0026#39; // The address of your strapi backend instance const STRAPI = \u0026#34;http://localhost:1337\u0026#34; ReactDOM.render( \u0026lt;React.StrictMode\u0026gt; \u0026lt;ReviewsProvider apiURL={STRAPI}\u0026gt; \u0026lt;App /\u0026gt; \u0026lt;/ReviewsProvider\u0026gt; \u0026lt;/React.StrictMode\u0026gt;, document.getElementById(\u0026#39;root\u0026#39;) ) Where apiURL is the URL of your running Strapi application, and this property is required.\nThis way, the ratings provider will do all the magic of fetching and posting comments for you!\nThis library also exports an utility React.Context to update some of the parameters for fetching and posting reviews:\nimport { ReviewsConfigContext } from \u0026#34;strapi-ratings-client\u0026#34; This ReviewsConfigContext exposes three setter functions: setUser, setContentID and setCanPostReview.\nWith setContentID you can load the ratings for a given content and post reviews to it. It receives a single parameter of type string and must be URLized, i.e. no spaces.\nWith setUser you can set the credentials of a given user to authorize the posting of reviews. It receives a single parameter of type IUser, with the following Typescript interface:\ninterface IUser { username: string, email: string, id: string, token: string // This is a JWT } With setCanPostReview, you can enable the user to post a review on the given content. This is useful for when you only allow a user to post a review after they purchase the product.\nIt\u0026rsquo;s a little confusing but we\u0026rsquo;ll see how to use it in a component:\nconst App = () =\u0026gt; { const { setUser, setContentID, setCanPostReview } = useContext(ReviewsConfigContext) // The following data should come from Strapi Users and Permissions Plugin // for authenticated requests. const user = { username: \u0026#34;John Doe\u0026#34;, email: \u0026#34;jhohndoe@gmail.com\u0026#34;, id: 5, token: \u0026#34;this_should_be_a_JWT\u0026#34; } if (user) { setUser(user) } setContentID(\u0026#34;sample-content-1\u0026#34;) // Load reviews for this content setCanPostReview(true) // Allow this user to post a review return ( \u0026lt;\u0026gt; { !user \u0026amp;\u0026amp; \u0026lt;Login /\u0026gt; } \u0026lt;ReviewForm /\u0026gt; \u0026lt;Reviews /\u0026gt; \u0026lt;/\u0026gt; ) } And that\u0026rsquo;s it!\nAfter setting the content ID through setContentID, ReviewsProvider will start loading the reviews for the given content ID and the ReviewForm will render an input to post a user review related to the given content ID if there is a user and he’s allowed to post a review. Otherwise, it will display the message Login to post a review or nothing at all if the user is not allowed to post a review.\nHere\u0026rsquo;s how the interface looks like so far:\nThis library exports one more component: ErrorBox\nimport { ErrorBox } from \u0026#34;strapi-ratings-client\u0026#34; .It\u0026rsquo;s useful for when you\u0026rsquo;d like to display error messages when things go wrong fetching or posting reviews.\nYou can place this component wherever you want, for example in between the ReviewForm and the Reviews components.\nIf you\u0026rsquo;re wondering how this error box looks like, here‘s a screenshot:\nGeneral settings You can customize the page size, i.e. specify how many user reviews are showed at once.\nIn the Strapi admin panel, head over to Settings, then select Pagination under Ratings Plugin.\nHere you\u0026rsquo;ll find an input to set the page size, which defaults to 10.\nManage reviews Once you\u0026rsquo;ve got the plugin up an running, as users start to post reviews, you can view them from within the Ratings section of the left sidebar in the Strapi admin dashboard.\nHere you can see two tabs: one for the latest reviews and one for reviews grouped by content ID.\nIn both of them you can delete unwanted reviews.\nExample project You can find a full working example of a React App using the Strapi Ratings Client Library in this repo: https://github.com/luisguve/strapi-ratings-client-example\nConclusion With this plugin you can enable and manage user reviews for any content with little effort and even use a library of components styled with Bootstrap to display the user reviews in your frontend.\nAnd that\u0026rsquo;s it! The features are pretty basic at the moment but if there\u0026rsquo;s interest, I\u0026rsquo;m willing to work on more features as well as improve the UI/UX.\n","image":"//localhost:1313/images/post/tutorial-ratings.webp","permalink":"//localhost:1313/blogs/how-to-enable-and-manage-user-reviews-in-your-strapi-application/","tags":["Strapi","Strapi tutorials"],"title":"How To Enable And Manage User Reviews In Your Strapi Application"},{"categories":["Documentation"],"contents":"Ratings is a Strapi plugin that allows your users to post reviews.\nEnable and manage user reviews for your content very easily!\nRequirements You should have installed an instance of Strapi v4.x.x\nInstallation Run the following command in your project root:\nnpm install strapi-plugin-ratings Then, rebuild the admin dashboard using the following command\nnpm run build Configurarion For your frontend to have access to the API, enable the following permissions for Ratings from Users \u0026amp; Permissions Plugin on your project settings:\nFor public, enable: count, find, getPageSize and getStats.\nFor authenticated, enable create, find and getUserReview.\nDisplay user reviews on the frontend Reviews can be displayed in the frontend in two ways:\nUsing the React components library strapi-ratings-client (recommended) Build your custom frontend using the API endpoints, described as follows: API There are some Typescript interfaces that will help to get an idea of the data structures.\nReviews: interface IReview { id: number, createdAt: string, comment: string | null, author: IAuthor | null, score: number, } Authors: interface IAuthor { username: string, email: string, id: number } Content Stats interface IStats { averageScore: number; reviewsCount: number | null; } The following endpoints are exposed to fetch and post reviews:\nGet reviews for a content ID Method: GET\nPath: /api/ratings/reviews/:slug\nOptional query parameters: start, ignoreCount\nReturns:\n{ reviewsCount: number, averageScore: number, userReview: IReview | null, reviews: IReview[] } The parameter start indicates how many reviews to skip. This is for pagination purposes.\nThe parameter ignoreCount indicates whether or not to return the total number of reviews associated with the given slug.\nGet review stats for a content ID Method: GET\nPath: /api/ratings/reviews/:slug/stats\nReturns:\n{ averageScore: number, reviewsCount: number | null } Get the number of reviews associated with a given content ID Method: GET\nPath: /api/ratings/reviews/:slug/count\nReturns:\n{ count: number } Post a review Method: POST\nPath: /api/ratings/reviews/:slug\nAuthentication: Bearer token\nPayload:\n{ content: string } Returns:\n{ id: number } By default, every authenticated user can post reviews on any content.\nIn order to customize this behavior, e.g. allowing or disallowing a user from posting reviews, you must extend the service userCanPostReview from whithin register function in ./src/index.js. For example:\nstrapi.service(\u0026#34;plugin::ratings.review\u0026#34;).userCanPostReview = async (user, slug) =\u0026gt; { /* Here you will check whether or not the user is allowed to post a review on this content ID and return either true or false. */ return true } Notice that userCanPostReview will receive two parameters: the user from Users \u0026amp; Permissions Plugin, containing it\u0026rsquo;s id, username, confirmed, etc., and the slug, which is a string and refers to the content ID which the review is being posted on.\nIn case this function returns false, the response of the endpoint will be 403 (forbidden) with the text User cannot post a review on this content.\nGet the page size Method: GET\nPath: /api/ratings/page-size\nReturns:\n{ pageSize: number } General settings The plugin allows to set how many reviews are returned per page by going to the Pagination section under Ratings Plugin of the Settings section.\nThe default page size is 10.\nManagement of reviews Admin users are able to delete reviews from within the plugin page of the Strapi admin dashboard.\nThe plugin interface has two tabs: one for the latest reviews and one for reviews by content ID.\nRoadmap and future plans The plugin is pretty basic but it can be improved with more features and a better UI/UX. Collaborations and suggestions are very welcome.\n","image":"//localhost:1313/images/post/ratings.webp","permalink":"//localhost:1313/blogs/strapi-plugin-ratings/","tags":["Strapi","Strapi plugins"],"title":"Strapi Plugin Ratings"},{"categories":["Projects"],"contents":"ManyLMS is an e-learning platform built on top of Strapi, React Router 7, Typescript and other technologies.\nOutline The idea Platform features The stack The API The frontend Conclusion Landing Page The idea This project doesn\u0026rsquo;t necessarily bring a huge amount of innovation on the e-learning platforms that already exists, but it\u0026rsquo;s just another way of doing this type of application.\nThe main idea is to apply a JAMstack approach in this application, where the platform is a static website, and the backend is just an API that serves static content only once to build the website and just adds the dynamism that\u0026rsquo;s necessary to allow users to authenticate, create orders, confirm payments and take courses.\nIf we compare this approach to a WordPress website, we are taking out most of the overhead that implies rendering the pages everytime a user visits them. Despite that there are plugins for caching that may improve the performance, it\u0026rsquo;s still never going to be faster and more efficient than just static content served by a CDN. That\u0026rsquo;s why React Router 7 and Headless CMSs are so popular right now.\nPlatform features and user stories The following user stories illustrates the desired features the platform should have.\nAs an administrator, I want to: login in the admin panel. create categories. create courses. upload lectures. organise courses into categories. assign lectures to courses. As a student, I want to: login in the platform. view the available courses. add courses to the shopping cart. review the shopping cart. create an order. pay with credit card or paypal. view the courses i\u0026rsquo;ve purchased in my learning page. go to the course page from my learning page and watch the videos. mark lectures as seen. come back later and resume where I left. The requirements The backend requires to handle user authentication, permissions, different data structures as content types and define relationships between them. It also requires to allow uploading videos to some third party platform that supports streaming on demand.\nThe frontend is a web platform where users can register and login, view and buy courses, leave comments and reviews and take courses.\nThe API Since all of the features involve authentication, permissions and roles, and because there is no need to reinvent the wheel, I chose to use Strapi to build the backend for it\u0026rsquo;s simplicity, ease of use and great developer experience, whereas for streaming videos on demand, I chose to use Mux.com.\nThe instance of Strapi and the Postgres database it requires was deployed in the cloud hosting platform https://fly.io.\nStrapi is good for managing users, content that\u0026rsquo;s typically updated and fetched via CRUD API, and setting up relations between content types.\nThe platform needs the following content types:\nCategory to group courses Course Lecture Module to group lectures Order Student: has many courses Student-Course: stores a student\u0026rsquo;s current lecture of a course Video Strapi makes the creation of these content types and setting up relationships between them really straightforward.\nBelow are some screenshots of these content types and the relationships between them:\nThe frontend The platform where users are able to login, view, buy and view courses is a web application built with React Router 7. Among the features of this application are:\nState managed by Context API Interface styled with Bootstrap Play streaming videos with @mux/mux-player-react library Use of localStorage to save user session Below are some sample screenshots of how this app looks like\nConclusion and final thoughts While building this project, I learned:\nHow streaming on demand works and how to use a streaming provider How to statically build websites with React Router 7 and Strapi How to setup dynamic pages in React Router 7 How to process payments with Stripe and Paypal How to build custom plugins in Strapi How to publish packages to NPM Project source codes: https://github.com/luisguve/maestro-backend\nhttps://github.com/luisguve/new-lms-remix\n","image":"//localhost:1313/images/project/manylms/frontend/course_overview.png","permalink":"//localhost:1313/projects/e-learning-platform-maestro-lms/","tags":["Strapi","React","React Router 7","Typescript","Mux"],"title":"ManyLMS: E-Learning platform"},{"categories":["Projects"],"contents":"ETMday (Emprende tu Mente) is a large-scale entrepreneurship event website built on top of WordPress with the Themosis framework, featuring an interactive SVG map, real-time countdown timers, advanced search functionality, and comprehensive content management using Vue 3, Laravel Mix, and modern frontend technologies.\nOutline The project Key features The stack Frontend architecture Interactive components Conclusion Live website The project ETMday is Chile\u0026rsquo;s premier entrepreneurship event, bringing together thousands of entrepreneurs, startups, corporates, and strategic partners. The website serves as the central hub for event information, featuring speakers, activities, stands, program schedules, and an interactive event map.\nThe frontend development required implementing complex interactive features including an SVG-based interactive map with tooltips, real-time countdown timers, advanced filtering and search systems, and dynamic content displays that handle thousands of attendees and hundreds of activities.\nKey features The website includes several sophisticated features:\nInteractive SVG Map: Custom-built interactive map with clickable zones, tooltips, and dynamic content display Real-time Countdown: Event countdown timer with automatic updates and mobile optimization Advanced Search: Multi-category search across activities, speakers, stands, and content Dynamic Filtering: Complex filtering system with tabs, favorites, and downloadable resources Animated Statistics: Odometer animations for displaying event metrics Content Management: Comprehensive card components for activities, speakers, stands, and blog posts Form Handling: Multi-step forms with validation using Vee-Validate Lightbox Galleries: Image galleries with LightGallery integration Responsive Design: Fully responsive design optimized for all devices The stack The frontend stack consists of:\nVue 3.2.4: Modern reactive framework for building interactive components Laravel Mix 6.0: Asset compilation and bundling SCSS: Advanced styling with organized architecture Vee-Validate 4.15.0: Form validation with Yup schemas Axios 1.6.8: HTTP client for API requests Splide.js 4.1.4: Modern carousel and slider components LightGallery 2.8.3: Lightbox gallery functionality Odometer 0.4.8: Animated number counting Headroom.js: Header behavior on scroll jQuery 3.7.1: DOM manipulation and legacy support SweetAlert2: Modern alert dialogs GLightbox 3.3.1: Alternative lightbox solution Frontend architecture Vue components The application features a comprehensive set of Vue 3 components:\nCard Components:\ncards/activities.vue: Activity cards with favorites functionality cards/speakers.vue: Speaker cards with modal details cards/stands.vue: Stand/exhibitor cards cards/blog.vue: Blog post cards cards/shortcut.vue: Quick access shortcut cards Functional Components:\nSectionCards.vue: Main section component with tabs, filtering, and card display Search.vue: Advanced search component with multi-category results Form.vue: Dynamic form component with validation FormCalendar.vue: Calendar form component CustomFilter.vue: Reusable filter component CustomSelect.vue: Custom select dropdown Pagination.vue: Pagination component JavaScript components The application includes 17 specialized JavaScript components:\nInteractive Features:\ninteractiveMap.js: SVG map interaction with tooltips, zones, and dynamic content countdown.js: Real-time countdown timer with automatic updates odometer.js: Animated number counting with scroll triggers map.js: Map zone interactions and modal displays UI Components:\nheader.js: Header functionality and navigation headroom.js: Header hide/show on scroll accordion.js: Accordion interactions tabs.js: Tab functionality cards.js: Card interactions and modals siteModals.js: Modal management system UI.js: General UI utilities Media Components:\nvideo.js: Video player setup lightgallery.js: Lightbox gallery initialization splide.js: Carousel initialization slick.js: Legacy carousel support Utilities:\nscrollTrigger.js: Scroll-based animations imgToSvg.js: SVG image conversion utility SCSS architecture The styling follows a well-organized SCSS architecture:\nscss/ ├── abstracts/ # Variables, mixins, functions │ ├── _functions.scss │ ├── _mixins.scss │ ├── _variables.scss │ ├── _mq.scss # Media query mixins │ └── _keyframes.scss ├── base/ # Base styles and typography │ ├── _typography.scss │ ├── _container.scss │ └── _reset.scss └── components/ # Component-specific styles └── [52 component files] Key SCSS features:\nBEM methodology: Consistent naming convention Media query mixins: Using sass-mq for responsive design Modular architecture: Each component has its own SCSS file Component organization: 52 component-specific SCSS files Interactive components Interactive SVG Map The interactiveMap.js component implements a sophisticated SVG-based interactive map:\nFeatures:\nSVG Tooltips: Dynamically generated tooltips with text wrapping Zone Interactions: Clickable zones with modal displays Point Markers: Interactive points with icons and labels Dynamic Content: Content loaded based on zone/point selection Responsive Design: Optimized for mobile and desktop Technical Implementation:\nSVG namespace manipulation for tooltip creation Text wrapping algorithm for tooltip content Path generation for tooltip shapes with rounded corners Event delegation for zone and point interactions Smooth animations and transitions Real-time Countdown The countdown.js component provides a real-time countdown timer:\nFeatures:\nAutomatic Updates: Updates every second Multi-unit Display: Days, hours, minutes, and seconds Pluralization: Proper Spanish pluralization (Día/Días, Hora/Horas) Mobile Optimization: Simplified display on mobile devices End State Handling: Automatic transition when countdown ends Advanced Search System The Search.vue component implements a comprehensive search system:\nFeatures:\nMulti-category Search: Searches across activities, speakers, stands, and other content Category Tabs: Quick navigation between result categories Result Counts: Dynamic result counts per category Scroll Navigation: Smooth scrolling to category sections Carousel Display: Splide carousels for result display Loading States: Loading indicators during search Empty States: User-friendly empty state messages Dynamic Filtering System The SectionCards.vue component provides advanced filtering:\nFeatures:\nTab Navigation: Multiple filter tabs Favorites System: Save and filter favorite items Search Integration: Inline search within filters Reset Functionality: Clear all filters with one click Downloadable Resources: Download buttons for resources URL Synchronization: Filter state in URL parameters Responsive Design: Mobile accordion interface Animated Statistics The odometer.js component provides animated number counting:\nFeatures:\nScroll-triggered: Animations trigger on scroll Prefix/Suffix Support: Handles formatted numbers (e.g., \u0026ldquo;56,000+\u0026rdquo;) Mobile Optimization: Static display on mobile Smooth Animations: Odometer theme integration Development workflow The project uses Laravel Mix for asset compilation:\n// Development npm run dev // Compile assets npm run watch // Watch for changes npm run hot // Hot module replacement // Production npm run production // Optimized production build BrowserSync integration provides:\nLive reloading during development Synchronized browser testing Proxy configuration for WordPress development Performance optimizations Code splitting: Laravel Mix extracts vendor libraries Asset versioning: Automatic cache busting Image optimization: Lazy loading and responsive images Minification: Production builds are minified and optimized Tree shaking: Unused code elimination in production SVG optimization: Efficient SVG manipulation and rendering Accessibility Semantic HTML structure ARIA labels for interactive elements Keyboard navigation support Focus management in forms and modals Screen reader considerations Proper alt text for images Conclusion and final thoughts Building the ETMday frontend was an excellent opportunity to:\nMaster SVG interactions: Creating complex interactive SVG maps with dynamic tooltips and zones Implement real-time features: Building countdown timers and live updates Build advanced search: Multi-category search with filtering and categorization Handle complex state: Managing filters, favorites, and dynamic content Optimize performance: Implementing efficient animations and lazy loading Ensure scalability: Building components that handle large datasets (thousands of attendees, hundreds of activities) The project demonstrates proficiency in:\nModern JavaScript frameworks (Vue 3) SVG manipulation and interaction Real-time UI updates Advanced filtering and search systems Build tools and asset compilation (Laravel Mix, Webpack) CSS architecture and methodologies (SCSS, BEM) Component-based development Event-driven architecture The integration with WordPress/Themosis backend required careful consideration of server-side rendering, API endpoints, and content management workflows, making this a full-stack frontend implementation for a large-scale event.\nLive website: https://etmday.org/\nFigma Prototype: https://www.figma.com/proto/mt9fJ8P03M5gf0nQwcU99q/EtM-Day-2025---Dise%C3%B1o?node-id=1-2743\u0026m=dev\u0026scaling=scale-down\u0026content-scaling=fixed\u0026page-id=0%3A1\u0026starting-point-node-id=1%3A2743\n","image":"//localhost:1313/images/project/etm/home.png","permalink":"//localhost:1313/projects/etmday-entrepreneurship-event-website/","tags":["Vue 3","Laravel Mix","WordPress","Themosis","SCSS","JavaScript","Interactive Map","SVG"],"title":"ETMday: Entrepreneurship Event Website"},{"categories":["Projects"],"contents":"Chile Nativo is a travel tour website for Patagonia experiences, built on top of WordPress with the Themosis framework, featuring a modern frontend implementation based on a Figma design using Vue 3, Laravel Mix, and a comprehensive SCSS architecture.\nOutline The project Design implementation The stack Frontend architecture Key features Conclusion Live website The project Chile Nativo is a travel company specializing in Patagonia tours, offering experiences in destinations like Torres del Paine, Tierra del Fuego, and Isla Navarino. The website serves as the primary platform for showcasing tours, managing bookings, and providing information about their travel experiences.\nThe frontend development was based on a comprehensive Figma design, requiring pixel-perfect implementation of complex UI components, interactive forms, filtering systems, and responsive layouts that work seamlessly across all devices.\nDesign implementation The entire frontend was built from a detailed Figma design, ensuring:\nPixel-perfect accuracy: Matching the design specifications precisely Responsive design: Implementing breakpoints and mobile-first approach Component consistency: Maintaining design system patterns throughout Interactive elements: Translating static designs into dynamic, interactive components Animation and transitions: Implementing smooth user experience enhancements The stack The frontend stack consists of:\nVue 3.2.4: Modern reactive framework for building interactive components Laravel Mix 6.0: Asset compilation and bundling SCSS: Advanced styling with a well-organized architecture Pinia 2.3.1: State management for Vue applications Vee-Validate 4.15.0: Form validation with Yup schemas Axios 1.6.8: HTTP client for API requests Splide.js 4.1.4: Modern carousel and slider components Headroom.js: Header behavior on scroll Plyr 3.7.8: Video player implementation SweetAlert2: Modern alert dialogs jQuery 3.7.1: Legacy support and DOM manipulation utilities Frontend architecture Vue components The application features a comprehensive set of Vue 3 components organized by functionality:\nFiltering and Search Components:\nToursFilter.vue: Advanced tour filtering with multiple criteria TourDatesFilter.vue: Date-based filtering for tour availability ToursFilterDropdown.vue \u0026amp; ToursFilterDropdownMobile.vue: Responsive filter dropdowns TestimonialsFilter.vue: Filtering system for customer testimonials NewsFilter.vue: Blog and news filtering SearchResults.vue: Search results display with pagination Form Components:\nPersonalizedTripForm.vue: Multi-step form for custom trip requests with validation ContactFormSimple.vue: Contact form with reCAPTCHA integration FormHelp.vue: Help center form FormGiftCard.vue: Gift card purchase form FormCareers.vue: Job application form NewsletterForm.vue: Newsletter subscription Card Components:\nTour.vue \u0026amp; TourLoading.vue: Tour card display with loading states TourDate.vue \u0026amp; TourDateLoading.vue: Tour date selection cards Testimonial.vue \u0026amp; TestimonialLoading.vue: Customer testimonial cards Blog.vue \u0026amp; BlogLoading.vue: Blog post cards Team.vue \u0026amp; TeamLoading.vue: Team member cards ResourceCard.vue \u0026amp; ResourceLoading.vue: Resource display cards Utility Components:\nPagination.vue: Reusable pagination component Select.vue: Custom select dropdown with search Loader.vue \u0026amp; LoaderFullScreen.vue: Loading indicators EmptyState.vue: Empty state displays ContentResources.vue: Resource content management TeamTabsFilter.vue: Tabbed team member filtering SCSS architecture The styling follows a well-organized SCSS architecture:\nscss/ ├── abstracts/ # Variables, mixins, functions │ ├── _functions.scss │ ├── _mixins.scss │ ├── _variables.scss │ ├── _mq.scss # Media query mixins │ └── _keyframes.scss ├── base/ # Base styles and typography │ ├── _typography.scss │ ├── _colors.scss │ ├── _fonts.scss │ └── _reset.scss └── components/ # Component-specific styles └── [125 component files] Key SCSS features:\nBEM methodology: Consistent naming convention throughout Media query mixins: Using sass-mq for responsive design Modular architecture: Each component has its own SCSS file Abstract layer: Reusable variables, mixins, and functions Vue transitions: Custom transition styles for Vue components JavaScript architecture The JavaScript is organized into two main entry points:\nMain application (app.js):\nInitializes core application functionality Sets up jQuery plugins and utilities Handles legacy browser support Vue application (vue/main.js):\nConfigures Vue 3 app with Pinia for state management Registers global Vue components Sets up Vee-Validate configuration Integrates third-party Vue plugins (VueTelInput, etc.) Component utilities (app/components/):\nheader.js: Header behavior and navigation footer.js: Footer functionality splide.js: Carousel initialization slick.js: Legacy carousel support accordions.js: Accordion interactions tabs.js: Tab functionality scrollTrigger.js: Scroll-based animations video.js: Video player setup sticky-sidebar.js: Sticky sidebar behavior Key features Multi-step forms The PersonalizedTripForm.vue component implements a sophisticated multi-step form with:\nStep-by-step navigation with progress indicators Form validation using Vee-Validate and Yup schemas Dynamic form fields based on user selections Phone number input with international support (VueTelInput) reCAPTCHA integration for spam protection Loading states and error handling Advanced filtering system The tour filtering system (ToursFilter.vue) provides:\nMultiple filter criteria (destination, activity type, trip type, month) Real-time filtering with URL parameter synchronization Responsive design with mobile accordion interface Custom select components with search functionality Empty states and loading indicators Integration with WordPress backend via Axios Responsive design The entire website is fully responsive with:\nMobile-first approach Breakpoint management using sass-mq Touch-friendly interactions Optimized images and assets Performance optimizations for mobile devices Performance optimizations Code splitting: Laravel Mix extracts vendor libraries Asset versioning: Automatic cache busting Image optimization: Lazy loading and responsive images Minification: Production builds are minified and optimized Tree shaking: Unused code elimination in production Accessibility Semantic HTML structure ARIA labels where appropriate Keyboard navigation support Focus management in forms Screen reader considerations Development workflow The project uses Laravel Mix for asset compilation:\n// Development npm run dev // Compile assets npm run watch // Watch for changes npm run hot // Hot module replacement // Production npm run production // Optimized production build BrowserSync integration provides:\nLive reloading during development Synchronized browser testing Proxy configuration for WordPress development Conclusion and final thoughts Building the Chile Nativo frontend from a Figma design was an excellent opportunity to:\nMaster Vue 3: Working with the Composition API, reactive systems, and modern Vue patterns Implement complex forms: Multi-step forms with validation, international phone inputs, and reCAPTCHA Build scalable architecture: Organizing 40+ Vue components and 125+ SCSS files in a maintainable structure Optimize performance: Implementing code splitting, lazy loading, and production optimizations Ensure design fidelity: Translating Figma designs into pixel-perfect implementations Handle responsive design: Creating seamless experiences across all device sizes The project demonstrates proficiency in:\nModern JavaScript frameworks (Vue 3) Build tools and asset compilation (Laravel Mix, Webpack) CSS architecture and methodologies (SCSS, BEM) Form validation and user experience Component-based development Design system implementation The integration with WordPress/Themosis backend required careful consideration of server-side rendering, API endpoints, and content management workflows, making this a full-stack frontend implementation.\nLive website: https://chilenativo.travel/\nFigma prototype: https://www.figma.com/proto/ywHPhSP1UfYUAE8eWVQv4L/Dise%C3%B1o-Desktop---Chile-Nativo?node-id=289-3912\u0026m=dev\u0026scaling=min-zoom\u0026content-scaling=fixed\u0026page-id=289%3A3911\u0026starting-point-node-id=289%3A3912\n","image":"//localhost:1313/images/project/chile-nativo/home.png","permalink":"//localhost:1313/projects/chile-nativo-patagonia-travel-website/","tags":["Vue 3","Laravel Mix","WordPress","Themosis","SCSS","JavaScript","Figma"],"title":"Chile Nativo: Patagonia Travel Website"},{"categories":["Projects"],"contents":"Rutieri is a SaaS platform built with Strapi, React Native, Typescript and other technologies.\nOutline The idea Platform features The stack The API The frontend The mobile app Conclusion Landing Page The idea Before starting to write a single line of code, it is generally a good idea to think about the problem, it\u0026rsquo;s limitations and whether or not it has already been solved by someone else (AKA competitors).\nThe problem I was looking into had to do with the way in which public and private transportation companies manage their routes, drivers and users. This process is generally carried out on paper, e.g. not digital, hence this could be problematic in case of new drivers joining the organization or in case of restricting access to data to only specific users.\nAfter a little bit of research, I could only find one platform that provides a similiar solution but for their own company.\nPlatform features and user stories The following user stories illustrates the desired features the platform should have in order to solve the aforementioned problems.\nAs an administrator user, I want to: login in the admin panel. create an organization. create routes in the organization. invite drivers and users to the organization. manage requests to join the organization. assign routes to drivers in the organization. see in real time the drivers and users currently active in the map of the different routes. As a driver, I want to: login in the mobile app. join an organization by entering the code in the search bar. see my route on the map. become visible to passengers on the road. see the passengers waiting on the road. remove my visibility and finish my run. As a passenger, I want to: login in the mobile app. join an organization by entering the code in the search bar. see the different routes of my organization in the map. search for a destination and get the available routes that pass nearby. see the drivers currently active on the routes in real time. become visible to drivers of a route. The requirements The backend requires to handle user authentication, permissions, different data structures as content types and define relations between them. It\u0026rsquo;s also necessary to synchronise passengers and drivers and view them on a map real time in the administration panel as well as in the mobile app.\nThe administration panel is a web page that fetches data from the backend as well as from the real time data provider and it\u0026rsquo;s goal is to provide a way for administrators to manage their organization and users. We\u0026rsquo;re talking about a Single Page Application built in React.\nAs for the mobile application, there isn\u0026rsquo;t a better choice nowadays than React Native and it works just fine in this case.\nThe API Since all of the features involve authentication, permissions and roles, and because there is no need to reinvent the wheel, I chose to use Strapi to build the backend for it\u0026rsquo;s simplicity, ease of use and great developer experience, whereas for realtime data, I used Firebase.\nThe instance of Strapi and the Postgres database it requires was deployed in the cloud hosting platform https://fly.io.\nStrapi is good for managing users, content that\u0026rsquo;s typically updated and fetched via CRUD API, and relations between content types.\nThe platform needs the following content types:\nOrganizations to group routes, drivers and users Routes Two user roles: drivers and users (passengers) Below are some screenshots of the overview of these content types\nAs I said before, Strapi makes the creation of these content types and the relationships between them really straightforward.\nHowever, not everything related to the API can be provided by Strapi. Some realtime features need to be addressed with other solutions, such as geolocation data in real time for drivers and users to synchronise each other, maps and the ability to search for places. Such features were implemented using Firebase, Google Maps and Google Places.\nThe frontend The platform where users are able to login as administrators and manage their organizations and users is a single page web application built in React. Among the features of this project that I think stand out are:\nState managed by Context API Interface styled with Bootstrap React Router for pages Leaflet to display the map GeoFire library to synchronise geolocation data in real time with Firebase Use of localStorage to save user session Below are some sample screenshots of how this app looks like\nThe mobile application This one is by far the most complex part of this project.\nThe project was bootstraped with Infinitered\u0026rsquo;s Ignite, which provides a great boilerplate and surely saved me of what would have been between 1-2 months of work.\nIgnite\u0026rsquo;s boilerplate includes many features out of the box, including:\nReact Native and Typescript (of course) React Navigation MobX-State-Tree for state management Expo SDK for developer experience AsyncStorage for persistence apisauce as REST client And some other libraries and features that make React Native apps super powerful and a joy to work on.\nIt consists of three screens:\nWelcome screen Login screen Map screen In the welcome screen, users are able to go to the login screen if not logged in. Otherwise, if they\u0026rsquo;re in an organisation, it shows their role and org\u0026rsquo;s information, and if they\u0026rsquo;re not, they are able to enter the organisation code and request to join as driver or as passenger.\nWelcome screens Login screens If the user is a driver in an organisation, the welcome screen also shows the route assigned to them. By tapping on it, it takes them to the map, where they can see themselves and start the tour, becoming visible to passengers on the road but being able to see passengers on the road as well.\nDrivers can finish the tour at any time by pressing the button stop.\nIf the user is a passenger in an organisation, the welcome screen shows the different routes available in the organisation. By tapping on them, they are taken to the map where they can see themselves, the route and the drivers on the road.\nPassengers are able to navigate between the available routes and search for the location they want to go to by using the search bar at the top of the map screen, filtering out the routes that pass nearby (less than 200 meters), if there are. Google Places API and turf library work together in this search process.\nPassengers become visible to drivers on the road by pressing the button wait and if they press the button again, they stop waiting and are removed from the driver\u0026rsquo;s map.\nMap screens The start/wait and finish buttons dispatch actions that update their location in firebase, so that passengers are able to see the bus on the map as it moves in real time and viceversa.\nAs for the state management, the project consists of two models and three stores from Mobx-State-Tree library: User and Route models, user-status, route-store and root-store stores.\nUser model Located in /app/models/user/user.ts\nconst OrganizationModel = types.model({ name: types.string, code: types.string, id: types.identifierNumber, drivers: types.number, rutas: types.array(RouteModel) }) const UserModel = types .model(\u0026#34;User\u0026#34;) .props({ id: types.identifierNumber, username: types.string, email: types.string, token: types.string, role: types.union(types.literal(\u0026#34;passenger\u0026#34;), types.literal(\u0026#34;driver\u0026#34;)), ruta: types.maybeNull(RouteModel), organization: types.maybeNull(OrganizationModel), pending_request: types.maybeNull(OrganizationModel), }) Route model Located in /app/models/route/route.ts\nThis model follows the GeoJSON format for routes.\nconst RouteModel = types .model(\u0026#34;Ruta\u0026#34;) .props({ id: types.identifierNumber, name: types.string, latlong: types.maybeNull(types.model({ lat: types.number, longt: types.number })), coords: types.model({ type: FeatureTypes, features: types.array(types.model({ type: types.string, geometry: types.model({ type: types.string, coordinates: types.union(types.array(types.number), types.array(types.array(types.number))) }), properties: types.model({ name: types.string }) })) }) }) user-status store Located in /app/models/user-status/user-status.ts\nThis store is responsible for managing the state of the user. It stores the user once it\u0026rsquo;s logged in and removes it when the user logs out. It also has some views to get the user key for firebase purposes, get the role and get the route in case of a driver.\nThis store has some methods that get the user location from the device\u0026rsquo;s GPS, displays the user icon on the map and sends it to firebase.\nconst UserStatusModel = types .model(\u0026#34;UserStatus\u0026#34;) .extend(withEnvironment) .props({ user: types.maybeNull(UserModel), location: types.maybeNull( types.model({latitude: types.number, longitude: types.number}) ), visibility: types.maybeNull(types.number) }) route-store store Located in /app/models/route-store/route-store.ts\nThis store is responsible for managing the state of the available routes. It stores the routes, drivers and passengers on the different routes. It also has some view methods to filter the routes that pass nearby a destination specified by the user, get passengers waiting on a given route and get drivers active in a specific route.\nThis store initializes a GeoQuery from Geofire library and listens for events to set, update and remove drivers and passengers from the map as they move.\nconst RouteStoreModel = types .model(\u0026#34;RouteStore\u0026#34;) .props({ routes: types.array(RouteModel), passengers: types.map(types.model({ key: types.identifier, location: types.array(types.number) })), drivers: types.map(types.model({ key: types.identifier, location: types.array(types.number) })), destinationAddress: types.maybeNull(types.model({ name: types.string, coords: types.array(types.number) })) }) Conclusion and final thoughts Using a CMS as the backend can make the development a lot faster than building the API from scratch and with Strapi this is specially true. On the other hand, Strapi doesn\u0026rsquo;t really make a good fit for real time applications, therefore, Firebase is the way to go in this case.\nAs of the client side, React always works very good for pretty much any kind of application, and because React Native uses React under the hood, it is so convenient for us React developers and ir works pretty good for almost any kind of application as well.\nHowever, one thing that I didn\u0026rsquo;t mention in this post was the use of Typescript; I find this quote by Brice Wilson pretty good to point out the whole purpose and motivation to learn and use (well) this powerful language and tool ecosystem:\n\u0026ldquo;You won\u0026rsquo;t have to wait for a frustrated user to report the error. All of this means that you provide value to your users faster, and that\u0026rsquo;s really what it\u0026rsquo;s all about.\u0026rdquo;\nAll in all, I got a lot of learning by building this project, both in languages/frameworks used and production stuff such as infrastructure, cloud hosting and cloud-based APIs.\nProject landing page: https://rutieri.netlify.app\n","image":"//localhost:1313/images/project/rutieri/landing/homepage.webp","permalink":"//localhost:1313/projects/saas-platform-rutieri/","tags":["Strapi","React Native","React","Typescript","Firebase"],"title":"SaaS platform: Rutieri"},{"categories":["Tutorial"],"contents":"Enable comments in a Strapi application and display them in the frontend with React\nOutline Introduction Prerequisites What is Strapi Comment Manager? Installation Configuration Display comments on the frontend Installation of Strapi Comments Client Usage of Strapi Comments Client Plugin settings Manage comments Full source code of the frontend Conclusion Introduction A comment system comes in very handy for pretty much any kind of website. In the JAMstack ecosystem, while it\u0026rsquo;s ok to rely on third party solutions hosted on their own platform such as Disqus to enable comments, you usually want to keep your content and all the stuff related to it in the same admin dashboard.\nIn this article, I\u0026rsquo;ll show you how to enable and manage comments for your content very easily using the Comment Manager plugin, and display them in your frontend application.\nPrerequisites You should have a basic understanding of the following.\nBasic knowledge of JavaScript Basic knowledge of React (OPTIONAL) Basic understanding of Strapi - get started here. Your Strapi V4 project setup What is Strapi Comment Manager? Strapi Comment Manager is a plugin that enables comments for pretty much any kind of content. It allows your users to post comments and anyone can get the comments associated with a given slug.\nWith this plugin, admin users can view and manage very easily all the comments from the Strapi administration dashboard. Within the dashboard, you will be able to delete comments and subcomments and leave replies on comments.\nInstallation Once into the Strapi project root, you can install the plugin by running the following command:\nnpm install strapi-plugin-comment-manager Next, build the project to see the new plugin in the dashboard with the following command:\nnpm run build And that\u0026rsquo;s it! If everything runs correctly, the plugin should now be installed.\nConfiguration Now you need to enable some permissions so that the frontend can access the endpoints to post and fetch comments.\nIn your Strapi admin dashboard, head over to Settings, then over to Roles under Users \u0026amp; Permissions Plugin.\nLet\u0026rsquo;s first setup the Public API; click on Public and hit the dropdown button of Comment Manager. Now check count, find and getPageSize, then hit the Save button. Below is a screenshot of a proper configuration:\nNow let\u0026rsquo;s setup the Authenticated API. Go back to Roles and click on Authenticated. Open the dropdown for Comment Manager and mark as checked the option create on both Comment and Subcomment. Below is a screenshot of a proper configuration:\nWith this configuration, the frontend should now be able to make requests to get and post comments.\nDisplay comments on the frontend The plugin exposes an API to get and post comments if you want to have fine-grained control over the workflow of your comments system and you can check the documentation on the package page, but this plugin also comes with a purpose-built React component library that makes it super easy to get up and running without getting your hands dirty.\nThis components library is called strapi-comments-client, fully supports typescript and it handles for you all of the complexity of fetching and posting comments and subcomments for every content ID that you pass to it.\nInstallation of Strapi Comments Client You will need to have installed react ^17.0.2, react-dom ^17.0.2 and react-router-dom ^5.2.0.\nInside of your React project, run this command:\nnpm install strapi-comments-client --save Usage of Strapi Comments Client Using this library is very easy!\nThis library exports three main components:\nCommentsProvider Comments CommentForm And you can import them this way:\nimport { CommentsProvider, Comments, CommentForm } from \u0026#34;strapi-comments-client\u0026#34; All you have to do is wrap your App component into the CommentsProvider component. Then you will be able to place anywhere in your app the Comments component to render a list of comments for a given content ID and the CommentForm component to render a form to post comments.\nFor example, this could be your index.js or main.js file:\nimport React from \u0026#39;react\u0026#39; import ReactDOM from \u0026#39;react-dom\u0026#39; // The address of your strapi backend instance const STRAPI = \u0026#34;http://localhost:1337\u0026#34; ReactDOM.render( \u0026lt;React.StrictMode\u0026gt; \u0026lt;CommentsProvider apiURL={STRAPI}\u0026gt; \u0026lt;App /\u0026gt; \u0026lt;/CommentsProvider\u0026gt; \u0026lt;/React.StrictMode\u0026gt;, document.getElementById(\u0026#39;root\u0026#39;) ) Where apiURL is the URL of your running Strapi application, and this property is required.\nThis way, the comments provider will do all the magic of fetching and posting comments for you!\nThis library also exports an utility React.Context to update some of the parameters for fetching and posting comments:\nimport { CommentsConfigContext } from \u0026#34;strapi-comments-client\u0026#34; This CommentsConfigContext exposes two setter functions: setUser and setContentID\nWith setContentID you can load the comments for a given content and post comments to it. It receives a single parameter of type string and must be URLized, i.e. no spaces.\nWith setUser you can set the credentials of a given user to authorize the posting of comments. It receives a single parameter of type IUser, with the following Typescript interface:\ninterface IUser { username: string, email: string, id: string, token: string // This is a JWT } It\u0026rsquo;s a little confusing but we\u0026rsquo;ll see how to use it in a component:\nconst App = () =\u0026gt; { const { setUser, setContentID } = useContext(CommentsConfigContext) // The following data should come from Strapi Users and Permissions Plugin // for authenticated requests const user = { username: \u0026#34;John Doe\u0026#34;, email: \u0026#34;jhohndoe@gmail.com\u0026#34;, id: 5, token: \u0026#34;this_should_be_a_JWT\u0026#34; } if (user) { setUser(user) } setContentID(\u0026#34;sample-content-1\u0026#34;) // Load comments for this content return ( \u0026lt;\u0026gt; { !user \u0026amp;\u0026amp; \u0026lt;Login /\u0026gt; } \u0026lt;CommentForm /\u0026gt; \u0026lt;Comments /\u0026gt; \u0026lt;/\u0026gt; ) } And that\u0026rsquo;s it!\nAfter setting the content ID through setContentID, CommentsProvider will start loading the comments for the given content ID and the CommentForm will render an input to post comments related to the given content ID if there is a user. Otherwise, it will display the message Login to post a comment.\nHere\u0026rsquo;s how the interface looks like so far:\nThere\u0026rsquo;s also a button to Leave a reply, which will open a form to post a subcomment associated with the parent comment.\nThis library exports one more component: ErrorBox\nimport { ErrorBox } from \u0026#34;strapi-comments-client\u0026#34; .It\u0026rsquo;s useful if you\u0026rsquo;d like to display error messages when things go wrong fetching or posting comments.\nYou can place this component wherever you want, for example in between the CommentForm and the Comments components.\nIf you\u0026rsquo;re wondering how this error box looks like, here you have a sample:\nGeneral settings You can customize the page size, i.e. specify how many comments are returned at once.\nIn the Strapi admin panel, head over to Settings, then select Pagination under Comment Manager Plugin.\nHere you\u0026rsquo;ll find an input to set the page size, which defaults to 10.\nManage comments Once you\u0026rsquo;ve got the plugin up an running, as users start to post comments, you can manage and reply to them as admin from the Comment Manager section of the left sidebar in the Strapi admin dashboard.\nHere you can see two tabs: one for the latest comments and one for comments grouped by content ID.\nIn both of them you can delete comments and subcomments as well as leave replies.\nExample project You can find a full working example of a React App using the Strapi Comments Client Library in this repo\nConclusion With this plugin you can enable and manage comments for any content with little effort and even use a component library to display the comments in your frontend application made with React.\nAnd that\u0026rsquo;s it! The features are pretty basic at the moment but if there\u0026rsquo;s interest, I\u0026rsquo;m willing to work on more features as well as improve the UI/UX.\n","image":"//localhost:1313/images/post/strapilogo.jpg","permalink":"//localhost:1313/blogs/how-to-enable-and-manage-comments-in-your-strapi-application/","tags":["Strapi","Strapi tutorials"],"title":"How To Enable And Manage Comments In Your Strapi Application."},{"categories":["Documentation"],"contents":"Comment Manager is a Strapi plugin to allow your users to post comments.\nWith this plugin you can enable and manage comments for your content very easily!\nRequirements You should have installed an instance of Strapi v4.x.x\nInstallation Run the following command in your project root:\nnpm install strapi-plugin-comment-manager Configurarion For your frontend to have access to the API, enable the following permissions for Comment Manager from Users \u0026amp; Permissions Plugin on your project settings:\nFor public, enable: count, find and getPageSize.\nFor authenticated, enable create on both Comment and Subcomment.\nDisplay comments on the frontend Comments can be displayed in the frontend in two ways:\nUsing the React components library strapi-comments-client (recommended) Build your custom frontend using the API API There are some Typescript interfaces that will help to get an idea of the data structures.\nComments: interface IComment { id: string, from_admin: boolean, createdAt: string, content: string, author: IAuthor | null, subcomments?: ISubcomment[] } Subcomments: interface ISubcomment { id: string, from_admin: boolean, createdAt: string, content: string, author: IAuthor | null, } Authors: IAuthor { username: string, email: string, id: string } The following endpoints are exposed to fetch and post comments and subcomments:\nGet comments for a content ID Method: GET\nPath: /api/comment-manager/comments/:slug\nOptional query parameters: start, ignoreCount\nReturns:\n{ commentsCount?: Number, comments: IComment[] } The parameter start indicates how many comments to skip. This is for pagination purposes.\nThe parameter ignoreCount indicates whether or not to return the total number of comments associated with the given slug.\nGet the number of comments associated with a given content ID Method: GET\nPath: /api/comment-manager/comments/:slug/count\nReturns:\n{ count: Number } Post a comment Method: POST\nPath: /api/comment-manager/comments/:slug\nAuthentication: Bearer token\nPayload:\n{ content: string } Returns:\n{ id: Number } Post a subcomment Method: POST\nPath: /api/comment-manager/subcomments/:parent-id\nAuthentication: Bearer token\nPayload:\n{ content: string } Returns:\n{ id: Number } Get the page size Method: GET\nPath: /api/comment-manager/page-size\nReturns:\n{ pageSize: Number } General settings The plugin allows to set how many comments are returned per page by going to the Pagination section under Comment Manager Plugin on the Settings section.\nThe default page size is 10.\nManagement of comments Admin users are able to delete comments and subcomments as well as leave replies as admins from within the plugin page of the Strapi admin dashboard.\nThe plugin interface has two tabs: one for the latest comments and one for comments by content ID.\nRoadmap and future plans The plugin is pretty basic but it can be improved with more features and a better UI/UX. Collaborations and suggestions are very welcome.\n","image":"//localhost:1313/images/post/strapilogo.jpg","permalink":"//localhost:1313/blogs/strapi-plugin-comment-manager/","tags":["Strapi","Strapi plugins"],"title":"Strapi Plugin Comment Manager"},{"categories":["Projects"],"contents":"In this post I’m going to share my experience on building a SaaS using the headless CMS Strapi as the Backend, React Native and other technologies.\nOutline Introduction What is SaaS? The problem What is Strapi? Developing features in Strapi The frontend: How to get content Conclusion Landing Page Introduction Very often, developers, product and project managers, testers and pretty much the entire team share their ideas to decide what language and which framework they\u0026rsquo;ll use to build their next project. Some considerations must be taken into account, from which in my opinion there are three that are the most important:\nDeveloper experience and ease of use Does the language and framework chosen provide a good developer experience? Is the langauge the same for the backend and frontend?\nDeadlines Is there a deadline to finish the project? if so, there is a good chance to finish the project on time if the team chooses the language they have more experience in.\nMaintainability As there will be usually more than one person working on the same part at the same time, if everything is kept organised, the whole development process will be frictionless.\nWith that in mind, developers and project managers will have a better insight on which language/framework to use.\nOther aspects should also be considered such as what the data structure will look like.\nIn my case, as it is usual, the backend of my project needs a database for users and their roles among other entities and their relations and a dashboard to allow admins to manage the data, and I was lucky to find out Strapi, as it includes a lot of these features out of the box with one single line of command to get started.\nWhat is SaaS? SaaS stands for Software-as-a-Service and it just means that a software is provided as a service in the cloud and it gives a solution to a specific problem, for which the users are willing to pay either monthly or annual subscription.\nThe problem Before starting to write a single line of code, it is generally a good idea to think about the problem, it\u0026rsquo;s limitations and whether or not it has already been solved by someone else (AKA competitors).\nThe problem I was looking into had to do with the way in which public and private transportation companies manage their routes, drivers and users. After a little bit of research, I could only find one platform that provides a similiar solution but for their own company.\nSo the platform I built needed the following content types:\nOrganizations to group routes, drivers and users Routes Two user roles: drivers and users (passengers) As I said before, Strapi makes the creation of these content types and the relationships between them really easy, but let\u0026rsquo;s first see what is Strapi and how it turns the API development into a satisfactory and fun experience.\nWhat is Strapi? Strapi is an open source headless CMS that allows developers to build complete RESTful APIs in just a couple of days instead of months. It includes a lot of useful features as plugins out of the box. Users and Roles management, Media library and an interface to create, view, edit and delete content are just some of them.\nRegarding the API, how does it makes the development faster?\nFirst of all, it enforces a specific folder structure, which helps to keep everything well organised and clean.\nSecondly, all database schemas are generated automatically and queries are made in JSON format, which really saves a lot of time.\nLastly, we can add more features to our Strapi application very easily via plugins from the marketplace.\nIt\u0026rsquo;s also worth noting that Strapi is a self-hosted CMS, which means that we can host it in whatever cloud platform we want, as well as test it locally in our computers before deploying it to the cloud.\nDeveloping features in Strapi Creating and configuring endpoints in Strapi is as straightforward as declaring a JSON in a single file:\nCreating controllers is straightforward as well:\nEvery controller gets all the data related to the request in the ctx parameter and it\u0026rsquo;s also used to send the response. This keeps everything in one place and really helps to improve the readability.\nOnce the API endpoints are defined, the next step is to enable the permissions for the specific user roles to have access to these endpoints:\nThe frontend: how to get content Since Strapi is a headless CMS, it\u0026rsquo;ll only provide content through the API. That means that the content can be consumed from anywhere. In our case, this content will be used in two applications: one for the organization owners and one for the users and drivers.\nThe application for the organization owners is a dashboard where administrators can create organizations, routes, accept drivers and users in the organization and assign routes to drivers. This is just a React Application:\nThe application for drivers and users is a mobile application built in React Native. Firebase was used to synchronise geolocation data in real time between drivers and users and display this information in a Map from Google Maps:\nConclusion Using a CMS as the backend can make the development a lot faster than building the API from scratch and with Strapi this is specially true. Furthermore, this becomes more important when building a brand-new product, as it\u0026rsquo;s usually recommended to launch as soon as possible to gather feedback from the users and validate the idea.\nProject landing page: https://rutieri.netlify.app\n","image":"//localhost:1313/images/post/03.webp","permalink":"//localhost:1313/blogs/how-i-built-a-saas-on-top-of-strapi-and-why-you-should-too/","tags":["Strapi","React Native","Typescript"],"title":"How I Built A SaaS On Top Of Strapi, And Why You Should Too"},{"categories":["Tutorial"],"contents":"Enable User Reviews in a Strapi application and display them in the frontend with React\nOutline Introduction Prerequisites What is Strapi Ratings? Installation Configuration Display user reviews on the frontend Plugin settings Manage user reviews Full source code of the frontend Conclusion Introduction Ratings systems have become a crucial part of any website with ecommerce capabilites, as they allow the users to post reviews on the items they purchase and publish their opinion to the public. A couple of reviews can make the difference between pressing the “Buy” button and moving on to the next website in the Google search results.\nIn this article, I\u0026rsquo;ll show you how to enable and manage user reviews for your content very easily using the Ratings plugin, and display them in your frontend application.\nPrerequisites First of all, you need to have a basic understanding of the following.\nBasic knowledge of JavaScript Basic knowledge of React (OPTIONAL) Basic understanding of Strapi - get started here. Your Strapi V4 project setup What is Strapi Ratings? Strapi Ratings is a plugin that gives your Strapi application the ability to manage ratings for pretty much any kind of content. It allows your users to post reviews and anyone can get the reviews associated with a given slug.\nWith this plugin, admin users can view and manage very easily all the reviews from the Strapi administration dashboard. Within the dashboard, you will be able to see reviews related to content slugs as well as delete reviews.\nInstallation Once into the Strapi project root, you can install the plugin by running the following command:\nnpm install strapi-plugin-ratings Next, build the project to see the new plugin in the dashboard with the following command:\nnpm run build And that\u0026rsquo;s it! If everything runs correctly, the plugin should now be installed.\nConfiguration Now you need to enable some permissions so that the frontend can access the endpoints to post and fetch reviews.\nIn your Strapi admin dashboard, head over to Settings, then over to Roles under Users \u0026amp; Permissions Plugin.\nLet\u0026rsquo;s first setup the Public API; click on Public and hit the dropdown button of Ratings. Now check count, find, getPageSize and getStats, then hit the Save button. Below is a screenshot of a proper configuration:\nNow let\u0026rsquo;s setup the Authenticated API. Go back to Roles and click on Authenticated. Open the dropdown for Ratings and mark as checked the options create, find and getUserReview. Below is a screenshot of a proper configuration:\nWith this configuration, the frontend should now be able to make requests to get and post user reviews.\nDisplay use reviews on the frontend The plugin exposes an API to get and post reviews if you want to have fine-grained control over the workflow of your ratings system and you can check the documentation on the package page, but this plugin also comes with a purpose-built React component library that makes it super easy to get up and running without getting your hands dirty.\nThis components library is called strapi-ratings-client, fully supports typescript and it takes care of all the complexity of fetching and posting user reviews for every content ID that you pass to it.\nInstallation of Strapi Ratings Client You will need to have installed react ^17.0.2, react-dom ^17.0.2, bootstrap ^5.1.3 and @popperjs/core^2.11.2\nInside of your React project, run this command:\nnpm install strapi-ratings-client --save Usage of Strapi Ratings Client Using this library is very easy!\nThis library exports three main components:\nReviewsProvider Reviews ReviewForm And you can import them this way:\nimport { ReviewsProvider, Reviews, ReviewForm } from \u0026#34;strapi-ratings-client\u0026#34; All you have to do is wrap your App component into the ReviewsProvider component. Then you will be able to place anywhere in your app the Reviews component to render a list of user reviews for a given content ID and the ReviewForm component to render a form to allow your users to post reviews.\nFor example, this could be your index.js or main.js file:\nimport React from \u0026#39;react\u0026#39; import ReactDOM from \u0026#39;react-dom\u0026#39; // The address of your strapi backend instance const STRAPI = \u0026#34;http://localhost:1337\u0026#34; ReactDOM.render( \u0026lt;React.StrictMode\u0026gt; \u0026lt;ReviewsProvider apiURL={STRAPI}\u0026gt; \u0026lt;App /\u0026gt; \u0026lt;/ReviewsProvider\u0026gt; \u0026lt;/React.StrictMode\u0026gt;, document.getElementById(\u0026#39;root\u0026#39;) ) Where apiURL is the URL of your running Strapi application, and this property is required.\nThis way, the ratings provider will do all the magic of fetching and posting comments for you!\nThis library also exports an utility React.Context to update some of the parameters for fetching and posting reviews:\nimport { ReviewsConfigContext } from \u0026#34;strapi-ratings-client\u0026#34; This ReviewsConfigContext exposes three setter functions: setUser, setContentID and setCanPostReview.\nWith setContentID you can load the ratings for a given content and post reviews to it. It receives a single parameter of type string and must be URLized, i.e. no spaces.\nWith setUser you can set the credentials of a given user to authorize the posting of reviews. It receives a single parameter of type IUser, with the following Typescript interface:\ninterface IUser { username: string, email: string, id: string, token: string // This is a JWT } With setCanPostReview, you can enable the user to post a review on the given content. This is useful for when you only allow a user to post a review after they purchase the product.\nIt\u0026rsquo;s a little confusing but we\u0026rsquo;ll see how to use it in a component:\nconst App = () =\u0026gt; { const { setUser, setContentID, setCanPostReview } = useContext(ReviewsConfigContext) // The following data should come from Strapi Users and Permissions Plugin // for authenticated requests. const user = { username: \u0026#34;John Doe\u0026#34;, email: \u0026#34;jhohndoe@gmail.com\u0026#34;, id: 5, token: \u0026#34;this_should_be_a_JWT\u0026#34; } if (user) { setUser(user) } setContentID(\u0026#34;sample-content-1\u0026#34;) // Load reviews for this content setCanPostReview(true) // Allow this user to post a review return ( \u0026lt;\u0026gt; { !user \u0026amp;\u0026amp; \u0026lt;Login /\u0026gt; } \u0026lt;ReviewForm /\u0026gt; \u0026lt;Reviews /\u0026gt; \u0026lt;/\u0026gt; ) } And that\u0026rsquo;s it!\nAfter setting the content ID through setContentID, ReviewsProvider will start loading the reviews for the given content ID and the ReviewForm will render an input to post a user review related to the given content ID if there is a user and he’s allowed to post a review. Otherwise, it will display the message Login to post a review or nothing at all if the user is not allowed to post a review.\nHere\u0026rsquo;s how the interface looks like so far:\nThis library exports one more component: ErrorBox\nimport { ErrorBox } from \u0026#34;strapi-ratings-client\u0026#34; .It\u0026rsquo;s useful for when you\u0026rsquo;d like to display error messages when things go wrong fetching or posting reviews.\nYou can place this component wherever you want, for example in between the ReviewForm and the Reviews components.\nIf you\u0026rsquo;re wondering how this error box looks like, here‘s a screenshot:\nGeneral settings You can customize the page size, i.e. specify how many user reviews are showed at once.\nIn the Strapi admin panel, head over to Settings, then select Pagination under Ratings Plugin.\nHere you\u0026rsquo;ll find an input to set the page size, which defaults to 10.\nManage reviews Once you\u0026rsquo;ve got the plugin up an running, as users start to post reviews, you can view them from within the Ratings section of the left sidebar in the Strapi admin dashboard.\nHere you can see two tabs: one for the latest reviews and one for reviews grouped by content ID.\nIn both of them you can delete unwanted reviews.\nExample project You can find a full working example of a React App using the Strapi Ratings Client Library in this repo: https://github.com/luisguve/strapi-ratings-client-example\nConclusion With this plugin you can enable and manage user reviews for any content with little effort and even use a library of components styled with Bootstrap to display the user reviews in your frontend.\nAnd that\u0026rsquo;s it! The features are pretty basic at the moment but if there\u0026rsquo;s interest, I\u0026rsquo;m willing to work on more features as well as improve the UI/UX.\n","image":"//localhost:1313/images/post/tutorial-ratings.webp","permalink":"//localhost:1313/blogs/how-to-enable-and-manage-user-reviews-in-your-strapi-application/","tags":["Strapi","Strapi tutorials"],"title":"How To Enable And Manage User Reviews In Your Strapi Application"},{"categories":["Documentation"],"contents":"Ratings is a Strapi plugin that allows your users to post reviews.\nEnable and manage user reviews for your content very easily!\nRequirements You should have installed an instance of Strapi v4.x.x\nInstallation Run the following command in your project root:\nnpm install strapi-plugin-ratings Then, rebuild the admin dashboard using the following command\nnpm run build Configurarion For your frontend to have access to the API, enable the following permissions for Ratings from Users \u0026amp; Permissions Plugin on your project settings:\nFor public, enable: count, find, getPageSize and getStats.\nFor authenticated, enable create, find and getUserReview.\nDisplay user reviews on the frontend Reviews can be displayed in the frontend in two ways:\nUsing the React components library strapi-ratings-client (recommended) Build your custom frontend using the API endpoints, described as follows: API There are some Typescript interfaces that will help to get an idea of the data structures.\nReviews: interface IReview { id: number, createdAt: string, comment: string | null, author: IAuthor | null, score: number, } Authors: interface IAuthor { username: string, email: string, id: number } Content Stats interface IStats { averageScore: number; reviewsCount: number | null; } The following endpoints are exposed to fetch and post reviews:\nGet reviews for a content ID Method: GET\nPath: /api/ratings/reviews/:slug\nOptional query parameters: start, ignoreCount\nReturns:\n{ reviewsCount: number, averageScore: number, userReview: IReview | null, reviews: IReview[] } The parameter start indicates how many reviews to skip. This is for pagination purposes.\nThe parameter ignoreCount indicates whether or not to return the total number of reviews associated with the given slug.\nGet review stats for a content ID Method: GET\nPath: /api/ratings/reviews/:slug/stats\nReturns:\n{ averageScore: number, reviewsCount: number | null } Get the number of reviews associated with a given content ID Method: GET\nPath: /api/ratings/reviews/:slug/count\nReturns:\n{ count: number } Post a review Method: POST\nPath: /api/ratings/reviews/:slug\nAuthentication: Bearer token\nPayload:\n{ content: string } Returns:\n{ id: number } By default, every authenticated user can post reviews on any content.\nIn order to customize this behavior, e.g. allowing or disallowing a user from posting reviews, you must extend the service userCanPostReview from whithin register function in ./src/index.js. For example:\nstrapi.service(\u0026#34;plugin::ratings.review\u0026#34;).userCanPostReview = async (user, slug) =\u0026gt; { /* Here you will check whether or not the user is allowed to post a review on this content ID and return either true or false. */ return true } Notice that userCanPostReview will receive two parameters: the user from Users \u0026amp; Permissions Plugin, containing it\u0026rsquo;s id, username, confirmed, etc., and the slug, which is a string and refers to the content ID which the review is being posted on.\nIn case this function returns false, the response of the endpoint will be 403 (forbidden) with the text User cannot post a review on this content.\nGet the page size Method: GET\nPath: /api/ratings/page-size\nReturns:\n{ pageSize: number } General settings The plugin allows to set how many reviews are returned per page by going to the Pagination section under Ratings Plugin of the Settings section.\nThe default page size is 10.\nManagement of reviews Admin users are able to delete reviews from within the plugin page of the Strapi admin dashboard.\nThe plugin interface has two tabs: one for the latest reviews and one for reviews by content ID.\nRoadmap and future plans The plugin is pretty basic but it can be improved with more features and a better UI/UX. Collaborations and suggestions are very welcome.\n","image":"//localhost:1313/images/post/ratings.webp","permalink":"//localhost:1313/blogs/strapi-plugin-ratings/","tags":["Strapi","Strapi plugins"],"title":"Strapi Plugin Ratings"},{"categories":["Projects"],"contents":"ManyLMS is an e-learning platform built on top of Strapi, React Router 7, Typescript and other technologies.\nOutline The idea Platform features The stack The API The frontend Conclusion Landing Page The idea This project doesn\u0026rsquo;t necessarily bring a huge amount of innovation on the e-learning platforms that already exists, but it\u0026rsquo;s just another way of doing this type of application.\nThe main idea is to apply a JAMstack approach in this application, where the platform is a static website, and the backend is just an API that serves static content only once to build the website and just adds the dynamism that\u0026rsquo;s necessary to allow users to authenticate, create orders, confirm payments and take courses.\nIf we compare this approach to a WordPress website, we are taking out most of the overhead that implies rendering the pages everytime a user visits them. Despite that there are plugins for caching that may improve the performance, it\u0026rsquo;s still never going to be faster and more efficient than just static content served by a CDN. That\u0026rsquo;s why React Router 7 and Headless CMSs are so popular right now.\nPlatform features and user stories The following user stories illustrates the desired features the platform should have.\nAs an administrator, I want to: login in the admin panel. create categories. create courses. upload lectures. organise courses into categories. assign lectures to courses. As a student, I want to: login in the platform. view the available courses. add courses to the shopping cart. review the shopping cart. create an order. pay with credit card or paypal. view the courses i\u0026rsquo;ve purchased in my learning page. go to the course page from my learning page and watch the videos. mark lectures as seen. come back later and resume where I left. The requirements The backend requires to handle user authentication, permissions, different data structures as content types and define relationships between them. It also requires to allow uploading videos to some third party platform that supports streaming on demand.\nThe frontend is a web platform where users can register and login, view and buy courses, leave comments and reviews and take courses.\nThe API Since all of the features involve authentication, permissions and roles, and because there is no need to reinvent the wheel, I chose to use Strapi to build the backend for it\u0026rsquo;s simplicity, ease of use and great developer experience, whereas for streaming videos on demand, I chose to use Mux.com.\nThe instance of Strapi and the Postgres database it requires was deployed in the cloud hosting platform https://fly.io.\nStrapi is good for managing users, content that\u0026rsquo;s typically updated and fetched via CRUD API, and setting up relations between content types.\nThe platform needs the following content types:\nCategory to group courses Course Lecture Module to group lectures Order Student: has many courses Student-Course: stores a student\u0026rsquo;s current lecture of a course Video Strapi makes the creation of these content types and setting up relationships between them really straightforward.\nBelow are some screenshots of these content types and the relationships between them:\nThe frontend The platform where users are able to login, view, buy and view courses is a web application built with React Router 7. Among the features of this application are:\nState managed by Context API Interface styled with Bootstrap Play streaming videos with @mux/mux-player-react library Use of localStorage to save user session Below are some sample screenshots of how this app looks like\nConclusion and final thoughts While building this project, I learned:\nHow streaming on demand works and how to use a streaming provider How to statically build websites with React Router 7 and Strapi How to setup dynamic pages in React Router 7 How to process payments with Stripe and Paypal How to build custom plugins in Strapi How to publish packages to NPM Project source codes: https://github.com/luisguve/maestro-backend\nhttps://github.com/luisguve/new-lms-remix\n","image":"//localhost:1313/images/project/manylms/frontend/course_overview.png","permalink":"//localhost:1313/projects/e-learning-platform-maestro-lms/","tags":["Strapi","React","React Router 7","Typescript","Mux"],"title":"ManyLMS: E-Learning platform"},{"categories":["Projects"],"contents":"ETMday (Emprende tu Mente) is a large-scale entrepreneurship event website built on top of WordPress with the Themosis framework, featuring an interactive SVG map, real-time countdown timers, advanced search functionality, and comprehensive content management using Vue 3, Laravel Mix, and modern frontend technologies.\nOutline The project Key features The stack Frontend architecture Interactive components Conclusion Live website The project ETMday is Chile\u0026rsquo;s premier entrepreneurship event, bringing together thousands of entrepreneurs, startups, corporates, and strategic partners. The website serves as the central hub for event information, featuring speakers, activities, stands, program schedules, and an interactive event map.\nThe frontend development required implementing complex interactive features including an SVG-based interactive map with tooltips, real-time countdown timers, advanced filtering and search systems, and dynamic content displays that handle thousands of attendees and hundreds of activities.\nKey features The website includes several sophisticated features:\nInteractive SVG Map: Custom-built interactive map with clickable zones, tooltips, and dynamic content display Real-time Countdown: Event countdown timer with automatic updates and mobile optimization Advanced Search: Multi-category search across activities, speakers, stands, and content Dynamic Filtering: Complex filtering system with tabs, favorites, and downloadable resources Animated Statistics: Odometer animations for displaying event metrics Content Management: Comprehensive card components for activities, speakers, stands, and blog posts Form Handling: Multi-step forms with validation using Vee-Validate Lightbox Galleries: Image galleries with LightGallery integration Responsive Design: Fully responsive design optimized for all devices The stack The frontend stack consists of:\nVue 3.2.4: Modern reactive framework for building interactive components Laravel Mix 6.0: Asset compilation and bundling SCSS: Advanced styling with organized architecture Vee-Validate 4.15.0: Form validation with Yup schemas Axios 1.6.8: HTTP client for API requests Splide.js 4.1.4: Modern carousel and slider components LightGallery 2.8.3: Lightbox gallery functionality Odometer 0.4.8: Animated number counting Headroom.js: Header behavior on scroll jQuery 3.7.1: DOM manipulation and legacy support SweetAlert2: Modern alert dialogs GLightbox 3.3.1: Alternative lightbox solution Frontend architecture Vue components The application features a comprehensive set of Vue 3 components:\nCard Components:\ncards/activities.vue: Activity cards with favorites functionality cards/speakers.vue: Speaker cards with modal details cards/stands.vue: Stand/exhibitor cards cards/blog.vue: Blog post cards cards/shortcut.vue: Quick access shortcut cards Functional Components:\nSectionCards.vue: Main section component with tabs, filtering, and card display Search.vue: Advanced search component with multi-category results Form.vue: Dynamic form component with validation FormCalendar.vue: Calendar form component CustomFilter.vue: Reusable filter component CustomSelect.vue: Custom select dropdown Pagination.vue: Pagination component JavaScript components The application includes 17 specialized JavaScript components:\nInteractive Features:\ninteractiveMap.js: SVG map interaction with tooltips, zones, and dynamic content countdown.js: Real-time countdown timer with automatic updates odometer.js: Animated number counting with scroll triggers map.js: Map zone interactions and modal displays UI Components:\nheader.js: Header functionality and navigation headroom.js: Header hide/show on scroll accordion.js: Accordion interactions tabs.js: Tab functionality cards.js: Card interactions and modals siteModals.js: Modal management system UI.js: General UI utilities Media Components:\nvideo.js: Video player setup lightgallery.js: Lightbox gallery initialization splide.js: Carousel initialization slick.js: Legacy carousel support Utilities:\nscrollTrigger.js: Scroll-based animations imgToSvg.js: SVG image conversion utility SCSS architecture The styling follows a well-organized SCSS architecture:\nscss/ ├── abstracts/ # Variables, mixins, functions │ ├── _functions.scss │ ├── _mixins.scss │ ├── _variables.scss │ ├── _mq.scss # Media query mixins │ └── _keyframes.scss ├── base/ # Base styles and typography │ ├── _typography.scss │ ├── _container.scss │ └── _reset.scss └── components/ # Component-specific styles └── [52 component files] Key SCSS features:\nBEM methodology: Consistent naming convention Media query mixins: Using sass-mq for responsive design Modular architecture: Each component has its own SCSS file Component organization: 52 component-specific SCSS files Interactive components Interactive SVG Map The interactiveMap.js component implements a sophisticated SVG-based interactive map:\nFeatures:\nSVG Tooltips: Dynamically generated tooltips with text wrapping Zone Interactions: Clickable zones with modal displays Point Markers: Interactive points with icons and labels Dynamic Content: Content loaded based on zone/point selection Responsive Design: Optimized for mobile and desktop Technical Implementation:\nSVG namespace manipulation for tooltip creation Text wrapping algorithm for tooltip content Path generation for tooltip shapes with rounded corners Event delegation for zone and point interactions Smooth animations and transitions Real-time Countdown The countdown.js component provides a real-time countdown timer:\nFeatures:\nAutomatic Updates: Updates every second Multi-unit Display: Days, hours, minutes, and seconds Pluralization: Proper Spanish pluralization (Día/Días, Hora/Horas) Mobile Optimization: Simplified display on mobile devices End State Handling: Automatic transition when countdown ends Advanced Search System The Search.vue component implements a comprehensive search system:\nFeatures:\nMulti-category Search: Searches across activities, speakers, stands, and other content Category Tabs: Quick navigation between result categories Result Counts: Dynamic result counts per category Scroll Navigation: Smooth scrolling to category sections Carousel Display: Splide carousels for result display Loading States: Loading indicators during search Empty States: User-friendly empty state messages Dynamic Filtering System The SectionCards.vue component provides advanced filtering:\nFeatures:\nTab Navigation: Multiple filter tabs Favorites System: Save and filter favorite items Search Integration: Inline search within filters Reset Functionality: Clear all filters with one click Downloadable Resources: Download buttons for resources URL Synchronization: Filter state in URL parameters Responsive Design: Mobile accordion interface Animated Statistics The odometer.js component provides animated number counting:\nFeatures:\nScroll-triggered: Animations trigger on scroll Prefix/Suffix Support: Handles formatted numbers (e.g., \u0026ldquo;56,000+\u0026rdquo;) Mobile Optimization: Static display on mobile Smooth Animations: Odometer theme integration Development workflow The project uses Laravel Mix for asset compilation:\n// Development npm run dev // Compile assets npm run watch // Watch for changes npm run hot // Hot module replacement // Production npm run production // Optimized production build BrowserSync integration provides:\nLive reloading during development Synchronized browser testing Proxy configuration for WordPress development Performance optimizations Code splitting: Laravel Mix extracts vendor libraries Asset versioning: Automatic cache busting Image optimization: Lazy loading and responsive images Minification: Production builds are minified and optimized Tree shaking: Unused code elimination in production SVG optimization: Efficient SVG manipulation and rendering Accessibility Semantic HTML structure ARIA labels for interactive elements Keyboard navigation support Focus management in forms and modals Screen reader considerations Proper alt text for images Conclusion and final thoughts Building the ETMday frontend was an excellent opportunity to:\nMaster SVG interactions: Creating complex interactive SVG maps with dynamic tooltips and zones Implement real-time features: Building countdown timers and live updates Build advanced search: Multi-category search with filtering and categorization Handle complex state: Managing filters, favorites, and dynamic content Optimize performance: Implementing efficient animations and lazy loading Ensure scalability: Building components that handle large datasets (thousands of attendees, hundreds of activities) The project demonstrates proficiency in:\nModern JavaScript frameworks (Vue 3) SVG manipulation and interaction Real-time UI updates Advanced filtering and search systems Build tools and asset compilation (Laravel Mix, Webpack) CSS architecture and methodologies (SCSS, BEM) Component-based development Event-driven architecture The integration with WordPress/Themosis backend required careful consideration of server-side rendering, API endpoints, and content management workflows, making this a full-stack frontend implementation for a large-scale event.\nLive website: https://etmday.org/\nFigma Prototype: https://www.figma.com/proto/mt9fJ8P03M5gf0nQwcU99q/EtM-Day-2025---Dise%C3%B1o?node-id=1-2743\u0026m=dev\u0026scaling=scale-down\u0026content-scaling=fixed\u0026page-id=0%3A1\u0026starting-point-node-id=1%3A2743\n","image":"//localhost:1313/images/project/etm/home.png","permalink":"//localhost:1313/projects/etmday-entrepreneurship-event-website/","tags":["Vue 3","Laravel Mix","WordPress","Themosis","SCSS","JavaScript","Interactive Map","SVG"],"title":"ETMday: Entrepreneurship Event Website"},{"categories":["Projects"],"contents":"ISC Chile is an educational consultancy website for study abroad programs, built on top of WordPress with the Themosis framework, featuring GSAP animations, multi-step contact forms, advanced blog filtering, and comprehensive content management using Vue 2, Laravel Mix, and modern frontend technologies.\nOutline The project Design implementation The stack Frontend architecture Key features Conclusion Live website The project ISC Chile is an educational consultancy agency that has been providing study abroad advisory services since 1996. The website serves as the primary platform for showcasing various educational programs including English courses, school exchanges, group travel programs, and Pathways programs for university admission abroad.\nThe frontend development was based on a comprehensive Figma design, requiring pixel-perfect implementation of complex UI components, multi-step forms, animated statistics, and responsive layouts that work seamlessly across all devices.\nDesign implementation The entire frontend was built from a detailed Figma design, ensuring:\nPixel-perfect accuracy: Matching the design specifications precisely (as evidenced by Figma height references in SCSS) Responsive design: Implementing breakpoints and mobile-first approach Component consistency: Maintaining design system patterns throughout Interactive elements: Translating static designs into dynamic, interactive components Animation and transitions: Implementing smooth GSAP-powered animations The stack The frontend stack consists of:\nVue 2.6.12: Reactive framework for building interactive components Laravel Mix 6.0: Asset compilation and bundling SCSS: Advanced styling with a well-organized architecture Vuex 3.6.2: State management for Vue applications Vee-Validate 3.4.14: Form validation GSAP 3.12.5: Professional animation library with ScrollTrigger Axios 0.18: HTTP client for API requests Splide.js 4.1.4: Modern carousel and slider components Slick Carousel 1.8.1: Legacy carousel support LightGallery 2.7.2: Lightbox gallery functionality Odometer 0.4.8: Animated number counting Headroom.js: Header behavior on scroll V-Calendar 2.4.2: Calendar component for date selection V-Mask 2.3.0: Input masking Vue-Select 3.20.2: Custom select component jQuery 3.2: DOM manipulation and legacy support SweetAlert: Alert dialogs Frontend architecture Vue components The application features a comprehensive set of Vue 2 components:\nForm Components:\nContact.vue: Multi-step contact form with validation and reCAPTCHA ContactFormStep1.vue: First step of the contact form ContactFormStep2.vue: Second step of the contact form ContactFormStep3.vue: Third step of the contact form FormBanner.vue: Banner form component Content Components:\nBlog.vue: Blog listing with advanced filtering and search BlogArticleCard.vue \u0026amp; BlogArticleCardLoading.vue: Blog post cards with loading states ExperiencesPanel.vue: Testimonials and experiences display panel ExperiencesFiltersMobile.vue: Mobile filter component for experiences Search Components:\nSearchResults.vue: Search results display component SearchResultCardLoading.vue: Loading skeleton for search results UI Components:\nCheckboxDropdown.vue: Custom checkbox dropdown component CheckboxDropdownFieldset.vue: Fieldset wrapper for checkbox dropdowns EmptyState.vue: Empty state displays Loader.vue \u0026amp; Loading.vue: Loading indicators JavaScript components The application includes 15 specialized JavaScript components:\nAnimation Components:\ngsap.js: GSAP animations with ScrollTrigger for scroll-based reveals scrolltrigger.js: Custom scroll trigger utilities odometer.js: Animated number counting with scroll triggers UI Components:\nheader.js: Header functionality and navigation headroom.js: Header hide/show on scroll megamenu.js: Mega menu functionality mobileMenu.js: Mobile menu interactions searchbar.js: Search bar functionality floating-banner.js: Floating banner component footer.js: Footer functionality Media Components:\nvideo.js: Video player setup lightgallery.js: Lightbox gallery initialization splide.js: Carousel initialization slick.js: Legacy carousel support Interactive Components:\naccordion.js: Accordion interactions tabs.js: Tab functionality cards.js: Card interactions Utilities:\nimg-to-svg.js: SVG image conversion utility SCSS architecture The styling follows a well-organized SCSS architecture:\nscss/ ├── abstracts/ # Variables, mixins, functions │ ├── _mixins.scss │ ├── _mq.scss # Media query mixins │ └── _vendor.scss ├── base/ # Base styles and typography │ ├── _typography.scss │ ├── _colors.scss │ ├── _container.scss │ ├── _globals.scss │ └── fonts/ # Custom TWK Everett font family └── components/ # Component-specific styles └── [45 component files] Key SCSS features:\nBEM methodology: Consistent naming convention throughout Media query mixins: Using sass-mq for responsive design Modular architecture: Each component has its own SCSS file Custom typography: TWK Everett font family with multiple weights Figma references: Direct references to Figma design specifications Key features Multi-step contact form The Contact.vue component implements a sophisticated multi-step form with:\nThree-step navigation: Step-by-step form progression Form validation: Using Vee-Validate with comprehensive rules Date picker: V-Calendar integration for date selection Input masking: V-Mask for phone numbers and formatted inputs reCAPTCHA integration: Spam protection Dynamic fields: Fields that change based on user selections Loading states: Visual feedback during form submission Error handling: Comprehensive error messages and validation Form steps include:\nStep 1: Personal information and contact details Step 2: Educational background and program interests Step 3: Additional information and submission GSAP animations The gsap.js component provides professional animations:\nFeatures:\nScroll-triggered animations: Elements animate on scroll Vertical scroll reveals: Fade and slide animations Horizontal scroll reveals: Staggered animations for grid layouts Timeline management: Complex animation sequences Performance optimized: Efficient animation triggers Animation types:\nFade in with vertical movement Staggered grid animations Scroll-based reveals Smooth transitions Advanced blog system The Blog.vue component provides comprehensive blog functionality:\nFeatures:\nCategory filtering: Filter posts by category Search functionality: Real-time search across blog posts Mobile filters: Dedicated mobile filter interface Pagination: Efficient content pagination Loading states: Skeleton loading screens Empty states: User-friendly empty state messages Experiences/testimonials panel The ExperiencesPanel.vue component displays student testimonials:\nFeatures:\nFilter by type: Filter testimonials (Students/Parents) Dynamic loading: Load testimonials from API Responsive design: Mobile-optimized display Carousel integration: Splide carousel for testimonial display Animated statistics The odometer.js component provides animated number counting:\nFeatures:\nScroll-triggered: Animations trigger on scroll Smooth counting: Odometer theme integration Performance optimized: Efficient scroll detection Mobile support: Optimized for all devices Search functionality The SearchResults.vue component provides comprehensive search:\nFeatures:\nMulti-content search: Search across programs, blog posts, and pages Result categorization: Organized search results Image support: Results with and without images Tag display: Category tags for results Loading states: Skeleton loading screens Custom typography The website features a custom font family, TWK Everett, with:\nMultiple weights: From Hairline to Super Italic variants: All weights include italic versions Optimized formats: WOFF, WOFF2, and OTF formats Performance: Efficient font loading and rendering Development workflow The project uses Laravel Mix for asset compilation:\n// Development npm run dev // Compile assets npm run watch // Watch for changes npm run hot // Hot module replacement // Production npm run production // Optimized production build BrowserSync integration provides:\nLive reloading during development Synchronized browser testing Proxy configuration for WordPress development Performance optimizations Code splitting: Laravel Mix extracts vendor libraries Asset versioning: Automatic cache busting Image optimization: Lazy loading and responsive images Minification: Production builds are minified and optimized Tree shaking: Unused code elimination in production Font optimization: Efficient font loading strategies Accessibility Semantic HTML structure ARIA labels for interactive elements Keyboard navigation support Focus management in forms Screen reader considerations Proper alt text for images Conclusion and final thoughts Building the ISC Chile frontend from a Figma design was an excellent opportunity to:\nMaster Vue 2: Working with Options API, Vuex state management, and Vue 2 patterns Implement GSAP animations: Creating professional scroll-triggered animations Build complex forms: Multi-step forms with validation, date pickers, and input masking Create advanced filtering: Blog filtering with search and category selection Optimize performance: Implementing efficient animations and lazy loading Ensure design fidelity: Translating Figma designs into pixel-perfect implementations (with direct Figma references in code) The project demonstrates proficiency in:\nModern JavaScript frameworks (Vue 2) Animation libraries (GSAP, ScrollTrigger) Form validation and user experience (Vee-Validate, V-Mask, V-Calendar) Build tools and asset compilation (Laravel Mix, Webpack) CSS architecture and methodologies (SCSS, BEM) Component-based development State management (Vuex) Design system implementation The integration with WordPress/Themosis backend required careful consideration of server-side rendering, API endpoints, and content management workflows, making this a full-stack frontend implementation for an educational consultancy platform.\nLive website: https://www.iscchile.cl/\n","image":"//localhost:1313/images/project/isc-chile/homepage.webp","permalink":"//localhost:1313/projects/isc-chile-educational-consultancy-website/","tags":["Vue 2","Laravel Mix","WordPress","Themosis","SCSS","GSAP","JavaScript","Figma"],"title":"ISC Chile: Educational Consultancy Website"},{"categories":["Projects"],"contents":"Chile Nativo is a travel tour website for Patagonia experiences, built on top of WordPress with the Themosis framework, featuring a modern frontend implementation based on a Figma design using Vue 3, Laravel Mix, and a comprehensive SCSS architecture.\nOutline The project Design implementation The stack Frontend architecture Key features Conclusion Live website The project Chile Nativo is a travel company specializing in Patagonia tours, offering experiences in destinations like Torres del Paine, Tierra del Fuego, and Isla Navarino. The website serves as the primary platform for showcasing tours, managing bookings, and providing information about their travel experiences.\nThe frontend development was based on a comprehensive Figma design, requiring pixel-perfect implementation of complex UI components, interactive forms, filtering systems, and responsive layouts that work seamlessly across all devices.\nDesign implementation The entire frontend was built from a detailed Figma design, ensuring:\nPixel-perfect accuracy: Matching the design specifications precisely Responsive design: Implementing breakpoints and mobile-first approach Component consistency: Maintaining design system patterns throughout Interactive elements: Translating static designs into dynamic, interactive components Animation and transitions: Implementing smooth user experience enhancements The stack The frontend stack consists of:\nVue 3.2.4: Modern reactive framework for building interactive components Laravel Mix 6.0: Asset compilation and bundling SCSS: Advanced styling with a well-organized architecture Pinia 2.3.1: State management for Vue applications Vee-Validate 4.15.0: Form validation with Yup schemas Axios 1.6.8: HTTP client for API requests Splide.js 4.1.4: Modern carousel and slider components Headroom.js: Header behavior on scroll Plyr 3.7.8: Video player implementation SweetAlert2: Modern alert dialogs jQuery 3.7.1: Legacy support and DOM manipulation utilities Frontend architecture Vue components The application features a comprehensive set of Vue 3 components organized by functionality:\nFiltering and Search Components:\nToursFilter.vue: Advanced tour filtering with multiple criteria TourDatesFilter.vue: Date-based filtering for tour availability ToursFilterDropdown.vue \u0026amp; ToursFilterDropdownMobile.vue: Responsive filter dropdowns TestimonialsFilter.vue: Filtering system for customer testimonials NewsFilter.vue: Blog and news filtering SearchResults.vue: Search results display with pagination Form Components:\nPersonalizedTripForm.vue: Multi-step form for custom trip requests with validation ContactFormSimple.vue: Contact form with reCAPTCHA integration FormHelp.vue: Help center form FormGiftCard.vue: Gift card purchase form FormCareers.vue: Job application form NewsletterForm.vue: Newsletter subscription Card Components:\nTour.vue \u0026amp; TourLoading.vue: Tour card display with loading states TourDate.vue \u0026amp; TourDateLoading.vue: Tour date selection cards Testimonial.vue \u0026amp; TestimonialLoading.vue: Customer testimonial cards Blog.vue \u0026amp; BlogLoading.vue: Blog post cards Team.vue \u0026amp; TeamLoading.vue: Team member cards ResourceCard.vue \u0026amp; ResourceLoading.vue: Resource display cards Utility Components:\nPagination.vue: Reusable pagination component Select.vue: Custom select dropdown with search Loader.vue \u0026amp; LoaderFullScreen.vue: Loading indicators EmptyState.vue: Empty state displays ContentResources.vue: Resource content management TeamTabsFilter.vue: Tabbed team member filtering SCSS architecture The styling follows a well-organized SCSS architecture:\nscss/ ├── abstracts/ # Variables, mixins, functions │ ├── _functions.scss │ ├── _mixins.scss │ ├── _variables.scss │ ├── _mq.scss # Media query mixins │ └── _keyframes.scss ├── base/ # Base styles and typography │ ├── _typography.scss │ ├── _colors.scss │ ├── _fonts.scss │ └── _reset.scss └── components/ # Component-specific styles └── [125 component files] Key SCSS features:\nBEM methodology: Consistent naming convention throughout Media query mixins: Using sass-mq for responsive design Modular architecture: Each component has its own SCSS file Abstract layer: Reusable variables, mixins, and functions Vue transitions: Custom transition styles for Vue components JavaScript architecture The JavaScript is organized into two main entry points:\nMain application (app.js):\nInitializes core application functionality Sets up jQuery plugins and utilities Handles legacy browser support Vue application (vue/main.js):\nConfigures Vue 3 app with Pinia for state management Registers global Vue components Sets up Vee-Validate configuration Integrates third-party Vue plugins (VueTelInput, etc.) Component utilities (app/components/):\nheader.js: Header behavior and navigation footer.js: Footer functionality splide.js: Carousel initialization slick.js: Legacy carousel support accordions.js: Accordion interactions tabs.js: Tab functionality scrollTrigger.js: Scroll-based animations video.js: Video player setup sticky-sidebar.js: Sticky sidebar behavior Key features Multi-step forms The PersonalizedTripForm.vue component implements a sophisticated multi-step form with:\nStep-by-step navigation with progress indicators Form validation using Vee-Validate and Yup schemas Dynamic form fields based on user selections Phone number input with international support (VueTelInput) reCAPTCHA integration for spam protection Loading states and error handling Advanced filtering system The tour filtering system (ToursFilter.vue) provides:\nMultiple filter criteria (destination, activity type, trip type, month) Real-time filtering with URL parameter synchronization Responsive design with mobile accordion interface Custom select components with search functionality Empty states and loading indicators Integration with WordPress backend via Axios Responsive design The entire website is fully responsive with:\nMobile-first approach Breakpoint management using sass-mq Touch-friendly interactions Optimized images and assets Performance optimizations for mobile devices Performance optimizations Code splitting: Laravel Mix extracts vendor libraries Asset versioning: Automatic cache busting Image optimization: Lazy loading and responsive images Minification: Production builds are minified and optimized Tree shaking: Unused code elimination in production Accessibility Semantic HTML structure ARIA labels where appropriate Keyboard navigation support Focus management in forms Screen reader considerations Development workflow The project uses Laravel Mix for asset compilation:\n// Development npm run dev // Compile assets npm run watch // Watch for changes npm run hot // Hot module replacement // Production npm run production // Optimized production build BrowserSync integration provides:\nLive reloading during development Synchronized browser testing Proxy configuration for WordPress development Conclusion and final thoughts Building the Chile Nativo frontend from a Figma design was an excellent opportunity to:\nMaster Vue 3: Working with the Composition API, reactive systems, and modern Vue patterns Implement complex forms: Multi-step forms with validation, international phone inputs, and reCAPTCHA Build scalable architecture: Organizing 40+ Vue components and 125+ SCSS files in a maintainable structure Optimize performance: Implementing code splitting, lazy loading, and production optimizations Ensure design fidelity: Translating Figma designs into pixel-perfect implementations Handle responsive design: Creating seamless experiences across all device sizes The project demonstrates proficiency in:\nModern JavaScript frameworks (Vue 3) Build tools and asset compilation (Laravel Mix, Webpack) CSS architecture and methodologies (SCSS, BEM) Form validation and user experience Component-based development Design system implementation The integration with WordPress/Themosis backend required careful consideration of server-side rendering, API endpoints, and content management workflows, making this a full-stack frontend implementation.\nLive website: https://chilenativo.travel/\nFigma prototype: https://www.figma.com/proto/ywHPhSP1UfYUAE8eWVQv4L/Dise%C3%B1o-Desktop---Chile-Nativo?node-id=289-3912\u0026m=dev\u0026scaling=min-zoom\u0026content-scaling=fixed\u0026page-id=289%3A3911\u0026starting-point-node-id=289%3A3912\n","image":"//localhost:1313/images/project/chile-nativo/home.png","permalink":"//localhost:1313/projects/chile-nativo-patagonia-travel-website/","tags":["Vue 3","Laravel Mix","WordPress","Themosis","SCSS","JavaScript","Figma"],"title":"Chile Nativo: Patagonia Travel Website"},{"categories":["Projects"],"contents":"Rutieri is a SaaS platform built with Strapi, React Native, Typescript and other technologies.\nOutline The idea Platform features The stack The API The frontend The mobile app Conclusion Landing Page The idea Before starting to write a single line of code, it is generally a good idea to think about the problem, it\u0026rsquo;s limitations and whether or not it has already been solved by someone else (AKA competitors).\nThe problem I was looking into had to do with the way in which public and private transportation companies manage their routes, drivers and users. This process is generally carried out on paper, e.g. not digital, hence this could be problematic in case of new drivers joining the organization or in case of restricting access to data to only specific users.\nAfter a little bit of research, I could only find one platform that provides a similiar solution but for their own company.\nPlatform features and user stories The following user stories illustrates the desired features the platform should have in order to solve the aforementioned problems.\nAs an administrator user, I want to: login in the admin panel. create an organization. create routes in the organization. invite drivers and users to the organization. manage requests to join the organization. assign routes to drivers in the organization. see in real time the drivers and users currently active in the map of the different routes. As a driver, I want to: login in the mobile app. join an organization by entering the code in the search bar. see my route on the map. become visible to passengers on the road. see the passengers waiting on the road. remove my visibility and finish my run. As a passenger, I want to: login in the mobile app. join an organization by entering the code in the search bar. see the different routes of my organization in the map. search for a destination and get the available routes that pass nearby. see the drivers currently active on the routes in real time. become visible to drivers of a route. The requirements The backend requires to handle user authentication, permissions, different data structures as content types and define relations between them. It\u0026rsquo;s also necessary to synchronise passengers and drivers and view them on a map real time in the administration panel as well as in the mobile app.\nThe administration panel is a web page that fetches data from the backend as well as from the real time data provider and it\u0026rsquo;s goal is to provide a way for administrators to manage their organization and users. We\u0026rsquo;re talking about a Single Page Application built in React.\nAs for the mobile application, there isn\u0026rsquo;t a better choice nowadays than React Native and it works just fine in this case.\nThe API Since all of the features involve authentication, permissions and roles, and because there is no need to reinvent the wheel, I chose to use Strapi to build the backend for it\u0026rsquo;s simplicity, ease of use and great developer experience, whereas for realtime data, I used Firebase.\nThe instance of Strapi and the Postgres database it requires was deployed in the cloud hosting platform https://fly.io.\nStrapi is good for managing users, content that\u0026rsquo;s typically updated and fetched via CRUD API, and relations between content types.\nThe platform needs the following content types:\nOrganizations to group routes, drivers and users Routes Two user roles: drivers and users (passengers) Below are some screenshots of the overview of these content types\nAs I said before, Strapi makes the creation of these content types and the relationships between them really straightforward.\nHowever, not everything related to the API can be provided by Strapi. Some realtime features need to be addressed with other solutions, such as geolocation data in real time for drivers and users to synchronise each other, maps and the ability to search for places. Such features were implemented using Firebase, Google Maps and Google Places.\nThe frontend The platform where users are able to login as administrators and manage their organizations and users is a single page web application built in React. Among the features of this project that I think stand out are:\nState managed by Context API Interface styled with Bootstrap React Router for pages Leaflet to display the map GeoFire library to synchronise geolocation data in real time with Firebase Use of localStorage to save user session Below are some sample screenshots of how this app looks like\nThe mobile application This one is by far the most complex part of this project.\nThe project was bootstraped with Infinitered\u0026rsquo;s Ignite, which provides a great boilerplate and surely saved me of what would have been between 1-2 months of work.\nIgnite\u0026rsquo;s boilerplate includes many features out of the box, including:\nReact Native and Typescript (of course) React Navigation MobX-State-Tree for state management Expo SDK for developer experience AsyncStorage for persistence apisauce as REST client And some other libraries and features that make React Native apps super powerful and a joy to work on.\nIt consists of three screens:\nWelcome screen Login screen Map screen In the welcome screen, users are able to go to the login screen if not logged in. Otherwise, if they\u0026rsquo;re in an organisation, it shows their role and org\u0026rsquo;s information, and if they\u0026rsquo;re not, they are able to enter the organisation code and request to join as driver or as passenger.\nWelcome screens Login screens If the user is a driver in an organisation, the welcome screen also shows the route assigned to them. By tapping on it, it takes them to the map, where they can see themselves and start the tour, becoming visible to passengers on the road but being able to see passengers on the road as well.\nDrivers can finish the tour at any time by pressing the button stop.\nIf the user is a passenger in an organisation, the welcome screen shows the different routes available in the organisation. By tapping on them, they are taken to the map where they can see themselves, the route and the drivers on the road.\nPassengers are able to navigate between the available routes and search for the location they want to go to by using the search bar at the top of the map screen, filtering out the routes that pass nearby (less than 200 meters), if there are. Google Places API and turf library work together in this search process.\nPassengers become visible to drivers on the road by pressing the button wait and if they press the button again, they stop waiting and are removed from the driver\u0026rsquo;s map.\nMap screens The start/wait and finish buttons dispatch actions that update their location in firebase, so that passengers are able to see the bus on the map as it moves in real time and viceversa.\nAs for the state management, the project consists of two models and three stores from Mobx-State-Tree library: User and Route models, user-status, route-store and root-store stores.\nUser model Located in /app/models/user/user.ts\nconst OrganizationModel = types.model({ name: types.string, code: types.string, id: types.identifierNumber, drivers: types.number, rutas: types.array(RouteModel) }) const UserModel = types .model(\u0026#34;User\u0026#34;) .props({ id: types.identifierNumber, username: types.string, email: types.string, token: types.string, role: types.union(types.literal(\u0026#34;passenger\u0026#34;), types.literal(\u0026#34;driver\u0026#34;)), ruta: types.maybeNull(RouteModel), organization: types.maybeNull(OrganizationModel), pending_request: types.maybeNull(OrganizationModel), }) Route model Located in /app/models/route/route.ts\nThis model follows the GeoJSON format for routes.\nconst RouteModel = types .model(\u0026#34;Ruta\u0026#34;) .props({ id: types.identifierNumber, name: types.string, latlong: types.maybeNull(types.model({ lat: types.number, longt: types.number })), coords: types.model({ type: FeatureTypes, features: types.array(types.model({ type: types.string, geometry: types.model({ type: types.string, coordinates: types.union(types.array(types.number), types.array(types.array(types.number))) }), properties: types.model({ name: types.string }) })) }) }) user-status store Located in /app/models/user-status/user-status.ts\nThis store is responsible for managing the state of the user. It stores the user once it\u0026rsquo;s logged in and removes it when the user logs out. It also has some views to get the user key for firebase purposes, get the role and get the route in case of a driver.\nThis store has some methods that get the user location from the device\u0026rsquo;s GPS, displays the user icon on the map and sends it to firebase.\nconst UserStatusModel = types .model(\u0026#34;UserStatus\u0026#34;) .extend(withEnvironment) .props({ user: types.maybeNull(UserModel), location: types.maybeNull( types.model({latitude: types.number, longitude: types.number}) ), visibility: types.maybeNull(types.number) }) route-store store Located in /app/models/route-store/route-store.ts\nThis store is responsible for managing the state of the available routes. It stores the routes, drivers and passengers on the different routes. It also has some view methods to filter the routes that pass nearby a destination specified by the user, get passengers waiting on a given route and get drivers active in a specific route.\nThis store initializes a GeoQuery from Geofire library and listens for events to set, update and remove drivers and passengers from the map as they move.\nconst RouteStoreModel = types .model(\u0026#34;RouteStore\u0026#34;) .props({ routes: types.array(RouteModel), passengers: types.map(types.model({ key: types.identifier, location: types.array(types.number) })), drivers: types.map(types.model({ key: types.identifier, location: types.array(types.number) })), destinationAddress: types.maybeNull(types.model({ name: types.string, coords: types.array(types.number) })) }) Conclusion and final thoughts Using a CMS as the backend can make the development a lot faster than building the API from scratch and with Strapi this is specially true. On the other hand, Strapi doesn\u0026rsquo;t really make a good fit for real time applications, therefore, Firebase is the way to go in this case.\nAs of the client side, React always works very good for pretty much any kind of application, and because React Native uses React under the hood, it is so convenient for us React developers and ir works pretty good for almost any kind of application as well.\nHowever, one thing that I didn\u0026rsquo;t mention in this post was the use of Typescript; I find this quote by Brice Wilson pretty good to point out the whole purpose and motivation to learn and use (well) this powerful language and tool ecosystem:\n\u0026ldquo;You won\u0026rsquo;t have to wait for a frustrated user to report the error. All of this means that you provide value to your users faster, and that\u0026rsquo;s really what it\u0026rsquo;s all about.\u0026rdquo;\nAll in all, I got a lot of learning by building this project, both in languages/frameworks used and production stuff such as infrastructure, cloud hosting and cloud-based APIs.\nProject landing page: https://rutieri.netlify.app\n","image":"//localhost:1313/images/project/rutieri/landing/homepage.webp","permalink":"//localhost:1313/projects/saas-platform-rutieri/","tags":["Strapi","React Native","React","Typescript","Firebase"],"title":"SaaS platform: Rutieri"},{"categories":["Tutorial"],"contents":"Enable comments in a Strapi application and display them in the frontend with React\nOutline Introduction Prerequisites What is Strapi Comment Manager? Installation Configuration Display comments on the frontend Installation of Strapi Comments Client Usage of Strapi Comments Client Plugin settings Manage comments Full source code of the frontend Conclusion Introduction A comment system comes in very handy for pretty much any kind of website. In the JAMstack ecosystem, while it\u0026rsquo;s ok to rely on third party solutions hosted on their own platform such as Disqus to enable comments, you usually want to keep your content and all the stuff related to it in the same admin dashboard.\nIn this article, I\u0026rsquo;ll show you how to enable and manage comments for your content very easily using the Comment Manager plugin, and display them in your frontend application.\nPrerequisites You should have a basic understanding of the following.\nBasic knowledge of JavaScript Basic knowledge of React (OPTIONAL) Basic understanding of Strapi - get started here. Your Strapi V4 project setup What is Strapi Comment Manager? Strapi Comment Manager is a plugin that enables comments for pretty much any kind of content. It allows your users to post comments and anyone can get the comments associated with a given slug.\nWith this plugin, admin users can view and manage very easily all the comments from the Strapi administration dashboard. Within the dashboard, you will be able to delete comments and subcomments and leave replies on comments.\nInstallation Once into the Strapi project root, you can install the plugin by running the following command:\nnpm install strapi-plugin-comment-manager Next, build the project to see the new plugin in the dashboard with the following command:\nnpm run build And that\u0026rsquo;s it! If everything runs correctly, the plugin should now be installed.\nConfiguration Now you need to enable some permissions so that the frontend can access the endpoints to post and fetch comments.\nIn your Strapi admin dashboard, head over to Settings, then over to Roles under Users \u0026amp; Permissions Plugin.\nLet\u0026rsquo;s first setup the Public API; click on Public and hit the dropdown button of Comment Manager. Now check count, find and getPageSize, then hit the Save button. Below is a screenshot of a proper configuration:\nNow let\u0026rsquo;s setup the Authenticated API. Go back to Roles and click on Authenticated. Open the dropdown for Comment Manager and mark as checked the option create on both Comment and Subcomment. Below is a screenshot of a proper configuration:\nWith this configuration, the frontend should now be able to make requests to get and post comments.\nDisplay comments on the frontend The plugin exposes an API to get and post comments if you want to have fine-grained control over the workflow of your comments system and you can check the documentation on the package page, but this plugin also comes with a purpose-built React component library that makes it super easy to get up and running without getting your hands dirty.\nThis components library is called strapi-comments-client, fully supports typescript and it handles for you all of the complexity of fetching and posting comments and subcomments for every content ID that you pass to it.\nInstallation of Strapi Comments Client You will need to have installed react ^17.0.2, react-dom ^17.0.2 and react-router-dom ^5.2.0.\nInside of your React project, run this command:\nnpm install strapi-comments-client --save Usage of Strapi Comments Client Using this library is very easy!\nThis library exports three main components:\nCommentsProvider Comments CommentForm And you can import them this way:\nimport { CommentsProvider, Comments, CommentForm } from \u0026#34;strapi-comments-client\u0026#34; All you have to do is wrap your App component into the CommentsProvider component. Then you will be able to place anywhere in your app the Comments component to render a list of comments for a given content ID and the CommentForm component to render a form to post comments.\nFor example, this could be your index.js or main.js file:\nimport React from \u0026#39;react\u0026#39; import ReactDOM from \u0026#39;react-dom\u0026#39; // The address of your strapi backend instance const STRAPI = \u0026#34;http://localhost:1337\u0026#34; ReactDOM.render( \u0026lt;React.StrictMode\u0026gt; \u0026lt;CommentsProvider apiURL={STRAPI}\u0026gt; \u0026lt;App /\u0026gt; \u0026lt;/CommentsProvider\u0026gt; \u0026lt;/React.StrictMode\u0026gt;, document.getElementById(\u0026#39;root\u0026#39;) ) Where apiURL is the URL of your running Strapi application, and this property is required.\nThis way, the comments provider will do all the magic of fetching and posting comments for you!\nThis library also exports an utility React.Context to update some of the parameters for fetching and posting comments:\nimport { CommentsConfigContext } from \u0026#34;strapi-comments-client\u0026#34; This CommentsConfigContext exposes two setter functions: setUser and setContentID\nWith setContentID you can load the comments for a given content and post comments to it. It receives a single parameter of type string and must be URLized, i.e. no spaces.\nWith setUser you can set the credentials of a given user to authorize the posting of comments. It receives a single parameter of type IUser, with the following Typescript interface:\ninterface IUser { username: string, email: string, id: string, token: string // This is a JWT } It\u0026rsquo;s a little confusing but we\u0026rsquo;ll see how to use it in a component:\nconst App = () =\u0026gt; { const { setUser, setContentID } = useContext(CommentsConfigContext) // The following data should come from Strapi Users and Permissions Plugin // for authenticated requests const user = { username: \u0026#34;John Doe\u0026#34;, email: \u0026#34;jhohndoe@gmail.com\u0026#34;, id: 5, token: \u0026#34;this_should_be_a_JWT\u0026#34; } if (user) { setUser(user) } setContentID(\u0026#34;sample-content-1\u0026#34;) // Load comments for this content return ( \u0026lt;\u0026gt; { !user \u0026amp;\u0026amp; \u0026lt;Login /\u0026gt; } \u0026lt;CommentForm /\u0026gt; \u0026lt;Comments /\u0026gt; \u0026lt;/\u0026gt; ) } And that\u0026rsquo;s it!\nAfter setting the content ID through setContentID, CommentsProvider will start loading the comments for the given content ID and the CommentForm will render an input to post comments related to the given content ID if there is a user. Otherwise, it will display the message Login to post a comment.\nHere\u0026rsquo;s how the interface looks like so far:\nThere\u0026rsquo;s also a button to Leave a reply, which will open a form to post a subcomment associated with the parent comment.\nThis library exports one more component: ErrorBox\nimport { ErrorBox } from \u0026#34;strapi-comments-client\u0026#34; .It\u0026rsquo;s useful if you\u0026rsquo;d like to display error messages when things go wrong fetching or posting comments.\nYou can place this component wherever you want, for example in between the CommentForm and the Comments components.\nIf you\u0026rsquo;re wondering how this error box looks like, here you have a sample:\nGeneral settings You can customize the page size, i.e. specify how many comments are returned at once.\nIn the Strapi admin panel, head over to Settings, then select Pagination under Comment Manager Plugin.\nHere you\u0026rsquo;ll find an input to set the page size, which defaults to 10.\nManage comments Once you\u0026rsquo;ve got the plugin up an running, as users start to post comments, you can manage and reply to them as admin from the Comment Manager section of the left sidebar in the Strapi admin dashboard.\nHere you can see two tabs: one for the latest comments and one for comments grouped by content ID.\nIn both of them you can delete comments and subcomments as well as leave replies.\nExample project You can find a full working example of a React App using the Strapi Comments Client Library in this repo\nConclusion With this plugin you can enable and manage comments for any content with little effort and even use a component library to display the comments in your frontend application made with React.\nAnd that\u0026rsquo;s it! The features are pretty basic at the moment but if there\u0026rsquo;s interest, I\u0026rsquo;m willing to work on more features as well as improve the UI/UX.\n","image":"//localhost:1313/images/post/strapilogo.jpg","permalink":"//localhost:1313/blogs/how-to-enable-and-manage-comments-in-your-strapi-application/","tags":["Strapi","Strapi tutorials"],"title":"How To Enable And Manage Comments In Your Strapi Application."},{"categories":["Documentation"],"contents":"Comment Manager is a Strapi plugin to allow your users to post comments.\nWith this plugin you can enable and manage comments for your content very easily!\nRequirements You should have installed an instance of Strapi v4.x.x\nInstallation Run the following command in your project root:\nnpm install strapi-plugin-comment-manager Configurarion For your frontend to have access to the API, enable the following permissions for Comment Manager from Users \u0026amp; Permissions Plugin on your project settings:\nFor public, enable: count, find and getPageSize.\nFor authenticated, enable create on both Comment and Subcomment.\nDisplay comments on the frontend Comments can be displayed in the frontend in two ways:\nUsing the React components library strapi-comments-client (recommended) Build your custom frontend using the API API There are some Typescript interfaces that will help to get an idea of the data structures.\nComments: interface IComment { id: string, from_admin: boolean, createdAt: string, content: string, author: IAuthor | null, subcomments?: ISubcomment[] } Subcomments: interface ISubcomment { id: string, from_admin: boolean, createdAt: string, content: string, author: IAuthor | null, } Authors: IAuthor { username: string, email: string, id: string } The following endpoints are exposed to fetch and post comments and subcomments:\nGet comments for a content ID Method: GET\nPath: /api/comment-manager/comments/:slug\nOptional query parameters: start, ignoreCount\nReturns:\n{ commentsCount?: Number, comments: IComment[] } The parameter start indicates how many comments to skip. This is for pagination purposes.\nThe parameter ignoreCount indicates whether or not to return the total number of comments associated with the given slug.\nGet the number of comments associated with a given content ID Method: GET\nPath: /api/comment-manager/comments/:slug/count\nReturns:\n{ count: Number } Post a comment Method: POST\nPath: /api/comment-manager/comments/:slug\nAuthentication: Bearer token\nPayload:\n{ content: string } Returns:\n{ id: Number } Post a subcomment Method: POST\nPath: /api/comment-manager/subcomments/:parent-id\nAuthentication: Bearer token\nPayload:\n{ content: string } Returns:\n{ id: Number } Get the page size Method: GET\nPath: /api/comment-manager/page-size\nReturns:\n{ pageSize: Number } General settings The plugin allows to set how many comments are returned per page by going to the Pagination section under Comment Manager Plugin on the Settings section.\nThe default page size is 10.\nManagement of comments Admin users are able to delete comments and subcomments as well as leave replies as admins from within the plugin page of the Strapi admin dashboard.\nThe plugin interface has two tabs: one for the latest comments and one for comments by content ID.\nRoadmap and future plans The plugin is pretty basic but it can be improved with more features and a better UI/UX. Collaborations and suggestions are very welcome.\n","image":"//localhost:1313/images/post/strapilogo.jpg","permalink":"//localhost:1313/blogs/strapi-plugin-comment-manager/","tags":["Strapi","Strapi plugins"],"title":"Strapi Plugin Comment Manager"},{"categories":["Projects"],"contents":"In this post I’m going to share my experience on building a SaaS using the headless CMS Strapi as the Backend, React Native and other technologies.\nOutline Introduction What is SaaS? The problem What is Strapi? Developing features in Strapi The frontend: How to get content Conclusion Landing Page Introduction Very often, developers, product and project managers, testers and pretty much the entire team share their ideas to decide what language and which framework they\u0026rsquo;ll use to build their next project. Some considerations must be taken into account, from which in my opinion there are three that are the most important:\nDeveloper experience and ease of use Does the language and framework chosen provide a good developer experience? Is the langauge the same for the backend and frontend?\nDeadlines Is there a deadline to finish the project? if so, there is a good chance to finish the project on time if the team chooses the language they have more experience in.\nMaintainability As there will be usually more than one person working on the same part at the same time, if everything is kept organised, the whole development process will be frictionless.\nWith that in mind, developers and project managers will have a better insight on which language/framework to use.\nOther aspects should also be considered such as what the data structure will look like.\nIn my case, as it is usual, the backend of my project needs a database for users and their roles among other entities and their relations and a dashboard to allow admins to manage the data, and I was lucky to find out Strapi, as it includes a lot of these features out of the box with one single line of command to get started.\nWhat is SaaS? SaaS stands for Software-as-a-Service and it just means that a software is provided as a service in the cloud and it gives a solution to a specific problem, for which the users are willing to pay either monthly or annual subscription.\nThe problem Before starting to write a single line of code, it is generally a good idea to think about the problem, it\u0026rsquo;s limitations and whether or not it has already been solved by someone else (AKA competitors).\nThe problem I was looking into had to do with the way in which public and private transportation companies manage their routes, drivers and users. After a little bit of research, I could only find one platform that provides a similiar solution but for their own company.\nSo the platform I built needed the following content types:\nOrganizations to group routes, drivers and users Routes Two user roles: drivers and users (passengers) As I said before, Strapi makes the creation of these content types and the relationships between them really easy, but let\u0026rsquo;s first see what is Strapi and how it turns the API development into a satisfactory and fun experience.\nWhat is Strapi? Strapi is an open source headless CMS that allows developers to build complete RESTful APIs in just a couple of days instead of months. It includes a lot of useful features as plugins out of the box. Users and Roles management, Media library and an interface to create, view, edit and delete content are just some of them.\nRegarding the API, how does it makes the development faster?\nFirst of all, it enforces a specific folder structure, which helps to keep everything well organised and clean.\nSecondly, all database schemas are generated automatically and queries are made in JSON format, which really saves a lot of time.\nLastly, we can add more features to our Strapi application very easily via plugins from the marketplace.\nIt\u0026rsquo;s also worth noting that Strapi is a self-hosted CMS, which means that we can host it in whatever cloud platform we want, as well as test it locally in our computers before deploying it to the cloud.\nDeveloping features in Strapi Creating and configuring endpoints in Strapi is as straightforward as declaring a JSON in a single file:\nCreating controllers is straightforward as well:\nEvery controller gets all the data related to the request in the ctx parameter and it\u0026rsquo;s also used to send the response. This keeps everything in one place and really helps to improve the readability.\nOnce the API endpoints are defined, the next step is to enable the permissions for the specific user roles to have access to these endpoints:\nThe frontend: how to get content Since Strapi is a headless CMS, it\u0026rsquo;ll only provide content through the API. That means that the content can be consumed from anywhere. In our case, this content will be used in two applications: one for the organization owners and one for the users and drivers.\nThe application for the organization owners is a dashboard where administrators can create organizations, routes, accept drivers and users in the organization and assign routes to drivers. This is just a React Application:\nThe application for drivers and users is a mobile application built in React Native. Firebase was used to synchronise geolocation data in real time between drivers and users and display this information in a Map from Google Maps:\nConclusion Using a CMS as the backend can make the development a lot faster than building the API from scratch and with Strapi this is specially true. Furthermore, this becomes more important when building a brand-new product, as it\u0026rsquo;s usually recommended to launch as soon as possible to gather feedback from the users and validate the idea.\nProject landing page: https://rutieri.netlify.app\n","image":"//localhost:1313/images/post/03.webp","permalink":"//localhost:1313/blogs/how-i-built-a-saas-on-top-of-strapi-and-why-you-should-too/","tags":["Strapi","React Native","Typescript"],"title":"How I Built A SaaS On Top Of Strapi, And Why You Should Too"},{"categories":["Tutorial"],"contents":"Enable User Reviews in a Strapi application and display them in the frontend with React\nOutline Introduction Prerequisites What is Strapi Ratings? Installation Configuration Display user reviews on the frontend Plugin settings Manage user reviews Full source code of the frontend Conclusion Introduction Ratings systems have become a crucial part of any website with ecommerce capabilites, as they allow the users to post reviews on the items they purchase and publish their opinion to the public. A couple of reviews can make the difference between pressing the “Buy” button and moving on to the next website in the Google search results.\nIn this article, I\u0026rsquo;ll show you how to enable and manage user reviews for your content very easily using the Ratings plugin, and display them in your frontend application.\nPrerequisites First of all, you need to have a basic understanding of the following.\nBasic knowledge of JavaScript Basic knowledge of React (OPTIONAL) Basic understanding of Strapi - get started here. Your Strapi V4 project setup What is Strapi Ratings? Strapi Ratings is a plugin that gives your Strapi application the ability to manage ratings for pretty much any kind of content. It allows your users to post reviews and anyone can get the reviews associated with a given slug.\nWith this plugin, admin users can view and manage very easily all the reviews from the Strapi administration dashboard. Within the dashboard, you will be able to see reviews related to content slugs as well as delete reviews.\nInstallation Once into the Strapi project root, you can install the plugin by running the following command:\nnpm install strapi-plugin-ratings Next, build the project to see the new plugin in the dashboard with the following command:\nnpm run build And that\u0026rsquo;s it! If everything runs correctly, the plugin should now be installed.\nConfiguration Now you need to enable some permissions so that the frontend can access the endpoints to post and fetch reviews.\nIn your Strapi admin dashboard, head over to Settings, then over to Roles under Users \u0026amp; Permissions Plugin.\nLet\u0026rsquo;s first setup the Public API; click on Public and hit the dropdown button of Ratings. Now check count, find, getPageSize and getStats, then hit the Save button. Below is a screenshot of a proper configuration:\nNow let\u0026rsquo;s setup the Authenticated API. Go back to Roles and click on Authenticated. Open the dropdown for Ratings and mark as checked the options create, find and getUserReview. Below is a screenshot of a proper configuration:\nWith this configuration, the frontend should now be able to make requests to get and post user reviews.\nDisplay use reviews on the frontend The plugin exposes an API to get and post reviews if you want to have fine-grained control over the workflow of your ratings system and you can check the documentation on the package page, but this plugin also comes with a purpose-built React component library that makes it super easy to get up and running without getting your hands dirty.\nThis components library is called strapi-ratings-client, fully supports typescript and it takes care of all the complexity of fetching and posting user reviews for every content ID that you pass to it.\nInstallation of Strapi Ratings Client You will need to have installed react ^17.0.2, react-dom ^17.0.2, bootstrap ^5.1.3 and @popperjs/core^2.11.2\nInside of your React project, run this command:\nnpm install strapi-ratings-client --save Usage of Strapi Ratings Client Using this library is very easy!\nThis library exports three main components:\nReviewsProvider Reviews ReviewForm And you can import them this way:\nimport { ReviewsProvider, Reviews, ReviewForm } from \u0026#34;strapi-ratings-client\u0026#34; All you have to do is wrap your App component into the ReviewsProvider component. Then you will be able to place anywhere in your app the Reviews component to render a list of user reviews for a given content ID and the ReviewForm component to render a form to allow your users to post reviews.\nFor example, this could be your index.js or main.js file:\nimport React from \u0026#39;react\u0026#39; import ReactDOM from \u0026#39;react-dom\u0026#39; // The address of your strapi backend instance const STRAPI = \u0026#34;http://localhost:1337\u0026#34; ReactDOM.render( \u0026lt;React.StrictMode\u0026gt; \u0026lt;ReviewsProvider apiURL={STRAPI}\u0026gt; \u0026lt;App /\u0026gt; \u0026lt;/ReviewsProvider\u0026gt; \u0026lt;/React.StrictMode\u0026gt;, document.getElementById(\u0026#39;root\u0026#39;) ) Where apiURL is the URL of your running Strapi application, and this property is required.\nThis way, the ratings provider will do all the magic of fetching and posting comments for you!\nThis library also exports an utility React.Context to update some of the parameters for fetching and posting reviews:\nimport { ReviewsConfigContext } from \u0026#34;strapi-ratings-client\u0026#34; This ReviewsConfigContext exposes three setter functions: setUser, setContentID and setCanPostReview.\nWith setContentID you can load the ratings for a given content and post reviews to it. It receives a single parameter of type string and must be URLized, i.e. no spaces.\nWith setUser you can set the credentials of a given user to authorize the posting of reviews. It receives a single parameter of type IUser, with the following Typescript interface:\ninterface IUser { username: string, email: string, id: string, token: string // This is a JWT } With setCanPostReview, you can enable the user to post a review on the given content. This is useful for when you only allow a user to post a review after they purchase the product.\nIt\u0026rsquo;s a little confusing but we\u0026rsquo;ll see how to use it in a component:\nconst App = () =\u0026gt; { const { setUser, setContentID, setCanPostReview } = useContext(ReviewsConfigContext) // The following data should come from Strapi Users and Permissions Plugin // for authenticated requests. const user = { username: \u0026#34;John Doe\u0026#34;, email: \u0026#34;jhohndoe@gmail.com\u0026#34;, id: 5, token: \u0026#34;this_should_be_a_JWT\u0026#34; } if (user) { setUser(user) } setContentID(\u0026#34;sample-content-1\u0026#34;) // Load reviews for this content setCanPostReview(true) // Allow this user to post a review return ( \u0026lt;\u0026gt; { !user \u0026amp;\u0026amp; \u0026lt;Login /\u0026gt; } \u0026lt;ReviewForm /\u0026gt; \u0026lt;Reviews /\u0026gt; \u0026lt;/\u0026gt; ) } And that\u0026rsquo;s it!\nAfter setting the content ID through setContentID, ReviewsProvider will start loading the reviews for the given content ID and the ReviewForm will render an input to post a user review related to the given content ID if there is a user and he’s allowed to post a review. Otherwise, it will display the message Login to post a review or nothing at all if the user is not allowed to post a review.\nHere\u0026rsquo;s how the interface looks like so far:\nThis library exports one more component: ErrorBox\nimport { ErrorBox } from \u0026#34;strapi-ratings-client\u0026#34; .It\u0026rsquo;s useful for when you\u0026rsquo;d like to display error messages when things go wrong fetching or posting reviews.\nYou can place this component wherever you want, for example in between the ReviewForm and the Reviews components.\nIf you\u0026rsquo;re wondering how this error box looks like, here‘s a screenshot:\nGeneral settings You can customize the page size, i.e. specify how many user reviews are showed at once.\nIn the Strapi admin panel, head over to Settings, then select Pagination under Ratings Plugin.\nHere you\u0026rsquo;ll find an input to set the page size, which defaults to 10.\nManage reviews Once you\u0026rsquo;ve got the plugin up an running, as users start to post reviews, you can view them from within the Ratings section of the left sidebar in the Strapi admin dashboard.\nHere you can see two tabs: one for the latest reviews and one for reviews grouped by content ID.\nIn both of them you can delete unwanted reviews.\nExample project You can find a full working example of a React App using the Strapi Ratings Client Library in this repo: https://github.com/luisguve/strapi-ratings-client-example\nConclusion With this plugin you can enable and manage user reviews for any content with little effort and even use a library of components styled with Bootstrap to display the user reviews in your frontend.\nAnd that\u0026rsquo;s it! The features are pretty basic at the moment but if there\u0026rsquo;s interest, I\u0026rsquo;m willing to work on more features as well as improve the UI/UX.\n","image":"//localhost:1313/images/post/tutorial-ratings.webp","permalink":"//localhost:1313/blogs/how-to-enable-and-manage-user-reviews-in-your-strapi-application/","tags":["Strapi","Strapi tutorials"],"title":"How To Enable And Manage User Reviews In Your Strapi Application"},{"categories":["Documentation"],"contents":"Ratings is a Strapi plugin that allows your users to post reviews.\nEnable and manage user reviews for your content very easily!\nRequirements You should have installed an instance of Strapi v4.x.x\nInstallation Run the following command in your project root:\nnpm install strapi-plugin-ratings Then, rebuild the admin dashboard using the following command\nnpm run build Configurarion For your frontend to have access to the API, enable the following permissions for Ratings from Users \u0026amp; Permissions Plugin on your project settings:\nFor public, enable: count, find, getPageSize and getStats.\nFor authenticated, enable create, find and getUserReview.\nDisplay user reviews on the frontend Reviews can be displayed in the frontend in two ways:\nUsing the React components library strapi-ratings-client (recommended) Build your custom frontend using the API endpoints, described as follows: API There are some Typescript interfaces that will help to get an idea of the data structures.\nReviews: interface IReview { id: number, createdAt: string, comment: string | null, author: IAuthor | null, score: number, } Authors: interface IAuthor { username: string, email: string, id: number } Content Stats interface IStats { averageScore: number; reviewsCount: number | null; } The following endpoints are exposed to fetch and post reviews:\nGet reviews for a content ID Method: GET\nPath: /api/ratings/reviews/:slug\nOptional query parameters: start, ignoreCount\nReturns:\n{ reviewsCount: number, averageScore: number, userReview: IReview | null, reviews: IReview[] } The parameter start indicates how many reviews to skip. This is for pagination purposes.\nThe parameter ignoreCount indicates whether or not to return the total number of reviews associated with the given slug.\nGet review stats for a content ID Method: GET\nPath: /api/ratings/reviews/:slug/stats\nReturns:\n{ averageScore: number, reviewsCount: number | null } Get the number of reviews associated with a given content ID Method: GET\nPath: /api/ratings/reviews/:slug/count\nReturns:\n{ count: number } Post a review Method: POST\nPath: /api/ratings/reviews/:slug\nAuthentication: Bearer token\nPayload:\n{ content: string } Returns:\n{ id: number } By default, every authenticated user can post reviews on any content.\nIn order to customize this behavior, e.g. allowing or disallowing a user from posting reviews, you must extend the service userCanPostReview from whithin register function in ./src/index.js. For example:\nstrapi.service(\u0026#34;plugin::ratings.review\u0026#34;).userCanPostReview = async (user, slug) =\u0026gt; { /* Here you will check whether or not the user is allowed to post a review on this content ID and return either true or false. */ return true } Notice that userCanPostReview will receive two parameters: the user from Users \u0026amp; Permissions Plugin, containing it\u0026rsquo;s id, username, confirmed, etc., and the slug, which is a string and refers to the content ID which the review is being posted on.\nIn case this function returns false, the response of the endpoint will be 403 (forbidden) with the text User cannot post a review on this content.\nGet the page size Method: GET\nPath: /api/ratings/page-size\nReturns:\n{ pageSize: number } General settings The plugin allows to set how many reviews are returned per page by going to the Pagination section under Ratings Plugin of the Settings section.\nThe default page size is 10.\nManagement of reviews Admin users are able to delete reviews from within the plugin page of the Strapi admin dashboard.\nThe plugin interface has two tabs: one for the latest reviews and one for reviews by content ID.\nRoadmap and future plans The plugin is pretty basic but it can be improved with more features and a better UI/UX. Collaborations and suggestions are very welcome.\n","image":"//localhost:1313/images/post/ratings.webp","permalink":"//localhost:1313/blogs/strapi-plugin-ratings/","tags":["Strapi","Strapi plugins"],"title":"Strapi Plugin Ratings"},{"categories":["Projects"],"contents":"ManyLMS is an e-learning platform built on top of Strapi, React Router 7, Typescript and other technologies.\nOutline The idea Platform features The stack The API The frontend Conclusion Landing Page The idea This project doesn\u0026rsquo;t necessarily bring a huge amount of innovation on the e-learning platforms that already exists, but it\u0026rsquo;s just another way of doing this type of application.\nThe main idea is to apply a JAMstack approach in this application, where the platform is a static website, and the backend is just an API that serves static content only once to build the website and just adds the dynamism that\u0026rsquo;s necessary to allow users to authenticate, create orders, confirm payments and take courses.\nIf we compare this approach to a WordPress website, we are taking out most of the overhead that implies rendering the pages everytime a user visits them. Despite that there are plugins for caching that may improve the performance, it\u0026rsquo;s still never going to be faster and more efficient than just static content served by a CDN. That\u0026rsquo;s why React Router 7 and Headless CMSs are so popular right now.\nPlatform features and user stories The following user stories illustrates the desired features the platform should have.\nAs an administrator, I want to: login in the admin panel. create categories. create courses. upload lectures. organise courses into categories. assign lectures to courses. As a student, I want to: login in the platform. view the available courses. add courses to the shopping cart. review the shopping cart. create an order. pay with credit card or paypal. view the courses i\u0026rsquo;ve purchased in my learning page. go to the course page from my learning page and watch the videos. mark lectures as seen. come back later and resume where I left. The requirements The backend requires to handle user authentication, permissions, different data structures as content types and define relationships between them. It also requires to allow uploading videos to some third party platform that supports streaming on demand.\nThe frontend is a web platform where users can register and login, view and buy courses, leave comments and reviews and take courses.\nThe API Since all of the features involve authentication, permissions and roles, and because there is no need to reinvent the wheel, I chose to use Strapi to build the backend for it\u0026rsquo;s simplicity, ease of use and great developer experience, whereas for streaming videos on demand, I chose to use Mux.com.\nThe instance of Strapi and the Postgres database it requires was deployed in the cloud hosting platform https://fly.io.\nStrapi is good for managing users, content that\u0026rsquo;s typically updated and fetched via CRUD API, and setting up relations between content types.\nThe platform needs the following content types:\nCategory to group courses Course Lecture Module to group lectures Order Student: has many courses Student-Course: stores a student\u0026rsquo;s current lecture of a course Video Strapi makes the creation of these content types and setting up relationships between them really straightforward.\nBelow are some screenshots of these content types and the relationships between them:\nThe frontend The platform where users are able to login, view, buy and view courses is a web application built with React Router 7. Among the features of this application are:\nState managed by Context API Interface styled with Bootstrap Play streaming videos with @mux/mux-player-react library Use of localStorage to save user session Below are some sample screenshots of how this app looks like\nConclusion and final thoughts While building this project, I learned:\nHow streaming on demand works and how to use a streaming provider How to statically build websites with React Router 7 and Strapi How to setup dynamic pages in React Router 7 How to process payments with Stripe and Paypal How to build custom plugins in Strapi How to publish packages to NPM Project source codes: https://github.com/luisguve/maestro-backend\nhttps://github.com/luisguve/new-lms-remix\n","image":"//localhost:1313/images/project/manylms/frontend/course_overview.png","permalink":"//localhost:1313/projects/e-learning-platform-maestro-lms/","tags":["Strapi","React","React Router 7","Typescript","Mux"],"title":"ManyLMS: E-Learning platform"},{"categories":["Projects"],"contents":"ETMday (Emprende tu Mente) is a large-scale entrepreneurship event website built on top of WordPress with the Themosis framework, featuring an interactive SVG map, real-time countdown timers, advanced search functionality, and comprehensive content management using Vue 3, Laravel Mix, and modern frontend technologies.\nOutline The project Key features The stack Frontend architecture Interactive components Conclusion Live website The project ETMday is Chile\u0026rsquo;s premier entrepreneurship event, bringing together thousands of entrepreneurs, startups, corporates, and strategic partners. The website serves as the central hub for event information, featuring speakers, activities, stands, program schedules, and an interactive event map.\nThe frontend development required implementing complex interactive features including an SVG-based interactive map with tooltips, real-time countdown timers, advanced filtering and search systems, and dynamic content displays that handle thousands of attendees and hundreds of activities.\nKey features The website includes several sophisticated features:\nInteractive SVG Map: Custom-built interactive map with clickable zones, tooltips, and dynamic content display Real-time Countdown: Event countdown timer with automatic updates and mobile optimization Advanced Search: Multi-category search across activities, speakers, stands, and content Dynamic Filtering: Complex filtering system with tabs, favorites, and downloadable resources Animated Statistics: Odometer animations for displaying event metrics Content Management: Comprehensive card components for activities, speakers, stands, and blog posts Form Handling: Multi-step forms with validation using Vee-Validate Lightbox Galleries: Image galleries with LightGallery integration Responsive Design: Fully responsive design optimized for all devices The stack The frontend stack consists of:\nVue 3.2.4: Modern reactive framework for building interactive components Laravel Mix 6.0: Asset compilation and bundling SCSS: Advanced styling with organized architecture Vee-Validate 4.15.0: Form validation with Yup schemas Axios 1.6.8: HTTP client for API requests Splide.js 4.1.4: Modern carousel and slider components LightGallery 2.8.3: Lightbox gallery functionality Odometer 0.4.8: Animated number counting Headroom.js: Header behavior on scroll jQuery 3.7.1: DOM manipulation and legacy support SweetAlert2: Modern alert dialogs GLightbox 3.3.1: Alternative lightbox solution Frontend architecture Vue components The application features a comprehensive set of Vue 3 components:\nCard Components:\ncards/activities.vue: Activity cards with favorites functionality cards/speakers.vue: Speaker cards with modal details cards/stands.vue: Stand/exhibitor cards cards/blog.vue: Blog post cards cards/shortcut.vue: Quick access shortcut cards Functional Components:\nSectionCards.vue: Main section component with tabs, filtering, and card display Search.vue: Advanced search component with multi-category results Form.vue: Dynamic form component with validation FormCalendar.vue: Calendar form component CustomFilter.vue: Reusable filter component CustomSelect.vue: Custom select dropdown Pagination.vue: Pagination component JavaScript components The application includes 17 specialized JavaScript components:\nInteractive Features:\ninteractiveMap.js: SVG map interaction with tooltips, zones, and dynamic content countdown.js: Real-time countdown timer with automatic updates odometer.js: Animated number counting with scroll triggers map.js: Map zone interactions and modal displays UI Components:\nheader.js: Header functionality and navigation headroom.js: Header hide/show on scroll accordion.js: Accordion interactions tabs.js: Tab functionality cards.js: Card interactions and modals siteModals.js: Modal management system UI.js: General UI utilities Media Components:\nvideo.js: Video player setup lightgallery.js: Lightbox gallery initialization splide.js: Carousel initialization slick.js: Legacy carousel support Utilities:\nscrollTrigger.js: Scroll-based animations imgToSvg.js: SVG image conversion utility SCSS architecture The styling follows a well-organized SCSS architecture:\nscss/ ├── abstracts/ # Variables, mixins, functions │ ├── _functions.scss │ ├── _mixins.scss │ ├── _variables.scss │ ├── _mq.scss # Media query mixins │ └── _keyframes.scss ├── base/ # Base styles and typography │ ├── _typography.scss │ ├── _container.scss │ └── _reset.scss └── components/ # Component-specific styles └── [52 component files] Key SCSS features:\nBEM methodology: Consistent naming convention Media query mixins: Using sass-mq for responsive design Modular architecture: Each component has its own SCSS file Component organization: 52 component-specific SCSS files Interactive components Interactive SVG Map The interactiveMap.js component implements a sophisticated SVG-based interactive map:\nFeatures:\nSVG Tooltips: Dynamically generated tooltips with text wrapping Zone Interactions: Clickable zones with modal displays Point Markers: Interactive points with icons and labels Dynamic Content: Content loaded based on zone/point selection Responsive Design: Optimized for mobile and desktop Technical Implementation:\nSVG namespace manipulation for tooltip creation Text wrapping algorithm for tooltip content Path generation for tooltip shapes with rounded corners Event delegation for zone and point interactions Smooth animations and transitions Real-time Countdown The countdown.js component provides a real-time countdown timer:\nFeatures:\nAutomatic Updates: Updates every second Multi-unit Display: Days, hours, minutes, and seconds Pluralization: Proper Spanish pluralization (Día/Días, Hora/Horas) Mobile Optimization: Simplified display on mobile devices End State Handling: Automatic transition when countdown ends Advanced Search System The Search.vue component implements a comprehensive search system:\nFeatures:\nMulti-category Search: Searches across activities, speakers, stands, and other content Category Tabs: Quick navigation between result categories Result Counts: Dynamic result counts per category Scroll Navigation: Smooth scrolling to category sections Carousel Display: Splide carousels for result display Loading States: Loading indicators during search Empty States: User-friendly empty state messages Dynamic Filtering System The SectionCards.vue component provides advanced filtering:\nFeatures:\nTab Navigation: Multiple filter tabs Favorites System: Save and filter favorite items Search Integration: Inline search within filters Reset Functionality: Clear all filters with one click Downloadable Resources: Download buttons for resources URL Synchronization: Filter state in URL parameters Responsive Design: Mobile accordion interface Animated Statistics The odometer.js component provides animated number counting:\nFeatures:\nScroll-triggered: Animations trigger on scroll Prefix/Suffix Support: Handles formatted numbers (e.g., \u0026ldquo;56,000+\u0026rdquo;) Mobile Optimization: Static display on mobile Smooth Animations: Odometer theme integration Development workflow The project uses Laravel Mix for asset compilation:\n// Development npm run dev // Compile assets npm run watch // Watch for changes npm run hot // Hot module replacement // Production npm run production // Optimized production build BrowserSync integration provides:\nLive reloading during development Synchronized browser testing Proxy configuration for WordPress development Performance optimizations Code splitting: Laravel Mix extracts vendor libraries Asset versioning: Automatic cache busting Image optimization: Lazy loading and responsive images Minification: Production builds are minified and optimized Tree shaking: Unused code elimination in production SVG optimization: Efficient SVG manipulation and rendering Accessibility Semantic HTML structure ARIA labels for interactive elements Keyboard navigation support Focus management in forms and modals Screen reader considerations Proper alt text for images Conclusion and final thoughts Building the ETMday frontend was an excellent opportunity to:\nMaster SVG interactions: Creating complex interactive SVG maps with dynamic tooltips and zones Implement real-time features: Building countdown timers and live updates Build advanced search: Multi-category search with filtering and categorization Handle complex state: Managing filters, favorites, and dynamic content Optimize performance: Implementing efficient animations and lazy loading Ensure scalability: Building components that handle large datasets (thousands of attendees, hundreds of activities) The project demonstrates proficiency in:\nModern JavaScript frameworks (Vue 3) SVG manipulation and interaction Real-time UI updates Advanced filtering and search systems Build tools and asset compilation (Laravel Mix, Webpack) CSS architecture and methodologies (SCSS, BEM) Component-based development Event-driven architecture The integration with WordPress/Themosis backend required careful consideration of server-side rendering, API endpoints, and content management workflows, making this a full-stack frontend implementation for a large-scale event.\nLive website: https://etmday.org/\nFigma Prototype: https://www.figma.com/proto/mt9fJ8P03M5gf0nQwcU99q/EtM-Day-2025---Dise%C3%B1o?node-id=1-2743\u0026m=dev\u0026scaling=scale-down\u0026content-scaling=fixed\u0026page-id=0%3A1\u0026starting-point-node-id=1%3A2743\n","image":"//localhost:1313/images/project/etm/home.png","permalink":"//localhost:1313/projects/etmday-entrepreneurship-event-website/","tags":["Vue 3","Laravel Mix","WordPress","Themosis","SCSS","JavaScript","Interactive Map","SVG"],"title":"ETMday: Entrepreneurship Event Website"},{"categories":["Projects"],"contents":"ISC Chile is an educational consultancy website for study abroad programs, built on top of WordPress with the Themosis framework, featuring GSAP animations, multi-step contact forms, advanced blog filtering, and comprehensive content management using Vue 2, Laravel Mix, and modern frontend technologies.\nOutline The project Design implementation The stack Frontend architecture Key features Conclusion Live website The project ISC Chile is an educational consultancy agency that has been providing study abroad advisory services since 1996. The website serves as the primary platform for showcasing various educational programs including English courses, school exchanges, group travel programs, and Pathways programs for university admission abroad.\nThe frontend development was based on a comprehensive Figma design, requiring pixel-perfect implementation of complex UI components, multi-step forms, animated statistics, and responsive layouts that work seamlessly across all devices.\nDesign implementation The entire frontend was built from a detailed Figma design, ensuring:\nPixel-perfect accuracy: Matching the design specifications precisely (as evidenced by Figma height references in SCSS) Responsive design: Implementing breakpoints and mobile-first approach Component consistency: Maintaining design system patterns throughout Interactive elements: Translating static designs into dynamic, interactive components Animation and transitions: Implementing smooth GSAP-powered animations The stack The frontend stack consists of:\nVue 2.6.12: Reactive framework for building interactive components Laravel Mix 6.0: Asset compilation and bundling SCSS: Advanced styling with a well-organized architecture Vuex 3.6.2: State management for Vue applications Vee-Validate 3.4.14: Form validation GSAP 3.12.5: Professional animation library with ScrollTrigger Axios 0.18: HTTP client for API requests Splide.js 4.1.4: Modern carousel and slider components Slick Carousel 1.8.1: Legacy carousel support LightGallery 2.7.2: Lightbox gallery functionality Odometer 0.4.8: Animated number counting Headroom.js: Header behavior on scroll V-Calendar 2.4.2: Calendar component for date selection V-Mask 2.3.0: Input masking Vue-Select 3.20.2: Custom select component jQuery 3.2: DOM manipulation and legacy support SweetAlert: Alert dialogs Frontend architecture Vue components The application features a comprehensive set of Vue 2 components:\nForm Components:\nContact.vue: Multi-step contact form with validation and reCAPTCHA ContactFormStep1.vue: First step of the contact form ContactFormStep2.vue: Second step of the contact form ContactFormStep3.vue: Third step of the contact form FormBanner.vue: Banner form component Content Components:\nBlog.vue: Blog listing with advanced filtering and search BlogArticleCard.vue \u0026amp; BlogArticleCardLoading.vue: Blog post cards with loading states ExperiencesPanel.vue: Testimonials and experiences display panel ExperiencesFiltersMobile.vue: Mobile filter component for experiences Search Components:\nSearchResults.vue: Search results display component SearchResultCardLoading.vue: Loading skeleton for search results UI Components:\nCheckboxDropdown.vue: Custom checkbox dropdown component CheckboxDropdownFieldset.vue: Fieldset wrapper for checkbox dropdowns EmptyState.vue: Empty state displays Loader.vue \u0026amp; Loading.vue: Loading indicators JavaScript components The application includes 15 specialized JavaScript components:\nAnimation Components:\ngsap.js: GSAP animations with ScrollTrigger for scroll-based reveals scrolltrigger.js: Custom scroll trigger utilities odometer.js: Animated number counting with scroll triggers UI Components:\nheader.js: Header functionality and navigation headroom.js: Header hide/show on scroll megamenu.js: Mega menu functionality mobileMenu.js: Mobile menu interactions searchbar.js: Search bar functionality floating-banner.js: Floating banner component footer.js: Footer functionality Media Components:\nvideo.js: Video player setup lightgallery.js: Lightbox gallery initialization splide.js: Carousel initialization slick.js: Legacy carousel support Interactive Components:\naccordion.js: Accordion interactions tabs.js: Tab functionality cards.js: Card interactions Utilities:\nimg-to-svg.js: SVG image conversion utility SCSS architecture The styling follows a well-organized SCSS architecture:\nscss/ ├── abstracts/ # Variables, mixins, functions │ ├── _mixins.scss │ ├── _mq.scss # Media query mixins │ └── _vendor.scss ├── base/ # Base styles and typography │ ├── _typography.scss │ ├── _colors.scss │ ├── _container.scss │ ├── _globals.scss │ └── fonts/ # Custom TWK Everett font family └── components/ # Component-specific styles └── [45 component files] Key SCSS features:\nBEM methodology: Consistent naming convention throughout Media query mixins: Using sass-mq for responsive design Modular architecture: Each component has its own SCSS file Custom typography: TWK Everett font family with multiple weights Figma references: Direct references to Figma design specifications Key features Multi-step contact form The Contact.vue component implements a sophisticated multi-step form with:\nThree-step navigation: Step-by-step form progression Form validation: Using Vee-Validate with comprehensive rules Date picker: V-Calendar integration for date selection Input masking: V-Mask for phone numbers and formatted inputs reCAPTCHA integration: Spam protection Dynamic fields: Fields that change based on user selections Loading states: Visual feedback during form submission Error handling: Comprehensive error messages and validation Form steps include:\nStep 1: Personal information and contact details Step 2: Educational background and program interests Step 3: Additional information and submission GSAP animations The gsap.js component provides professional animations:\nFeatures:\nScroll-triggered animations: Elements animate on scroll Vertical scroll reveals: Fade and slide animations Horizontal scroll reveals: Staggered animations for grid layouts Timeline management: Complex animation sequences Performance optimized: Efficient animation triggers Animation types:\nFade in with vertical movement Staggered grid animations Scroll-based reveals Smooth transitions Advanced blog system The Blog.vue component provides comprehensive blog functionality:\nFeatures:\nCategory filtering: Filter posts by category Search functionality: Real-time search across blog posts Mobile filters: Dedicated mobile filter interface Pagination: Efficient content pagination Loading states: Skeleton loading screens Empty states: User-friendly empty state messages Experiences/testimonials panel The ExperiencesPanel.vue component displays student testimonials:\nFeatures:\nFilter by type: Filter testimonials (Students/Parents) Dynamic loading: Load testimonials from API Responsive design: Mobile-optimized display Carousel integration: Splide carousel for testimonial display Animated statistics The odometer.js component provides animated number counting:\nFeatures:\nScroll-triggered: Animations trigger on scroll Smooth counting: Odometer theme integration Performance optimized: Efficient scroll detection Mobile support: Optimized for all devices Search functionality The SearchResults.vue component provides comprehensive search:\nFeatures:\nMulti-content search: Search across programs, blog posts, and pages Result categorization: Organized search results Image support: Results with and without images Tag display: Category tags for results Loading states: Skeleton loading screens Custom typography The website features a custom font family, TWK Everett, with:\nMultiple weights: From Hairline to Super Italic variants: All weights include italic versions Optimized formats: WOFF, WOFF2, and OTF formats Performance: Efficient font loading and rendering Development workflow The project uses Laravel Mix for asset compilation:\n// Development npm run dev // Compile assets npm run watch // Watch for changes npm run hot // Hot module replacement // Production npm run production // Optimized production build BrowserSync integration provides:\nLive reloading during development Synchronized browser testing Proxy configuration for WordPress development Performance optimizations Code splitting: Laravel Mix extracts vendor libraries Asset versioning: Automatic cache busting Image optimization: Lazy loading and responsive images Minification: Production builds are minified and optimized Tree shaking: Unused code elimination in production Font optimization: Efficient font loading strategies Accessibility Semantic HTML structure ARIA labels for interactive elements Keyboard navigation support Focus management in forms Screen reader considerations Proper alt text for images Conclusion and final thoughts Building the ISC Chile frontend from a Figma design was an excellent opportunity to:\nMaster Vue 2: Working with Options API, Vuex state management, and Vue 2 patterns Implement GSAP animations: Creating professional scroll-triggered animations Build complex forms: Multi-step forms with validation, date pickers, and input masking Create advanced filtering: Blog filtering with search and category selection Optimize performance: Implementing efficient animations and lazy loading Ensure design fidelity: Translating Figma designs into pixel-perfect implementations (with direct Figma references in code) The project demonstrates proficiency in:\nModern JavaScript frameworks (Vue 2) Animation libraries (GSAP, ScrollTrigger) Form validation and user experience (Vee-Validate, V-Mask, V-Calendar) Build tools and asset compilation (Laravel Mix, Webpack) CSS architecture and methodologies (SCSS, BEM) Component-based development State management (Vuex) Design system implementation The integration with WordPress/Themosis backend required careful consideration of server-side rendering, API endpoints, and content management workflows, making this a full-stack frontend implementation for an educational consultancy platform.\nLive website: https://www.iscchile.cl/\n","image":"//localhost:1313/images/project/isc-chile/homepage.webp","permalink":"//localhost:1313/projects/isc-chile-educational-consultancy-website/","tags":["Vue 2","Laravel Mix","WordPress","Themosis","SCSS","GSAP","JavaScript","Figma"],"title":"ISC Chile: Educational Consultancy Website"},{"categories":["Projects"],"contents":"Chile Nativo is a travel tour website for Patagonia experiences, built on top of WordPress with the Themosis framework, featuring a modern frontend implementation based on a Figma design using Vue 3, Laravel Mix, and a comprehensive SCSS architecture.\nOutline The project Design implementation The stack Frontend architecture Key features Conclusion Live website The project Chile Nativo is a travel company specializing in Patagonia tours, offering experiences in destinations like Torres del Paine, Tierra del Fuego, and Isla Navarino. The website serves as the primary platform for showcasing tours, managing bookings, and providing information about their travel experiences.\nThe frontend development was based on a comprehensive Figma design, requiring pixel-perfect implementation of complex UI components, interactive forms, filtering systems, and responsive layouts that work seamlessly across all devices.\nDesign implementation The entire frontend was built from a detailed Figma design, ensuring:\nPixel-perfect accuracy: Matching the design specifications precisely Responsive design: Implementing breakpoints and mobile-first approach Component consistency: Maintaining design system patterns throughout Interactive elements: Translating static designs into dynamic, interactive components Animation and transitions: Implementing smooth user experience enhancements The stack The frontend stack consists of:\nVue 3.2.4: Modern reactive framework for building interactive components Laravel Mix 6.0: Asset compilation and bundling SCSS: Advanced styling with a well-organized architecture Pinia 2.3.1: State management for Vue applications Vee-Validate 4.15.0: Form validation with Yup schemas Axios 1.6.8: HTTP client for API requests Splide.js 4.1.4: Modern carousel and slider components Headroom.js: Header behavior on scroll Plyr 3.7.8: Video player implementation SweetAlert2: Modern alert dialogs jQuery 3.7.1: Legacy support and DOM manipulation utilities Frontend architecture Vue components The application features a comprehensive set of Vue 3 components organized by functionality:\nFiltering and Search Components:\nToursFilter.vue: Advanced tour filtering with multiple criteria TourDatesFilter.vue: Date-based filtering for tour availability ToursFilterDropdown.vue \u0026amp; ToursFilterDropdownMobile.vue: Responsive filter dropdowns TestimonialsFilter.vue: Filtering system for customer testimonials NewsFilter.vue: Blog and news filtering SearchResults.vue: Search results display with pagination Form Components:\nPersonalizedTripForm.vue: Multi-step form for custom trip requests with validation ContactFormSimple.vue: Contact form with reCAPTCHA integration FormHelp.vue: Help center form FormGiftCard.vue: Gift card purchase form FormCareers.vue: Job application form NewsletterForm.vue: Newsletter subscription Card Components:\nTour.vue \u0026amp; TourLoading.vue: Tour card display with loading states TourDate.vue \u0026amp; TourDateLoading.vue: Tour date selection cards Testimonial.vue \u0026amp; TestimonialLoading.vue: Customer testimonial cards Blog.vue \u0026amp; BlogLoading.vue: Blog post cards Team.vue \u0026amp; TeamLoading.vue: Team member cards ResourceCard.vue \u0026amp; ResourceLoading.vue: Resource display cards Utility Components:\nPagination.vue: Reusable pagination component Select.vue: Custom select dropdown with search Loader.vue \u0026amp; LoaderFullScreen.vue: Loading indicators EmptyState.vue: Empty state displays ContentResources.vue: Resource content management TeamTabsFilter.vue: Tabbed team member filtering SCSS architecture The styling follows a well-organized SCSS architecture:\nscss/ ├── abstracts/ # Variables, mixins, functions │ ├── _functions.scss │ ├── _mixins.scss │ ├── _variables.scss │ ├── _mq.scss # Media query mixins │ └── _keyframes.scss ├── base/ # Base styles and typography │ ├── _typography.scss │ ├── _colors.scss │ ├── _fonts.scss │ └── _reset.scss └── components/ # Component-specific styles └── [125 component files] Key SCSS features:\nBEM methodology: Consistent naming convention throughout Media query mixins: Using sass-mq for responsive design Modular architecture: Each component has its own SCSS file Abstract layer: Reusable variables, mixins, and functions Vue transitions: Custom transition styles for Vue components JavaScript architecture The JavaScript is organized into two main entry points:\nMain application (app.js):\nInitializes core application functionality Sets up jQuery plugins and utilities Handles legacy browser support Vue application (vue/main.js):\nConfigures Vue 3 app with Pinia for state management Registers global Vue components Sets up Vee-Validate configuration Integrates third-party Vue plugins (VueTelInput, etc.) Component utilities (app/components/):\nheader.js: Header behavior and navigation footer.js: Footer functionality splide.js: Carousel initialization slick.js: Legacy carousel support accordions.js: Accordion interactions tabs.js: Tab functionality scrollTrigger.js: Scroll-based animations video.js: Video player setup sticky-sidebar.js: Sticky sidebar behavior Key features Multi-step forms The PersonalizedTripForm.vue component implements a sophisticated multi-step form with:\nStep-by-step navigation with progress indicators Form validation using Vee-Validate and Yup schemas Dynamic form fields based on user selections Phone number input with international support (VueTelInput) reCAPTCHA integration for spam protection Loading states and error handling Advanced filtering system The tour filtering system (ToursFilter.vue) provides:\nMultiple filter criteria (destination, activity type, trip type, month) Real-time filtering with URL parameter synchronization Responsive design with mobile accordion interface Custom select components with search functionality Empty states and loading indicators Integration with WordPress backend via Axios Responsive design The entire website is fully responsive with:\nMobile-first approach Breakpoint management using sass-mq Touch-friendly interactions Optimized images and assets Performance optimizations for mobile devices Performance optimizations Code splitting: Laravel Mix extracts vendor libraries Asset versioning: Automatic cache busting Image optimization: Lazy loading and responsive images Minification: Production builds are minified and optimized Tree shaking: Unused code elimination in production Accessibility Semantic HTML structure ARIA labels where appropriate Keyboard navigation support Focus management in forms Screen reader considerations Development workflow The project uses Laravel Mix for asset compilation:\n// Development npm run dev // Compile assets npm run watch // Watch for changes npm run hot // Hot module replacement // Production npm run production // Optimized production build BrowserSync integration provides:\nLive reloading during development Synchronized browser testing Proxy configuration for WordPress development Conclusion and final thoughts Building the Chile Nativo frontend from a Figma design was an excellent opportunity to:\nMaster Vue 3: Working with the Composition API, reactive systems, and modern Vue patterns Implement complex forms: Multi-step forms with validation, international phone inputs, and reCAPTCHA Build scalable architecture: Organizing 40+ Vue components and 125+ SCSS files in a maintainable structure Optimize performance: Implementing code splitting, lazy loading, and production optimizations Ensure design fidelity: Translating Figma designs into pixel-perfect implementations Handle responsive design: Creating seamless experiences across all device sizes The project demonstrates proficiency in:\nModern JavaScript frameworks (Vue 3) Build tools and asset compilation (Laravel Mix, Webpack) CSS architecture and methodologies (SCSS, BEM) Form validation and user experience Component-based development Design system implementation The integration with WordPress/Themosis backend required careful consideration of server-side rendering, API endpoints, and content management workflows, making this a full-stack frontend implementation.\nLive website: https://chilenativo.travel/\nFigma prototype: https://www.figma.com/proto/ywHPhSP1UfYUAE8eWVQv4L/Dise%C3%B1o-Desktop---Chile-Nativo?node-id=289-3912\u0026m=dev\u0026scaling=min-zoom\u0026content-scaling=fixed\u0026page-id=289%3A3911\u0026starting-point-node-id=289%3A3912\n","image":"//localhost:1313/images/project/chile-nativo/home.png","permalink":"//localhost:1313/projects/chile-nativo-patagonia-travel-website/","tags":["Vue 3","Laravel Mix","WordPress","Themosis","SCSS","JavaScript","Figma"],"title":"Chile Nativo: Patagonia Travel Website"},{"categories":["Projects"],"contents":"Rutieri is a SaaS platform built with Strapi, React Native, Typescript and other technologies.\nOutline The idea Platform features The stack The API The frontend The mobile app Conclusion Landing Page The idea Before starting to write a single line of code, it is generally a good idea to think about the problem, it\u0026rsquo;s limitations and whether or not it has already been solved by someone else (AKA competitors).\nThe problem I was looking into had to do with the way in which public and private transportation companies manage their routes, drivers and users. This process is generally carried out on paper, e.g. not digital, hence this could be problematic in case of new drivers joining the organization or in case of restricting access to data to only specific users.\nAfter a little bit of research, I could only find one platform that provides a similiar solution but for their own company.\nPlatform features and user stories The following user stories illustrates the desired features the platform should have in order to solve the aforementioned problems.\nAs an administrator user, I want to: login in the admin panel. create an organization. create routes in the organization. invite drivers and users to the organization. manage requests to join the organization. assign routes to drivers in the organization. see in real time the drivers and users currently active in the map of the different routes. As a driver, I want to: login in the mobile app. join an organization by entering the code in the search bar. see my route on the map. become visible to passengers on the road. see the passengers waiting on the road. remove my visibility and finish my run. As a passenger, I want to: login in the mobile app. join an organization by entering the code in the search bar. see the different routes of my organization in the map. search for a destination and get the available routes that pass nearby. see the drivers currently active on the routes in real time. become visible to drivers of a route. The requirements The backend requires to handle user authentication, permissions, different data structures as content types and define relations between them. It\u0026rsquo;s also necessary to synchronise passengers and drivers and view them on a map real time in the administration panel as well as in the mobile app.\nThe administration panel is a web page that fetches data from the backend as well as from the real time data provider and it\u0026rsquo;s goal is to provide a way for administrators to manage their organization and users. We\u0026rsquo;re talking about a Single Page Application built in React.\nAs for the mobile application, there isn\u0026rsquo;t a better choice nowadays than React Native and it works just fine in this case.\nThe API Since all of the features involve authentication, permissions and roles, and because there is no need to reinvent the wheel, I chose to use Strapi to build the backend for it\u0026rsquo;s simplicity, ease of use and great developer experience, whereas for realtime data, I used Firebase.\nThe instance of Strapi and the Postgres database it requires was deployed in the cloud hosting platform https://fly.io.\nStrapi is good for managing users, content that\u0026rsquo;s typically updated and fetched via CRUD API, and relations between content types.\nThe platform needs the following content types:\nOrganizations to group routes, drivers and users Routes Two user roles: drivers and users (passengers) Below are some screenshots of the overview of these content types\nAs I said before, Strapi makes the creation of these content types and the relationships between them really straightforward.\nHowever, not everything related to the API can be provided by Strapi. Some realtime features need to be addressed with other solutions, such as geolocation data in real time for drivers and users to synchronise each other, maps and the ability to search for places. Such features were implemented using Firebase, Google Maps and Google Places.\nThe frontend The platform where users are able to login as administrators and manage their organizations and users is a single page web application built in React. Among the features of this project that I think stand out are:\nState managed by Context API Interface styled with Bootstrap React Router for pages Leaflet to display the map GeoFire library to synchronise geolocation data in real time with Firebase Use of localStorage to save user session Below are some sample screenshots of how this app looks like\nThe mobile application This one is by far the most complex part of this project.\nThe project was bootstraped with Infinitered\u0026rsquo;s Ignite, which provides a great boilerplate and surely saved me of what would have been between 1-2 months of work.\nIgnite\u0026rsquo;s boilerplate includes many features out of the box, including:\nReact Native and Typescript (of course) React Navigation MobX-State-Tree for state management Expo SDK for developer experience AsyncStorage for persistence apisauce as REST client And some other libraries and features that make React Native apps super powerful and a joy to work on.\nIt consists of three screens:\nWelcome screen Login screen Map screen In the welcome screen, users are able to go to the login screen if not logged in. Otherwise, if they\u0026rsquo;re in an organisation, it shows their role and org\u0026rsquo;s information, and if they\u0026rsquo;re not, they are able to enter the organisation code and request to join as driver or as passenger.\nWelcome screens Login screens If the user is a driver in an organisation, the welcome screen also shows the route assigned to them. By tapping on it, it takes them to the map, where they can see themselves and start the tour, becoming visible to passengers on the road but being able to see passengers on the road as well.\nDrivers can finish the tour at any time by pressing the button stop.\nIf the user is a passenger in an organisation, the welcome screen shows the different routes available in the organisation. By tapping on them, they are taken to the map where they can see themselves, the route and the drivers on the road.\nPassengers are able to navigate between the available routes and search for the location they want to go to by using the search bar at the top of the map screen, filtering out the routes that pass nearby (less than 200 meters), if there are. Google Places API and turf library work together in this search process.\nPassengers become visible to drivers on the road by pressing the button wait and if they press the button again, they stop waiting and are removed from the driver\u0026rsquo;s map.\nMap screens The start/wait and finish buttons dispatch actions that update their location in firebase, so that passengers are able to see the bus on the map as it moves in real time and viceversa.\nAs for the state management, the project consists of two models and three stores from Mobx-State-Tree library: User and Route models, user-status, route-store and root-store stores.\nUser model Located in /app/models/user/user.ts\nconst OrganizationModel = types.model({ name: types.string, code: types.string, id: types.identifierNumber, drivers: types.number, rutas: types.array(RouteModel) }) const UserModel = types .model(\u0026#34;User\u0026#34;) .props({ id: types.identifierNumber, username: types.string, email: types.string, token: types.string, role: types.union(types.literal(\u0026#34;passenger\u0026#34;), types.literal(\u0026#34;driver\u0026#34;)), ruta: types.maybeNull(RouteModel), organization: types.maybeNull(OrganizationModel), pending_request: types.maybeNull(OrganizationModel), }) Route model Located in /app/models/route/route.ts\nThis model follows the GeoJSON format for routes.\nconst RouteModel = types .model(\u0026#34;Ruta\u0026#34;) .props({ id: types.identifierNumber, name: types.string, latlong: types.maybeNull(types.model({ lat: types.number, longt: types.number })), coords: types.model({ type: FeatureTypes, features: types.array(types.model({ type: types.string, geometry: types.model({ type: types.string, coordinates: types.union(types.array(types.number), types.array(types.array(types.number))) }), properties: types.model({ name: types.string }) })) }) }) user-status store Located in /app/models/user-status/user-status.ts\nThis store is responsible for managing the state of the user. It stores the user once it\u0026rsquo;s logged in and removes it when the user logs out. It also has some views to get the user key for firebase purposes, get the role and get the route in case of a driver.\nThis store has some methods that get the user location from the device\u0026rsquo;s GPS, displays the user icon on the map and sends it to firebase.\nconst UserStatusModel = types .model(\u0026#34;UserStatus\u0026#34;) .extend(withEnvironment) .props({ user: types.maybeNull(UserModel), location: types.maybeNull( types.model({latitude: types.number, longitude: types.number}) ), visibility: types.maybeNull(types.number) }) route-store store Located in /app/models/route-store/route-store.ts\nThis store is responsible for managing the state of the available routes. It stores the routes, drivers and passengers on the different routes. It also has some view methods to filter the routes that pass nearby a destination specified by the user, get passengers waiting on a given route and get drivers active in a specific route.\nThis store initializes a GeoQuery from Geofire library and listens for events to set, update and remove drivers and passengers from the map as they move.\nconst RouteStoreModel = types .model(\u0026#34;RouteStore\u0026#34;) .props({ routes: types.array(RouteModel), passengers: types.map(types.model({ key: types.identifier, location: types.array(types.number) })), drivers: types.map(types.model({ key: types.identifier, location: types.array(types.number) })), destinationAddress: types.maybeNull(types.model({ name: types.string, coords: types.array(types.number) })) }) Conclusion and final thoughts Using a CMS as the backend can make the development a lot faster than building the API from scratch and with Strapi this is specially true. On the other hand, Strapi doesn\u0026rsquo;t really make a good fit for real time applications, therefore, Firebase is the way to go in this case.\nAs of the client side, React always works very good for pretty much any kind of application, and because React Native uses React under the hood, it is so convenient for us React developers and ir works pretty good for almost any kind of application as well.\nHowever, one thing that I didn\u0026rsquo;t mention in this post was the use of Typescript; I find this quote by Brice Wilson pretty good to point out the whole purpose and motivation to learn and use (well) this powerful language and tool ecosystem:\n\u0026ldquo;You won\u0026rsquo;t have to wait for a frustrated user to report the error. All of this means that you provide value to your users faster, and that\u0026rsquo;s really what it\u0026rsquo;s all about.\u0026rdquo;\nAll in all, I got a lot of learning by building this project, both in languages/frameworks used and production stuff such as infrastructure, cloud hosting and cloud-based APIs.\nProject landing page: https://rutieri.netlify.app\n","image":"//localhost:1313/images/project/rutieri/landing/homepage.webp","permalink":"//localhost:1313/projects/saas-platform-rutieri/","tags":["Strapi","React Native","React","Typescript","Firebase"],"title":"SaaS platform: Rutieri"},{"categories":["Tutorial"],"contents":"Enable comments in a Strapi application and display them in the frontend with React\nOutline Introduction Prerequisites What is Strapi Comment Manager? Installation Configuration Display comments on the frontend Installation of Strapi Comments Client Usage of Strapi Comments Client Plugin settings Manage comments Full source code of the frontend Conclusion Introduction A comment system comes in very handy for pretty much any kind of website. In the JAMstack ecosystem, while it\u0026rsquo;s ok to rely on third party solutions hosted on their own platform such as Disqus to enable comments, you usually want to keep your content and all the stuff related to it in the same admin dashboard.\nIn this article, I\u0026rsquo;ll show you how to enable and manage comments for your content very easily using the Comment Manager plugin, and display them in your frontend application.\nPrerequisites You should have a basic understanding of the following.\nBasic knowledge of JavaScript Basic knowledge of React (OPTIONAL) Basic understanding of Strapi - get started here. Your Strapi V4 project setup What is Strapi Comment Manager? Strapi Comment Manager is a plugin that enables comments for pretty much any kind of content. It allows your users to post comments and anyone can get the comments associated with a given slug.\nWith this plugin, admin users can view and manage very easily all the comments from the Strapi administration dashboard. Within the dashboard, you will be able to delete comments and subcomments and leave replies on comments.\nInstallation Once into the Strapi project root, you can install the plugin by running the following command:\nnpm install strapi-plugin-comment-manager Next, build the project to see the new plugin in the dashboard with the following command:\nnpm run build And that\u0026rsquo;s it! If everything runs correctly, the plugin should now be installed.\nConfiguration Now you need to enable some permissions so that the frontend can access the endpoints to post and fetch comments.\nIn your Strapi admin dashboard, head over to Settings, then over to Roles under Users \u0026amp; Permissions Plugin.\nLet\u0026rsquo;s first setup the Public API; click on Public and hit the dropdown button of Comment Manager. Now check count, find and getPageSize, then hit the Save button. Below is a screenshot of a proper configuration:\nNow let\u0026rsquo;s setup the Authenticated API. Go back to Roles and click on Authenticated. Open the dropdown for Comment Manager and mark as checked the option create on both Comment and Subcomment. Below is a screenshot of a proper configuration:\nWith this configuration, the frontend should now be able to make requests to get and post comments.\nDisplay comments on the frontend The plugin exposes an API to get and post comments if you want to have fine-grained control over the workflow of your comments system and you can check the documentation on the package page, but this plugin also comes with a purpose-built React component library that makes it super easy to get up and running without getting your hands dirty.\nThis components library is called strapi-comments-client, fully supports typescript and it handles for you all of the complexity of fetching and posting comments and subcomments for every content ID that you pass to it.\nInstallation of Strapi Comments Client You will need to have installed react ^17.0.2, react-dom ^17.0.2 and react-router-dom ^5.2.0.\nInside of your React project, run this command:\nnpm install strapi-comments-client --save Usage of Strapi Comments Client Using this library is very easy!\nThis library exports three main components:\nCommentsProvider Comments CommentForm And you can import them this way:\nimport { CommentsProvider, Comments, CommentForm } from \u0026#34;strapi-comments-client\u0026#34; All you have to do is wrap your App component into the CommentsProvider component. Then you will be able to place anywhere in your app the Comments component to render a list of comments for a given content ID and the CommentForm component to render a form to post comments.\nFor example, this could be your index.js or main.js file:\nimport React from \u0026#39;react\u0026#39; import ReactDOM from \u0026#39;react-dom\u0026#39; // The address of your strapi backend instance const STRAPI = \u0026#34;http://localhost:1337\u0026#34; ReactDOM.render( \u0026lt;React.StrictMode\u0026gt; \u0026lt;CommentsProvider apiURL={STRAPI}\u0026gt; \u0026lt;App /\u0026gt; \u0026lt;/CommentsProvider\u0026gt; \u0026lt;/React.StrictMode\u0026gt;, document.getElementById(\u0026#39;root\u0026#39;) ) Where apiURL is the URL of your running Strapi application, and this property is required.\nThis way, the comments provider will do all the magic of fetching and posting comments for you!\nThis library also exports an utility React.Context to update some of the parameters for fetching and posting comments:\nimport { CommentsConfigContext } from \u0026#34;strapi-comments-client\u0026#34; This CommentsConfigContext exposes two setter functions: setUser and setContentID\nWith setContentID you can load the comments for a given content and post comments to it. It receives a single parameter of type string and must be URLized, i.e. no spaces.\nWith setUser you can set the credentials of a given user to authorize the posting of comments. It receives a single parameter of type IUser, with the following Typescript interface:\ninterface IUser { username: string, email: string, id: string, token: string // This is a JWT } It\u0026rsquo;s a little confusing but we\u0026rsquo;ll see how to use it in a component:\nconst App = () =\u0026gt; { const { setUser, setContentID } = useContext(CommentsConfigContext) // The following data should come from Strapi Users and Permissions Plugin // for authenticated requests const user = { username: \u0026#34;John Doe\u0026#34;, email: \u0026#34;jhohndoe@gmail.com\u0026#34;, id: 5, token: \u0026#34;this_should_be_a_JWT\u0026#34; } if (user) { setUser(user) } setContentID(\u0026#34;sample-content-1\u0026#34;) // Load comments for this content return ( \u0026lt;\u0026gt; { !user \u0026amp;\u0026amp; \u0026lt;Login /\u0026gt; } \u0026lt;CommentForm /\u0026gt; \u0026lt;Comments /\u0026gt; \u0026lt;/\u0026gt; ) } And that\u0026rsquo;s it!\nAfter setting the content ID through setContentID, CommentsProvider will start loading the comments for the given content ID and the CommentForm will render an input to post comments related to the given content ID if there is a user. Otherwise, it will display the message Login to post a comment.\nHere\u0026rsquo;s how the interface looks like so far:\nThere\u0026rsquo;s also a button to Leave a reply, which will open a form to post a subcomment associated with the parent comment.\nThis library exports one more component: ErrorBox\nimport { ErrorBox } from \u0026#34;strapi-comments-client\u0026#34; .It\u0026rsquo;s useful if you\u0026rsquo;d like to display error messages when things go wrong fetching or posting comments.\nYou can place this component wherever you want, for example in between the CommentForm and the Comments components.\nIf you\u0026rsquo;re wondering how this error box looks like, here you have a sample:\nGeneral settings You can customize the page size, i.e. specify how many comments are returned at once.\nIn the Strapi admin panel, head over to Settings, then select Pagination under Comment Manager Plugin.\nHere you\u0026rsquo;ll find an input to set the page size, which defaults to 10.\nManage comments Once you\u0026rsquo;ve got the plugin up an running, as users start to post comments, you can manage and reply to them as admin from the Comment Manager section of the left sidebar in the Strapi admin dashboard.\nHere you can see two tabs: one for the latest comments and one for comments grouped by content ID.\nIn both of them you can delete comments and subcomments as well as leave replies.\nExample project You can find a full working example of a React App using the Strapi Comments Client Library in this repo\nConclusion With this plugin you can enable and manage comments for any content with little effort and even use a component library to display the comments in your frontend application made with React.\nAnd that\u0026rsquo;s it! The features are pretty basic at the moment but if there\u0026rsquo;s interest, I\u0026rsquo;m willing to work on more features as well as improve the UI/UX.\n","image":"//localhost:1313/images/post/strapilogo.jpg","permalink":"//localhost:1313/blogs/how-to-enable-and-manage-comments-in-your-strapi-application/","tags":["Strapi","Strapi tutorials"],"title":"How To Enable And Manage Comments In Your Strapi Application."},{"categories":["Documentation"],"contents":"Comment Manager is a Strapi plugin to allow your users to post comments.\nWith this plugin you can enable and manage comments for your content very easily!\nRequirements You should have installed an instance of Strapi v4.x.x\nInstallation Run the following command in your project root:\nnpm install strapi-plugin-comment-manager Configurarion For your frontend to have access to the API, enable the following permissions for Comment Manager from Users \u0026amp; Permissions Plugin on your project settings:\nFor public, enable: count, find and getPageSize.\nFor authenticated, enable create on both Comment and Subcomment.\nDisplay comments on the frontend Comments can be displayed in the frontend in two ways:\nUsing the React components library strapi-comments-client (recommended) Build your custom frontend using the API API There are some Typescript interfaces that will help to get an idea of the data structures.\nComments: interface IComment { id: string, from_admin: boolean, createdAt: string, content: string, author: IAuthor | null, subcomments?: ISubcomment[] } Subcomments: interface ISubcomment { id: string, from_admin: boolean, createdAt: string, content: string, author: IAuthor | null, } Authors: IAuthor { username: string, email: string, id: string } The following endpoints are exposed to fetch and post comments and subcomments:\nGet comments for a content ID Method: GET\nPath: /api/comment-manager/comments/:slug\nOptional query parameters: start, ignoreCount\nReturns:\n{ commentsCount?: Number, comments: IComment[] } The parameter start indicates how many comments to skip. This is for pagination purposes.\nThe parameter ignoreCount indicates whether or not to return the total number of comments associated with the given slug.\nGet the number of comments associated with a given content ID Method: GET\nPath: /api/comment-manager/comments/:slug/count\nReturns:\n{ count: Number } Post a comment Method: POST\nPath: /api/comment-manager/comments/:slug\nAuthentication: Bearer token\nPayload:\n{ content: string } Returns:\n{ id: Number } Post a subcomment Method: POST\nPath: /api/comment-manager/subcomments/:parent-id\nAuthentication: Bearer token\nPayload:\n{ content: string } Returns:\n{ id: Number } Get the page size Method: GET\nPath: /api/comment-manager/page-size\nReturns:\n{ pageSize: Number } General settings The plugin allows to set how many comments are returned per page by going to the Pagination section under Comment Manager Plugin on the Settings section.\nThe default page size is 10.\nManagement of comments Admin users are able to delete comments and subcomments as well as leave replies as admins from within the plugin page of the Strapi admin dashboard.\nThe plugin interface has two tabs: one for the latest comments and one for comments by content ID.\nRoadmap and future plans The plugin is pretty basic but it can be improved with more features and a better UI/UX. Collaborations and suggestions are very welcome.\n","image":"//localhost:1313/images/post/strapilogo.jpg","permalink":"//localhost:1313/blogs/strapi-plugin-comment-manager/","tags":["Strapi","Strapi plugins"],"title":"Strapi Plugin Comment Manager"},{"categories":["Projects"],"contents":"In this post I’m going to share my experience on building a SaaS using the headless CMS Strapi as the Backend, React Native and other technologies.\nOutline Introduction What is SaaS? The problem What is Strapi? Developing features in Strapi The frontend: How to get content Conclusion Landing Page Introduction Very often, developers, product and project managers, testers and pretty much the entire team share their ideas to decide what language and which framework they\u0026rsquo;ll use to build their next project. Some considerations must be taken into account, from which in my opinion there are three that are the most important:\nDeveloper experience and ease of use Does the language and framework chosen provide a good developer experience? Is the langauge the same for the backend and frontend?\nDeadlines Is there a deadline to finish the project? if so, there is a good chance to finish the project on time if the team chooses the language they have more experience in.\nMaintainability As there will be usually more than one person working on the same part at the same time, if everything is kept organised, the whole development process will be frictionless.\nWith that in mind, developers and project managers will have a better insight on which language/framework to use.\nOther aspects should also be considered such as what the data structure will look like.\nIn my case, as it is usual, the backend of my project needs a database for users and their roles among other entities and their relations and a dashboard to allow admins to manage the data, and I was lucky to find out Strapi, as it includes a lot of these features out of the box with one single line of command to get started.\nWhat is SaaS? SaaS stands for Software-as-a-Service and it just means that a software is provided as a service in the cloud and it gives a solution to a specific problem, for which the users are willing to pay either monthly or annual subscription.\nThe problem Before starting to write a single line of code, it is generally a good idea to think about the problem, it\u0026rsquo;s limitations and whether or not it has already been solved by someone else (AKA competitors).\nThe problem I was looking into had to do with the way in which public and private transportation companies manage their routes, drivers and users. After a little bit of research, I could only find one platform that provides a similiar solution but for their own company.\nSo the platform I built needed the following content types:\nOrganizations to group routes, drivers and users Routes Two user roles: drivers and users (passengers) As I said before, Strapi makes the creation of these content types and the relationships between them really easy, but let\u0026rsquo;s first see what is Strapi and how it turns the API development into a satisfactory and fun experience.\nWhat is Strapi? Strapi is an open source headless CMS that allows developers to build complete RESTful APIs in just a couple of days instead of months. It includes a lot of useful features as plugins out of the box. Users and Roles management, Media library and an interface to create, view, edit and delete content are just some of them.\nRegarding the API, how does it makes the development faster?\nFirst of all, it enforces a specific folder structure, which helps to keep everything well organised and clean.\nSecondly, all database schemas are generated automatically and queries are made in JSON format, which really saves a lot of time.\nLastly, we can add more features to our Strapi application very easily via plugins from the marketplace.\nIt\u0026rsquo;s also worth noting that Strapi is a self-hosted CMS, which means that we can host it in whatever cloud platform we want, as well as test it locally in our computers before deploying it to the cloud.\nDeveloping features in Strapi Creating and configuring endpoints in Strapi is as straightforward as declaring a JSON in a single file:\nCreating controllers is straightforward as well:\nEvery controller gets all the data related to the request in the ctx parameter and it\u0026rsquo;s also used to send the response. This keeps everything in one place and really helps to improve the readability.\nOnce the API endpoints are defined, the next step is to enable the permissions for the specific user roles to have access to these endpoints:\nThe frontend: how to get content Since Strapi is a headless CMS, it\u0026rsquo;ll only provide content through the API. That means that the content can be consumed from anywhere. In our case, this content will be used in two applications: one for the organization owners and one for the users and drivers.\nThe application for the organization owners is a dashboard where administrators can create organizations, routes, accept drivers and users in the organization and assign routes to drivers. This is just a React Application:\nThe application for drivers and users is a mobile application built in React Native. Firebase was used to synchronise geolocation data in real time between drivers and users and display this information in a Map from Google Maps:\nConclusion Using a CMS as the backend can make the development a lot faster than building the API from scratch and with Strapi this is specially true. Furthermore, this becomes more important when building a brand-new product, as it\u0026rsquo;s usually recommended to launch as soon as possible to gather feedback from the users and validate the idea.\nProject landing page: https://rutieri.netlify.app\n","image":"//localhost:1313/images/post/03.webp","permalink":"//localhost:1313/blogs/how-i-built-a-saas-on-top-of-strapi-and-why-you-should-too/","tags":["Strapi","React Native","Typescript"],"title":"How I Built A SaaS On Top Of Strapi, And Why You Should Too"},{"categories":["Tutorial"],"contents":"Enable User Reviews in a Strapi application and display them in the frontend with React\nOutline Introduction Prerequisites What is Strapi Ratings? Installation Configuration Display user reviews on the frontend Plugin settings Manage user reviews Full source code of the frontend Conclusion Introduction Ratings systems have become a crucial part of any website with ecommerce capabilites, as they allow the users to post reviews on the items they purchase and publish their opinion to the public. A couple of reviews can make the difference between pressing the “Buy” button and moving on to the next website in the Google search results.\nIn this article, I\u0026rsquo;ll show you how to enable and manage user reviews for your content very easily using the Ratings plugin, and display them in your frontend application.\nPrerequisites First of all, you need to have a basic understanding of the following.\nBasic knowledge of JavaScript Basic knowledge of React (OPTIONAL) Basic understanding of Strapi - get started here. Your Strapi V4 project setup What is Strapi Ratings? Strapi Ratings is a plugin that gives your Strapi application the ability to manage ratings for pretty much any kind of content. It allows your users to post reviews and anyone can get the reviews associated with a given slug.\nWith this plugin, admin users can view and manage very easily all the reviews from the Strapi administration dashboard. Within the dashboard, you will be able to see reviews related to content slugs as well as delete reviews.\nInstallation Once into the Strapi project root, you can install the plugin by running the following command:\nnpm install strapi-plugin-ratings Next, build the project to see the new plugin in the dashboard with the following command:\nnpm run build And that\u0026rsquo;s it! If everything runs correctly, the plugin should now be installed.\nConfiguration Now you need to enable some permissions so that the frontend can access the endpoints to post and fetch reviews.\nIn your Strapi admin dashboard, head over to Settings, then over to Roles under Users \u0026amp; Permissions Plugin.\nLet\u0026rsquo;s first setup the Public API; click on Public and hit the dropdown button of Ratings. Now check count, find, getPageSize and getStats, then hit the Save button. Below is a screenshot of a proper configuration:\nNow let\u0026rsquo;s setup the Authenticated API. Go back to Roles and click on Authenticated. Open the dropdown for Ratings and mark as checked the options create, find and getUserReview. Below is a screenshot of a proper configuration:\nWith this configuration, the frontend should now be able to make requests to get and post user reviews.\nDisplay use reviews on the frontend The plugin exposes an API to get and post reviews if you want to have fine-grained control over the workflow of your ratings system and you can check the documentation on the package page, but this plugin also comes with a purpose-built React component library that makes it super easy to get up and running without getting your hands dirty.\nThis components library is called strapi-ratings-client, fully supports typescript and it takes care of all the complexity of fetching and posting user reviews for every content ID that you pass to it.\nInstallation of Strapi Ratings Client You will need to have installed react ^17.0.2, react-dom ^17.0.2, bootstrap ^5.1.3 and @popperjs/core^2.11.2\nInside of your React project, run this command:\nnpm install strapi-ratings-client --save Usage of Strapi Ratings Client Using this library is very easy!\nThis library exports three main components:\nReviewsProvider Reviews ReviewForm And you can import them this way:\nimport { ReviewsProvider, Reviews, ReviewForm } from \u0026#34;strapi-ratings-client\u0026#34; All you have to do is wrap your App component into the ReviewsProvider component. Then you will be able to place anywhere in your app the Reviews component to render a list of user reviews for a given content ID and the ReviewForm component to render a form to allow your users to post reviews.\nFor example, this could be your index.js or main.js file:\nimport React from \u0026#39;react\u0026#39; import ReactDOM from \u0026#39;react-dom\u0026#39; // The address of your strapi backend instance const STRAPI = \u0026#34;http://localhost:1337\u0026#34; ReactDOM.render( \u0026lt;React.StrictMode\u0026gt; \u0026lt;ReviewsProvider apiURL={STRAPI}\u0026gt; \u0026lt;App /\u0026gt; \u0026lt;/ReviewsProvider\u0026gt; \u0026lt;/React.StrictMode\u0026gt;, document.getElementById(\u0026#39;root\u0026#39;) ) Where apiURL is the URL of your running Strapi application, and this property is required.\nThis way, the ratings provider will do all the magic of fetching and posting comments for you!\nThis library also exports an utility React.Context to update some of the parameters for fetching and posting reviews:\nimport { ReviewsConfigContext } from \u0026#34;strapi-ratings-client\u0026#34; This ReviewsConfigContext exposes three setter functions: setUser, setContentID and setCanPostReview.\nWith setContentID you can load the ratings for a given content and post reviews to it. It receives a single parameter of type string and must be URLized, i.e. no spaces.\nWith setUser you can set the credentials of a given user to authorize the posting of reviews. It receives a single parameter of type IUser, with the following Typescript interface:\ninterface IUser { username: string, email: string, id: string, token: string // This is a JWT } With setCanPostReview, you can enable the user to post a review on the given content. This is useful for when you only allow a user to post a review after they purchase the product.\nIt\u0026rsquo;s a little confusing but we\u0026rsquo;ll see how to use it in a component:\nconst App = () =\u0026gt; { const { setUser, setContentID, setCanPostReview } = useContext(ReviewsConfigContext) // The following data should come from Strapi Users and Permissions Plugin // for authenticated requests. const user = { username: \u0026#34;John Doe\u0026#34;, email: \u0026#34;jhohndoe@gmail.com\u0026#34;, id: 5, token: \u0026#34;this_should_be_a_JWT\u0026#34; } if (user) { setUser(user) } setContentID(\u0026#34;sample-content-1\u0026#34;) // Load reviews for this content setCanPostReview(true) // Allow this user to post a review return ( \u0026lt;\u0026gt; { !user \u0026amp;\u0026amp; \u0026lt;Login /\u0026gt; } \u0026lt;ReviewForm /\u0026gt; \u0026lt;Reviews /\u0026gt; \u0026lt;/\u0026gt; ) } And that\u0026rsquo;s it!\nAfter setting the content ID through setContentID, ReviewsProvider will start loading the reviews for the given content ID and the ReviewForm will render an input to post a user review related to the given content ID if there is a user and he’s allowed to post a review. Otherwise, it will display the message Login to post a review or nothing at all if the user is not allowed to post a review.\nHere\u0026rsquo;s how the interface looks like so far:\nThis library exports one more component: ErrorBox\nimport { ErrorBox } from \u0026#34;strapi-ratings-client\u0026#34; .It\u0026rsquo;s useful for when you\u0026rsquo;d like to display error messages when things go wrong fetching or posting reviews.\nYou can place this component wherever you want, for example in between the ReviewForm and the Reviews components.\nIf you\u0026rsquo;re wondering how this error box looks like, here‘s a screenshot:\nGeneral settings You can customize the page size, i.e. specify how many user reviews are showed at once.\nIn the Strapi admin panel, head over to Settings, then select Pagination under Ratings Plugin.\nHere you\u0026rsquo;ll find an input to set the page size, which defaults to 10.\nManage reviews Once you\u0026rsquo;ve got the plugin up an running, as users start to post reviews, you can view them from within the Ratings section of the left sidebar in the Strapi admin dashboard.\nHere you can see two tabs: one for the latest reviews and one for reviews grouped by content ID.\nIn both of them you can delete unwanted reviews.\nExample project You can find a full working example of a React App using the Strapi Ratings Client Library in this repo: https://github.com/luisguve/strapi-ratings-client-example\nConclusion With this plugin you can enable and manage user reviews for any content with little effort and even use a library of components styled with Bootstrap to display the user reviews in your frontend.\nAnd that\u0026rsquo;s it! The features are pretty basic at the moment but if there\u0026rsquo;s interest, I\u0026rsquo;m willing to work on more features as well as improve the UI/UX.\n","image":"//localhost:1313/images/post/tutorial-ratings.webp","permalink":"//localhost:1313/blogs/how-to-enable-and-manage-user-reviews-in-your-strapi-application/","tags":["Strapi","Strapi tutorials"],"title":"How To Enable And Manage User Reviews In Your Strapi Application"},{"categories":["Documentation"],"contents":"Ratings is a Strapi plugin that allows your users to post reviews.\nEnable and manage user reviews for your content very easily!\nRequirements You should have installed an instance of Strapi v4.x.x\nInstallation Run the following command in your project root:\nnpm install strapi-plugin-ratings Then, rebuild the admin dashboard using the following command\nnpm run build Configurarion For your frontend to have access to the API, enable the following permissions for Ratings from Users \u0026amp; Permissions Plugin on your project settings:\nFor public, enable: count, find, getPageSize and getStats.\nFor authenticated, enable create, find and getUserReview.\nDisplay user reviews on the frontend Reviews can be displayed in the frontend in two ways:\nUsing the React components library strapi-ratings-client (recommended) Build your custom frontend using the API endpoints, described as follows: API There are some Typescript interfaces that will help to get an idea of the data structures.\nReviews: interface IReview { id: number, createdAt: string, comment: string | null, author: IAuthor | null, score: number, } Authors: interface IAuthor { username: string, email: string, id: number } Content Stats interface IStats { averageScore: number; reviewsCount: number | null; } The following endpoints are exposed to fetch and post reviews:\nGet reviews for a content ID Method: GET\nPath: /api/ratings/reviews/:slug\nOptional query parameters: start, ignoreCount\nReturns:\n{ reviewsCount: number, averageScore: number, userReview: IReview | null, reviews: IReview[] } The parameter start indicates how many reviews to skip. This is for pagination purposes.\nThe parameter ignoreCount indicates whether or not to return the total number of reviews associated with the given slug.\nGet review stats for a content ID Method: GET\nPath: /api/ratings/reviews/:slug/stats\nReturns:\n{ averageScore: number, reviewsCount: number | null } Get the number of reviews associated with a given content ID Method: GET\nPath: /api/ratings/reviews/:slug/count\nReturns:\n{ count: number } Post a review Method: POST\nPath: /api/ratings/reviews/:slug\nAuthentication: Bearer token\nPayload:\n{ content: string } Returns:\n{ id: number } By default, every authenticated user can post reviews on any content.\nIn order to customize this behavior, e.g. allowing or disallowing a user from posting reviews, you must extend the service userCanPostReview from whithin register function in ./src/index.js. For example:\nstrapi.service(\u0026#34;plugin::ratings.review\u0026#34;).userCanPostReview = async (user, slug) =\u0026gt; { /* Here you will check whether or not the user is allowed to post a review on this content ID and return either true or false. */ return true } Notice that userCanPostReview will receive two parameters: the user from Users \u0026amp; Permissions Plugin, containing it\u0026rsquo;s id, username, confirmed, etc., and the slug, which is a string and refers to the content ID which the review is being posted on.\nIn case this function returns false, the response of the endpoint will be 403 (forbidden) with the text User cannot post a review on this content.\nGet the page size Method: GET\nPath: /api/ratings/page-size\nReturns:\n{ pageSize: number } General settings The plugin allows to set how many reviews are returned per page by going to the Pagination section under Ratings Plugin of the Settings section.\nThe default page size is 10.\nManagement of reviews Admin users are able to delete reviews from within the plugin page of the Strapi admin dashboard.\nThe plugin interface has two tabs: one for the latest reviews and one for reviews by content ID.\nRoadmap and future plans The plugin is pretty basic but it can be improved with more features and a better UI/UX. Collaborations and suggestions are very welcome.\n","image":"//localhost:1313/images/post/ratings.webp","permalink":"//localhost:1313/blogs/strapi-plugin-ratings/","tags":["Strapi","Strapi plugins"],"title":"Strapi Plugin Ratings"},{"categories":["Projects"],"contents":"ManyLMS is an e-learning platform built on top of Strapi, React Router 7, Typescript and other technologies.\nOutline The idea Platform features The stack The API The frontend Conclusion Landing Page The idea This project doesn\u0026rsquo;t necessarily bring a huge amount of innovation on the e-learning platforms that already exists, but it\u0026rsquo;s just another way of doing this type of application.\nThe main idea is to apply a JAMstack approach in this application, where the platform is a static website, and the backend is just an API that serves static content only once to build the website and just adds the dynamism that\u0026rsquo;s necessary to allow users to authenticate, create orders, confirm payments and take courses.\nIf we compare this approach to a WordPress website, we are taking out most of the overhead that implies rendering the pages everytime a user visits them. Despite that there are plugins for caching that may improve the performance, it\u0026rsquo;s still never going to be faster and more efficient than just static content served by a CDN. That\u0026rsquo;s why React Router 7 and Headless CMSs are so popular right now.\nPlatform features and user stories The following user stories illustrates the desired features the platform should have.\nAs an administrator, I want to: login in the admin panel. create categories. create courses. upload lectures. organise courses into categories. assign lectures to courses. As a student, I want to: login in the platform. view the available courses. add courses to the shopping cart. review the shopping cart. create an order. pay with credit card or paypal. view the courses i\u0026rsquo;ve purchased in my learning page. go to the course page from my learning page and watch the videos. mark lectures as seen. come back later and resume where I left. The requirements The backend requires to handle user authentication, permissions, different data structures as content types and define relationships between them. It also requires to allow uploading videos to some third party platform that supports streaming on demand.\nThe frontend is a web platform where users can register and login, view and buy courses, leave comments and reviews and take courses.\nThe API Since all of the features involve authentication, permissions and roles, and because there is no need to reinvent the wheel, I chose to use Strapi to build the backend for it\u0026rsquo;s simplicity, ease of use and great developer experience, whereas for streaming videos on demand, I chose to use Mux.com.\nThe instance of Strapi and the Postgres database it requires was deployed in the cloud hosting platform https://fly.io.\nStrapi is good for managing users, content that\u0026rsquo;s typically updated and fetched via CRUD API, and setting up relations between content types.\nThe platform needs the following content types:\nCategory to group courses Course Lecture Module to group lectures Order Student: has many courses Student-Course: stores a student\u0026rsquo;s current lecture of a course Video Strapi makes the creation of these content types and setting up relationships between them really straightforward.\nBelow are some screenshots of these content types and the relationships between them:\nThe frontend The platform where users are able to login, view, buy and view courses is a web application built with React Router 7. Among the features of this application are:\nState managed by Context API Interface styled with Bootstrap Play streaming videos with @mux/mux-player-react library Use of localStorage to save user session Below are some sample screenshots of how this app looks like\nConclusion and final thoughts While building this project, I learned:\nHow streaming on demand works and how to use a streaming provider How to statically build websites with React Router 7 and Strapi How to setup dynamic pages in React Router 7 How to process payments with Stripe and Paypal How to build custom plugins in Strapi How to publish packages to NPM Project source codes: https://github.com/luisguve/maestro-backend\nhttps://github.com/luisguve/new-lms-remix\n","image":"//localhost:1313/images/project/manylms/frontend/course_overview.png","permalink":"//localhost:1313/projects/e-learning-platform-maestro-lms/","tags":["Strapi","React","React Router 7","Typescript","Mux"],"title":"ManyLMS: E-Learning platform"},{"categories":["Projects"],"contents":"ETMday (Emprende tu Mente) is a large-scale entrepreneurship event website built on top of WordPress with the Themosis framework, featuring an interactive SVG map, real-time countdown timers, advanced search functionality, and comprehensive content management using Vue 3, Laravel Mix, and modern frontend technologies.\nOutline The project Key features The stack Frontend architecture Interactive components Conclusion Live website The project ETMday is Chile\u0026rsquo;s premier entrepreneurship event, bringing together thousands of entrepreneurs, startups, corporates, and strategic partners. The website serves as the central hub for event information, featuring speakers, activities, stands, program schedules, and an interactive event map.\nThe frontend development required implementing complex interactive features including an SVG-based interactive map with tooltips, real-time countdown timers, advanced filtering and search systems, and dynamic content displays that handle thousands of attendees and hundreds of activities.\nKey features The website includes several sophisticated features:\nInteractive SVG Map: Custom-built interactive map with clickable zones, tooltips, and dynamic content display Real-time Countdown: Event countdown timer with automatic updates and mobile optimization Advanced Search: Multi-category search across activities, speakers, stands, and content Dynamic Filtering: Complex filtering system with tabs, favorites, and downloadable resources Animated Statistics: Odometer animations for displaying event metrics Content Management: Comprehensive card components for activities, speakers, stands, and blog posts Form Handling: Multi-step forms with validation using Vee-Validate Lightbox Galleries: Image galleries with LightGallery integration Responsive Design: Fully responsive design optimized for all devices The stack The frontend stack consists of:\nVue 3.2.4: Modern reactive framework for building interactive components Laravel Mix 6.0: Asset compilation and bundling SCSS: Advanced styling with organized architecture Vee-Validate 4.15.0: Form validation with Yup schemas Axios 1.6.8: HTTP client for API requests Splide.js 4.1.4: Modern carousel and slider components LightGallery 2.8.3: Lightbox gallery functionality Odometer 0.4.8: Animated number counting Headroom.js: Header behavior on scroll jQuery 3.7.1: DOM manipulation and legacy support SweetAlert2: Modern alert dialogs GLightbox 3.3.1: Alternative lightbox solution Frontend architecture Vue components The application features a comprehensive set of Vue 3 components:\nCard Components:\ncards/activities.vue: Activity cards with favorites functionality cards/speakers.vue: Speaker cards with modal details cards/stands.vue: Stand/exhibitor cards cards/blog.vue: Blog post cards cards/shortcut.vue: Quick access shortcut cards Functional Components:\nSectionCards.vue: Main section component with tabs, filtering, and card display Search.vue: Advanced search component with multi-category results Form.vue: Dynamic form component with validation FormCalendar.vue: Calendar form component CustomFilter.vue: Reusable filter component CustomSelect.vue: Custom select dropdown Pagination.vue: Pagination component JavaScript components The application includes 17 specialized JavaScript components:\nInteractive Features:\ninteractiveMap.js: SVG map interaction with tooltips, zones, and dynamic content countdown.js: Real-time countdown timer with automatic updates odometer.js: Animated number counting with scroll triggers map.js: Map zone interactions and modal displays UI Components:\nheader.js: Header functionality and navigation headroom.js: Header hide/show on scroll accordion.js: Accordion interactions tabs.js: Tab functionality cards.js: Card interactions and modals siteModals.js: Modal management system UI.js: General UI utilities Media Components:\nvideo.js: Video player setup lightgallery.js: Lightbox gallery initialization splide.js: Carousel initialization slick.js: Legacy carousel support Utilities:\nscrollTrigger.js: Scroll-based animations imgToSvg.js: SVG image conversion utility SCSS architecture The styling follows a well-organized SCSS architecture:\nscss/ ├── abstracts/ # Variables, mixins, functions │ ├── _functions.scss │ ├── _mixins.scss │ ├── _variables.scss │ ├── _mq.scss # Media query mixins │ └── _keyframes.scss ├── base/ # Base styles and typography │ ├── _typography.scss │ ├── _container.scss │ └── _reset.scss └── components/ # Component-specific styles └── [52 component files] Key SCSS features:\nBEM methodology: Consistent naming convention Media query mixins: Using sass-mq for responsive design Modular architecture: Each component has its own SCSS file Component organization: 52 component-specific SCSS files Interactive components Interactive SVG Map The interactiveMap.js component implements a sophisticated SVG-based interactive map:\nFeatures:\nSVG Tooltips: Dynamically generated tooltips with text wrapping Zone Interactions: Clickable zones with modal displays Point Markers: Interactive points with icons and labels Dynamic Content: Content loaded based on zone/point selection Responsive Design: Optimized for mobile and desktop Technical Implementation:\nSVG namespace manipulation for tooltip creation Text wrapping algorithm for tooltip content Path generation for tooltip shapes with rounded corners Event delegation for zone and point interactions Smooth animations and transitions Real-time Countdown The countdown.js component provides a real-time countdown timer:\nFeatures:\nAutomatic Updates: Updates every second Multi-unit Display: Days, hours, minutes, and seconds Pluralization: Proper Spanish pluralization (Día/Días, Hora/Horas) Mobile Optimization: Simplified display on mobile devices End State Handling: Automatic transition when countdown ends Advanced Search System The Search.vue component implements a comprehensive search system:\nFeatures:\nMulti-category Search: Searches across activities, speakers, stands, and other content Category Tabs: Quick navigation between result categories Result Counts: Dynamic result counts per category Scroll Navigation: Smooth scrolling to category sections Carousel Display: Splide carousels for result display Loading States: Loading indicators during search Empty States: User-friendly empty state messages Dynamic Filtering System The SectionCards.vue component provides advanced filtering:\nFeatures:\nTab Navigation: Multiple filter tabs Favorites System: Save and filter favorite items Search Integration: Inline search within filters Reset Functionality: Clear all filters with one click Downloadable Resources: Download buttons for resources URL Synchronization: Filter state in URL parameters Responsive Design: Mobile accordion interface Animated Statistics The odometer.js component provides animated number counting:\nFeatures:\nScroll-triggered: Animations trigger on scroll Prefix/Suffix Support: Handles formatted numbers (e.g., \u0026ldquo;56,000+\u0026rdquo;) Mobile Optimization: Static display on mobile Smooth Animations: Odometer theme integration Development workflow The project uses Laravel Mix for asset compilation:\n// Development npm run dev // Compile assets npm run watch // Watch for changes npm run hot // Hot module replacement // Production npm run production // Optimized production build BrowserSync integration provides:\nLive reloading during development Synchronized browser testing Proxy configuration for WordPress development Performance optimizations Code splitting: Laravel Mix extracts vendor libraries Asset versioning: Automatic cache busting Image optimization: Lazy loading and responsive images Minification: Production builds are minified and optimized Tree shaking: Unused code elimination in production SVG optimization: Efficient SVG manipulation and rendering Accessibility Semantic HTML structure ARIA labels for interactive elements Keyboard navigation support Focus management in forms and modals Screen reader considerations Proper alt text for images Conclusion and final thoughts Building the ETMday frontend was an excellent opportunity to:\nMaster SVG interactions: Creating complex interactive SVG maps with dynamic tooltips and zones Implement real-time features: Building countdown timers and live updates Build advanced search: Multi-category search with filtering and categorization Handle complex state: Managing filters, favorites, and dynamic content Optimize performance: Implementing efficient animations and lazy loading Ensure scalability: Building components that handle large datasets (thousands of attendees, hundreds of activities) The project demonstrates proficiency in:\nModern JavaScript frameworks (Vue 3) SVG manipulation and interaction Real-time UI updates Advanced filtering and search systems Build tools and asset compilation (Laravel Mix, Webpack) CSS architecture and methodologies (SCSS, BEM) Component-based development Event-driven architecture The integration with WordPress/Themosis backend required careful consideration of server-side rendering, API endpoints, and content management workflows, making this a full-stack frontend implementation for a large-scale event.\nLive website: https://etmday.org/\nFigma Prototype: https://www.figma.com/proto/mt9fJ8P03M5gf0nQwcU99q/EtM-Day-2025---Dise%C3%B1o?node-id=1-2743\u0026m=dev\u0026scaling=scale-down\u0026content-scaling=fixed\u0026page-id=0%3A1\u0026starting-point-node-id=1%3A2743\n","image":"//localhost:1313/images/project/etm/home.png","permalink":"//localhost:1313/projects/etmday-entrepreneurship-event-website/","tags":["Vue 3","Laravel Mix","WordPress","Themosis","SCSS","JavaScript","Interactive Map","SVG"],"title":"ETMday: Entrepreneurship Event Website"},{"categories":["Projects"],"contents":"ISC Chile is an educational consultancy website for study abroad programs, built on top of WordPress with the Themosis framework, featuring GSAP animations, multi-step contact forms, advanced blog filtering, and comprehensive content management using Vue 2, Laravel Mix, and modern frontend technologies.\nOutline The project Design implementation The stack Frontend architecture Key features Conclusion Live website The project ISC Chile is an educational consultancy agency that has been providing study abroad advisory services since 1996. The website serves as the primary platform for showcasing various educational programs including English courses, school exchanges, group travel programs, and Pathways programs for university admission abroad.\nThe frontend development was based on a comprehensive Figma design, requiring pixel-perfect implementation of complex UI components, multi-step forms, animated statistics, and responsive layouts that work seamlessly across all devices.\nDesign implementation The entire frontend was built from a detailed Figma design, ensuring:\nPixel-perfect accuracy: Matching the design specifications precisely (as evidenced by Figma height references in SCSS) Responsive design: Implementing breakpoints and mobile-first approach Component consistency: Maintaining design system patterns throughout Interactive elements: Translating static designs into dynamic, interactive components Animation and transitions: Implementing smooth GSAP-powered animations The stack The frontend stack consists of:\nVue 2.6.12: Reactive framework for building interactive components Laravel Mix 6.0: Asset compilation and bundling SCSS: Advanced styling with a well-organized architecture Vuex 3.6.2: State management for Vue applications Vee-Validate 3.4.14: Form validation GSAP 3.12.5: Professional animation library with ScrollTrigger Axios 0.18: HTTP client for API requests Splide.js 4.1.4: Modern carousel and slider components Slick Carousel 1.8.1: Legacy carousel support LightGallery 2.7.2: Lightbox gallery functionality Odometer 0.4.8: Animated number counting Headroom.js: Header behavior on scroll V-Calendar 2.4.2: Calendar component for date selection V-Mask 2.3.0: Input masking Vue-Select 3.20.2: Custom select component jQuery 3.2: DOM manipulation and legacy support SweetAlert: Alert dialogs Frontend architecture Vue components The application features a comprehensive set of Vue 2 components:\nForm Components:\nContact.vue: Multi-step contact form with validation and reCAPTCHA ContactFormStep1.vue: First step of the contact form ContactFormStep2.vue: Second step of the contact form ContactFormStep3.vue: Third step of the contact form FormBanner.vue: Banner form component Content Components:\nBlog.vue: Blog listing with advanced filtering and search BlogArticleCard.vue \u0026amp; BlogArticleCardLoading.vue: Blog post cards with loading states ExperiencesPanel.vue: Testimonials and experiences display panel ExperiencesFiltersMobile.vue: Mobile filter component for experiences Search Components:\nSearchResults.vue: Search results display component SearchResultCardLoading.vue: Loading skeleton for search results UI Components:\nCheckboxDropdown.vue: Custom checkbox dropdown component CheckboxDropdownFieldset.vue: Fieldset wrapper for checkbox dropdowns EmptyState.vue: Empty state displays Loader.vue \u0026amp; Loading.vue: Loading indicators JavaScript components The application includes 15 specialized JavaScript components:\nAnimation Components:\ngsap.js: GSAP animations with ScrollTrigger for scroll-based reveals scrolltrigger.js: Custom scroll trigger utilities odometer.js: Animated number counting with scroll triggers UI Components:\nheader.js: Header functionality and navigation headroom.js: Header hide/show on scroll megamenu.js: Mega menu functionality mobileMenu.js: Mobile menu interactions searchbar.js: Search bar functionality floating-banner.js: Floating banner component footer.js: Footer functionality Media Components:\nvideo.js: Video player setup lightgallery.js: Lightbox gallery initialization splide.js: Carousel initialization slick.js: Legacy carousel support Interactive Components:\naccordion.js: Accordion interactions tabs.js: Tab functionality cards.js: Card interactions Utilities:\nimg-to-svg.js: SVG image conversion utility SCSS architecture The styling follows a well-organized SCSS architecture:\nscss/ ├── abstracts/ # Variables, mixins, functions │ ├── _mixins.scss │ ├── _mq.scss # Media query mixins │ └── _vendor.scss ├── base/ # Base styles and typography │ ├── _typography.scss │ ├── _colors.scss │ ├── _container.scss │ ├── _globals.scss │ └── fonts/ # Custom TWK Everett font family └── components/ # Component-specific styles └── [45 component files] Key SCSS features:\nBEM methodology: Consistent naming convention throughout Media query mixins: Using sass-mq for responsive design Modular architecture: Each component has its own SCSS file Custom typography: TWK Everett font family with multiple weights Figma references: Direct references to Figma design specifications Key features Multi-step contact form The Contact.vue component implements a sophisticated multi-step form with:\nThree-step navigation: Step-by-step form progression Form validation: Using Vee-Validate with comprehensive rules Date picker: V-Calendar integration for date selection Input masking: V-Mask for phone numbers and formatted inputs reCAPTCHA integration: Spam protection Dynamic fields: Fields that change based on user selections Loading states: Visual feedback during form submission Error handling: Comprehensive error messages and validation Form steps include:\nStep 1: Personal information and contact details Step 2: Educational background and program interests Step 3: Additional information and submission GSAP animations The gsap.js component provides professional animations:\nFeatures:\nScroll-triggered animations: Elements animate on scroll Vertical scroll reveals: Fade and slide animations Horizontal scroll reveals: Staggered animations for grid layouts Timeline management: Complex animation sequences Performance optimized: Efficient animation triggers Animation types:\nFade in with vertical movement Staggered grid animations Scroll-based reveals Smooth transitions Advanced blog system The Blog.vue component provides comprehensive blog functionality:\nFeatures:\nCategory filtering: Filter posts by category Search functionality: Real-time search across blog posts Mobile filters: Dedicated mobile filter interface Pagination: Efficient content pagination Loading states: Skeleton loading screens Empty states: User-friendly empty state messages Experiences/testimonials panel The ExperiencesPanel.vue component displays student testimonials:\nFeatures:\nFilter by type: Filter testimonials (Students/Parents) Dynamic loading: Load testimonials from API Responsive design: Mobile-optimized display Carousel integration: Splide carousel for testimonial display Animated statistics The odometer.js component provides animated number counting:\nFeatures:\nScroll-triggered: Animations trigger on scroll Smooth counting: Odometer theme integration Performance optimized: Efficient scroll detection Mobile support: Optimized for all devices Search functionality The SearchResults.vue component provides comprehensive search:\nFeatures:\nMulti-content search: Search across programs, blog posts, and pages Result categorization: Organized search results Image support: Results with and without images Tag display: Category tags for results Loading states: Skeleton loading screens Custom typography The website features a custom font family, TWK Everett, with:\nMultiple weights: From Hairline to Super Italic variants: All weights include italic versions Optimized formats: WOFF, WOFF2, and OTF formats Performance: Efficient font loading and rendering Development workflow The project uses Laravel Mix for asset compilation:\n// Development npm run dev // Compile assets npm run watch // Watch for changes npm run hot // Hot module replacement // Production npm run production // Optimized production build BrowserSync integration provides:\nLive reloading during development Synchronized browser testing Proxy configuration for WordPress development Performance optimizations Code splitting: Laravel Mix extracts vendor libraries Asset versioning: Automatic cache busting Image optimization: Lazy loading and responsive images Minification: Production builds are minified and optimized Tree shaking: Unused code elimination in production Font optimization: Efficient font loading strategies Accessibility Semantic HTML structure ARIA labels for interactive elements Keyboard navigation support Focus management in forms Screen reader considerations Proper alt text for images Conclusion and final thoughts Building the ISC Chile frontend from a Figma design was an excellent opportunity to:\nMaster Vue 2: Working with Options API, Vuex state management, and Vue 2 patterns Implement GSAP animations: Creating professional scroll-triggered animations Build complex forms: Multi-step forms with validation, date pickers, and input masking Create advanced filtering: Blog filtering with search and category selection Optimize performance: Implementing efficient animations and lazy loading Ensure design fidelity: Translating Figma designs into pixel-perfect implementations (with direct Figma references in code) The project demonstrates proficiency in:\nModern JavaScript frameworks (Vue 2) Animation libraries (GSAP, ScrollTrigger) Form validation and user experience (Vee-Validate, V-Mask, V-Calendar) Build tools and asset compilation (Laravel Mix, Webpack) CSS architecture and methodologies (SCSS, BEM) Component-based development State management (Vuex) Design system implementation The integration with WordPress/Themosis backend required careful consideration of server-side rendering, API endpoints, and content management workflows, making this a full-stack frontend implementation for an educational consultancy platform.\nLive website: https://www.iscchile.cl/\n","image":"//localhost:1313/images/project/isc-chile/homepage.webp","permalink":"//localhost:1313/projects/isc-chile-educational-consultancy-website/","tags":["Vue 2","Laravel Mix","WordPress","Themosis","SCSS","GSAP","JavaScript","Figma"],"title":"ISC Chile: Educational Consultancy Website"},{"categories":["Projects"],"contents":"Chile Nativo is a travel tour website for Patagonia experiences, built on top of WordPress with the Themosis framework, featuring a modern frontend implementation based on a Figma design using Vue 3, Laravel Mix, and a comprehensive SCSS architecture.\nOutline The project Design implementation The stack Frontend architecture Key features Conclusion Live website The project Chile Nativo is a travel company specializing in Patagonia tours, offering experiences in destinations like Torres del Paine, Tierra del Fuego, and Isla Navarino. The website serves as the primary platform for showcasing tours, managing bookings, and providing information about their travel experiences.\nThe frontend development was based on a comprehensive Figma design, requiring pixel-perfect implementation of complex UI components, interactive forms, filtering systems, and responsive layouts that work seamlessly across all devices.\nDesign implementation The entire frontend was built from a detailed Figma design, ensuring:\nPixel-perfect accuracy: Matching the design specifications precisely Responsive design: Implementing breakpoints and mobile-first approach Component consistency: Maintaining design system patterns throughout Interactive elements: Translating static designs into dynamic, interactive components Animation and transitions: Implementing smooth user experience enhancements The stack The frontend stack consists of:\nVue 3.2.4: Modern reactive framework for building interactive components Laravel Mix 6.0: Asset compilation and bundling SCSS: Advanced styling with a well-organized architecture Pinia 2.3.1: State management for Vue applications Vee-Validate 4.15.0: Form validation with Yup schemas Axios 1.6.8: HTTP client for API requests Splide.js 4.1.4: Modern carousel and slider components Headroom.js: Header behavior on scroll Plyr 3.7.8: Video player implementation SweetAlert2: Modern alert dialogs jQuery 3.7.1: Legacy support and DOM manipulation utilities Frontend architecture Vue components The application features a comprehensive set of Vue 3 components organized by functionality:\nFiltering and Search Components:\nToursFilter.vue: Advanced tour filtering with multiple criteria TourDatesFilter.vue: Date-based filtering for tour availability ToursFilterDropdown.vue \u0026amp; ToursFilterDropdownMobile.vue: Responsive filter dropdowns TestimonialsFilter.vue: Filtering system for customer testimonials NewsFilter.vue: Blog and news filtering SearchResults.vue: Search results display with pagination Form Components:\nPersonalizedTripForm.vue: Multi-step form for custom trip requests with validation ContactFormSimple.vue: Contact form with reCAPTCHA integration FormHelp.vue: Help center form FormGiftCard.vue: Gift card purchase form FormCareers.vue: Job application form NewsletterForm.vue: Newsletter subscription Card Components:\nTour.vue \u0026amp; TourLoading.vue: Tour card display with loading states TourDate.vue \u0026amp; TourDateLoading.vue: Tour date selection cards Testimonial.vue \u0026amp; TestimonialLoading.vue: Customer testimonial cards Blog.vue \u0026amp; BlogLoading.vue: Blog post cards Team.vue \u0026amp; TeamLoading.vue: Team member cards ResourceCard.vue \u0026amp; ResourceLoading.vue: Resource display cards Utility Components:\nPagination.vue: Reusable pagination component Select.vue: Custom select dropdown with search Loader.vue \u0026amp; LoaderFullScreen.vue: Loading indicators EmptyState.vue: Empty state displays ContentResources.vue: Resource content management TeamTabsFilter.vue: Tabbed team member filtering SCSS architecture The styling follows a well-organized SCSS architecture:\nscss/ ├── abstracts/ # Variables, mixins, functions │ ├── _functions.scss │ ├── _mixins.scss │ ├── _variables.scss │ ├── _mq.scss # Media query mixins │ └── _keyframes.scss ├── base/ # Base styles and typography │ ├── _typography.scss │ ├── _colors.scss │ ├── _fonts.scss │ └── _reset.scss └── components/ # Component-specific styles └── [125 component files] Key SCSS features:\nBEM methodology: Consistent naming convention throughout Media query mixins: Using sass-mq for responsive design Modular architecture: Each component has its own SCSS file Abstract layer: Reusable variables, mixins, and functions Vue transitions: Custom transition styles for Vue components JavaScript architecture The JavaScript is organized into two main entry points:\nMain application (app.js):\nInitializes core application functionality Sets up jQuery plugins and utilities Handles legacy browser support Vue application (vue/main.js):\nConfigures Vue 3 app with Pinia for state management Registers global Vue components Sets up Vee-Validate configuration Integrates third-party Vue plugins (VueTelInput, etc.) Component utilities (app/components/):\nheader.js: Header behavior and navigation footer.js: Footer functionality splide.js: Carousel initialization slick.js: Legacy carousel support accordions.js: Accordion interactions tabs.js: Tab functionality scrollTrigger.js: Scroll-based animations video.js: Video player setup sticky-sidebar.js: Sticky sidebar behavior Key features Multi-step forms The PersonalizedTripForm.vue component implements a sophisticated multi-step form with:\nStep-by-step navigation with progress indicators Form validation using Vee-Validate and Yup schemas Dynamic form fields based on user selections Phone number input with international support (VueTelInput) reCAPTCHA integration for spam protection Loading states and error handling Advanced filtering system The tour filtering system (ToursFilter.vue) provides:\nMultiple filter criteria (destination, activity type, trip type, month) Real-time filtering with URL parameter synchronization Responsive design with mobile accordion interface Custom select components with search functionality Empty states and loading indicators Integration with WordPress backend via Axios Responsive design The entire website is fully responsive with:\nMobile-first approach Breakpoint management using sass-mq Touch-friendly interactions Optimized images and assets Performance optimizations for mobile devices Performance optimizations Code splitting: Laravel Mix extracts vendor libraries Asset versioning: Automatic cache busting Image optimization: Lazy loading and responsive images Minification: Production builds are minified and optimized Tree shaking: Unused code elimination in production Accessibility Semantic HTML structure ARIA labels where appropriate Keyboard navigation support Focus management in forms Screen reader considerations Development workflow The project uses Laravel Mix for asset compilation:\n// Development npm run dev // Compile assets npm run watch // Watch for changes npm run hot // Hot module replacement // Production npm run production // Optimized production build BrowserSync integration provides:\nLive reloading during development Synchronized browser testing Proxy configuration for WordPress development Conclusion and final thoughts Building the Chile Nativo frontend from a Figma design was an excellent opportunity to:\nMaster Vue 3: Working with the Composition API, reactive systems, and modern Vue patterns Implement complex forms: Multi-step forms with validation, international phone inputs, and reCAPTCHA Build scalable architecture: Organizing 40+ Vue components and 125+ SCSS files in a maintainable structure Optimize performance: Implementing code splitting, lazy loading, and production optimizations Ensure design fidelity: Translating Figma designs into pixel-perfect implementations Handle responsive design: Creating seamless experiences across all device sizes The project demonstrates proficiency in:\nModern JavaScript frameworks (Vue 3) Build tools and asset compilation (Laravel Mix, Webpack) CSS architecture and methodologies (SCSS, BEM) Form validation and user experience Component-based development Design system implementation The integration with WordPress/Themosis backend required careful consideration of server-side rendering, API endpoints, and content management workflows, making this a full-stack frontend implementation.\nLive website: https://chilenativo.travel/\nFigma prototype: https://www.figma.com/proto/ywHPhSP1UfYUAE8eWVQv4L/Dise%C3%B1o-Desktop---Chile-Nativo?node-id=289-3912\u0026m=dev\u0026scaling=min-zoom\u0026content-scaling=fixed\u0026page-id=289%3A3911\u0026starting-point-node-id=289%3A3912\n","image":"//localhost:1313/images/project/chile-nativo/home.png","permalink":"//localhost:1313/projects/chile-nativo-patagonia-travel-website/","tags":["Vue 3","Laravel Mix","WordPress","Themosis","SCSS","JavaScript","Figma"],"title":"Chile Nativo: Patagonia Travel Website"},{"categories":["Projects"],"contents":"Rutieri is a SaaS platform built with Strapi, React Native, Typescript and other technologies.\nOutline The idea Platform features The stack The API The frontend The mobile app Conclusion Landing Page The idea Before starting to write a single line of code, it is generally a good idea to think about the problem, it\u0026rsquo;s limitations and whether or not it has already been solved by someone else (AKA competitors).\nThe problem I was looking into had to do with the way in which public and private transportation companies manage their routes, drivers and users. This process is generally carried out on paper, e.g. not digital, hence this could be problematic in case of new drivers joining the organization or in case of restricting access to data to only specific users.\nAfter a little bit of research, I could only find one platform that provides a similiar solution but for their own company.\nPlatform features and user stories The following user stories illustrates the desired features the platform should have in order to solve the aforementioned problems.\nAs an administrator user, I want to: login in the admin panel. create an organization. create routes in the organization. invite drivers and users to the organization. manage requests to join the organization. assign routes to drivers in the organization. see in real time the drivers and users currently active in the map of the different routes. As a driver, I want to: login in the mobile app. join an organization by entering the code in the search bar. see my route on the map. become visible to passengers on the road. see the passengers waiting on the road. remove my visibility and finish my run. As a passenger, I want to: login in the mobile app. join an organization by entering the code in the search bar. see the different routes of my organization in the map. search for a destination and get the available routes that pass nearby. see the drivers currently active on the routes in real time. become visible to drivers of a route. The requirements The backend requires to handle user authentication, permissions, different data structures as content types and define relations between them. It\u0026rsquo;s also necessary to synchronise passengers and drivers and view them on a map real time in the administration panel as well as in the mobile app.\nThe administration panel is a web page that fetches data from the backend as well as from the real time data provider and it\u0026rsquo;s goal is to provide a way for administrators to manage their organization and users. We\u0026rsquo;re talking about a Single Page Application built in React.\nAs for the mobile application, there isn\u0026rsquo;t a better choice nowadays than React Native and it works just fine in this case.\nThe API Since all of the features involve authentication, permissions and roles, and because there is no need to reinvent the wheel, I chose to use Strapi to build the backend for it\u0026rsquo;s simplicity, ease of use and great developer experience, whereas for realtime data, I used Firebase.\nThe instance of Strapi and the Postgres database it requires was deployed in the cloud hosting platform https://fly.io.\nStrapi is good for managing users, content that\u0026rsquo;s typically updated and fetched via CRUD API, and relations between content types.\nThe platform needs the following content types:\nOrganizations to group routes, drivers and users Routes Two user roles: drivers and users (passengers) Below are some screenshots of the overview of these content types\nAs I said before, Strapi makes the creation of these content types and the relationships between them really straightforward.\nHowever, not everything related to the API can be provided by Strapi. Some realtime features need to be addressed with other solutions, such as geolocation data in real time for drivers and users to synchronise each other, maps and the ability to search for places. Such features were implemented using Firebase, Google Maps and Google Places.\nThe frontend The platform where users are able to login as administrators and manage their organizations and users is a single page web application built in React. Among the features of this project that I think stand out are:\nState managed by Context API Interface styled with Bootstrap React Router for pages Leaflet to display the map GeoFire library to synchronise geolocation data in real time with Firebase Use of localStorage to save user session Below are some sample screenshots of how this app looks like\nThe mobile application This one is by far the most complex part of this project.\nThe project was bootstraped with Infinitered\u0026rsquo;s Ignite, which provides a great boilerplate and surely saved me of what would have been between 1-2 months of work.\nIgnite\u0026rsquo;s boilerplate includes many features out of the box, including:\nReact Native and Typescript (of course) React Navigation MobX-State-Tree for state management Expo SDK for developer experience AsyncStorage for persistence apisauce as REST client And some other libraries and features that make React Native apps super powerful and a joy to work on.\nIt consists of three screens:\nWelcome screen Login screen Map screen In the welcome screen, users are able to go to the login screen if not logged in. Otherwise, if they\u0026rsquo;re in an organisation, it shows their role and org\u0026rsquo;s information, and if they\u0026rsquo;re not, they are able to enter the organisation code and request to join as driver or as passenger.\nWelcome screens Login screens If the user is a driver in an organisation, the welcome screen also shows the route assigned to them. By tapping on it, it takes them to the map, where they can see themselves and start the tour, becoming visible to passengers on the road but being able to see passengers on the road as well.\nDrivers can finish the tour at any time by pressing the button stop.\nIf the user is a passenger in an organisation, the welcome screen shows the different routes available in the organisation. By tapping on them, they are taken to the map where they can see themselves, the route and the drivers on the road.\nPassengers are able to navigate between the available routes and search for the location they want to go to by using the search bar at the top of the map screen, filtering out the routes that pass nearby (less than 200 meters), if there are. Google Places API and turf library work together in this search process.\nPassengers become visible to drivers on the road by pressing the button wait and if they press the button again, they stop waiting and are removed from the driver\u0026rsquo;s map.\nMap screens The start/wait and finish buttons dispatch actions that update their location in firebase, so that passengers are able to see the bus on the map as it moves in real time and viceversa.\nAs for the state management, the project consists of two models and three stores from Mobx-State-Tree library: User and Route models, user-status, route-store and root-store stores.\nUser model Located in /app/models/user/user.ts\nconst OrganizationModel = types.model({ name: types.string, code: types.string, id: types.identifierNumber, drivers: types.number, rutas: types.array(RouteModel) }) const UserModel = types .model(\u0026#34;User\u0026#34;) .props({ id: types.identifierNumber, username: types.string, email: types.string, token: types.string, role: types.union(types.literal(\u0026#34;passenger\u0026#34;), types.literal(\u0026#34;driver\u0026#34;)), ruta: types.maybeNull(RouteModel), organization: types.maybeNull(OrganizationModel), pending_request: types.maybeNull(OrganizationModel), }) Route model Located in /app/models/route/route.ts\nThis model follows the GeoJSON format for routes.\nconst RouteModel = types .model(\u0026#34;Ruta\u0026#34;) .props({ id: types.identifierNumber, name: types.string, latlong: types.maybeNull(types.model({ lat: types.number, longt: types.number })), coords: types.model({ type: FeatureTypes, features: types.array(types.model({ type: types.string, geometry: types.model({ type: types.string, coordinates: types.union(types.array(types.number), types.array(types.array(types.number))) }), properties: types.model({ name: types.string }) })) }) }) user-status store Located in /app/models/user-status/user-status.ts\nThis store is responsible for managing the state of the user. It stores the user once it\u0026rsquo;s logged in and removes it when the user logs out. It also has some views to get the user key for firebase purposes, get the role and get the route in case of a driver.\nThis store has some methods that get the user location from the device\u0026rsquo;s GPS, displays the user icon on the map and sends it to firebase.\nconst UserStatusModel = types .model(\u0026#34;UserStatus\u0026#34;) .extend(withEnvironment) .props({ user: types.maybeNull(UserModel), location: types.maybeNull( types.model({latitude: types.number, longitude: types.number}) ), visibility: types.maybeNull(types.number) }) route-store store Located in /app/models/route-store/route-store.ts\nThis store is responsible for managing the state of the available routes. It stores the routes, drivers and passengers on the different routes. It also has some view methods to filter the routes that pass nearby a destination specified by the user, get passengers waiting on a given route and get drivers active in a specific route.\nThis store initializes a GeoQuery from Geofire library and listens for events to set, update and remove drivers and passengers from the map as they move.\nconst RouteStoreModel = types .model(\u0026#34;RouteStore\u0026#34;) .props({ routes: types.array(RouteModel), passengers: types.map(types.model({ key: types.identifier, location: types.array(types.number) })), drivers: types.map(types.model({ key: types.identifier, location: types.array(types.number) })), destinationAddress: types.maybeNull(types.model({ name: types.string, coords: types.array(types.number) })) }) Conclusion and final thoughts Using a CMS as the backend can make the development a lot faster than building the API from scratch and with Strapi this is specially true. On the other hand, Strapi doesn\u0026rsquo;t really make a good fit for real time applications, therefore, Firebase is the way to go in this case.\nAs of the client side, React always works very good for pretty much any kind of application, and because React Native uses React under the hood, it is so convenient for us React developers and ir works pretty good for almost any kind of application as well.\nHowever, one thing that I didn\u0026rsquo;t mention in this post was the use of Typescript; I find this quote by Brice Wilson pretty good to point out the whole purpose and motivation to learn and use (well) this powerful language and tool ecosystem:\n\u0026ldquo;You won\u0026rsquo;t have to wait for a frustrated user to report the error. All of this means that you provide value to your users faster, and that\u0026rsquo;s really what it\u0026rsquo;s all about.\u0026rdquo;\nAll in all, I got a lot of learning by building this project, both in languages/frameworks used and production stuff such as infrastructure, cloud hosting and cloud-based APIs.\nProject landing page: https://rutieri.netlify.app\n","image":"//localhost:1313/images/project/rutieri/landing/homepage.webp","permalink":"//localhost:1313/projects/saas-platform-rutieri/","tags":["Strapi","React Native","React","Typescript","Firebase"],"title":"SaaS platform: Rutieri"},{"categories":["Tutorial"],"contents":"Enable comments in a Strapi application and display them in the frontend with React\nOutline Introduction Prerequisites What is Strapi Comment Manager? Installation Configuration Display comments on the frontend Installation of Strapi Comments Client Usage of Strapi Comments Client Plugin settings Manage comments Full source code of the frontend Conclusion Introduction A comment system comes in very handy for pretty much any kind of website. In the JAMstack ecosystem, while it\u0026rsquo;s ok to rely on third party solutions hosted on their own platform such as Disqus to enable comments, you usually want to keep your content and all the stuff related to it in the same admin dashboard.\nIn this article, I\u0026rsquo;ll show you how to enable and manage comments for your content very easily using the Comment Manager plugin, and display them in your frontend application.\nPrerequisites You should have a basic understanding of the following.\nBasic knowledge of JavaScript Basic knowledge of React (OPTIONAL) Basic understanding of Strapi - get started here. Your Strapi V4 project setup What is Strapi Comment Manager? Strapi Comment Manager is a plugin that enables comments for pretty much any kind of content. It allows your users to post comments and anyone can get the comments associated with a given slug.\nWith this plugin, admin users can view and manage very easily all the comments from the Strapi administration dashboard. Within the dashboard, you will be able to delete comments and subcomments and leave replies on comments.\nInstallation Once into the Strapi project root, you can install the plugin by running the following command:\nnpm install strapi-plugin-comment-manager Next, build the project to see the new plugin in the dashboard with the following command:\nnpm run build And that\u0026rsquo;s it! If everything runs correctly, the plugin should now be installed.\nConfiguration Now you need to enable some permissions so that the frontend can access the endpoints to post and fetch comments.\nIn your Strapi admin dashboard, head over to Settings, then over to Roles under Users \u0026amp; Permissions Plugin.\nLet\u0026rsquo;s first setup the Public API; click on Public and hit the dropdown button of Comment Manager. Now check count, find and getPageSize, then hit the Save button. Below is a screenshot of a proper configuration:\nNow let\u0026rsquo;s setup the Authenticated API. Go back to Roles and click on Authenticated. Open the dropdown for Comment Manager and mark as checked the option create on both Comment and Subcomment. Below is a screenshot of a proper configuration:\nWith this configuration, the frontend should now be able to make requests to get and post comments.\nDisplay comments on the frontend The plugin exposes an API to get and post comments if you want to have fine-grained control over the workflow of your comments system and you can check the documentation on the package page, but this plugin also comes with a purpose-built React component library that makes it super easy to get up and running without getting your hands dirty.\nThis components library is called strapi-comments-client, fully supports typescript and it handles for you all of the complexity of fetching and posting comments and subcomments for every content ID that you pass to it.\nInstallation of Strapi Comments Client You will need to have installed react ^17.0.2, react-dom ^17.0.2 and react-router-dom ^5.2.0.\nInside of your React project, run this command:\nnpm install strapi-comments-client --save Usage of Strapi Comments Client Using this library is very easy!\nThis library exports three main components:\nCommentsProvider Comments CommentForm And you can import them this way:\nimport { CommentsProvider, Comments, CommentForm } from \u0026#34;strapi-comments-client\u0026#34; All you have to do is wrap your App component into the CommentsProvider component. Then you will be able to place anywhere in your app the Comments component to render a list of comments for a given content ID and the CommentForm component to render a form to post comments.\nFor example, this could be your index.js or main.js file:\nimport React from \u0026#39;react\u0026#39; import ReactDOM from \u0026#39;react-dom\u0026#39; // The address of your strapi backend instance const STRAPI = \u0026#34;http://localhost:1337\u0026#34; ReactDOM.render( \u0026lt;React.StrictMode\u0026gt; \u0026lt;CommentsProvider apiURL={STRAPI}\u0026gt; \u0026lt;App /\u0026gt; \u0026lt;/CommentsProvider\u0026gt; \u0026lt;/React.StrictMode\u0026gt;, document.getElementById(\u0026#39;root\u0026#39;) ) Where apiURL is the URL of your running Strapi application, and this property is required.\nThis way, the comments provider will do all the magic of fetching and posting comments for you!\nThis library also exports an utility React.Context to update some of the parameters for fetching and posting comments:\nimport { CommentsConfigContext } from \u0026#34;strapi-comments-client\u0026#34; This CommentsConfigContext exposes two setter functions: setUser and setContentID\nWith setContentID you can load the comments for a given content and post comments to it. It receives a single parameter of type string and must be URLized, i.e. no spaces.\nWith setUser you can set the credentials of a given user to authorize the posting of comments. It receives a single parameter of type IUser, with the following Typescript interface:\ninterface IUser { username: string, email: string, id: string, token: string // This is a JWT } It\u0026rsquo;s a little confusing but we\u0026rsquo;ll see how to use it in a component:\nconst App = () =\u0026gt; { const { setUser, setContentID } = useContext(CommentsConfigContext) // The following data should come from Strapi Users and Permissions Plugin // for authenticated requests const user = { username: \u0026#34;John Doe\u0026#34;, email: \u0026#34;jhohndoe@gmail.com\u0026#34;, id: 5, token: \u0026#34;this_should_be_a_JWT\u0026#34; } if (user) { setUser(user) } setContentID(\u0026#34;sample-content-1\u0026#34;) // Load comments for this content return ( \u0026lt;\u0026gt; { !user \u0026amp;\u0026amp; \u0026lt;Login /\u0026gt; } \u0026lt;CommentForm /\u0026gt; \u0026lt;Comments /\u0026gt; \u0026lt;/\u0026gt; ) } And that\u0026rsquo;s it!\nAfter setting the content ID through setContentID, CommentsProvider will start loading the comments for the given content ID and the CommentForm will render an input to post comments related to the given content ID if there is a user. Otherwise, it will display the message Login to post a comment.\nHere\u0026rsquo;s how the interface looks like so far:\nThere\u0026rsquo;s also a button to Leave a reply, which will open a form to post a subcomment associated with the parent comment.\nThis library exports one more component: ErrorBox\nimport { ErrorBox } from \u0026#34;strapi-comments-client\u0026#34; .It\u0026rsquo;s useful if you\u0026rsquo;d like to display error messages when things go wrong fetching or posting comments.\nYou can place this component wherever you want, for example in between the CommentForm and the Comments components.\nIf you\u0026rsquo;re wondering how this error box looks like, here you have a sample:\nGeneral settings You can customize the page size, i.e. specify how many comments are returned at once.\nIn the Strapi admin panel, head over to Settings, then select Pagination under Comment Manager Plugin.\nHere you\u0026rsquo;ll find an input to set the page size, which defaults to 10.\nManage comments Once you\u0026rsquo;ve got the plugin up an running, as users start to post comments, you can manage and reply to them as admin from the Comment Manager section of the left sidebar in the Strapi admin dashboard.\nHere you can see two tabs: one for the latest comments and one for comments grouped by content ID.\nIn both of them you can delete comments and subcomments as well as leave replies.\nExample project You can find a full working example of a React App using the Strapi Comments Client Library in this repo\nConclusion With this plugin you can enable and manage comments for any content with little effort and even use a component library to display the comments in your frontend application made with React.\nAnd that\u0026rsquo;s it! The features are pretty basic at the moment but if there\u0026rsquo;s interest, I\u0026rsquo;m willing to work on more features as well as improve the UI/UX.\n","image":"//localhost:1313/images/post/strapilogo.jpg","permalink":"//localhost:1313/blogs/how-to-enable-and-manage-comments-in-your-strapi-application/","tags":["Strapi","Strapi tutorials"],"title":"How To Enable And Manage Comments In Your Strapi Application."},{"categories":["Documentation"],"contents":"Comment Manager is a Strapi plugin to allow your users to post comments.\nWith this plugin you can enable and manage comments for your content very easily!\nRequirements You should have installed an instance of Strapi v4.x.x\nInstallation Run the following command in your project root:\nnpm install strapi-plugin-comment-manager Configurarion For your frontend to have access to the API, enable the following permissions for Comment Manager from Users \u0026amp; Permissions Plugin on your project settings:\nFor public, enable: count, find and getPageSize.\nFor authenticated, enable create on both Comment and Subcomment.\nDisplay comments on the frontend Comments can be displayed in the frontend in two ways:\nUsing the React components library strapi-comments-client (recommended) Build your custom frontend using the API API There are some Typescript interfaces that will help to get an idea of the data structures.\nComments: interface IComment { id: string, from_admin: boolean, createdAt: string, content: string, author: IAuthor | null, subcomments?: ISubcomment[] } Subcomments: interface ISubcomment { id: string, from_admin: boolean, createdAt: string, content: string, author: IAuthor | null, } Authors: IAuthor { username: string, email: string, id: string } The following endpoints are exposed to fetch and post comments and subcomments:\nGet comments for a content ID Method: GET\nPath: /api/comment-manager/comments/:slug\nOptional query parameters: start, ignoreCount\nReturns:\n{ commentsCount?: Number, comments: IComment[] } The parameter start indicates how many comments to skip. This is for pagination purposes.\nThe parameter ignoreCount indicates whether or not to return the total number of comments associated with the given slug.\nGet the number of comments associated with a given content ID Method: GET\nPath: /api/comment-manager/comments/:slug/count\nReturns:\n{ count: Number } Post a comment Method: POST\nPath: /api/comment-manager/comments/:slug\nAuthentication: Bearer token\nPayload:\n{ content: string } Returns:\n{ id: Number } Post a subcomment Method: POST\nPath: /api/comment-manager/subcomments/:parent-id\nAuthentication: Bearer token\nPayload:\n{ content: string } Returns:\n{ id: Number } Get the page size Method: GET\nPath: /api/comment-manager/page-size\nReturns:\n{ pageSize: Number } General settings The plugin allows to set how many comments are returned per page by going to the Pagination section under Comment Manager Plugin on the Settings section.\nThe default page size is 10.\nManagement of comments Admin users are able to delete comments and subcomments as well as leave replies as admins from within the plugin page of the Strapi admin dashboard.\nThe plugin interface has two tabs: one for the latest comments and one for comments by content ID.\nRoadmap and future plans The plugin is pretty basic but it can be improved with more features and a better UI/UX. Collaborations and suggestions are very welcome.\n","image":"//localhost:1313/images/post/strapilogo.jpg","permalink":"//localhost:1313/blogs/strapi-plugin-comment-manager/","tags":["Strapi","Strapi plugins"],"title":"Strapi Plugin Comment Manager"},{"categories":["Projects"],"contents":"In this post I’m going to share my experience on building a SaaS using the headless CMS Strapi as the Backend, React Native and other technologies.\nOutline Introduction What is SaaS? The problem What is Strapi? Developing features in Strapi The frontend: How to get content Conclusion Landing Page Introduction Very often, developers, product and project managers, testers and pretty much the entire team share their ideas to decide what language and which framework they\u0026rsquo;ll use to build their next project. Some considerations must be taken into account, from which in my opinion there are three that are the most important:\nDeveloper experience and ease of use Does the language and framework chosen provide a good developer experience? Is the langauge the same for the backend and frontend?\nDeadlines Is there a deadline to finish the project? if so, there is a good chance to finish the project on time if the team chooses the language they have more experience in.\nMaintainability As there will be usually more than one person working on the same part at the same time, if everything is kept organised, the whole development process will be frictionless.\nWith that in mind, developers and project managers will have a better insight on which language/framework to use.\nOther aspects should also be considered such as what the data structure will look like.\nIn my case, as it is usual, the backend of my project needs a database for users and their roles among other entities and their relations and a dashboard to allow admins to manage the data, and I was lucky to find out Strapi, as it includes a lot of these features out of the box with one single line of command to get started.\nWhat is SaaS? SaaS stands for Software-as-a-Service and it just means that a software is provided as a service in the cloud and it gives a solution to a specific problem, for which the users are willing to pay either monthly or annual subscription.\nThe problem Before starting to write a single line of code, it is generally a good idea to think about the problem, it\u0026rsquo;s limitations and whether or not it has already been solved by someone else (AKA competitors).\nThe problem I was looking into had to do with the way in which public and private transportation companies manage their routes, drivers and users. After a little bit of research, I could only find one platform that provides a similiar solution but for their own company.\nSo the platform I built needed the following content types:\nOrganizations to group routes, drivers and users Routes Two user roles: drivers and users (passengers) As I said before, Strapi makes the creation of these content types and the relationships between them really easy, but let\u0026rsquo;s first see what is Strapi and how it turns the API development into a satisfactory and fun experience.\nWhat is Strapi? Strapi is an open source headless CMS that allows developers to build complete RESTful APIs in just a couple of days instead of months. It includes a lot of useful features as plugins out of the box. Users and Roles management, Media library and an interface to create, view, edit and delete content are just some of them.\nRegarding the API, how does it makes the development faster?\nFirst of all, it enforces a specific folder structure, which helps to keep everything well organised and clean.\nSecondly, all database schemas are generated automatically and queries are made in JSON format, which really saves a lot of time.\nLastly, we can add more features to our Strapi application very easily via plugins from the marketplace.\nIt\u0026rsquo;s also worth noting that Strapi is a self-hosted CMS, which means that we can host it in whatever cloud platform we want, as well as test it locally in our computers before deploying it to the cloud.\nDeveloping features in Strapi Creating and configuring endpoints in Strapi is as straightforward as declaring a JSON in a single file:\nCreating controllers is straightforward as well:\nEvery controller gets all the data related to the request in the ctx parameter and it\u0026rsquo;s also used to send the response. This keeps everything in one place and really helps to improve the readability.\nOnce the API endpoints are defined, the next step is to enable the permissions for the specific user roles to have access to these endpoints:\nThe frontend: how to get content Since Strapi is a headless CMS, it\u0026rsquo;ll only provide content through the API. That means that the content can be consumed from anywhere. In our case, this content will be used in two applications: one for the organization owners and one for the users and drivers.\nThe application for the organization owners is a dashboard where administrators can create organizations, routes, accept drivers and users in the organization and assign routes to drivers. This is just a React Application:\nThe application for drivers and users is a mobile application built in React Native. Firebase was used to synchronise geolocation data in real time between drivers and users and display this information in a Map from Google Maps:\nConclusion Using a CMS as the backend can make the development a lot faster than building the API from scratch and with Strapi this is specially true. Furthermore, this becomes more important when building a brand-new product, as it\u0026rsquo;s usually recommended to launch as soon as possible to gather feedback from the users and validate the idea.\nProject landing page: https://rutieri.netlify.app\n","image":"//localhost:1313/images/post/03.webp","permalink":"//localhost:1313/blogs/how-i-built-a-saas-on-top-of-strapi-and-why-you-should-too/","tags":["Strapi","React Native","Typescript"],"title":"How I Built A SaaS On Top Of Strapi, And Why You Should Too"},{"categories":["Tutorial"],"contents":"Enable User Reviews in a Strapi application and display them in the frontend with React\nOutline Introduction Prerequisites What is Strapi Ratings? Installation Configuration Display user reviews on the frontend Plugin settings Manage user reviews Full source code of the frontend Conclusion Introduction Ratings systems have become a crucial part of any website with ecommerce capabilites, as they allow the users to post reviews on the items they purchase and publish their opinion to the public. A couple of reviews can make the difference between pressing the “Buy” button and moving on to the next website in the Google search results.\nIn this article, I\u0026rsquo;ll show you how to enable and manage user reviews for your content very easily using the Ratings plugin, and display them in your frontend application.\nPrerequisites First of all, you need to have a basic understanding of the following.\nBasic knowledge of JavaScript Basic knowledge of React (OPTIONAL) Basic understanding of Strapi - get started here. Your Strapi V4 project setup What is Strapi Ratings? Strapi Ratings is a plugin that gives your Strapi application the ability to manage ratings for pretty much any kind of content. It allows your users to post reviews and anyone can get the reviews associated with a given slug.\nWith this plugin, admin users can view and manage very easily all the reviews from the Strapi administration dashboard. Within the dashboard, you will be able to see reviews related to content slugs as well as delete reviews.\nInstallation Once into the Strapi project root, you can install the plugin by running the following command:\nnpm install strapi-plugin-ratings Next, build the project to see the new plugin in the dashboard with the following command:\nnpm run build And that\u0026rsquo;s it! If everything runs correctly, the plugin should now be installed.\nConfiguration Now you need to enable some permissions so that the frontend can access the endpoints to post and fetch reviews.\nIn your Strapi admin dashboard, head over to Settings, then over to Roles under Users \u0026amp; Permissions Plugin.\nLet\u0026rsquo;s first setup the Public API; click on Public and hit the dropdown button of Ratings. Now check count, find, getPageSize and getStats, then hit the Save button. Below is a screenshot of a proper configuration:\nNow let\u0026rsquo;s setup the Authenticated API. Go back to Roles and click on Authenticated. Open the dropdown for Ratings and mark as checked the options create, find and getUserReview. Below is a screenshot of a proper configuration:\nWith this configuration, the frontend should now be able to make requests to get and post user reviews.\nDisplay use reviews on the frontend The plugin exposes an API to get and post reviews if you want to have fine-grained control over the workflow of your ratings system and you can check the documentation on the package page, but this plugin also comes with a purpose-built React component library that makes it super easy to get up and running without getting your hands dirty.\nThis components library is called strapi-ratings-client, fully supports typescript and it takes care of all the complexity of fetching and posting user reviews for every content ID that you pass to it.\nInstallation of Strapi Ratings Client You will need to have installed react ^17.0.2, react-dom ^17.0.2, bootstrap ^5.1.3 and @popperjs/core^2.11.2\nInside of your React project, run this command:\nnpm install strapi-ratings-client --save Usage of Strapi Ratings Client Using this library is very easy!\nThis library exports three main components:\nReviewsProvider Reviews ReviewForm And you can import them this way:\nimport { ReviewsProvider, Reviews, ReviewForm } from \u0026#34;strapi-ratings-client\u0026#34; All you have to do is wrap your App component into the ReviewsProvider component. Then you will be able to place anywhere in your app the Reviews component to render a list of user reviews for a given content ID and the ReviewForm component to render a form to allow your users to post reviews.\nFor example, this could be your index.js or main.js file:\nimport React from \u0026#39;react\u0026#39; import ReactDOM from \u0026#39;react-dom\u0026#39; // The address of your strapi backend instance const STRAPI = \u0026#34;http://localhost:1337\u0026#34; ReactDOM.render( \u0026lt;React.StrictMode\u0026gt; \u0026lt;ReviewsProvider apiURL={STRAPI}\u0026gt; \u0026lt;App /\u0026gt; \u0026lt;/ReviewsProvider\u0026gt; \u0026lt;/React.StrictMode\u0026gt;, document.getElementById(\u0026#39;root\u0026#39;) ) Where apiURL is the URL of your running Strapi application, and this property is required.\nThis way, the ratings provider will do all the magic of fetching and posting comments for you!\nThis library also exports an utility React.Context to update some of the parameters for fetching and posting reviews:\nimport { ReviewsConfigContext } from \u0026#34;strapi-ratings-client\u0026#34; This ReviewsConfigContext exposes three setter functions: setUser, setContentID and setCanPostReview.\nWith setContentID you can load the ratings for a given content and post reviews to it. It receives a single parameter of type string and must be URLized, i.e. no spaces.\nWith setUser you can set the credentials of a given user to authorize the posting of reviews. It receives a single parameter of type IUser, with the following Typescript interface:\ninterface IUser { username: string, email: string, id: string, token: string // This is a JWT } With setCanPostReview, you can enable the user to post a review on the given content. This is useful for when you only allow a user to post a review after they purchase the product.\nIt\u0026rsquo;s a little confusing but we\u0026rsquo;ll see how to use it in a component:\nconst App = () =\u0026gt; { const { setUser, setContentID, setCanPostReview } = useContext(ReviewsConfigContext) // The following data should come from Strapi Users and Permissions Plugin // for authenticated requests. const user = { username: \u0026#34;John Doe\u0026#34;, email: \u0026#34;jhohndoe@gmail.com\u0026#34;, id: 5, token: \u0026#34;this_should_be_a_JWT\u0026#34; } if (user) { setUser(user) } setContentID(\u0026#34;sample-content-1\u0026#34;) // Load reviews for this content setCanPostReview(true) // Allow this user to post a review return ( \u0026lt;\u0026gt; { !user \u0026amp;\u0026amp; \u0026lt;Login /\u0026gt; } \u0026lt;ReviewForm /\u0026gt; \u0026lt;Reviews /\u0026gt; \u0026lt;/\u0026gt; ) } And that\u0026rsquo;s it!\nAfter setting the content ID through setContentID, ReviewsProvider will start loading the reviews for the given content ID and the ReviewForm will render an input to post a user review related to the given content ID if there is a user and he’s allowed to post a review. Otherwise, it will display the message Login to post a review or nothing at all if the user is not allowed to post a review.\nHere\u0026rsquo;s how the interface looks like so far:\nThis library exports one more component: ErrorBox\nimport { ErrorBox } from \u0026#34;strapi-ratings-client\u0026#34; .It\u0026rsquo;s useful for when you\u0026rsquo;d like to display error messages when things go wrong fetching or posting reviews.\nYou can place this component wherever you want, for example in between the ReviewForm and the Reviews components.\nIf you\u0026rsquo;re wondering how this error box looks like, here‘s a screenshot:\nGeneral settings You can customize the page size, i.e. specify how many user reviews are showed at once.\nIn the Strapi admin panel, head over to Settings, then select Pagination under Ratings Plugin.\nHere you\u0026rsquo;ll find an input to set the page size, which defaults to 10.\nManage reviews Once you\u0026rsquo;ve got the plugin up an running, as users start to post reviews, you can view them from within the Ratings section of the left sidebar in the Strapi admin dashboard.\nHere you can see two tabs: one for the latest reviews and one for reviews grouped by content ID.\nIn both of them you can delete unwanted reviews.\nExample project You can find a full working example of a React App using the Strapi Ratings Client Library in this repo: https://github.com/luisguve/strapi-ratings-client-example\nConclusion With this plugin you can enable and manage user reviews for any content with little effort and even use a library of components styled with Bootstrap to display the user reviews in your frontend.\nAnd that\u0026rsquo;s it! The features are pretty basic at the moment but if there\u0026rsquo;s interest, I\u0026rsquo;m willing to work on more features as well as improve the UI/UX.\n","image":"//localhost:1313/images/post/tutorial-ratings.webp","permalink":"//localhost:1313/blogs/how-to-enable-and-manage-user-reviews-in-your-strapi-application/","tags":["Strapi","Strapi tutorials"],"title":"How To Enable And Manage User Reviews In Your Strapi Application"},{"categories":["Documentation"],"contents":"Ratings is a Strapi plugin that allows your users to post reviews.\nEnable and manage user reviews for your content very easily!\nRequirements You should have installed an instance of Strapi v4.x.x\nInstallation Run the following command in your project root:\nnpm install strapi-plugin-ratings Then, rebuild the admin dashboard using the following command\nnpm run build Configurarion For your frontend to have access to the API, enable the following permissions for Ratings from Users \u0026amp; Permissions Plugin on your project settings:\nFor public, enable: count, find, getPageSize and getStats.\nFor authenticated, enable create, find and getUserReview.\nDisplay user reviews on the frontend Reviews can be displayed in the frontend in two ways:\nUsing the React components library strapi-ratings-client (recommended) Build your custom frontend using the API endpoints, described as follows: API There are some Typescript interfaces that will help to get an idea of the data structures.\nReviews: interface IReview { id: number, createdAt: string, comment: string | null, author: IAuthor | null, score: number, } Authors: interface IAuthor { username: string, email: string, id: number } Content Stats interface IStats { averageScore: number; reviewsCount: number | null; } The following endpoints are exposed to fetch and post reviews:\nGet reviews for a content ID Method: GET\nPath: /api/ratings/reviews/:slug\nOptional query parameters: start, ignoreCount\nReturns:\n{ reviewsCount: number, averageScore: number, userReview: IReview | null, reviews: IReview[] } The parameter start indicates how many reviews to skip. This is for pagination purposes.\nThe parameter ignoreCount indicates whether or not to return the total number of reviews associated with the given slug.\nGet review stats for a content ID Method: GET\nPath: /api/ratings/reviews/:slug/stats\nReturns:\n{ averageScore: number, reviewsCount: number | null } Get the number of reviews associated with a given content ID Method: GET\nPath: /api/ratings/reviews/:slug/count\nReturns:\n{ count: number } Post a review Method: POST\nPath: /api/ratings/reviews/:slug\nAuthentication: Bearer token\nPayload:\n{ content: string } Returns:\n{ id: number } By default, every authenticated user can post reviews on any content.\nIn order to customize this behavior, e.g. allowing or disallowing a user from posting reviews, you must extend the service userCanPostReview from whithin register function in ./src/index.js. For example:\nstrapi.service(\u0026#34;plugin::ratings.review\u0026#34;).userCanPostReview = async (user, slug) =\u0026gt; { /* Here you will check whether or not the user is allowed to post a review on this content ID and return either true or false. */ return true } Notice that userCanPostReview will receive two parameters: the user from Users \u0026amp; Permissions Plugin, containing it\u0026rsquo;s id, username, confirmed, etc., and the slug, which is a string and refers to the content ID which the review is being posted on.\nIn case this function returns false, the response of the endpoint will be 403 (forbidden) with the text User cannot post a review on this content.\nGet the page size Method: GET\nPath: /api/ratings/page-size\nReturns:\n{ pageSize: number } General settings The plugin allows to set how many reviews are returned per page by going to the Pagination section under Ratings Plugin of the Settings section.\nThe default page size is 10.\nManagement of reviews Admin users are able to delete reviews from within the plugin page of the Strapi admin dashboard.\nThe plugin interface has two tabs: one for the latest reviews and one for reviews by content ID.\nRoadmap and future plans The plugin is pretty basic but it can be improved with more features and a better UI/UX. Collaborations and suggestions are very welcome.\n","image":"//localhost:1313/images/post/ratings.webp","permalink":"//localhost:1313/blogs/strapi-plugin-ratings/","tags":["Strapi","Strapi plugins"],"title":"Strapi Plugin Ratings"},{"categories":["Projects"],"contents":"ManyLMS is an e-learning platform built on top of Strapi, React Router 7, Typescript and other technologies.\nOutline The idea Platform features The stack The API The frontend Conclusion Landing Page The idea This project doesn\u0026rsquo;t necessarily bring a huge amount of innovation on the e-learning platforms that already exists, but it\u0026rsquo;s just another way of doing this type of application.\nThe main idea is to apply a JAMstack approach in this application, where the platform is a static website, and the backend is just an API that serves static content only once to build the website and just adds the dynamism that\u0026rsquo;s necessary to allow users to authenticate, create orders, confirm payments and take courses.\nIf we compare this approach to a WordPress website, we are taking out most of the overhead that implies rendering the pages everytime a user visits them. Despite that there are plugins for caching that may improve the performance, it\u0026rsquo;s still never going to be faster and more efficient than just static content served by a CDN. That\u0026rsquo;s why React Router 7 and Headless CMSs are so popular right now.\nPlatform features and user stories The following user stories illustrates the desired features the platform should have.\nAs an administrator, I want to: login in the admin panel. create categories. create courses. upload lectures. organise courses into categories. assign lectures to courses. As a student, I want to: login in the platform. view the available courses. add courses to the shopping cart. review the shopping cart. create an order. pay with credit card or paypal. view the courses i\u0026rsquo;ve purchased in my learning page. go to the course page from my learning page and watch the videos. mark lectures as seen. come back later and resume where I left. The requirements The backend requires to handle user authentication, permissions, different data structures as content types and define relationships between them. It also requires to allow uploading videos to some third party platform that supports streaming on demand.\nThe frontend is a web platform where users can register and login, view and buy courses, leave comments and reviews and take courses.\nThe API Since all of the features involve authentication, permissions and roles, and because there is no need to reinvent the wheel, I chose to use Strapi to build the backend for it\u0026rsquo;s simplicity, ease of use and great developer experience, whereas for streaming videos on demand, I chose to use Mux.com.\nThe instance of Strapi and the Postgres database it requires was deployed in the cloud hosting platform https://fly.io.\nStrapi is good for managing users, content that\u0026rsquo;s typically updated and fetched via CRUD API, and setting up relations between content types.\nThe platform needs the following content types:\nCategory to group courses Course Lecture Module to group lectures Order Student: has many courses Student-Course: stores a student\u0026rsquo;s current lecture of a course Video Strapi makes the creation of these content types and setting up relationships between them really straightforward.\nBelow are some screenshots of these content types and the relationships between them:\nThe frontend The platform where users are able to login, view, buy and view courses is a web application built with React Router 7. Among the features of this application are:\nState managed by Context API Interface styled with Bootstrap Play streaming videos with @mux/mux-player-react library Use of localStorage to save user session Below are some sample screenshots of how this app looks like\nConclusion and final thoughts While building this project, I learned:\nHow streaming on demand works and how to use a streaming provider How to statically build websites with React Router 7 and Strapi How to setup dynamic pages in React Router 7 How to process payments with Stripe and Paypal How to build custom plugins in Strapi How to publish packages to NPM Project source codes: https://github.com/luisguve/maestro-backend\nhttps://github.com/luisguve/new-lms-remix\n","image":"//localhost:1313/images/project/manylms/frontend/course_overview.png","permalink":"//localhost:1313/projects/e-learning-platform-maestro-lms/","tags":["Strapi","React","React Router 7","Typescript","Mux"],"title":"ManyLMS: E-Learning platform"},{"categories":["Projects"],"contents":"ETMday (Emprende tu Mente) is a large-scale entrepreneurship event website built on top of WordPress with the Themosis framework, featuring an interactive SVG map, real-time countdown timers, advanced search functionality, and comprehensive content management using Vue 3, Laravel Mix, and modern frontend technologies.\nOutline The project Key features The stack Frontend architecture Interactive components Conclusion Live website The project ETMday is Chile\u0026rsquo;s premier entrepreneurship event, bringing together thousands of entrepreneurs, startups, corporates, and strategic partners. The website serves as the central hub for event information, featuring speakers, activities, stands, program schedules, and an interactive event map.\nThe frontend development required implementing complex interactive features including an SVG-based interactive map with tooltips, real-time countdown timers, advanced filtering and search systems, and dynamic content displays that handle thousands of attendees and hundreds of activities.\nKey features The website includes several sophisticated features:\nInteractive SVG Map: Custom-built interactive map with clickable zones, tooltips, and dynamic content display Real-time Countdown: Event countdown timer with automatic updates and mobile optimization Advanced Search: Multi-category search across activities, speakers, stands, and content Dynamic Filtering: Complex filtering system with tabs, favorites, and downloadable resources Animated Statistics: Odometer animations for displaying event metrics Content Management: Comprehensive card components for activities, speakers, stands, and blog posts Form Handling: Multi-step forms with validation using Vee-Validate Lightbox Galleries: Image galleries with LightGallery integration Responsive Design: Fully responsive design optimized for all devices The stack The frontend stack consists of:\nVue 3.2.4: Modern reactive framework for building interactive components Laravel Mix 6.0: Asset compilation and bundling SCSS: Advanced styling with organized architecture Vee-Validate 4.15.0: Form validation with Yup schemas Axios 1.6.8: HTTP client for API requests Splide.js 4.1.4: Modern carousel and slider components LightGallery 2.8.3: Lightbox gallery functionality Odometer 0.4.8: Animated number counting Headroom.js: Header behavior on scroll jQuery 3.7.1: DOM manipulation and legacy support SweetAlert2: Modern alert dialogs GLightbox 3.3.1: Alternative lightbox solution Frontend architecture Vue components The application features a comprehensive set of Vue 3 components:\nCard Components:\ncards/activities.vue: Activity cards with favorites functionality cards/speakers.vue: Speaker cards with modal details cards/stands.vue: Stand/exhibitor cards cards/blog.vue: Blog post cards cards/shortcut.vue: Quick access shortcut cards Functional Components:\nSectionCards.vue: Main section component with tabs, filtering, and card display Search.vue: Advanced search component with multi-category results Form.vue: Dynamic form component with validation FormCalendar.vue: Calendar form component CustomFilter.vue: Reusable filter component CustomSelect.vue: Custom select dropdown Pagination.vue: Pagination component JavaScript components The application includes 17 specialized JavaScript components:\nInteractive Features:\ninteractiveMap.js: SVG map interaction with tooltips, zones, and dynamic content countdown.js: Real-time countdown timer with automatic updates odometer.js: Animated number counting with scroll triggers map.js: Map zone interactions and modal displays UI Components:\nheader.js: Header functionality and navigation headroom.js: Header hide/show on scroll accordion.js: Accordion interactions tabs.js: Tab functionality cards.js: Card interactions and modals siteModals.js: Modal management system UI.js: General UI utilities Media Components:\nvideo.js: Video player setup lightgallery.js: Lightbox gallery initialization splide.js: Carousel initialization slick.js: Legacy carousel support Utilities:\nscrollTrigger.js: Scroll-based animations imgToSvg.js: SVG image conversion utility SCSS architecture The styling follows a well-organized SCSS architecture:\nscss/ ├── abstracts/ # Variables, mixins, functions │ ├── _functions.scss │ ├── _mixins.scss │ ├── _variables.scss │ ├── _mq.scss # Media query mixins │ └── _keyframes.scss ├── base/ # Base styles and typography │ ├── _typography.scss │ ├── _container.scss │ └── _reset.scss └── components/ # Component-specific styles └── [52 component files] Key SCSS features:\nBEM methodology: Consistent naming convention Media query mixins: Using sass-mq for responsive design Modular architecture: Each component has its own SCSS file Component organization: 52 component-specific SCSS files Interactive components Interactive SVG Map The interactiveMap.js component implements a sophisticated SVG-based interactive map:\nFeatures:\nSVG Tooltips: Dynamically generated tooltips with text wrapping Zone Interactions: Clickable zones with modal displays Point Markers: Interactive points with icons and labels Dynamic Content: Content loaded based on zone/point selection Responsive Design: Optimized for mobile and desktop Technical Implementation:\nSVG namespace manipulation for tooltip creation Text wrapping algorithm for tooltip content Path generation for tooltip shapes with rounded corners Event delegation for zone and point interactions Smooth animations and transitions Real-time Countdown The countdown.js component provides a real-time countdown timer:\nFeatures:\nAutomatic Updates: Updates every second Multi-unit Display: Days, hours, minutes, and seconds Pluralization: Proper Spanish pluralization (Día/Días, Hora/Horas) Mobile Optimization: Simplified display on mobile devices End State Handling: Automatic transition when countdown ends Advanced Search System The Search.vue component implements a comprehensive search system:\nFeatures:\nMulti-category Search: Searches across activities, speakers, stands, and other content Category Tabs: Quick navigation between result categories Result Counts: Dynamic result counts per category Scroll Navigation: Smooth scrolling to category sections Carousel Display: Splide carousels for result display Loading States: Loading indicators during search Empty States: User-friendly empty state messages Dynamic Filtering System The SectionCards.vue component provides advanced filtering:\nFeatures:\nTab Navigation: Multiple filter tabs Favorites System: Save and filter favorite items Search Integration: Inline search within filters Reset Functionality: Clear all filters with one click Downloadable Resources: Download buttons for resources URL Synchronization: Filter state in URL parameters Responsive Design: Mobile accordion interface Animated Statistics The odometer.js component provides animated number counting:\nFeatures:\nScroll-triggered: Animations trigger on scroll Prefix/Suffix Support: Handles formatted numbers (e.g., \u0026ldquo;56,000+\u0026rdquo;) Mobile Optimization: Static display on mobile Smooth Animations: Odometer theme integration Development workflow The project uses Laravel Mix for asset compilation:\n// Development npm run dev // Compile assets npm run watch // Watch for changes npm run hot // Hot module replacement // Production npm run production // Optimized production build BrowserSync integration provides:\nLive reloading during development Synchronized browser testing Proxy configuration for WordPress development Performance optimizations Code splitting: Laravel Mix extracts vendor libraries Asset versioning: Automatic cache busting Image optimization: Lazy loading and responsive images Minification: Production builds are minified and optimized Tree shaking: Unused code elimination in production SVG optimization: Efficient SVG manipulation and rendering Accessibility Semantic HTML structure ARIA labels for interactive elements Keyboard navigation support Focus management in forms and modals Screen reader considerations Proper alt text for images Conclusion and final thoughts Building the ETMday frontend was an excellent opportunity to:\nMaster SVG interactions: Creating complex interactive SVG maps with dynamic tooltips and zones Implement real-time features: Building countdown timers and live updates Build advanced search: Multi-category search with filtering and categorization Handle complex state: Managing filters, favorites, and dynamic content Optimize performance: Implementing efficient animations and lazy loading Ensure scalability: Building components that handle large datasets (thousands of attendees, hundreds of activities) The project demonstrates proficiency in:\nModern JavaScript frameworks (Vue 3) SVG manipulation and interaction Real-time UI updates Advanced filtering and search systems Build tools and asset compilation (Laravel Mix, Webpack) CSS architecture and methodologies (SCSS, BEM) Component-based development Event-driven architecture The integration with WordPress/Themosis backend required careful consideration of server-side rendering, API endpoints, and content management workflows, making this a full-stack frontend implementation for a large-scale event.\nLive website: https://etmday.org/\nFigma Prototype: https://www.figma.com/proto/mt9fJ8P03M5gf0nQwcU99q/EtM-Day-2025---Dise%C3%B1o?node-id=1-2743\u0026m=dev\u0026scaling=scale-down\u0026content-scaling=fixed\u0026page-id=0%3A1\u0026starting-point-node-id=1%3A2743\n","image":"//localhost:1313/images/project/etm/home.png","permalink":"//localhost:1313/projects/etmday-entrepreneurship-event-website/","tags":["Vue 3","Laravel Mix","WordPress","Themosis","SCSS","JavaScript","Interactive Map","SVG"],"title":"ETMday: Entrepreneurship Event Website"},{"categories":["Projects"],"contents":"ISC Chile is an educational consultancy website for study abroad programs, built on top of WordPress with the Themosis framework, featuring GSAP animations, multi-step contact forms, advanced blog filtering, and comprehensive content management using Vue 2, Laravel Mix, and modern frontend technologies.\nOutline The project Design implementation The stack Frontend architecture Key features Conclusion Live website The project ISC Chile is an educational consultancy agency that has been providing study abroad advisory services since 1996. The website serves as the primary platform for showcasing various educational programs including English courses, school exchanges, group travel programs, and Pathways programs for university admission abroad.\nThe frontend development was based on a comprehensive Figma design, requiring pixel-perfect implementation of complex UI components, multi-step forms, animated statistics, and responsive layouts that work seamlessly across all devices.\nDesign implementation The entire frontend was built from a detailed Figma design, ensuring:\nPixel-perfect accuracy: Matching the design specifications precisely (as evidenced by Figma height references in SCSS) Responsive design: Implementing breakpoints and mobile-first approach Component consistency: Maintaining design system patterns throughout Interactive elements: Translating static designs into dynamic, interactive components Animation and transitions: Implementing smooth GSAP-powered animations The stack The frontend stack consists of:\nVue 2.6.12: Reactive framework for building interactive components Laravel Mix 6.0: Asset compilation and bundling SCSS: Advanced styling with a well-organized architecture Vuex 3.6.2: State management for Vue applications Vee-Validate 3.4.14: Form validation GSAP 3.12.5: Professional animation library with ScrollTrigger Axios 0.18: HTTP client for API requests Splide.js 4.1.4: Modern carousel and slider components Slick Carousel 1.8.1: Legacy carousel support LightGallery 2.7.2: Lightbox gallery functionality Odometer 0.4.8: Animated number counting Headroom.js: Header behavior on scroll V-Calendar 2.4.2: Calendar component for date selection V-Mask 2.3.0: Input masking Vue-Select 3.20.2: Custom select component jQuery 3.2: DOM manipulation and legacy support SweetAlert: Alert dialogs Frontend architecture Vue components The application features a comprehensive set of Vue 2 components:\nForm Components:\nContact.vue: Multi-step contact form with validation and reCAPTCHA ContactFormStep1.vue: First step of the contact form ContactFormStep2.vue: Second step of the contact form ContactFormStep3.vue: Third step of the contact form FormBanner.vue: Banner form component Content Components:\nBlog.vue: Blog listing with advanced filtering and search BlogArticleCard.vue \u0026amp; BlogArticleCardLoading.vue: Blog post cards with loading states ExperiencesPanel.vue: Testimonials and experiences display panel ExperiencesFiltersMobile.vue: Mobile filter component for experiences Search Components:\nSearchResults.vue: Search results display component SearchResultCardLoading.vue: Loading skeleton for search results UI Components:\nCheckboxDropdown.vue: Custom checkbox dropdown component CheckboxDropdownFieldset.vue: Fieldset wrapper for checkbox dropdowns EmptyState.vue: Empty state displays Loader.vue \u0026amp; Loading.vue: Loading indicators JavaScript components The application includes 15 specialized JavaScript components:\nAnimation Components:\ngsap.js: GSAP animations with ScrollTrigger for scroll-based reveals scrolltrigger.js: Custom scroll trigger utilities odometer.js: Animated number counting with scroll triggers UI Components:\nheader.js: Header functionality and navigation headroom.js: Header hide/show on scroll megamenu.js: Mega menu functionality mobileMenu.js: Mobile menu interactions searchbar.js: Search bar functionality floating-banner.js: Floating banner component footer.js: Footer functionality Media Components:\nvideo.js: Video player setup lightgallery.js: Lightbox gallery initialization splide.js: Carousel initialization slick.js: Legacy carousel support Interactive Components:\naccordion.js: Accordion interactions tabs.js: Tab functionality cards.js: Card interactions Utilities:\nimg-to-svg.js: SVG image conversion utility SCSS architecture The styling follows a well-organized SCSS architecture:\nscss/ ├── abstracts/ # Variables, mixins, functions │ ├── _mixins.scss │ ├── _mq.scss # Media query mixins │ └── _vendor.scss ├── base/ # Base styles and typography │ ├── _typography.scss │ ├── _colors.scss │ ├── _container.scss │ ├── _globals.scss │ └── fonts/ # Custom TWK Everett font family └── components/ # Component-specific styles └── [45 component files] Key SCSS features:\nBEM methodology: Consistent naming convention throughout Media query mixins: Using sass-mq for responsive design Modular architecture: Each component has its own SCSS file Custom typography: TWK Everett font family with multiple weights Figma references: Direct references to Figma design specifications Key features Multi-step contact form The Contact.vue component implements a sophisticated multi-step form with:\nThree-step navigation: Step-by-step form progression Form validation: Using Vee-Validate with comprehensive rules Date picker: V-Calendar integration for date selection Input masking: V-Mask for phone numbers and formatted inputs reCAPTCHA integration: Spam protection Dynamic fields: Fields that change based on user selections Loading states: Visual feedback during form submission Error handling: Comprehensive error messages and validation Form steps include:\nStep 1: Personal information and contact details Step 2: Educational background and program interests Step 3: Additional information and submission GSAP animations The gsap.js component provides professional animations:\nFeatures:\nScroll-triggered animations: Elements animate on scroll Vertical scroll reveals: Fade and slide animations Horizontal scroll reveals: Staggered animations for grid layouts Timeline management: Complex animation sequences Performance optimized: Efficient animation triggers Animation types:\nFade in with vertical movement Staggered grid animations Scroll-based reveals Smooth transitions Advanced blog system The Blog.vue component provides comprehensive blog functionality:\nFeatures:\nCategory filtering: Filter posts by category Search functionality: Real-time search across blog posts Mobile filters: Dedicated mobile filter interface Pagination: Efficient content pagination Loading states: Skeleton loading screens Empty states: User-friendly empty state messages Experiences/testimonials panel The ExperiencesPanel.vue component displays student testimonials:\nFeatures:\nFilter by type: Filter testimonials (Students/Parents) Dynamic loading: Load testimonials from API Responsive design: Mobile-optimized display Carousel integration: Splide carousel for testimonial display Animated statistics The odometer.js component provides animated number counting:\nFeatures:\nScroll-triggered: Animations trigger on scroll Smooth counting: Odometer theme integration Performance optimized: Efficient scroll detection Mobile support: Optimized for all devices Search functionality The SearchResults.vue component provides comprehensive search:\nFeatures:\nMulti-content search: Search across programs, blog posts, and pages Result categorization: Organized search results Image support: Results with and without images Tag display: Category tags for results Loading states: Skeleton loading screens Custom typography The website features a custom font family, TWK Everett, with:\nMultiple weights: From Hairline to Super Italic variants: All weights include italic versions Optimized formats: WOFF, WOFF2, and OTF formats Performance: Efficient font loading and rendering Development workflow The project uses Laravel Mix for asset compilation:\n// Development npm run dev // Compile assets npm run watch // Watch for changes npm run hot // Hot module replacement // Production npm run production // Optimized production build BrowserSync integration provides:\nLive reloading during development Synchronized browser testing Proxy configuration for WordPress development Performance optimizations Code splitting: Laravel Mix extracts vendor libraries Asset versioning: Automatic cache busting Image optimization: Lazy loading and responsive images Minification: Production builds are minified and optimized Tree shaking: Unused code elimination in production Font optimization: Efficient font loading strategies Accessibility Semantic HTML structure ARIA labels for interactive elements Keyboard navigation support Focus management in forms Screen reader considerations Proper alt text for images Conclusion and final thoughts Building the ISC Chile frontend from a Figma design was an excellent opportunity to:\nMaster Vue 2: Working with Options API, Vuex state management, and Vue 2 patterns Implement GSAP animations: Creating professional scroll-triggered animations Build complex forms: Multi-step forms with validation, date pickers, and input masking Create advanced filtering: Blog filtering with search and category selection Optimize performance: Implementing efficient animations and lazy loading Ensure design fidelity: Translating Figma designs into pixel-perfect implementations (with direct Figma references in code) The project demonstrates proficiency in:\nModern JavaScript frameworks (Vue 2) Animation libraries (GSAP, ScrollTrigger) Form validation and user experience (Vee-Validate, V-Mask, V-Calendar) Build tools and asset compilation (Laravel Mix, Webpack) CSS architecture and methodologies (SCSS, BEM) Component-based development State management (Vuex) Design system implementation The integration with WordPress/Themosis backend required careful consideration of server-side rendering, API endpoints, and content management workflows, making this a full-stack frontend implementation for an educational consultancy platform.\nLive website: https://www.iscchile.cl/\n","image":"//localhost:1313/images/project/isc-chile/home.png","permalink":"//localhost:1313/projects/isc-chile-educational-consultancy-website/","tags":["Vue 2","Laravel Mix","WordPress","Themosis","SCSS","GSAP","JavaScript","Figma"],"title":"ISC Chile: Educational Consultancy Website"},{"categories":["Projects"],"contents":"Chile Nativo is a travel tour website for Patagonia experiences, built on top of WordPress with the Themosis framework, featuring a modern frontend implementation based on a Figma design using Vue 3, Laravel Mix, and a comprehensive SCSS architecture.\nOutline The project Design implementation The stack Frontend architecture Key features Conclusion Live website The project Chile Nativo is a travel company specializing in Patagonia tours, offering experiences in destinations like Torres del Paine, Tierra del Fuego, and Isla Navarino. The website serves as the primary platform for showcasing tours, managing bookings, and providing information about their travel experiences.\nThe frontend development was based on a comprehensive Figma design, requiring pixel-perfect implementation of complex UI components, interactive forms, filtering systems, and responsive layouts that work seamlessly across all devices.\nDesign implementation The entire frontend was built from a detailed Figma design, ensuring:\nPixel-perfect accuracy: Matching the design specifications precisely Responsive design: Implementing breakpoints and mobile-first approach Component consistency: Maintaining design system patterns throughout Interactive elements: Translating static designs into dynamic, interactive components Animation and transitions: Implementing smooth user experience enhancements The stack The frontend stack consists of:\nVue 3.2.4: Modern reactive framework for building interactive components Laravel Mix 6.0: Asset compilation and bundling SCSS: Advanced styling with a well-organized architecture Pinia 2.3.1: State management for Vue applications Vee-Validate 4.15.0: Form validation with Yup schemas Axios 1.6.8: HTTP client for API requests Splide.js 4.1.4: Modern carousel and slider components Headroom.js: Header behavior on scroll Plyr 3.7.8: Video player implementation SweetAlert2: Modern alert dialogs jQuery 3.7.1: Legacy support and DOM manipulation utilities Frontend architecture Vue components The application features a comprehensive set of Vue 3 components organized by functionality:\nFiltering and Search Components:\nToursFilter.vue: Advanced tour filtering with multiple criteria TourDatesFilter.vue: Date-based filtering for tour availability ToursFilterDropdown.vue \u0026amp; ToursFilterDropdownMobile.vue: Responsive filter dropdowns TestimonialsFilter.vue: Filtering system for customer testimonials NewsFilter.vue: Blog and news filtering SearchResults.vue: Search results display with pagination Form Components:\nPersonalizedTripForm.vue: Multi-step form for custom trip requests with validation ContactFormSimple.vue: Contact form with reCAPTCHA integration FormHelp.vue: Help center form FormGiftCard.vue: Gift card purchase form FormCareers.vue: Job application form NewsletterForm.vue: Newsletter subscription Card Components:\nTour.vue \u0026amp; TourLoading.vue: Tour card display with loading states TourDate.vue \u0026amp; TourDateLoading.vue: Tour date selection cards Testimonial.vue \u0026amp; TestimonialLoading.vue: Customer testimonial cards Blog.vue \u0026amp; BlogLoading.vue: Blog post cards Team.vue \u0026amp; TeamLoading.vue: Team member cards ResourceCard.vue \u0026amp; ResourceLoading.vue: Resource display cards Utility Components:\nPagination.vue: Reusable pagination component Select.vue: Custom select dropdown with search Loader.vue \u0026amp; LoaderFullScreen.vue: Loading indicators EmptyState.vue: Empty state displays ContentResources.vue: Resource content management TeamTabsFilter.vue: Tabbed team member filtering SCSS architecture The styling follows a well-organized SCSS architecture:\nscss/ ├── abstracts/ # Variables, mixins, functions │ ├── _functions.scss │ ├── _mixins.scss │ ├── _variables.scss │ ├── _mq.scss # Media query mixins │ └── _keyframes.scss ├── base/ # Base styles and typography │ ├── _typography.scss │ ├── _colors.scss │ ├── _fonts.scss │ └── _reset.scss └── components/ # Component-specific styles └── [125 component files] Key SCSS features:\nBEM methodology: Consistent naming convention throughout Media query mixins: Using sass-mq for responsive design Modular architecture: Each component has its own SCSS file Abstract layer: Reusable variables, mixins, and functions Vue transitions: Custom transition styles for Vue components JavaScript architecture The JavaScript is organized into two main entry points:\nMain application (app.js):\nInitializes core application functionality Sets up jQuery plugins and utilities Handles legacy browser support Vue application (vue/main.js):\nConfigures Vue 3 app with Pinia for state management Registers global Vue components Sets up Vee-Validate configuration Integrates third-party Vue plugins (VueTelInput, etc.) Component utilities (app/components/):\nheader.js: Header behavior and navigation footer.js: Footer functionality splide.js: Carousel initialization slick.js: Legacy carousel support accordions.js: Accordion interactions tabs.js: Tab functionality scrollTrigger.js: Scroll-based animations video.js: Video player setup sticky-sidebar.js: Sticky sidebar behavior Key features Multi-step forms The PersonalizedTripForm.vue component implements a sophisticated multi-step form with:\nStep-by-step navigation with progress indicators Form validation using Vee-Validate and Yup schemas Dynamic form fields based on user selections Phone number input with international support (VueTelInput) reCAPTCHA integration for spam protection Loading states and error handling Advanced filtering system The tour filtering system (ToursFilter.vue) provides:\nMultiple filter criteria (destination, activity type, trip type, month) Real-time filtering with URL parameter synchronization Responsive design with mobile accordion interface Custom select components with search functionality Empty states and loading indicators Integration with WordPress backend via Axios Responsive design The entire website is fully responsive with:\nMobile-first approach Breakpoint management using sass-mq Touch-friendly interactions Optimized images and assets Performance optimizations for mobile devices Performance optimizations Code splitting: Laravel Mix extracts vendor libraries Asset versioning: Automatic cache busting Image optimization: Lazy loading and responsive images Minification: Production builds are minified and optimized Tree shaking: Unused code elimination in production Accessibility Semantic HTML structure ARIA labels where appropriate Keyboard navigation support Focus management in forms Screen reader considerations Development workflow The project uses Laravel Mix for asset compilation:\n// Development npm run dev // Compile assets npm run watch // Watch for changes npm run hot // Hot module replacement // Production npm run production // Optimized production build BrowserSync integration provides:\nLive reloading during development Synchronized browser testing Proxy configuration for WordPress development Conclusion and final thoughts Building the Chile Nativo frontend from a Figma design was an excellent opportunity to:\nMaster Vue 3: Working with the Composition API, reactive systems, and modern Vue patterns Implement complex forms: Multi-step forms with validation, international phone inputs, and reCAPTCHA Build scalable architecture: Organizing 40+ Vue components and 125+ SCSS files in a maintainable structure Optimize performance: Implementing code splitting, lazy loading, and production optimizations Ensure design fidelity: Translating Figma designs into pixel-perfect implementations Handle responsive design: Creating seamless experiences across all device sizes The project demonstrates proficiency in:\nModern JavaScript frameworks (Vue 3) Build tools and asset compilation (Laravel Mix, Webpack) CSS architecture and methodologies (SCSS, BEM) Form validation and user experience Component-based development Design system implementation The integration with WordPress/Themosis backend required careful consideration of server-side rendering, API endpoints, and content management workflows, making this a full-stack frontend implementation.\nLive website: https://chilenativo.travel/\nFigma prototype: https://www.figma.com/proto/ywHPhSP1UfYUAE8eWVQv4L/Dise%C3%B1o-Desktop---Chile-Nativo?node-id=289-3912\u0026m=dev\u0026scaling=min-zoom\u0026content-scaling=fixed\u0026page-id=289%3A3911\u0026starting-point-node-id=289%3A3912\n","image":"//localhost:1313/images/project/chile-nativo/home.png","permalink":"//localhost:1313/projects/chile-nativo-patagonia-travel-website/","tags":["Vue 3","Laravel Mix","WordPress","Themosis","SCSS","JavaScript","Figma"],"title":"Chile Nativo: Patagonia Travel Website"},{"categories":["Projects"],"contents":"Rutieri is a SaaS platform built with Strapi, React Native, Typescript and other technologies.\nOutline The idea Platform features The stack The API The frontend The mobile app Conclusion Landing Page The idea Before starting to write a single line of code, it is generally a good idea to think about the problem, it\u0026rsquo;s limitations and whether or not it has already been solved by someone else (AKA competitors).\nThe problem I was looking into had to do with the way in which public and private transportation companies manage their routes, drivers and users. This process is generally carried out on paper, e.g. not digital, hence this could be problematic in case of new drivers joining the organization or in case of restricting access to data to only specific users.\nAfter a little bit of research, I could only find one platform that provides a similiar solution but for their own company.\nPlatform features and user stories The following user stories illustrates the desired features the platform should have in order to solve the aforementioned problems.\nAs an administrator user, I want to: login in the admin panel. create an organization. create routes in the organization. invite drivers and users to the organization. manage requests to join the organization. assign routes to drivers in the organization. see in real time the drivers and users currently active in the map of the different routes. As a driver, I want to: login in the mobile app. join an organization by entering the code in the search bar. see my route on the map. become visible to passengers on the road. see the passengers waiting on the road. remove my visibility and finish my run. As a passenger, I want to: login in the mobile app. join an organization by entering the code in the search bar. see the different routes of my organization in the map. search for a destination and get the available routes that pass nearby. see the drivers currently active on the routes in real time. become visible to drivers of a route. The requirements The backend requires to handle user authentication, permissions, different data structures as content types and define relations between them. It\u0026rsquo;s also necessary to synchronise passengers and drivers and view them on a map real time in the administration panel as well as in the mobile app.\nThe administration panel is a web page that fetches data from the backend as well as from the real time data provider and it\u0026rsquo;s goal is to provide a way for administrators to manage their organization and users. We\u0026rsquo;re talking about a Single Page Application built in React.\nAs for the mobile application, there isn\u0026rsquo;t a better choice nowadays than React Native and it works just fine in this case.\nThe API Since all of the features involve authentication, permissions and roles, and because there is no need to reinvent the wheel, I chose to use Strapi to build the backend for it\u0026rsquo;s simplicity, ease of use and great developer experience, whereas for realtime data, I used Firebase.\nThe instance of Strapi and the Postgres database it requires was deployed in the cloud hosting platform https://fly.io.\nStrapi is good for managing users, content that\u0026rsquo;s typically updated and fetched via CRUD API, and relations between content types.\nThe platform needs the following content types:\nOrganizations to group routes, drivers and users Routes Two user roles: drivers and users (passengers) Below are some screenshots of the overview of these content types\nAs I said before, Strapi makes the creation of these content types and the relationships between them really straightforward.\nHowever, not everything related to the API can be provided by Strapi. Some realtime features need to be addressed with other solutions, such as geolocation data in real time for drivers and users to synchronise each other, maps and the ability to search for places. Such features were implemented using Firebase, Google Maps and Google Places.\nThe frontend The platform where users are able to login as administrators and manage their organizations and users is a single page web application built in React. Among the features of this project that I think stand out are:\nState managed by Context API Interface styled with Bootstrap React Router for pages Leaflet to display the map GeoFire library to synchronise geolocation data in real time with Firebase Use of localStorage to save user session Below are some sample screenshots of how this app looks like\nThe mobile application This one is by far the most complex part of this project.\nThe project was bootstraped with Infinitered\u0026rsquo;s Ignite, which provides a great boilerplate and surely saved me of what would have been between 1-2 months of work.\nIgnite\u0026rsquo;s boilerplate includes many features out of the box, including:\nReact Native and Typescript (of course) React Navigation MobX-State-Tree for state management Expo SDK for developer experience AsyncStorage for persistence apisauce as REST client And some other libraries and features that make React Native apps super powerful and a joy to work on.\nIt consists of three screens:\nWelcome screen Login screen Map screen In the welcome screen, users are able to go to the login screen if not logged in. Otherwise, if they\u0026rsquo;re in an organisation, it shows their role and org\u0026rsquo;s information, and if they\u0026rsquo;re not, they are able to enter the organisation code and request to join as driver or as passenger.\nWelcome screens Login screens If the user is a driver in an organisation, the welcome screen also shows the route assigned to them. By tapping on it, it takes them to the map, where they can see themselves and start the tour, becoming visible to passengers on the road but being able to see passengers on the road as well.\nDrivers can finish the tour at any time by pressing the button stop.\nIf the user is a passenger in an organisation, the welcome screen shows the different routes available in the organisation. By tapping on them, they are taken to the map where they can see themselves, the route and the drivers on the road.\nPassengers are able to navigate between the available routes and search for the location they want to go to by using the search bar at the top of the map screen, filtering out the routes that pass nearby (less than 200 meters), if there are. Google Places API and turf library work together in this search process.\nPassengers become visible to drivers on the road by pressing the button wait and if they press the button again, they stop waiting and are removed from the driver\u0026rsquo;s map.\nMap screens The start/wait and finish buttons dispatch actions that update their location in firebase, so that passengers are able to see the bus on the map as it moves in real time and viceversa.\nAs for the state management, the project consists of two models and three stores from Mobx-State-Tree library: User and Route models, user-status, route-store and root-store stores.\nUser model Located in /app/models/user/user.ts\nconst OrganizationModel = types.model({ name: types.string, code: types.string, id: types.identifierNumber, drivers: types.number, rutas: types.array(RouteModel) }) const UserModel = types .model(\u0026#34;User\u0026#34;) .props({ id: types.identifierNumber, username: types.string, email: types.string, token: types.string, role: types.union(types.literal(\u0026#34;passenger\u0026#34;), types.literal(\u0026#34;driver\u0026#34;)), ruta: types.maybeNull(RouteModel), organization: types.maybeNull(OrganizationModel), pending_request: types.maybeNull(OrganizationModel), }) Route model Located in /app/models/route/route.ts\nThis model follows the GeoJSON format for routes.\nconst RouteModel = types .model(\u0026#34;Ruta\u0026#34;) .props({ id: types.identifierNumber, name: types.string, latlong: types.maybeNull(types.model({ lat: types.number, longt: types.number })), coords: types.model({ type: FeatureTypes, features: types.array(types.model({ type: types.string, geometry: types.model({ type: types.string, coordinates: types.union(types.array(types.number), types.array(types.array(types.number))) }), properties: types.model({ name: types.string }) })) }) }) user-status store Located in /app/models/user-status/user-status.ts\nThis store is responsible for managing the state of the user. It stores the user once it\u0026rsquo;s logged in and removes it when the user logs out. It also has some views to get the user key for firebase purposes, get the role and get the route in case of a driver.\nThis store has some methods that get the user location from the device\u0026rsquo;s GPS, displays the user icon on the map and sends it to firebase.\nconst UserStatusModel = types .model(\u0026#34;UserStatus\u0026#34;) .extend(withEnvironment) .props({ user: types.maybeNull(UserModel), location: types.maybeNull( types.model({latitude: types.number, longitude: types.number}) ), visibility: types.maybeNull(types.number) }) route-store store Located in /app/models/route-store/route-store.ts\nThis store is responsible for managing the state of the available routes. It stores the routes, drivers and passengers on the different routes. It also has some view methods to filter the routes that pass nearby a destination specified by the user, get passengers waiting on a given route and get drivers active in a specific route.\nThis store initializes a GeoQuery from Geofire library and listens for events to set, update and remove drivers and passengers from the map as they move.\nconst RouteStoreModel = types .model(\u0026#34;RouteStore\u0026#34;) .props({ routes: types.array(RouteModel), passengers: types.map(types.model({ key: types.identifier, location: types.array(types.number) })), drivers: types.map(types.model({ key: types.identifier, location: types.array(types.number) })), destinationAddress: types.maybeNull(types.model({ name: types.string, coords: types.array(types.number) })) }) Conclusion and final thoughts Using a CMS as the backend can make the development a lot faster than building the API from scratch and with Strapi this is specially true. On the other hand, Strapi doesn\u0026rsquo;t really make a good fit for real time applications, therefore, Firebase is the way to go in this case.\nAs of the client side, React always works very good for pretty much any kind of application, and because React Native uses React under the hood, it is so convenient for us React developers and ir works pretty good for almost any kind of application as well.\nHowever, one thing that I didn\u0026rsquo;t mention in this post was the use of Typescript; I find this quote by Brice Wilson pretty good to point out the whole purpose and motivation to learn and use (well) this powerful language and tool ecosystem:\n\u0026ldquo;You won\u0026rsquo;t have to wait for a frustrated user to report the error. All of this means that you provide value to your users faster, and that\u0026rsquo;s really what it\u0026rsquo;s all about.\u0026rdquo;\nAll in all, I got a lot of learning by building this project, both in languages/frameworks used and production stuff such as infrastructure, cloud hosting and cloud-based APIs.\nProject landing page: https://rutieri.netlify.app\n","image":"//localhost:1313/images/project/rutieri/landing/homepage.webp","permalink":"//localhost:1313/projects/saas-platform-rutieri/","tags":["Strapi","React Native","React","Typescript","Firebase"],"title":"SaaS platform: Rutieri"},{"categories":["Tutorial"],"contents":"Enable comments in a Strapi application and display them in the frontend with React\nOutline Introduction Prerequisites What is Strapi Comment Manager? Installation Configuration Display comments on the frontend Installation of Strapi Comments Client Usage of Strapi Comments Client Plugin settings Manage comments Full source code of the frontend Conclusion Introduction A comment system comes in very handy for pretty much any kind of website. In the JAMstack ecosystem, while it\u0026rsquo;s ok to rely on third party solutions hosted on their own platform such as Disqus to enable comments, you usually want to keep your content and all the stuff related to it in the same admin dashboard.\nIn this article, I\u0026rsquo;ll show you how to enable and manage comments for your content very easily using the Comment Manager plugin, and display them in your frontend application.\nPrerequisites You should have a basic understanding of the following.\nBasic knowledge of JavaScript Basic knowledge of React (OPTIONAL) Basic understanding of Strapi - get started here. Your Strapi V4 project setup What is Strapi Comment Manager? Strapi Comment Manager is a plugin that enables comments for pretty much any kind of content. It allows your users to post comments and anyone can get the comments associated with a given slug.\nWith this plugin, admin users can view and manage very easily all the comments from the Strapi administration dashboard. Within the dashboard, you will be able to delete comments and subcomments and leave replies on comments.\nInstallation Once into the Strapi project root, you can install the plugin by running the following command:\nnpm install strapi-plugin-comment-manager Next, build the project to see the new plugin in the dashboard with the following command:\nnpm run build And that\u0026rsquo;s it! If everything runs correctly, the plugin should now be installed.\nConfiguration Now you need to enable some permissions so that the frontend can access the endpoints to post and fetch comments.\nIn your Strapi admin dashboard, head over to Settings, then over to Roles under Users \u0026amp; Permissions Plugin.\nLet\u0026rsquo;s first setup the Public API; click on Public and hit the dropdown button of Comment Manager. Now check count, find and getPageSize, then hit the Save button. Below is a screenshot of a proper configuration:\nNow let\u0026rsquo;s setup the Authenticated API. Go back to Roles and click on Authenticated. Open the dropdown for Comment Manager and mark as checked the option create on both Comment and Subcomment. Below is a screenshot of a proper configuration:\nWith this configuration, the frontend should now be able to make requests to get and post comments.\nDisplay comments on the frontend The plugin exposes an API to get and post comments if you want to have fine-grained control over the workflow of your comments system and you can check the documentation on the package page, but this plugin also comes with a purpose-built React component library that makes it super easy to get up and running without getting your hands dirty.\nThis components library is called strapi-comments-client, fully supports typescript and it handles for you all of the complexity of fetching and posting comments and subcomments for every content ID that you pass to it.\nInstallation of Strapi Comments Client You will need to have installed react ^17.0.2, react-dom ^17.0.2 and react-router-dom ^5.2.0.\nInside of your React project, run this command:\nnpm install strapi-comments-client --save Usage of Strapi Comments Client Using this library is very easy!\nThis library exports three main components:\nCommentsProvider Comments CommentForm And you can import them this way:\nimport { CommentsProvider, Comments, CommentForm } from \u0026#34;strapi-comments-client\u0026#34; All you have to do is wrap your App component into the CommentsProvider component. Then you will be able to place anywhere in your app the Comments component to render a list of comments for a given content ID and the CommentForm component to render a form to post comments.\nFor example, this could be your index.js or main.js file:\nimport React from \u0026#39;react\u0026#39; import ReactDOM from \u0026#39;react-dom\u0026#39; // The address of your strapi backend instance const STRAPI = \u0026#34;http://localhost:1337\u0026#34; ReactDOM.render( \u0026lt;React.StrictMode\u0026gt; \u0026lt;CommentsProvider apiURL={STRAPI}\u0026gt; \u0026lt;App /\u0026gt; \u0026lt;/CommentsProvider\u0026gt; \u0026lt;/React.StrictMode\u0026gt;, document.getElementById(\u0026#39;root\u0026#39;) ) Where apiURL is the URL of your running Strapi application, and this property is required.\nThis way, the comments provider will do all the magic of fetching and posting comments for you!\nThis library also exports an utility React.Context to update some of the parameters for fetching and posting comments:\nimport { CommentsConfigContext } from \u0026#34;strapi-comments-client\u0026#34; This CommentsConfigContext exposes two setter functions: setUser and setContentID\nWith setContentID you can load the comments for a given content and post comments to it. It receives a single parameter of type string and must be URLized, i.e. no spaces.\nWith setUser you can set the credentials of a given user to authorize the posting of comments. It receives a single parameter of type IUser, with the following Typescript interface:\ninterface IUser { username: string, email: string, id: string, token: string // This is a JWT } It\u0026rsquo;s a little confusing but we\u0026rsquo;ll see how to use it in a component:\nconst App = () =\u0026gt; { const { setUser, setContentID } = useContext(CommentsConfigContext) // The following data should come from Strapi Users and Permissions Plugin // for authenticated requests const user = { username: \u0026#34;John Doe\u0026#34;, email: \u0026#34;jhohndoe@gmail.com\u0026#34;, id: 5, token: \u0026#34;this_should_be_a_JWT\u0026#34; } if (user) { setUser(user) } setContentID(\u0026#34;sample-content-1\u0026#34;) // Load comments for this content return ( \u0026lt;\u0026gt; { !user \u0026amp;\u0026amp; \u0026lt;Login /\u0026gt; } \u0026lt;CommentForm /\u0026gt; \u0026lt;Comments /\u0026gt; \u0026lt;/\u0026gt; ) } And that\u0026rsquo;s it!\nAfter setting the content ID through setContentID, CommentsProvider will start loading the comments for the given content ID and the CommentForm will render an input to post comments related to the given content ID if there is a user. Otherwise, it will display the message Login to post a comment.\nHere\u0026rsquo;s how the interface looks like so far:\nThere\u0026rsquo;s also a button to Leave a reply, which will open a form to post a subcomment associated with the parent comment.\nThis library exports one more component: ErrorBox\nimport { ErrorBox } from \u0026#34;strapi-comments-client\u0026#34; .It\u0026rsquo;s useful if you\u0026rsquo;d like to display error messages when things go wrong fetching or posting comments.\nYou can place this component wherever you want, for example in between the CommentForm and the Comments components.\nIf you\u0026rsquo;re wondering how this error box looks like, here you have a sample:\nGeneral settings You can customize the page size, i.e. specify how many comments are returned at once.\nIn the Strapi admin panel, head over to Settings, then select Pagination under Comment Manager Plugin.\nHere you\u0026rsquo;ll find an input to set the page size, which defaults to 10.\nManage comments Once you\u0026rsquo;ve got the plugin up an running, as users start to post comments, you can manage and reply to them as admin from the Comment Manager section of the left sidebar in the Strapi admin dashboard.\nHere you can see two tabs: one for the latest comments and one for comments grouped by content ID.\nIn both of them you can delete comments and subcomments as well as leave replies.\nExample project You can find a full working example of a React App using the Strapi Comments Client Library in this repo\nConclusion With this plugin you can enable and manage comments for any content with little effort and even use a component library to display the comments in your frontend application made with React.\nAnd that\u0026rsquo;s it! The features are pretty basic at the moment but if there\u0026rsquo;s interest, I\u0026rsquo;m willing to work on more features as well as improve the UI/UX.\n","image":"//localhost:1313/images/post/strapilogo.jpg","permalink":"//localhost:1313/blogs/how-to-enable-and-manage-comments-in-your-strapi-application/","tags":["Strapi","Strapi tutorials"],"title":"How To Enable And Manage Comments In Your Strapi Application."},{"categories":["Documentation"],"contents":"Comment Manager is a Strapi plugin to allow your users to post comments.\nWith this plugin you can enable and manage comments for your content very easily!\nRequirements You should have installed an instance of Strapi v4.x.x\nInstallation Run the following command in your project root:\nnpm install strapi-plugin-comment-manager Configurarion For your frontend to have access to the API, enable the following permissions for Comment Manager from Users \u0026amp; Permissions Plugin on your project settings:\nFor public, enable: count, find and getPageSize.\nFor authenticated, enable create on both Comment and Subcomment.\nDisplay comments on the frontend Comments can be displayed in the frontend in two ways:\nUsing the React components library strapi-comments-client (recommended) Build your custom frontend using the API API There are some Typescript interfaces that will help to get an idea of the data structures.\nComments: interface IComment { id: string, from_admin: boolean, createdAt: string, content: string, author: IAuthor | null, subcomments?: ISubcomment[] } Subcomments: interface ISubcomment { id: string, from_admin: boolean, createdAt: string, content: string, author: IAuthor | null, } Authors: IAuthor { username: string, email: string, id: string } The following endpoints are exposed to fetch and post comments and subcomments:\nGet comments for a content ID Method: GET\nPath: /api/comment-manager/comments/:slug\nOptional query parameters: start, ignoreCount\nReturns:\n{ commentsCount?: Number, comments: IComment[] } The parameter start indicates how many comments to skip. This is for pagination purposes.\nThe parameter ignoreCount indicates whether or not to return the total number of comments associated with the given slug.\nGet the number of comments associated with a given content ID Method: GET\nPath: /api/comment-manager/comments/:slug/count\nReturns:\n{ count: Number } Post a comment Method: POST\nPath: /api/comment-manager/comments/:slug\nAuthentication: Bearer token\nPayload:\n{ content: string } Returns:\n{ id: Number } Post a subcomment Method: POST\nPath: /api/comment-manager/subcomments/:parent-id\nAuthentication: Bearer token\nPayload:\n{ content: string } Returns:\n{ id: Number } Get the page size Method: GET\nPath: /api/comment-manager/page-size\nReturns:\n{ pageSize: Number } General settings The plugin allows to set how many comments are returned per page by going to the Pagination section under Comment Manager Plugin on the Settings section.\nThe default page size is 10.\nManagement of comments Admin users are able to delete comments and subcomments as well as leave replies as admins from within the plugin page of the Strapi admin dashboard.\nThe plugin interface has two tabs: one for the latest comments and one for comments by content ID.\nRoadmap and future plans The plugin is pretty basic but it can be improved with more features and a better UI/UX. Collaborations and suggestions are very welcome.\n","image":"//localhost:1313/images/post/strapilogo.jpg","permalink":"//localhost:1313/blogs/strapi-plugin-comment-manager/","tags":["Strapi","Strapi plugins"],"title":"Strapi Plugin Comment Manager"},{"categories":["Projects"],"contents":"In this post I’m going to share my experience on building a SaaS using the headless CMS Strapi as the Backend, React Native and other technologies.\nOutline Introduction What is SaaS? The problem What is Strapi? Developing features in Strapi The frontend: How to get content Conclusion Landing Page Introduction Very often, developers, product and project managers, testers and pretty much the entire team share their ideas to decide what language and which framework they\u0026rsquo;ll use to build their next project. Some considerations must be taken into account, from which in my opinion there are three that are the most important:\nDeveloper experience and ease of use Does the language and framework chosen provide a good developer experience? Is the langauge the same for the backend and frontend?\nDeadlines Is there a deadline to finish the project? if so, there is a good chance to finish the project on time if the team chooses the language they have more experience in.\nMaintainability As there will be usually more than one person working on the same part at the same time, if everything is kept organised, the whole development process will be frictionless.\nWith that in mind, developers and project managers will have a better insight on which language/framework to use.\nOther aspects should also be considered such as what the data structure will look like.\nIn my case, as it is usual, the backend of my project needs a database for users and their roles among other entities and their relations and a dashboard to allow admins to manage the data, and I was lucky to find out Strapi, as it includes a lot of these features out of the box with one single line of command to get started.\nWhat is SaaS? SaaS stands for Software-as-a-Service and it just means that a software is provided as a service in the cloud and it gives a solution to a specific problem, for which the users are willing to pay either monthly or annual subscription.\nThe problem Before starting to write a single line of code, it is generally a good idea to think about the problem, it\u0026rsquo;s limitations and whether or not it has already been solved by someone else (AKA competitors).\nThe problem I was looking into had to do with the way in which public and private transportation companies manage their routes, drivers and users. After a little bit of research, I could only find one platform that provides a similiar solution but for their own company.\nSo the platform I built needed the following content types:\nOrganizations to group routes, drivers and users Routes Two user roles: drivers and users (passengers) As I said before, Strapi makes the creation of these content types and the relationships between them really easy, but let\u0026rsquo;s first see what is Strapi and how it turns the API development into a satisfactory and fun experience.\nWhat is Strapi? Strapi is an open source headless CMS that allows developers to build complete RESTful APIs in just a couple of days instead of months. It includes a lot of useful features as plugins out of the box. Users and Roles management, Media library and an interface to create, view, edit and delete content are just some of them.\nRegarding the API, how does it makes the development faster?\nFirst of all, it enforces a specific folder structure, which helps to keep everything well organised and clean.\nSecondly, all database schemas are generated automatically and queries are made in JSON format, which really saves a lot of time.\nLastly, we can add more features to our Strapi application very easily via plugins from the marketplace.\nIt\u0026rsquo;s also worth noting that Strapi is a self-hosted CMS, which means that we can host it in whatever cloud platform we want, as well as test it locally in our computers before deploying it to the cloud.\nDeveloping features in Strapi Creating and configuring endpoints in Strapi is as straightforward as declaring a JSON in a single file:\nCreating controllers is straightforward as well:\nEvery controller gets all the data related to the request in the ctx parameter and it\u0026rsquo;s also used to send the response. This keeps everything in one place and really helps to improve the readability.\nOnce the API endpoints are defined, the next step is to enable the permissions for the specific user roles to have access to these endpoints:\nThe frontend: how to get content Since Strapi is a headless CMS, it\u0026rsquo;ll only provide content through the API. That means that the content can be consumed from anywhere. In our case, this content will be used in two applications: one for the organization owners and one for the users and drivers.\nThe application for the organization owners is a dashboard where administrators can create organizations, routes, accept drivers and users in the organization and assign routes to drivers. This is just a React Application:\nThe application for drivers and users is a mobile application built in React Native. Firebase was used to synchronise geolocation data in real time between drivers and users and display this information in a Map from Google Maps:\nConclusion Using a CMS as the backend can make the development a lot faster than building the API from scratch and with Strapi this is specially true. Furthermore, this becomes more important when building a brand-new product, as it\u0026rsquo;s usually recommended to launch as soon as possible to gather feedback from the users and validate the idea.\nProject landing page: https://rutieri.netlify.app\n","image":"//localhost:1313/images/post/03.webp","permalink":"//localhost:1313/blogs/how-i-built-a-saas-on-top-of-strapi-and-why-you-should-too/","tags":["Strapi","React Native","Typescript"],"title":"How I Built A SaaS On Top Of Strapi, And Why You Should Too"},{"categories":["Tutorial"],"contents":"Enable User Reviews in a Strapi application and display them in the frontend with React\nOutline Introduction Prerequisites What is Strapi Ratings? Installation Configuration Display user reviews on the frontend Plugin settings Manage user reviews Full source code of the frontend Conclusion Introduction Ratings systems have become a crucial part of any website with ecommerce capabilites, as they allow the users to post reviews on the items they purchase and publish their opinion to the public. A couple of reviews can make the difference between pressing the “Buy” button and moving on to the next website in the Google search results.\nIn this article, I\u0026rsquo;ll show you how to enable and manage user reviews for your content very easily using the Ratings plugin, and display them in your frontend application.\nPrerequisites First of all, you need to have a basic understanding of the following.\nBasic knowledge of JavaScript Basic knowledge of React (OPTIONAL) Basic understanding of Strapi - get started here. Your Strapi V4 project setup What is Strapi Ratings? Strapi Ratings is a plugin that gives your Strapi application the ability to manage ratings for pretty much any kind of content. It allows your users to post reviews and anyone can get the reviews associated with a given slug.\nWith this plugin, admin users can view and manage very easily all the reviews from the Strapi administration dashboard. Within the dashboard, you will be able to see reviews related to content slugs as well as delete reviews.\nInstallation Once into the Strapi project root, you can install the plugin by running the following command:\nnpm install strapi-plugin-ratings Next, build the project to see the new plugin in the dashboard with the following command:\nnpm run build And that\u0026rsquo;s it! If everything runs correctly, the plugin should now be installed.\nConfiguration Now you need to enable some permissions so that the frontend can access the endpoints to post and fetch reviews.\nIn your Strapi admin dashboard, head over to Settings, then over to Roles under Users \u0026amp; Permissions Plugin.\nLet\u0026rsquo;s first setup the Public API; click on Public and hit the dropdown button of Ratings. Now check count, find, getPageSize and getStats, then hit the Save button. Below is a screenshot of a proper configuration:\nNow let\u0026rsquo;s setup the Authenticated API. Go back to Roles and click on Authenticated. Open the dropdown for Ratings and mark as checked the options create, find and getUserReview. Below is a screenshot of a proper configuration:\nWith this configuration, the frontend should now be able to make requests to get and post user reviews.\nDisplay use reviews on the frontend The plugin exposes an API to get and post reviews if you want to have fine-grained control over the workflow of your ratings system and you can check the documentation on the package page, but this plugin also comes with a purpose-built React component library that makes it super easy to get up and running without getting your hands dirty.\nThis components library is called strapi-ratings-client, fully supports typescript and it takes care of all the complexity of fetching and posting user reviews for every content ID that you pass to it.\nInstallation of Strapi Ratings Client You will need to have installed react ^17.0.2, react-dom ^17.0.2, bootstrap ^5.1.3 and @popperjs/core^2.11.2\nInside of your React project, run this command:\nnpm install strapi-ratings-client --save Usage of Strapi Ratings Client Using this library is very easy!\nThis library exports three main components:\nReviewsProvider Reviews ReviewForm And you can import them this way:\nimport { ReviewsProvider, Reviews, ReviewForm } from \u0026#34;strapi-ratings-client\u0026#34; All you have to do is wrap your App component into the ReviewsProvider component. Then you will be able to place anywhere in your app the Reviews component to render a list of user reviews for a given content ID and the ReviewForm component to render a form to allow your users to post reviews.\nFor example, this could be your index.js or main.js file:\nimport React from \u0026#39;react\u0026#39; import ReactDOM from \u0026#39;react-dom\u0026#39; // The address of your strapi backend instance const STRAPI = \u0026#34;http://localhost:1337\u0026#34; ReactDOM.render( \u0026lt;React.StrictMode\u0026gt; \u0026lt;ReviewsProvider apiURL={STRAPI}\u0026gt; \u0026lt;App /\u0026gt; \u0026lt;/ReviewsProvider\u0026gt; \u0026lt;/React.StrictMode\u0026gt;, document.getElementById(\u0026#39;root\u0026#39;) ) Where apiURL is the URL of your running Strapi application, and this property is required.\nThis way, the ratings provider will do all the magic of fetching and posting comments for you!\nThis library also exports an utility React.Context to update some of the parameters for fetching and posting reviews:\nimport { ReviewsConfigContext } from \u0026#34;strapi-ratings-client\u0026#34; This ReviewsConfigContext exposes three setter functions: setUser, setContentID and setCanPostReview.\nWith setContentID you can load the ratings for a given content and post reviews to it. It receives a single parameter of type string and must be URLized, i.e. no spaces.\nWith setUser you can set the credentials of a given user to authorize the posting of reviews. It receives a single parameter of type IUser, with the following Typescript interface:\ninterface IUser { username: string, email: string, id: string, token: string // This is a JWT } With setCanPostReview, you can enable the user to post a review on the given content. This is useful for when you only allow a user to post a review after they purchase the product.\nIt\u0026rsquo;s a little confusing but we\u0026rsquo;ll see how to use it in a component:\nconst App = () =\u0026gt; { const { setUser, setContentID, setCanPostReview } = useContext(ReviewsConfigContext) // The following data should come from Strapi Users and Permissions Plugin // for authenticated requests. const user = { username: \u0026#34;John Doe\u0026#34;, email: \u0026#34;jhohndoe@gmail.com\u0026#34;, id: 5, token: \u0026#34;this_should_be_a_JWT\u0026#34; } if (user) { setUser(user) } setContentID(\u0026#34;sample-content-1\u0026#34;) // Load reviews for this content setCanPostReview(true) // Allow this user to post a review return ( \u0026lt;\u0026gt; { !user \u0026amp;\u0026amp; \u0026lt;Login /\u0026gt; } \u0026lt;ReviewForm /\u0026gt; \u0026lt;Reviews /\u0026gt; \u0026lt;/\u0026gt; ) } And that\u0026rsquo;s it!\nAfter setting the content ID through setContentID, ReviewsProvider will start loading the reviews for the given content ID and the ReviewForm will render an input to post a user review related to the given content ID if there is a user and he’s allowed to post a review. Otherwise, it will display the message Login to post a review or nothing at all if the user is not allowed to post a review.\nHere\u0026rsquo;s how the interface looks like so far:\nThis library exports one more component: ErrorBox\nimport { ErrorBox } from \u0026#34;strapi-ratings-client\u0026#34; .It\u0026rsquo;s useful for when you\u0026rsquo;d like to display error messages when things go wrong fetching or posting reviews.\nYou can place this component wherever you want, for example in between the ReviewForm and the Reviews components.\nIf you\u0026rsquo;re wondering how this error box looks like, here‘s a screenshot:\nGeneral settings You can customize the page size, i.e. specify how many user reviews are showed at once.\nIn the Strapi admin panel, head over to Settings, then select Pagination under Ratings Plugin.\nHere you\u0026rsquo;ll find an input to set the page size, which defaults to 10.\nManage reviews Once you\u0026rsquo;ve got the plugin up an running, as users start to post reviews, you can view them from within the Ratings section of the left sidebar in the Strapi admin dashboard.\nHere you can see two tabs: one for the latest reviews and one for reviews grouped by content ID.\nIn both of them you can delete unwanted reviews.\nExample project You can find a full working example of a React App using the Strapi Ratings Client Library in this repo: https://github.com/luisguve/strapi-ratings-client-example\nConclusion With this plugin you can enable and manage user reviews for any content with little effort and even use a library of components styled with Bootstrap to display the user reviews in your frontend.\nAnd that\u0026rsquo;s it! The features are pretty basic at the moment but if there\u0026rsquo;s interest, I\u0026rsquo;m willing to work on more features as well as improve the UI/UX.\n","image":"//localhost:1313/images/post/tutorial-ratings.webp","permalink":"//localhost:1313/blogs/how-to-enable-and-manage-user-reviews-in-your-strapi-application/","tags":["Strapi","Strapi tutorials"],"title":"How To Enable And Manage User Reviews In Your Strapi Application"},{"categories":["Documentation"],"contents":"Ratings is a Strapi plugin that allows your users to post reviews.\nEnable and manage user reviews for your content very easily!\nRequirements You should have installed an instance of Strapi v4.x.x\nInstallation Run the following command in your project root:\nnpm install strapi-plugin-ratings Then, rebuild the admin dashboard using the following command\nnpm run build Configurarion For your frontend to have access to the API, enable the following permissions for Ratings from Users \u0026amp; Permissions Plugin on your project settings:\nFor public, enable: count, find, getPageSize and getStats.\nFor authenticated, enable create, find and getUserReview.\nDisplay user reviews on the frontend Reviews can be displayed in the frontend in two ways:\nUsing the React components library strapi-ratings-client (recommended) Build your custom frontend using the API endpoints, described as follows: API There are some Typescript interfaces that will help to get an idea of the data structures.\nReviews: interface IReview { id: number, createdAt: string, comment: string | null, author: IAuthor | null, score: number, } Authors: interface IAuthor { username: string, email: string, id: number } Content Stats interface IStats { averageScore: number; reviewsCount: number | null; } The following endpoints are exposed to fetch and post reviews:\nGet reviews for a content ID Method: GET\nPath: /api/ratings/reviews/:slug\nOptional query parameters: start, ignoreCount\nReturns:\n{ reviewsCount: number, averageScore: number, userReview: IReview | null, reviews: IReview[] } The parameter start indicates how many reviews to skip. This is for pagination purposes.\nThe parameter ignoreCount indicates whether or not to return the total number of reviews associated with the given slug.\nGet review stats for a content ID Method: GET\nPath: /api/ratings/reviews/:slug/stats\nReturns:\n{ averageScore: number, reviewsCount: number | null } Get the number of reviews associated with a given content ID Method: GET\nPath: /api/ratings/reviews/:slug/count\nReturns:\n{ count: number } Post a review Method: POST\nPath: /api/ratings/reviews/:slug\nAuthentication: Bearer token\nPayload:\n{ content: string } Returns:\n{ id: number } By default, every authenticated user can post reviews on any content.\nIn order to customize this behavior, e.g. allowing or disallowing a user from posting reviews, you must extend the service userCanPostReview from whithin register function in ./src/index.js. For example:\nstrapi.service(\u0026#34;plugin::ratings.review\u0026#34;).userCanPostReview = async (user, slug) =\u0026gt; { /* Here you will check whether or not the user is allowed to post a review on this content ID and return either true or false. */ return true } Notice that userCanPostReview will receive two parameters: the user from Users \u0026amp; Permissions Plugin, containing it\u0026rsquo;s id, username, confirmed, etc., and the slug, which is a string and refers to the content ID which the review is being posted on.\nIn case this function returns false, the response of the endpoint will be 403 (forbidden) with the text User cannot post a review on this content.\nGet the page size Method: GET\nPath: /api/ratings/page-size\nReturns:\n{ pageSize: number } General settings The plugin allows to set how many reviews are returned per page by going to the Pagination section under Ratings Plugin of the Settings section.\nThe default page size is 10.\nManagement of reviews Admin users are able to delete reviews from within the plugin page of the Strapi admin dashboard.\nThe plugin interface has two tabs: one for the latest reviews and one for reviews by content ID.\nRoadmap and future plans The plugin is pretty basic but it can be improved with more features and a better UI/UX. Collaborations and suggestions are very welcome.\n","image":"//localhost:1313/images/post/ratings.webp","permalink":"//localhost:1313/blogs/strapi-plugin-ratings/","tags":["Strapi","Strapi plugins"],"title":"Strapi Plugin Ratings"},{"categories":["Projects"],"contents":"ManyLMS is an e-learning platform built on top of Strapi, React Router 7, Typescript and other technologies.\nOutline The idea Platform features The stack The API The frontend Conclusion Landing Page The idea This project doesn\u0026rsquo;t necessarily bring a huge amount of innovation on the e-learning platforms that already exists, but it\u0026rsquo;s just another way of doing this type of application.\nThe main idea is to apply a JAMstack approach in this application, where the platform is a static website, and the backend is just an API that serves static content only once to build the website and just adds the dynamism that\u0026rsquo;s necessary to allow users to authenticate, create orders, confirm payments and take courses.\nIf we compare this approach to a WordPress website, we are taking out most of the overhead that implies rendering the pages everytime a user visits them. Despite that there are plugins for caching that may improve the performance, it\u0026rsquo;s still never going to be faster and more efficient than just static content served by a CDN. That\u0026rsquo;s why React Router 7 and Headless CMSs are so popular right now.\nPlatform features and user stories The following user stories illustrates the desired features the platform should have.\nAs an administrator, I want to: login in the admin panel. create categories. create courses. upload lectures. organise courses into categories. assign lectures to courses. As a student, I want to: login in the platform. view the available courses. add courses to the shopping cart. review the shopping cart. create an order. pay with credit card or paypal. view the courses i\u0026rsquo;ve purchased in my learning page. go to the course page from my learning page and watch the videos. mark lectures as seen. come back later and resume where I left. The requirements The backend requires to handle user authentication, permissions, different data structures as content types and define relationships between them. It also requires to allow uploading videos to some third party platform that supports streaming on demand.\nThe frontend is a web platform where users can register and login, view and buy courses, leave comments and reviews and take courses.\nThe API Since all of the features involve authentication, permissions and roles, and because there is no need to reinvent the wheel, I chose to use Strapi to build the backend for it\u0026rsquo;s simplicity, ease of use and great developer experience, whereas for streaming videos on demand, I chose to use Mux.com.\nThe instance of Strapi and the Postgres database it requires was deployed in the cloud hosting platform https://fly.io.\nStrapi is good for managing users, content that\u0026rsquo;s typically updated and fetched via CRUD API, and setting up relations between content types.\nThe platform needs the following content types:\nCategory to group courses Course Lecture Module to group lectures Order Student: has many courses Student-Course: stores a student\u0026rsquo;s current lecture of a course Video Strapi makes the creation of these content types and setting up relationships between them really straightforward.\nBelow are some screenshots of these content types and the relationships between them:\nThe frontend The platform where users are able to login, view, buy and view courses is a web application built with React Router 7. Among the features of this application are:\nState managed by Context API Interface styled with Bootstrap Play streaming videos with @mux/mux-player-react library Use of localStorage to save user session Below are some sample screenshots of how this app looks like\nConclusion and final thoughts While building this project, I learned:\nHow streaming on demand works and how to use a streaming provider How to statically build websites with React Router 7 and Strapi How to setup dynamic pages in React Router 7 How to process payments with Stripe and Paypal How to build custom plugins in Strapi How to publish packages to NPM Project source codes: https://github.com/luisguve/maestro-backend\nhttps://github.com/luisguve/new-lms-remix\n","image":"//localhost:1313/images/project/manylms/frontend/course_overview.png","permalink":"//localhost:1313/projects/e-learning-platform-maestro-lms/","tags":["Strapi","React","React Router 7","Typescript","Mux"],"title":"ManyLMS: E-Learning platform"},{"categories":["Projects"],"contents":"ETMday (Emprende tu Mente) is a large-scale entrepreneurship event website built on top of WordPress with the Themosis framework, featuring an interactive SVG map, real-time countdown timers, advanced search functionality, and comprehensive content management using Vue 3, Laravel Mix, and modern frontend technologies.\nOutline The project Key features The stack Frontend architecture Interactive components Conclusion Live website The project ETMday is Chile\u0026rsquo;s premier entrepreneurship event, bringing together thousands of entrepreneurs, startups, corporates, and strategic partners. The website serves as the central hub for event information, featuring speakers, activities, stands, program schedules, and an interactive event map.\nThe frontend development required implementing complex interactive features including an SVG-based interactive map with tooltips, real-time countdown timers, advanced filtering and search systems, and dynamic content displays that handle thousands of attendees and hundreds of activities.\nKey features The website includes several sophisticated features:\nInteractive SVG Map: Custom-built interactive map with clickable zones, tooltips, and dynamic content display Real-time Countdown: Event countdown timer with automatic updates and mobile optimization Advanced Search: Multi-category search across activities, speakers, stands, and content Dynamic Filtering: Complex filtering system with tabs, favorites, and downloadable resources Animated Statistics: Odometer animations for displaying event metrics Content Management: Comprehensive card components for activities, speakers, stands, and blog posts Form Handling: Multi-step forms with validation using Vee-Validate Lightbox Galleries: Image galleries with LightGallery integration Responsive Design: Fully responsive design optimized for all devices The stack The frontend stack consists of:\nVue 3.2.4: Modern reactive framework for building interactive components Laravel Mix 6.0: Asset compilation and bundling SCSS: Advanced styling with organized architecture Vee-Validate 4.15.0: Form validation with Yup schemas Axios 1.6.8: HTTP client for API requests Splide.js 4.1.4: Modern carousel and slider components LightGallery 2.8.3: Lightbox gallery functionality Odometer 0.4.8: Animated number counting Headroom.js: Header behavior on scroll jQuery 3.7.1: DOM manipulation and legacy support SweetAlert2: Modern alert dialogs GLightbox 3.3.1: Alternative lightbox solution Frontend architecture Vue components The application features a comprehensive set of Vue 3 components:\nCard Components:\ncards/activities.vue: Activity cards with favorites functionality cards/speakers.vue: Speaker cards with modal details cards/stands.vue: Stand/exhibitor cards cards/blog.vue: Blog post cards cards/shortcut.vue: Quick access shortcut cards Functional Components:\nSectionCards.vue: Main section component with tabs, filtering, and card display Search.vue: Advanced search component with multi-category results Form.vue: Dynamic form component with validation FormCalendar.vue: Calendar form component CustomFilter.vue: Reusable filter component CustomSelect.vue: Custom select dropdown Pagination.vue: Pagination component JavaScript components The application includes 17 specialized JavaScript components:\nInteractive Features:\ninteractiveMap.js: SVG map interaction with tooltips, zones, and dynamic content countdown.js: Real-time countdown timer with automatic updates odometer.js: Animated number counting with scroll triggers map.js: Map zone interactions and modal displays UI Components:\nheader.js: Header functionality and navigation headroom.js: Header hide/show on scroll accordion.js: Accordion interactions tabs.js: Tab functionality cards.js: Card interactions and modals siteModals.js: Modal management system UI.js: General UI utilities Media Components:\nvideo.js: Video player setup lightgallery.js: Lightbox gallery initialization splide.js: Carousel initialization slick.js: Legacy carousel support Utilities:\nscrollTrigger.js: Scroll-based animations imgToSvg.js: SVG image conversion utility SCSS architecture The styling follows a well-organized SCSS architecture:\nscss/ ├── abstracts/ # Variables, mixins, functions │ ├── _functions.scss │ ├── _mixins.scss │ ├── _variables.scss │ ├── _mq.scss # Media query mixins │ └── _keyframes.scss ├── base/ # Base styles and typography │ ├── _typography.scss │ ├── _container.scss │ └── _reset.scss └── components/ # Component-specific styles └── [52 component files] Key SCSS features:\nBEM methodology: Consistent naming convention Media query mixins: Using sass-mq for responsive design Modular architecture: Each component has its own SCSS file Component organization: 52 component-specific SCSS files Interactive components Interactive SVG Map The interactiveMap.js component implements a sophisticated SVG-based interactive map:\nFeatures:\nSVG Tooltips: Dynamically generated tooltips with text wrapping Zone Interactions: Clickable zones with modal displays Point Markers: Interactive points with icons and labels Dynamic Content: Content loaded based on zone/point selection Responsive Design: Optimized for mobile and desktop Technical Implementation:\nSVG namespace manipulation for tooltip creation Text wrapping algorithm for tooltip content Path generation for tooltip shapes with rounded corners Event delegation for zone and point interactions Smooth animations and transitions Real-time Countdown The countdown.js component provides a real-time countdown timer:\nFeatures:\nAutomatic Updates: Updates every second Multi-unit Display: Days, hours, minutes, and seconds Pluralization: Proper Spanish pluralization (Día/Días, Hora/Horas) Mobile Optimization: Simplified display on mobile devices End State Handling: Automatic transition when countdown ends Advanced Search System The Search.vue component implements a comprehensive search system:\nFeatures:\nMulti-category Search: Searches across activities, speakers, stands, and other content Category Tabs: Quick navigation between result categories Result Counts: Dynamic result counts per category Scroll Navigation: Smooth scrolling to category sections Carousel Display: Splide carousels for result display Loading States: Loading indicators during search Empty States: User-friendly empty state messages Dynamic Filtering System The SectionCards.vue component provides advanced filtering:\nFeatures:\nTab Navigation: Multiple filter tabs Favorites System: Save and filter favorite items Search Integration: Inline search within filters Reset Functionality: Clear all filters with one click Downloadable Resources: Download buttons for resources URL Synchronization: Filter state in URL parameters Responsive Design: Mobile accordion interface Animated Statistics The odometer.js component provides animated number counting:\nFeatures:\nScroll-triggered: Animations trigger on scroll Prefix/Suffix Support: Handles formatted numbers (e.g., \u0026ldquo;56,000+\u0026rdquo;) Mobile Optimization: Static display on mobile Smooth Animations: Odometer theme integration Development workflow The project uses Laravel Mix for asset compilation:\n// Development npm run dev // Compile assets npm run watch // Watch for changes npm run hot // Hot module replacement // Production npm run production // Optimized production build BrowserSync integration provides:\nLive reloading during development Synchronized browser testing Proxy configuration for WordPress development Performance optimizations Code splitting: Laravel Mix extracts vendor libraries Asset versioning: Automatic cache busting Image optimization: Lazy loading and responsive images Minification: Production builds are minified and optimized Tree shaking: Unused code elimination in production SVG optimization: Efficient SVG manipulation and rendering Accessibility Semantic HTML structure ARIA labels for interactive elements Keyboard navigation support Focus management in forms and modals Screen reader considerations Proper alt text for images Conclusion and final thoughts Building the ETMday frontend was an excellent opportunity to:\nMaster SVG interactions: Creating complex interactive SVG maps with dynamic tooltips and zones Implement real-time features: Building countdown timers and live updates Build advanced search: Multi-category search with filtering and categorization Handle complex state: Managing filters, favorites, and dynamic content Optimize performance: Implementing efficient animations and lazy loading Ensure scalability: Building components that handle large datasets (thousands of attendees, hundreds of activities) The project demonstrates proficiency in:\nModern JavaScript frameworks (Vue 3) SVG manipulation and interaction Real-time UI updates Advanced filtering and search systems Build tools and asset compilation (Laravel Mix, Webpack) CSS architecture and methodologies (SCSS, BEM) Component-based development Event-driven architecture The integration with WordPress/Themosis backend required careful consideration of server-side rendering, API endpoints, and content management workflows, making this a full-stack frontend implementation for a large-scale event.\nLive website: https://etmday.org/\nFigma Prototype: https://www.figma.com/proto/mt9fJ8P03M5gf0nQwcU99q/EtM-Day-2025---Dise%C3%B1o?node-id=1-2743\u0026m=dev\u0026scaling=scale-down\u0026content-scaling=fixed\u0026page-id=0%3A1\u0026starting-point-node-id=1%3A2743\n","image":"//localhost:1313/images/project/etm/home.png","permalink":"//localhost:1313/projects/etmday-entrepreneurship-event-website/","tags":["Vue 3","Laravel Mix","WordPress","Themosis","SCSS","JavaScript","Interactive Map","SVG"],"title":"ETMday: Entrepreneurship Event Website"},{"categories":["Projects"],"contents":"ISC Chile is an educational consultancy website for study abroad programs, built on top of WordPress with the Themosis framework, featuring GSAP animations, multi-step contact forms, advanced blog filtering, and comprehensive content management using Vue 2, Laravel Mix, and modern frontend technologies.\nOutline The project Design implementation The stack Frontend architecture Key features Conclusion Live website The project ISC Chile is an educational consultancy agency that has been providing study abroad advisory services since 1996. The website serves as the primary platform for showcasing various educational programs including English courses, school exchanges, group travel programs, and Pathways programs for university admission abroad.\nThe frontend development was based on a comprehensive Figma design, requiring pixel-perfect implementation of complex UI components, multi-step forms, animated statistics, and responsive layouts that work seamlessly across all devices.\nDesign implementation The entire frontend was built from a detailed Figma design, ensuring:\nPixel-perfect accuracy: Matching the design specifications precisely (as evidenced by Figma height references in SCSS) Responsive design: Implementing breakpoints and mobile-first approach Component consistency: Maintaining design system patterns throughout Interactive elements: Translating static designs into dynamic, interactive components Animation and transitions: Implementing smooth GSAP-powered animations The stack The frontend stack consists of:\nVue 2.6.12: Reactive framework for building interactive components Laravel Mix 6.0: Asset compilation and bundling SCSS: Advanced styling with a well-organized architecture Vuex 3.6.2: State management for Vue applications Vee-Validate 3.4.14: Form validation GSAP 3.12.5: Professional animation library with ScrollTrigger Axios 0.18: HTTP client for API requests Splide.js 4.1.4: Modern carousel and slider components Slick Carousel 1.8.1: Legacy carousel support LightGallery 2.7.2: Lightbox gallery functionality Odometer 0.4.8: Animated number counting Headroom.js: Header behavior on scroll V-Calendar 2.4.2: Calendar component for date selection V-Mask 2.3.0: Input masking Vue-Select 3.20.2: Custom select component jQuery 3.2: DOM manipulation and legacy support SweetAlert: Alert dialogs Frontend architecture Vue components The application features a comprehensive set of Vue 2 components:\nForm Components:\nContact.vue: Multi-step contact form with validation and reCAPTCHA ContactFormStep1.vue: First step of the contact form ContactFormStep2.vue: Second step of the contact form ContactFormStep3.vue: Third step of the contact form FormBanner.vue: Banner form component Content Components:\nBlog.vue: Blog listing with advanced filtering and search BlogArticleCard.vue \u0026amp; BlogArticleCardLoading.vue: Blog post cards with loading states ExperiencesPanel.vue: Testimonials and experiences display panel ExperiencesFiltersMobile.vue: Mobile filter component for experiences Search Components:\nSearchResults.vue: Search results display component SearchResultCardLoading.vue: Loading skeleton for search results UI Components:\nCheckboxDropdown.vue: Custom checkbox dropdown component CheckboxDropdownFieldset.vue: Fieldset wrapper for checkbox dropdowns EmptyState.vue: Empty state displays Loader.vue \u0026amp; Loading.vue: Loading indicators JavaScript components The application includes 15 specialized JavaScript components:\nAnimation Components:\ngsap.js: GSAP animations with ScrollTrigger for scroll-based reveals scrolltrigger.js: Custom scroll trigger utilities odometer.js: Animated number counting with scroll triggers UI Components:\nheader.js: Header functionality and navigation headroom.js: Header hide/show on scroll megamenu.js: Mega menu functionality mobileMenu.js: Mobile menu interactions searchbar.js: Search bar functionality floating-banner.js: Floating banner component footer.js: Footer functionality Media Components:\nvideo.js: Video player setup lightgallery.js: Lightbox gallery initialization splide.js: Carousel initialization slick.js: Legacy carousel support Interactive Components:\naccordion.js: Accordion interactions tabs.js: Tab functionality cards.js: Card interactions Utilities:\nimg-to-svg.js: SVG image conversion utility SCSS architecture The styling follows a well-organized SCSS architecture:\nscss/ ├── abstracts/ # Variables, mixins, functions │ ├── _mixins.scss │ ├── _mq.scss # Media query mixins │ └── _vendor.scss ├── base/ # Base styles and typography │ ├── _typography.scss │ ├── _colors.scss │ ├── _container.scss │ ├── _globals.scss │ └── fonts/ # Custom TWK Everett font family └── components/ # Component-specific styles └── [45 component files] Key SCSS features:\nBEM methodology: Consistent naming convention throughout Media query mixins: Using sass-mq for responsive design Modular architecture: Each component has its own SCSS file Custom typography: TWK Everett font family with multiple weights Figma references: Direct references to Figma design specifications Key features Multi-step contact form The Contact.vue component implements a sophisticated multi-step form with:\nThree-step navigation: Step-by-step form progression Form validation: Using Vee-Validate with comprehensive rules Date picker: V-Calendar integration for date selection Input masking: V-Mask for phone numbers and formatted inputs reCAPTCHA integration: Spam protection Dynamic fields: Fields that change based on user selections Loading states: Visual feedback during form submission Error handling: Comprehensive error messages and validation Form steps include:\nStep 1: Personal information and contact details Step 2: Educational background and program interests Step 3: Additional information and submission GSAP animations The gsap.js component provides professional animations:\nFeatures:\nScroll-triggered animations: Elements animate on scroll Vertical scroll reveals: Fade and slide animations Horizontal scroll reveals: Staggered animations for grid layouts Timeline management: Complex animation sequences Performance optimized: Efficient animation triggers Animation types:\nFade in with vertical movement Staggered grid animations Scroll-based reveals Smooth transitions Advanced blog system The Blog.vue component provides comprehensive blog functionality:\nFeatures:\nCategory filtering: Filter posts by category Search functionality: Real-time search across blog posts Mobile filters: Dedicated mobile filter interface Pagination: Efficient content pagination Loading states: Skeleton loading screens Empty states: User-friendly empty state messages Experiences/testimonials panel The ExperiencesPanel.vue component displays student testimonials:\nFeatures:\nFilter by type: Filter testimonials (Students/Parents) Dynamic loading: Load testimonials from API Responsive design: Mobile-optimized display Carousel integration: Splide carousel for testimonial display Animated statistics The odometer.js component provides animated number counting:\nFeatures:\nScroll-triggered: Animations trigger on scroll Smooth counting: Odometer theme integration Performance optimized: Efficient scroll detection Mobile support: Optimized for all devices Search functionality The SearchResults.vue component provides comprehensive search:\nFeatures:\nMulti-content search: Search across programs, blog posts, and pages Result categorization: Organized search results Image support: Results with and without images Tag display: Category tags for results Loading states: Skeleton loading screens Custom typography The website features a custom font family, TWK Everett, with:\nMultiple weights: From Hairline to Super Italic variants: All weights include italic versions Optimized formats: WOFF, WOFF2, and OTF formats Performance: Efficient font loading and rendering Development workflow The project uses Laravel Mix for asset compilation:\n// Development npm run dev // Compile assets npm run watch // Watch for changes npm run hot // Hot module replacement // Production npm run production // Optimized production build BrowserSync integration provides:\nLive reloading during development Synchronized browser testing Proxy configuration for WordPress development Performance optimizations Code splitting: Laravel Mix extracts vendor libraries Asset versioning: Automatic cache busting Image optimization: Lazy loading and responsive images Minification: Production builds are minified and optimized Tree shaking: Unused code elimination in production Font optimization: Efficient font loading strategies Accessibility Semantic HTML structure ARIA labels for interactive elements Keyboard navigation support Focus management in forms Screen reader considerations Proper alt text for images Conclusion and final thoughts Building the ISC Chile frontend from a Figma design was an excellent opportunity to:\nMaster Vue 2: Working with Options API, Vuex state management, and Vue 2 patterns Implement GSAP animations: Creating professional scroll-triggered animations Build complex forms: Multi-step forms with validation, date pickers, and input masking Create advanced filtering: Blog filtering with search and category selection Optimize performance: Implementing efficient animations and lazy loading Ensure design fidelity: Translating Figma designs into pixel-perfect implementations (with direct Figma references in code) The project demonstrates proficiency in:\nModern JavaScript frameworks (Vue 2) Animation libraries (GSAP, ScrollTrigger) Form validation and user experience (Vee-Validate, V-Mask, V-Calendar) Build tools and asset compilation (Laravel Mix, Webpack) CSS architecture and methodologies (SCSS, BEM) Component-based development State management (Vuex) Design system implementation The integration with WordPress/Themosis backend required careful consideration of server-side rendering, API endpoints, and content management workflows, making this a full-stack frontend implementation for an educational consultancy platform.\nLive website: https://www.iscchile.cl/\nFigma prototype: https://www.figma.com/proto/BfdKGJlzx7xAnE7rpZ1vda/Dise%C3%B1o-ISC?page-id=314%3A12071\u0026type=design\u0026node-id=314-12072\u0026viewport=-1452%2C930%2C0.29\u0026t=hFYiwcionjRAZ47v-1\u0026scaling=min-zoom\n","image":"//localhost:1313/images/project/isc-chile/home.png","permalink":"//localhost:1313/projects/isc-chile-educational-consultancy-website/","tags":["Vue 2","Laravel Mix","WordPress","Themosis","SCSS","GSAP","JavaScript","Figma"],"title":"ISC Chile: Educational Consultancy Website"},{"categories":["Projects"],"contents":"Chile Nativo is a travel tour website for Patagonia experiences, built on top of WordPress with the Themosis framework, featuring a modern frontend implementation based on a Figma design using Vue 3, Laravel Mix, and a comprehensive SCSS architecture.\nOutline The project Design implementation The stack Frontend architecture Key features Conclusion Live website The project Chile Nativo is a travel company specializing in Patagonia tours, offering experiences in destinations like Torres del Paine, Tierra del Fuego, and Isla Navarino. The website serves as the primary platform for showcasing tours, managing bookings, and providing information about their travel experiences.\nThe frontend development was based on a comprehensive Figma design, requiring pixel-perfect implementation of complex UI components, interactive forms, filtering systems, and responsive layouts that work seamlessly across all devices.\nDesign implementation The entire frontend was built from a detailed Figma design, ensuring:\nPixel-perfect accuracy: Matching the design specifications precisely Responsive design: Implementing breakpoints and mobile-first approach Component consistency: Maintaining design system patterns throughout Interactive elements: Translating static designs into dynamic, interactive components Animation and transitions: Implementing smooth user experience enhancements The stack The frontend stack consists of:\nVue 3.2.4: Modern reactive framework for building interactive components Laravel Mix 6.0: Asset compilation and bundling SCSS: Advanced styling with a well-organized architecture Pinia 2.3.1: State management for Vue applications Vee-Validate 4.15.0: Form validation with Yup schemas Axios 1.6.8: HTTP client for API requests Splide.js 4.1.4: Modern carousel and slider components Headroom.js: Header behavior on scroll Plyr 3.7.8: Video player implementation SweetAlert2: Modern alert dialogs jQuery 3.7.1: Legacy support and DOM manipulation utilities Frontend architecture Vue components The application features a comprehensive set of Vue 3 components organized by functionality:\nFiltering and Search Components:\nToursFilter.vue: Advanced tour filtering with multiple criteria TourDatesFilter.vue: Date-based filtering for tour availability ToursFilterDropdown.vue \u0026amp; ToursFilterDropdownMobile.vue: Responsive filter dropdowns TestimonialsFilter.vue: Filtering system for customer testimonials NewsFilter.vue: Blog and news filtering SearchResults.vue: Search results display with pagination Form Components:\nPersonalizedTripForm.vue: Multi-step form for custom trip requests with validation ContactFormSimple.vue: Contact form with reCAPTCHA integration FormHelp.vue: Help center form FormGiftCard.vue: Gift card purchase form FormCareers.vue: Job application form NewsletterForm.vue: Newsletter subscription Card Components:\nTour.vue \u0026amp; TourLoading.vue: Tour card display with loading states TourDate.vue \u0026amp; TourDateLoading.vue: Tour date selection cards Testimonial.vue \u0026amp; TestimonialLoading.vue: Customer testimonial cards Blog.vue \u0026amp; BlogLoading.vue: Blog post cards Team.vue \u0026amp; TeamLoading.vue: Team member cards ResourceCard.vue \u0026amp; ResourceLoading.vue: Resource display cards Utility Components:\nPagination.vue: Reusable pagination component Select.vue: Custom select dropdown with search Loader.vue \u0026amp; LoaderFullScreen.vue: Loading indicators EmptyState.vue: Empty state displays ContentResources.vue: Resource content management TeamTabsFilter.vue: Tabbed team member filtering SCSS architecture The styling follows a well-organized SCSS architecture:\nscss/ ├── abstracts/ # Variables, mixins, functions │ ├── _functions.scss │ ├── _mixins.scss │ ├── _variables.scss │ ├── _mq.scss # Media query mixins │ └── _keyframes.scss ├── base/ # Base styles and typography │ ├── _typography.scss │ ├── _colors.scss │ ├── _fonts.scss │ └── _reset.scss └── components/ # Component-specific styles └── [125 component files] Key SCSS features:\nBEM methodology: Consistent naming convention throughout Media query mixins: Using sass-mq for responsive design Modular architecture: Each component has its own SCSS file Abstract layer: Reusable variables, mixins, and functions Vue transitions: Custom transition styles for Vue components JavaScript architecture The JavaScript is organized into two main entry points:\nMain application (app.js):\nInitializes core application functionality Sets up jQuery plugins and utilities Handles legacy browser support Vue application (vue/main.js):\nConfigures Vue 3 app with Pinia for state management Registers global Vue components Sets up Vee-Validate configuration Integrates third-party Vue plugins (VueTelInput, etc.) Component utilities (app/components/):\nheader.js: Header behavior and navigation footer.js: Footer functionality splide.js: Carousel initialization slick.js: Legacy carousel support accordions.js: Accordion interactions tabs.js: Tab functionality scrollTrigger.js: Scroll-based animations video.js: Video player setup sticky-sidebar.js: Sticky sidebar behavior Key features Multi-step forms The PersonalizedTripForm.vue component implements a sophisticated multi-step form with:\nStep-by-step navigation with progress indicators Form validation using Vee-Validate and Yup schemas Dynamic form fields based on user selections Phone number input with international support (VueTelInput) reCAPTCHA integration for spam protection Loading states and error handling Advanced filtering system The tour filtering system (ToursFilter.vue) provides:\nMultiple filter criteria (destination, activity type, trip type, month) Real-time filtering with URL parameter synchronization Responsive design with mobile accordion interface Custom select components with search functionality Empty states and loading indicators Integration with WordPress backend via Axios Responsive design The entire website is fully responsive with:\nMobile-first approach Breakpoint management using sass-mq Touch-friendly interactions Optimized images and assets Performance optimizations for mobile devices Performance optimizations Code splitting: Laravel Mix extracts vendor libraries Asset versioning: Automatic cache busting Image optimization: Lazy loading and responsive images Minification: Production builds are minified and optimized Tree shaking: Unused code elimination in production Accessibility Semantic HTML structure ARIA labels where appropriate Keyboard navigation support Focus management in forms Screen reader considerations Development workflow The project uses Laravel Mix for asset compilation:\n// Development npm run dev // Compile assets npm run watch // Watch for changes npm run hot // Hot module replacement // Production npm run production // Optimized production build BrowserSync integration provides:\nLive reloading during development Synchronized browser testing Proxy configuration for WordPress development Conclusion and final thoughts Building the Chile Nativo frontend from a Figma design was an excellent opportunity to:\nMaster Vue 3: Working with the Composition API, reactive systems, and modern Vue patterns Implement complex forms: Multi-step forms with validation, international phone inputs, and reCAPTCHA Build scalable architecture: Organizing 40+ Vue components and 125+ SCSS files in a maintainable structure Optimize performance: Implementing code splitting, lazy loading, and production optimizations Ensure design fidelity: Translating Figma designs into pixel-perfect implementations Handle responsive design: Creating seamless experiences across all device sizes The project demonstrates proficiency in:\nModern JavaScript frameworks (Vue 3) Build tools and asset compilation (Laravel Mix, Webpack) CSS architecture and methodologies (SCSS, BEM) Form validation and user experience Component-based development Design system implementation The integration with WordPress/Themosis backend required careful consideration of server-side rendering, API endpoints, and content management workflows, making this a full-stack frontend implementation.\nLive website: https://chilenativo.travel/\nFigma prototype: https://www.figma.com/proto/ywHPhSP1UfYUAE8eWVQv4L/Dise%C3%B1o-Desktop---Chile-Nativo?node-id=289-3912\u0026m=dev\u0026scaling=min-zoom\u0026content-scaling=fixed\u0026page-id=289%3A3911\u0026starting-point-node-id=289%3A3912\n","image":"//localhost:1313/images/project/chile-nativo/home.png","permalink":"//localhost:1313/projects/chile-nativo-patagonia-travel-website/","tags":["Vue 3","Laravel Mix","WordPress","Themosis","SCSS","JavaScript","Figma"],"title":"Chile Nativo: Patagonia Travel Website"},{"categories":["Projects"],"contents":"Rutieri is a SaaS platform built with Strapi, React Native, Typescript and other technologies.\nOutline The idea Platform features The stack The API The frontend The mobile app Conclusion Landing Page The idea Before starting to write a single line of code, it is generally a good idea to think about the problem, it\u0026rsquo;s limitations and whether or not it has already been solved by someone else (AKA competitors).\nThe problem I was looking into had to do with the way in which public and private transportation companies manage their routes, drivers and users. This process is generally carried out on paper, e.g. not digital, hence this could be problematic in case of new drivers joining the organization or in case of restricting access to data to only specific users.\nAfter a little bit of research, I could only find one platform that provides a similiar solution but for their own company.\nPlatform features and user stories The following user stories illustrates the desired features the platform should have in order to solve the aforementioned problems.\nAs an administrator user, I want to: login in the admin panel. create an organization. create routes in the organization. invite drivers and users to the organization. manage requests to join the organization. assign routes to drivers in the organization. see in real time the drivers and users currently active in the map of the different routes. As a driver, I want to: login in the mobile app. join an organization by entering the code in the search bar. see my route on the map. become visible to passengers on the road. see the passengers waiting on the road. remove my visibility and finish my run. As a passenger, I want to: login in the mobile app. join an organization by entering the code in the search bar. see the different routes of my organization in the map. search for a destination and get the available routes that pass nearby. see the drivers currently active on the routes in real time. become visible to drivers of a route. The requirements The backend requires to handle user authentication, permissions, different data structures as content types and define relations between them. It\u0026rsquo;s also necessary to synchronise passengers and drivers and view them on a map real time in the administration panel as well as in the mobile app.\nThe administration panel is a web page that fetches data from the backend as well as from the real time data provider and it\u0026rsquo;s goal is to provide a way for administrators to manage their organization and users. We\u0026rsquo;re talking about a Single Page Application built in React.\nAs for the mobile application, there isn\u0026rsquo;t a better choice nowadays than React Native and it works just fine in this case.\nThe API Since all of the features involve authentication, permissions and roles, and because there is no need to reinvent the wheel, I chose to use Strapi to build the backend for it\u0026rsquo;s simplicity, ease of use and great developer experience, whereas for realtime data, I used Firebase.\nThe instance of Strapi and the Postgres database it requires was deployed in the cloud hosting platform https://fly.io.\nStrapi is good for managing users, content that\u0026rsquo;s typically updated and fetched via CRUD API, and relations between content types.\nThe platform needs the following content types:\nOrganizations to group routes, drivers and users Routes Two user roles: drivers and users (passengers) Below are some screenshots of the overview of these content types\nAs I said before, Strapi makes the creation of these content types and the relationships between them really straightforward.\nHowever, not everything related to the API can be provided by Strapi. Some realtime features need to be addressed with other solutions, such as geolocation data in real time for drivers and users to synchronise each other, maps and the ability to search for places. Such features were implemented using Firebase, Google Maps and Google Places.\nThe frontend The platform where users are able to login as administrators and manage their organizations and users is a single page web application built in React. Among the features of this project that I think stand out are:\nState managed by Context API Interface styled with Bootstrap React Router for pages Leaflet to display the map GeoFire library to synchronise geolocation data in real time with Firebase Use of localStorage to save user session Below are some sample screenshots of how this app looks like\nThe mobile application This one is by far the most complex part of this project.\nThe project was bootstraped with Infinitered\u0026rsquo;s Ignite, which provides a great boilerplate and surely saved me of what would have been between 1-2 months of work.\nIgnite\u0026rsquo;s boilerplate includes many features out of the box, including:\nReact Native and Typescript (of course) React Navigation MobX-State-Tree for state management Expo SDK for developer experience AsyncStorage for persistence apisauce as REST client And some other libraries and features that make React Native apps super powerful and a joy to work on.\nIt consists of three screens:\nWelcome screen Login screen Map screen In the welcome screen, users are able to go to the login screen if not logged in. Otherwise, if they\u0026rsquo;re in an organisation, it shows their role and org\u0026rsquo;s information, and if they\u0026rsquo;re not, they are able to enter the organisation code and request to join as driver or as passenger.\nWelcome screens Login screens If the user is a driver in an organisation, the welcome screen also shows the route assigned to them. By tapping on it, it takes them to the map, where they can see themselves and start the tour, becoming visible to passengers on the road but being able to see passengers on the road as well.\nDrivers can finish the tour at any time by pressing the button stop.\nIf the user is a passenger in an organisation, the welcome screen shows the different routes available in the organisation. By tapping on them, they are taken to the map where they can see themselves, the route and the drivers on the road.\nPassengers are able to navigate between the available routes and search for the location they want to go to by using the search bar at the top of the map screen, filtering out the routes that pass nearby (less than 200 meters), if there are. Google Places API and turf library work together in this search process.\nPassengers become visible to drivers on the road by pressing the button wait and if they press the button again, they stop waiting and are removed from the driver\u0026rsquo;s map.\nMap screens The start/wait and finish buttons dispatch actions that update their location in firebase, so that passengers are able to see the bus on the map as it moves in real time and viceversa.\nAs for the state management, the project consists of two models and three stores from Mobx-State-Tree library: User and Route models, user-status, route-store and root-store stores.\nUser model Located in /app/models/user/user.ts\nconst OrganizationModel = types.model({ name: types.string, code: types.string, id: types.identifierNumber, drivers: types.number, rutas: types.array(RouteModel) }) const UserModel = types .model(\u0026#34;User\u0026#34;) .props({ id: types.identifierNumber, username: types.string, email: types.string, token: types.string, role: types.union(types.literal(\u0026#34;passenger\u0026#34;), types.literal(\u0026#34;driver\u0026#34;)), ruta: types.maybeNull(RouteModel), organization: types.maybeNull(OrganizationModel), pending_request: types.maybeNull(OrganizationModel), }) Route model Located in /app/models/route/route.ts\nThis model follows the GeoJSON format for routes.\nconst RouteModel = types .model(\u0026#34;Ruta\u0026#34;) .props({ id: types.identifierNumber, name: types.string, latlong: types.maybeNull(types.model({ lat: types.number, longt: types.number })), coords: types.model({ type: FeatureTypes, features: types.array(types.model({ type: types.string, geometry: types.model({ type: types.string, coordinates: types.union(types.array(types.number), types.array(types.array(types.number))) }), properties: types.model({ name: types.string }) })) }) }) user-status store Located in /app/models/user-status/user-status.ts\nThis store is responsible for managing the state of the user. It stores the user once it\u0026rsquo;s logged in and removes it when the user logs out. It also has some views to get the user key for firebase purposes, get the role and get the route in case of a driver.\nThis store has some methods that get the user location from the device\u0026rsquo;s GPS, displays the user icon on the map and sends it to firebase.\nconst UserStatusModel = types .model(\u0026#34;UserStatus\u0026#34;) .extend(withEnvironment) .props({ user: types.maybeNull(UserModel), location: types.maybeNull( types.model({latitude: types.number, longitude: types.number}) ), visibility: types.maybeNull(types.number) }) route-store store Located in /app/models/route-store/route-store.ts\nThis store is responsible for managing the state of the available routes. It stores the routes, drivers and passengers on the different routes. It also has some view methods to filter the routes that pass nearby a destination specified by the user, get passengers waiting on a given route and get drivers active in a specific route.\nThis store initializes a GeoQuery from Geofire library and listens for events to set, update and remove drivers and passengers from the map as they move.\nconst RouteStoreModel = types .model(\u0026#34;RouteStore\u0026#34;) .props({ routes: types.array(RouteModel), passengers: types.map(types.model({ key: types.identifier, location: types.array(types.number) })), drivers: types.map(types.model({ key: types.identifier, location: types.array(types.number) })), destinationAddress: types.maybeNull(types.model({ name: types.string, coords: types.array(types.number) })) }) Conclusion and final thoughts Using a CMS as the backend can make the development a lot faster than building the API from scratch and with Strapi this is specially true. On the other hand, Strapi doesn\u0026rsquo;t really make a good fit for real time applications, therefore, Firebase is the way to go in this case.\nAs of the client side, React always works very good for pretty much any kind of application, and because React Native uses React under the hood, it is so convenient for us React developers and ir works pretty good for almost any kind of application as well.\nHowever, one thing that I didn\u0026rsquo;t mention in this post was the use of Typescript; I find this quote by Brice Wilson pretty good to point out the whole purpose and motivation to learn and use (well) this powerful language and tool ecosystem:\n\u0026ldquo;You won\u0026rsquo;t have to wait for a frustrated user to report the error. All of this means that you provide value to your users faster, and that\u0026rsquo;s really what it\u0026rsquo;s all about.\u0026rdquo;\nAll in all, I got a lot of learning by building this project, both in languages/frameworks used and production stuff such as infrastructure, cloud hosting and cloud-based APIs.\nProject landing page: https://rutieri.netlify.app\n","image":"//localhost:1313/images/project/rutieri/landing/homepage.webp","permalink":"//localhost:1313/projects/saas-platform-rutieri/","tags":["Strapi","React Native","React","Typescript","Firebase"],"title":"SaaS platform: Rutieri"},{"categories":["Tutorial"],"contents":"Enable comments in a Strapi application and display them in the frontend with React\nOutline Introduction Prerequisites What is Strapi Comment Manager? Installation Configuration Display comments on the frontend Installation of Strapi Comments Client Usage of Strapi Comments Client Plugin settings Manage comments Full source code of the frontend Conclusion Introduction A comment system comes in very handy for pretty much any kind of website. In the JAMstack ecosystem, while it\u0026rsquo;s ok to rely on third party solutions hosted on their own platform such as Disqus to enable comments, you usually want to keep your content and all the stuff related to it in the same admin dashboard.\nIn this article, I\u0026rsquo;ll show you how to enable and manage comments for your content very easily using the Comment Manager plugin, and display them in your frontend application.\nPrerequisites You should have a basic understanding of the following.\nBasic knowledge of JavaScript Basic knowledge of React (OPTIONAL) Basic understanding of Strapi - get started here. Your Strapi V4 project setup What is Strapi Comment Manager? Strapi Comment Manager is a plugin that enables comments for pretty much any kind of content. It allows your users to post comments and anyone can get the comments associated with a given slug.\nWith this plugin, admin users can view and manage very easily all the comments from the Strapi administration dashboard. Within the dashboard, you will be able to delete comments and subcomments and leave replies on comments.\nInstallation Once into the Strapi project root, you can install the plugin by running the following command:\nnpm install strapi-plugin-comment-manager Next, build the project to see the new plugin in the dashboard with the following command:\nnpm run build And that\u0026rsquo;s it! If everything runs correctly, the plugin should now be installed.\nConfiguration Now you need to enable some permissions so that the frontend can access the endpoints to post and fetch comments.\nIn your Strapi admin dashboard, head over to Settings, then over to Roles under Users \u0026amp; Permissions Plugin.\nLet\u0026rsquo;s first setup the Public API; click on Public and hit the dropdown button of Comment Manager. Now check count, find and getPageSize, then hit the Save button. Below is a screenshot of a proper configuration:\nNow let\u0026rsquo;s setup the Authenticated API. Go back to Roles and click on Authenticated. Open the dropdown for Comment Manager and mark as checked the option create on both Comment and Subcomment. Below is a screenshot of a proper configuration:\nWith this configuration, the frontend should now be able to make requests to get and post comments.\nDisplay comments on the frontend The plugin exposes an API to get and post comments if you want to have fine-grained control over the workflow of your comments system and you can check the documentation on the package page, but this plugin also comes with a purpose-built React component library that makes it super easy to get up and running without getting your hands dirty.\nThis components library is called strapi-comments-client, fully supports typescript and it handles for you all of the complexity of fetching and posting comments and subcomments for every content ID that you pass to it.\nInstallation of Strapi Comments Client You will need to have installed react ^17.0.2, react-dom ^17.0.2 and react-router-dom ^5.2.0.\nInside of your React project, run this command:\nnpm install strapi-comments-client --save Usage of Strapi Comments Client Using this library is very easy!\nThis library exports three main components:\nCommentsProvider Comments CommentForm And you can import them this way:\nimport { CommentsProvider, Comments, CommentForm } from \u0026#34;strapi-comments-client\u0026#34; All you have to do is wrap your App component into the CommentsProvider component. Then you will be able to place anywhere in your app the Comments component to render a list of comments for a given content ID and the CommentForm component to render a form to post comments.\nFor example, this could be your index.js or main.js file:\nimport React from \u0026#39;react\u0026#39; import ReactDOM from \u0026#39;react-dom\u0026#39; // The address of your strapi backend instance const STRAPI = \u0026#34;http://localhost:1337\u0026#34; ReactDOM.render( \u0026lt;React.StrictMode\u0026gt; \u0026lt;CommentsProvider apiURL={STRAPI}\u0026gt; \u0026lt;App /\u0026gt; \u0026lt;/CommentsProvider\u0026gt; \u0026lt;/React.StrictMode\u0026gt;, document.getElementById(\u0026#39;root\u0026#39;) ) Where apiURL is the URL of your running Strapi application, and this property is required.\nThis way, the comments provider will do all the magic of fetching and posting comments for you!\nThis library also exports an utility React.Context to update some of the parameters for fetching and posting comments:\nimport { CommentsConfigContext } from \u0026#34;strapi-comments-client\u0026#34; This CommentsConfigContext exposes two setter functions: setUser and setContentID\nWith setContentID you can load the comments for a given content and post comments to it. It receives a single parameter of type string and must be URLized, i.e. no spaces.\nWith setUser you can set the credentials of a given user to authorize the posting of comments. It receives a single parameter of type IUser, with the following Typescript interface:\ninterface IUser { username: string, email: string, id: string, token: string // This is a JWT } It\u0026rsquo;s a little confusing but we\u0026rsquo;ll see how to use it in a component:\nconst App = () =\u0026gt; { const { setUser, setContentID } = useContext(CommentsConfigContext) // The following data should come from Strapi Users and Permissions Plugin // for authenticated requests const user = { username: \u0026#34;John Doe\u0026#34;, email: \u0026#34;jhohndoe@gmail.com\u0026#34;, id: 5, token: \u0026#34;this_should_be_a_JWT\u0026#34; } if (user) { setUser(user) } setContentID(\u0026#34;sample-content-1\u0026#34;) // Load comments for this content return ( \u0026lt;\u0026gt; { !user \u0026amp;\u0026amp; \u0026lt;Login /\u0026gt; } \u0026lt;CommentForm /\u0026gt; \u0026lt;Comments /\u0026gt; \u0026lt;/\u0026gt; ) } And that\u0026rsquo;s it!\nAfter setting the content ID through setContentID, CommentsProvider will start loading the comments for the given content ID and the CommentForm will render an input to post comments related to the given content ID if there is a user. Otherwise, it will display the message Login to post a comment.\nHere\u0026rsquo;s how the interface looks like so far:\nThere\u0026rsquo;s also a button to Leave a reply, which will open a form to post a subcomment associated with the parent comment.\nThis library exports one more component: ErrorBox\nimport { ErrorBox } from \u0026#34;strapi-comments-client\u0026#34; .It\u0026rsquo;s useful if you\u0026rsquo;d like to display error messages when things go wrong fetching or posting comments.\nYou can place this component wherever you want, for example in between the CommentForm and the Comments components.\nIf you\u0026rsquo;re wondering how this error box looks like, here you have a sample:\nGeneral settings You can customize the page size, i.e. specify how many comments are returned at once.\nIn the Strapi admin panel, head over to Settings, then select Pagination under Comment Manager Plugin.\nHere you\u0026rsquo;ll find an input to set the page size, which defaults to 10.\nManage comments Once you\u0026rsquo;ve got the plugin up an running, as users start to post comments, you can manage and reply to them as admin from the Comment Manager section of the left sidebar in the Strapi admin dashboard.\nHere you can see two tabs: one for the latest comments and one for comments grouped by content ID.\nIn both of them you can delete comments and subcomments as well as leave replies.\nExample project You can find a full working example of a React App using the Strapi Comments Client Library in this repo\nConclusion With this plugin you can enable and manage comments for any content with little effort and even use a component library to display the comments in your frontend application made with React.\nAnd that\u0026rsquo;s it! The features are pretty basic at the moment but if there\u0026rsquo;s interest, I\u0026rsquo;m willing to work on more features as well as improve the UI/UX.\n","image":"//localhost:1313/images/post/strapilogo.jpg","permalink":"//localhost:1313/blogs/how-to-enable-and-manage-comments-in-your-strapi-application/","tags":["Strapi","Strapi tutorials"],"title":"How To Enable And Manage Comments In Your Strapi Application."},{"categories":["Documentation"],"contents":"Comment Manager is a Strapi plugin to allow your users to post comments.\nWith this plugin you can enable and manage comments for your content very easily!\nRequirements You should have installed an instance of Strapi v4.x.x\nInstallation Run the following command in your project root:\nnpm install strapi-plugin-comment-manager Configurarion For your frontend to have access to the API, enable the following permissions for Comment Manager from Users \u0026amp; Permissions Plugin on your project settings:\nFor public, enable: count, find and getPageSize.\nFor authenticated, enable create on both Comment and Subcomment.\nDisplay comments on the frontend Comments can be displayed in the frontend in two ways:\nUsing the React components library strapi-comments-client (recommended) Build your custom frontend using the API API There are some Typescript interfaces that will help to get an idea of the data structures.\nComments: interface IComment { id: string, from_admin: boolean, createdAt: string, content: string, author: IAuthor | null, subcomments?: ISubcomment[] } Subcomments: interface ISubcomment { id: string, from_admin: boolean, createdAt: string, content: string, author: IAuthor | null, } Authors: IAuthor { username: string, email: string, id: string } The following endpoints are exposed to fetch and post comments and subcomments:\nGet comments for a content ID Method: GET\nPath: /api/comment-manager/comments/:slug\nOptional query parameters: start, ignoreCount\nReturns:\n{ commentsCount?: Number, comments: IComment[] } The parameter start indicates how many comments to skip. This is for pagination purposes.\nThe parameter ignoreCount indicates whether or not to return the total number of comments associated with the given slug.\nGet the number of comments associated with a given content ID Method: GET\nPath: /api/comment-manager/comments/:slug/count\nReturns:\n{ count: Number } Post a comment Method: POST\nPath: /api/comment-manager/comments/:slug\nAuthentication: Bearer token\nPayload:\n{ content: string } Returns:\n{ id: Number } Post a subcomment Method: POST\nPath: /api/comment-manager/subcomments/:parent-id\nAuthentication: Bearer token\nPayload:\n{ content: string } Returns:\n{ id: Number } Get the page size Method: GET\nPath: /api/comment-manager/page-size\nReturns:\n{ pageSize: Number } General settings The plugin allows to set how many comments are returned per page by going to the Pagination section under Comment Manager Plugin on the Settings section.\nThe default page size is 10.\nManagement of comments Admin users are able to delete comments and subcomments as well as leave replies as admins from within the plugin page of the Strapi admin dashboard.\nThe plugin interface has two tabs: one for the latest comments and one for comments by content ID.\nRoadmap and future plans The plugin is pretty basic but it can be improved with more features and a better UI/UX. Collaborations and suggestions are very welcome.\n","image":"//localhost:1313/images/post/strapilogo.jpg","permalink":"//localhost:1313/blogs/strapi-plugin-comment-manager/","tags":["Strapi","Strapi plugins"],"title":"Strapi Plugin Comment Manager"},{"categories":["Projects"],"contents":"In this post I’m going to share my experience on building a SaaS using the headless CMS Strapi as the Backend, React Native and other technologies.\nOutline Introduction What is SaaS? The problem What is Strapi? Developing features in Strapi The frontend: How to get content Conclusion Landing Page Introduction Very often, developers, product and project managers, testers and pretty much the entire team share their ideas to decide what language and which framework they\u0026rsquo;ll use to build their next project. Some considerations must be taken into account, from which in my opinion there are three that are the most important:\nDeveloper experience and ease of use Does the language and framework chosen provide a good developer experience? Is the langauge the same for the backend and frontend?\nDeadlines Is there a deadline to finish the project? if so, there is a good chance to finish the project on time if the team chooses the language they have more experience in.\nMaintainability As there will be usually more than one person working on the same part at the same time, if everything is kept organised, the whole development process will be frictionless.\nWith that in mind, developers and project managers will have a better insight on which language/framework to use.\nOther aspects should also be considered such as what the data structure will look like.\nIn my case, as it is usual, the backend of my project needs a database for users and their roles among other entities and their relations and a dashboard to allow admins to manage the data, and I was lucky to find out Strapi, as it includes a lot of these features out of the box with one single line of command to get started.\nWhat is SaaS? SaaS stands for Software-as-a-Service and it just means that a software is provided as a service in the cloud and it gives a solution to a specific problem, for which the users are willing to pay either monthly or annual subscription.\nThe problem Before starting to write a single line of code, it is generally a good idea to think about the problem, it\u0026rsquo;s limitations and whether or not it has already been solved by someone else (AKA competitors).\nThe problem I was looking into had to do with the way in which public and private transportation companies manage their routes, drivers and users. After a little bit of research, I could only find one platform that provides a similiar solution but for their own company.\nSo the platform I built needed the following content types:\nOrganizations to group routes, drivers and users Routes Two user roles: drivers and users (passengers) As I said before, Strapi makes the creation of these content types and the relationships between them really easy, but let\u0026rsquo;s first see what is Strapi and how it turns the API development into a satisfactory and fun experience.\nWhat is Strapi? Strapi is an open source headless CMS that allows developers to build complete RESTful APIs in just a couple of days instead of months. It includes a lot of useful features as plugins out of the box. Users and Roles management, Media library and an interface to create, view, edit and delete content are just some of them.\nRegarding the API, how does it makes the development faster?\nFirst of all, it enforces a specific folder structure, which helps to keep everything well organised and clean.\nSecondly, all database schemas are generated automatically and queries are made in JSON format, which really saves a lot of time.\nLastly, we can add more features to our Strapi application very easily via plugins from the marketplace.\nIt\u0026rsquo;s also worth noting that Strapi is a self-hosted CMS, which means that we can host it in whatever cloud platform we want, as well as test it locally in our computers before deploying it to the cloud.\nDeveloping features in Strapi Creating and configuring endpoints in Strapi is as straightforward as declaring a JSON in a single file:\nCreating controllers is straightforward as well:\nEvery controller gets all the data related to the request in the ctx parameter and it\u0026rsquo;s also used to send the response. This keeps everything in one place and really helps to improve the readability.\nOnce the API endpoints are defined, the next step is to enable the permissions for the specific user roles to have access to these endpoints:\nThe frontend: how to get content Since Strapi is a headless CMS, it\u0026rsquo;ll only provide content through the API. That means that the content can be consumed from anywhere. In our case, this content will be used in two applications: one for the organization owners and one for the users and drivers.\nThe application for the organization owners is a dashboard where administrators can create organizations, routes, accept drivers and users in the organization and assign routes to drivers. This is just a React Application:\nThe application for drivers and users is a mobile application built in React Native. Firebase was used to synchronise geolocation data in real time between drivers and users and display this information in a Map from Google Maps:\nConclusion Using a CMS as the backend can make the development a lot faster than building the API from scratch and with Strapi this is specially true. Furthermore, this becomes more important when building a brand-new product, as it\u0026rsquo;s usually recommended to launch as soon as possible to gather feedback from the users and validate the idea.\nProject landing page: https://rutieri.netlify.app\n","image":"//localhost:1313/images/post/03.webp","permalink":"//localhost:1313/blogs/how-i-built-a-saas-on-top-of-strapi-and-why-you-should-too/","tags":["Strapi","React Native","Typescript"],"title":"How I Built A SaaS On Top Of Strapi, And Why You Should Too"},{"categories":["Tutorial"],"contents":"Enable User Reviews in a Strapi application and display them in the frontend with React\nOutline Introduction Prerequisites What is Strapi Ratings? Installation Configuration Display user reviews on the frontend Plugin settings Manage user reviews Full source code of the frontend Conclusion Introduction Ratings systems have become a crucial part of any website with ecommerce capabilites, as they allow the users to post reviews on the items they purchase and publish their opinion to the public. A couple of reviews can make the difference between pressing the “Buy” button and moving on to the next website in the Google search results.\nIn this article, I\u0026rsquo;ll show you how to enable and manage user reviews for your content very easily using the Ratings plugin, and display them in your frontend application.\nPrerequisites First of all, you need to have a basic understanding of the following.\nBasic knowledge of JavaScript Basic knowledge of React (OPTIONAL) Basic understanding of Strapi - get started here. Your Strapi V4 project setup What is Strapi Ratings? Strapi Ratings is a plugin that gives your Strapi application the ability to manage ratings for pretty much any kind of content. It allows your users to post reviews and anyone can get the reviews associated with a given slug.\nWith this plugin, admin users can view and manage very easily all the reviews from the Strapi administration dashboard. Within the dashboard, you will be able to see reviews related to content slugs as well as delete reviews.\nInstallation Once into the Strapi project root, you can install the plugin by running the following command:\nnpm install strapi-plugin-ratings Next, build the project to see the new plugin in the dashboard with the following command:\nnpm run build And that\u0026rsquo;s it! If everything runs correctly, the plugin should now be installed.\nConfiguration Now you need to enable some permissions so that the frontend can access the endpoints to post and fetch reviews.\nIn your Strapi admin dashboard, head over to Settings, then over to Roles under Users \u0026amp; Permissions Plugin.\nLet\u0026rsquo;s first setup the Public API; click on Public and hit the dropdown button of Ratings. Now check count, find, getPageSize and getStats, then hit the Save button. Below is a screenshot of a proper configuration:\nNow let\u0026rsquo;s setup the Authenticated API. Go back to Roles and click on Authenticated. Open the dropdown for Ratings and mark as checked the options create, find and getUserReview. Below is a screenshot of a proper configuration:\nWith this configuration, the frontend should now be able to make requests to get and post user reviews.\nDisplay use reviews on the frontend The plugin exposes an API to get and post reviews if you want to have fine-grained control over the workflow of your ratings system and you can check the documentation on the package page, but this plugin also comes with a purpose-built React component library that makes it super easy to get up and running without getting your hands dirty.\nThis components library is called strapi-ratings-client, fully supports typescript and it takes care of all the complexity of fetching and posting user reviews for every content ID that you pass to it.\nInstallation of Strapi Ratings Client You will need to have installed react ^17.0.2, react-dom ^17.0.2, bootstrap ^5.1.3 and @popperjs/core^2.11.2\nInside of your React project, run this command:\nnpm install strapi-ratings-client --save Usage of Strapi Ratings Client Using this library is very easy!\nThis library exports three main components:\nReviewsProvider Reviews ReviewForm And you can import them this way:\nimport { ReviewsProvider, Reviews, ReviewForm } from \u0026#34;strapi-ratings-client\u0026#34; All you have to do is wrap your App component into the ReviewsProvider component. Then you will be able to place anywhere in your app the Reviews component to render a list of user reviews for a given content ID and the ReviewForm component to render a form to allow your users to post reviews.\nFor example, this could be your index.js or main.js file:\nimport React from \u0026#39;react\u0026#39; import ReactDOM from \u0026#39;react-dom\u0026#39; // The address of your strapi backend instance const STRAPI = \u0026#34;http://localhost:1337\u0026#34; ReactDOM.render( \u0026lt;React.StrictMode\u0026gt; \u0026lt;ReviewsProvider apiURL={STRAPI}\u0026gt; \u0026lt;App /\u0026gt; \u0026lt;/ReviewsProvider\u0026gt; \u0026lt;/React.StrictMode\u0026gt;, document.getElementById(\u0026#39;root\u0026#39;) ) Where apiURL is the URL of your running Strapi application, and this property is required.\nThis way, the ratings provider will do all the magic of fetching and posting comments for you!\nThis library also exports an utility React.Context to update some of the parameters for fetching and posting reviews:\nimport { ReviewsConfigContext } from \u0026#34;strapi-ratings-client\u0026#34; This ReviewsConfigContext exposes three setter functions: setUser, setContentID and setCanPostReview.\nWith setContentID you can load the ratings for a given content and post reviews to it. It receives a single parameter of type string and must be URLized, i.e. no spaces.\nWith setUser you can set the credentials of a given user to authorize the posting of reviews. It receives a single parameter of type IUser, with the following Typescript interface:\ninterface IUser { username: string, email: string, id: string, token: string // This is a JWT } With setCanPostReview, you can enable the user to post a review on the given content. This is useful for when you only allow a user to post a review after they purchase the product.\nIt\u0026rsquo;s a little confusing but we\u0026rsquo;ll see how to use it in a component:\nconst App = () =\u0026gt; { const { setUser, setContentID, setCanPostReview } = useContext(ReviewsConfigContext) // The following data should come from Strapi Users and Permissions Plugin // for authenticated requests. const user = { username: \u0026#34;John Doe\u0026#34;, email: \u0026#34;jhohndoe@gmail.com\u0026#34;, id: 5, token: \u0026#34;this_should_be_a_JWT\u0026#34; } if (user) { setUser(user) } setContentID(\u0026#34;sample-content-1\u0026#34;) // Load reviews for this content setCanPostReview(true) // Allow this user to post a review return ( \u0026lt;\u0026gt; { !user \u0026amp;\u0026amp; \u0026lt;Login /\u0026gt; } \u0026lt;ReviewForm /\u0026gt; \u0026lt;Reviews /\u0026gt; \u0026lt;/\u0026gt; ) } And that\u0026rsquo;s it!\nAfter setting the content ID through setContentID, ReviewsProvider will start loading the reviews for the given content ID and the ReviewForm will render an input to post a user review related to the given content ID if there is a user and he’s allowed to post a review. Otherwise, it will display the message Login to post a review or nothing at all if the user is not allowed to post a review.\nHere\u0026rsquo;s how the interface looks like so far:\nThis library exports one more component: ErrorBox\nimport { ErrorBox } from \u0026#34;strapi-ratings-client\u0026#34; .It\u0026rsquo;s useful for when you\u0026rsquo;d like to display error messages when things go wrong fetching or posting reviews.\nYou can place this component wherever you want, for example in between the ReviewForm and the Reviews components.\nIf you\u0026rsquo;re wondering how this error box looks like, here‘s a screenshot:\nGeneral settings You can customize the page size, i.e. specify how many user reviews are showed at once.\nIn the Strapi admin panel, head over to Settings, then select Pagination under Ratings Plugin.\nHere you\u0026rsquo;ll find an input to set the page size, which defaults to 10.\nManage reviews Once you\u0026rsquo;ve got the plugin up an running, as users start to post reviews, you can view them from within the Ratings section of the left sidebar in the Strapi admin dashboard.\nHere you can see two tabs: one for the latest reviews and one for reviews grouped by content ID.\nIn both of them you can delete unwanted reviews.\nExample project You can find a full working example of a React App using the Strapi Ratings Client Library in this repo: https://github.com/luisguve/strapi-ratings-client-example\nConclusion With this plugin you can enable and manage user reviews for any content with little effort and even use a library of components styled with Bootstrap to display the user reviews in your frontend.\nAnd that\u0026rsquo;s it! The features are pretty basic at the moment but if there\u0026rsquo;s interest, I\u0026rsquo;m willing to work on more features as well as improve the UI/UX.\n","image":"//localhost:1313/images/post/tutorial-ratings.webp","permalink":"//localhost:1313/blogs/how-to-enable-and-manage-user-reviews-in-your-strapi-application/","tags":["Strapi","Strapi tutorials"],"title":"How To Enable And Manage User Reviews In Your Strapi Application"},{"categories":["Documentation"],"contents":"Ratings is a Strapi plugin that allows your users to post reviews.\nEnable and manage user reviews for your content very easily!\nRequirements You should have installed an instance of Strapi v4.x.x\nInstallation Run the following command in your project root:\nnpm install strapi-plugin-ratings Then, rebuild the admin dashboard using the following command\nnpm run build Configurarion For your frontend to have access to the API, enable the following permissions for Ratings from Users \u0026amp; Permissions Plugin on your project settings:\nFor public, enable: count, find, getPageSize and getStats.\nFor authenticated, enable create, find and getUserReview.\nDisplay user reviews on the frontend Reviews can be displayed in the frontend in two ways:\nUsing the React components library strapi-ratings-client (recommended) Build your custom frontend using the API endpoints, described as follows: API There are some Typescript interfaces that will help to get an idea of the data structures.\nReviews: interface IReview { id: number, createdAt: string, comment: string | null, author: IAuthor | null, score: number, } Authors: interface IAuthor { username: string, email: string, id: number } Content Stats interface IStats { averageScore: number; reviewsCount: number | null; } The following endpoints are exposed to fetch and post reviews:\nGet reviews for a content ID Method: GET\nPath: /api/ratings/reviews/:slug\nOptional query parameters: start, ignoreCount\nReturns:\n{ reviewsCount: number, averageScore: number, userReview: IReview | null, reviews: IReview[] } The parameter start indicates how many reviews to skip. This is for pagination purposes.\nThe parameter ignoreCount indicates whether or not to return the total number of reviews associated with the given slug.\nGet review stats for a content ID Method: GET\nPath: /api/ratings/reviews/:slug/stats\nReturns:\n{ averageScore: number, reviewsCount: number | null } Get the number of reviews associated with a given content ID Method: GET\nPath: /api/ratings/reviews/:slug/count\nReturns:\n{ count: number } Post a review Method: POST\nPath: /api/ratings/reviews/:slug\nAuthentication: Bearer token\nPayload:\n{ content: string } Returns:\n{ id: number } By default, every authenticated user can post reviews on any content.\nIn order to customize this behavior, e.g. allowing or disallowing a user from posting reviews, you must extend the service userCanPostReview from whithin register function in ./src/index.js. For example:\nstrapi.service(\u0026#34;plugin::ratings.review\u0026#34;).userCanPostReview = async (user, slug) =\u0026gt; { /* Here you will check whether or not the user is allowed to post a review on this content ID and return either true or false. */ return true } Notice that userCanPostReview will receive two parameters: the user from Users \u0026amp; Permissions Plugin, containing it\u0026rsquo;s id, username, confirmed, etc., and the slug, which is a string and refers to the content ID which the review is being posted on.\nIn case this function returns false, the response of the endpoint will be 403 (forbidden) with the text User cannot post a review on this content.\nGet the page size Method: GET\nPath: /api/ratings/page-size\nReturns:\n{ pageSize: number } General settings The plugin allows to set how many reviews are returned per page by going to the Pagination section under Ratings Plugin of the Settings section.\nThe default page size is 10.\nManagement of reviews Admin users are able to delete reviews from within the plugin page of the Strapi admin dashboard.\nThe plugin interface has two tabs: one for the latest reviews and one for reviews by content ID.\nRoadmap and future plans The plugin is pretty basic but it can be improved with more features and a better UI/UX. Collaborations and suggestions are very welcome.\n","image":"//localhost:1313/images/post/ratings.webp","permalink":"//localhost:1313/blogs/strapi-plugin-ratings/","tags":["Strapi","Strapi plugins"],"title":"Strapi Plugin Ratings"},{"categories":["Projects"],"contents":"ManyLMS is an e-learning platform built on top of Strapi, React Router 7, Typescript and other technologies.\nOutline The idea Platform features The stack The API The frontend Conclusion Landing Page The idea This project doesn\u0026rsquo;t necessarily bring a huge amount of innovation on the e-learning platforms that already exists, but it\u0026rsquo;s just another way of doing this type of application.\nThe main idea is to apply a JAMstack approach in this application, where the platform is a static website, and the backend is just an API that serves static content only once to build the website and just adds the dynamism that\u0026rsquo;s necessary to allow users to authenticate, create orders, confirm payments and take courses.\nIf we compare this approach to a WordPress website, we are taking out most of the overhead that implies rendering the pages everytime a user visits them. Despite that there are plugins for caching that may improve the performance, it\u0026rsquo;s still never going to be faster and more efficient than just static content served by a CDN. That\u0026rsquo;s why React Router 7 and Headless CMSs are so popular right now.\nPlatform features and user stories The following user stories illustrates the desired features the platform should have.\nAs an administrator, I want to: login in the admin panel. create categories. create courses. upload lectures. organise courses into categories. assign lectures to courses. As a student, I want to: login in the platform. view the available courses. add courses to the shopping cart. review the shopping cart. create an order. pay with credit card or paypal. view the courses i\u0026rsquo;ve purchased in my learning page. go to the course page from my learning page and watch the videos. mark lectures as seen. come back later and resume where I left. The requirements The backend requires to handle user authentication, permissions, different data structures as content types and define relationships between them. It also requires to allow uploading videos to some third party platform that supports streaming on demand.\nThe frontend is a web platform where users can register and login, view and buy courses, leave comments and reviews and take courses.\nThe API Since all of the features involve authentication, permissions and roles, and because there is no need to reinvent the wheel, I chose to use Strapi to build the backend for it\u0026rsquo;s simplicity, ease of use and great developer experience, whereas for streaming videos on demand, I chose to use Mux.com.\nThe instance of Strapi and the Postgres database it requires was deployed in the cloud hosting platform https://fly.io.\nStrapi is good for managing users, content that\u0026rsquo;s typically updated and fetched via CRUD API, and setting up relations between content types.\nThe platform needs the following content types:\nCategory to group courses Course Lecture Module to group lectures Order Student: has many courses Student-Course: stores a student\u0026rsquo;s current lecture of a course Video Strapi makes the creation of these content types and setting up relationships between them really straightforward.\nBelow are some screenshots of these content types and the relationships between them:\nThe frontend The platform where users are able to login, view, buy and view courses is a web application built with React Router 7. Among the features of this application are:\nState managed by Context API Interface styled with Bootstrap Play streaming videos with @mux/mux-player-react library Use of localStorage to save user session Below are some sample screenshots of how this app looks like\nConclusion and final thoughts While building this project, I learned:\nHow streaming on demand works and how to use a streaming provider How to statically build websites with React Router 7 and Strapi How to setup dynamic pages in React Router 7 How to process payments with Stripe and Paypal How to build custom plugins in Strapi How to publish packages to NPM Project source codes: https://github.com/luisguve/maestro-backend\nhttps://github.com/luisguve/new-lms-remix\n","image":"//localhost:1313/images/project/manylms/frontend/course_overview.png","permalink":"//localhost:1313/projects/e-learning-platform-maestro-lms/","tags":["Strapi","React","React Router 7","Typescript","Mux"],"title":"ManyLMS: E-Learning platform"},{"categories":["Projects"],"contents":"ETMday (Emprende tu Mente) is a large-scale entrepreneurship event website built on top of WordPress with the Themosis framework, featuring an interactive SVG map, real-time countdown timers, advanced search functionality, and comprehensive content management using Vue 3, Laravel Mix, and modern frontend technologies.\nOutline The project Key features The stack Frontend architecture Interactive components Conclusion Live website The project ETMday is Chile\u0026rsquo;s premier entrepreneurship event, bringing together thousands of entrepreneurs, startups, corporates, and strategic partners. The website serves as the central hub for event information, featuring speakers, activities, stands, program schedules, and an interactive event map.\nThe frontend development required implementing complex interactive features including an SVG-based interactive map with tooltips, real-time countdown timers, advanced filtering and search systems, and dynamic content displays that handle thousands of attendees and hundreds of activities.\nKey features The website includes several sophisticated features:\nInteractive SVG Map: Custom-built interactive map with clickable zones, tooltips, and dynamic content display Real-time Countdown: Event countdown timer with automatic updates and mobile optimization Advanced Search: Multi-category search across activities, speakers, stands, and content Dynamic Filtering: Complex filtering system with tabs, favorites, and downloadable resources Animated Statistics: Odometer animations for displaying event metrics Content Management: Comprehensive card components for activities, speakers, stands, and blog posts Form Handling: Multi-step forms with validation using Vee-Validate Lightbox Galleries: Image galleries with LightGallery integration Responsive Design: Fully responsive design optimized for all devices The stack The frontend stack consists of:\nVue 3.2.4: Modern reactive framework for building interactive components Laravel Mix 6.0: Asset compilation and bundling SCSS: Advanced styling with organized architecture Vee-Validate 4.15.0: Form validation with Yup schemas Axios 1.6.8: HTTP client for API requests Splide.js 4.1.4: Modern carousel and slider components LightGallery 2.8.3: Lightbox gallery functionality Odometer 0.4.8: Animated number counting Headroom.js: Header behavior on scroll jQuery 3.7.1: DOM manipulation and legacy support SweetAlert2: Modern alert dialogs GLightbox 3.3.1: Alternative lightbox solution Frontend architecture Vue components The application features a comprehensive set of Vue 3 components:\nCard Components:\ncards/activities.vue: Activity cards with favorites functionality cards/speakers.vue: Speaker cards with modal details cards/stands.vue: Stand/exhibitor cards cards/blog.vue: Blog post cards cards/shortcut.vue: Quick access shortcut cards Functional Components:\nSectionCards.vue: Main section component with tabs, filtering, and card display Search.vue: Advanced search component with multi-category results Form.vue: Dynamic form component with validation FormCalendar.vue: Calendar form component CustomFilter.vue: Reusable filter component CustomSelect.vue: Custom select dropdown Pagination.vue: Pagination component JavaScript components The application includes 17 specialized JavaScript components:\nInteractive Features:\ninteractiveMap.js: SVG map interaction with tooltips, zones, and dynamic content countdown.js: Real-time countdown timer with automatic updates odometer.js: Animated number counting with scroll triggers map.js: Map zone interactions and modal displays UI Components:\nheader.js: Header functionality and navigation headroom.js: Header hide/show on scroll accordion.js: Accordion interactions tabs.js: Tab functionality cards.js: Card interactions and modals siteModals.js: Modal management system UI.js: General UI utilities Media Components:\nvideo.js: Video player setup lightgallery.js: Lightbox gallery initialization splide.js: Carousel initialization slick.js: Legacy carousel support Utilities:\nscrollTrigger.js: Scroll-based animations imgToSvg.js: SVG image conversion utility SCSS architecture The styling follows a well-organized SCSS architecture:\nscss/ ├── abstracts/ # Variables, mixins, functions │ ├── _functions.scss │ ├── _mixins.scss │ ├── _variables.scss │ ├── _mq.scss # Media query mixins │ └── _keyframes.scss ├── base/ # Base styles and typography │ ├── _typography.scss │ ├── _container.scss │ └── _reset.scss └── components/ # Component-specific styles └── [52 component files] Key SCSS features:\nBEM methodology: Consistent naming convention Media query mixins: Using sass-mq for responsive design Modular architecture: Each component has its own SCSS file Component organization: 52 component-specific SCSS files Interactive components Interactive SVG Map The interactiveMap.js component implements a sophisticated SVG-based interactive map:\nFeatures:\nSVG Tooltips: Dynamically generated tooltips with text wrapping Zone Interactions: Clickable zones with modal displays Point Markers: Interactive points with icons and labels Dynamic Content: Content loaded based on zone/point selection Responsive Design: Optimized for mobile and desktop Technical Implementation:\nSVG namespace manipulation for tooltip creation Text wrapping algorithm for tooltip content Path generation for tooltip shapes with rounded corners Event delegation for zone and point interactions Smooth animations and transitions Real-time Countdown The countdown.js component provides a real-time countdown timer:\nFeatures:\nAutomatic Updates: Updates every second Multi-unit Display: Days, hours, minutes, and seconds Pluralization: Proper Spanish pluralization (Día/Días, Hora/Horas) Mobile Optimization: Simplified display on mobile devices End State Handling: Automatic transition when countdown ends Advanced Search System The Search.vue component implements a comprehensive search system:\nFeatures:\nMulti-category Search: Searches across activities, speakers, stands, and other content Category Tabs: Quick navigation between result categories Result Counts: Dynamic result counts per category Scroll Navigation: Smooth scrolling to category sections Carousel Display: Splide carousels for result display Loading States: Loading indicators during search Empty States: User-friendly empty state messages Dynamic Filtering System The SectionCards.vue component provides advanced filtering:\nFeatures:\nTab Navigation: Multiple filter tabs Favorites System: Save and filter favorite items Search Integration: Inline search within filters Reset Functionality: Clear all filters with one click Downloadable Resources: Download buttons for resources URL Synchronization: Filter state in URL parameters Responsive Design: Mobile accordion interface Animated Statistics The odometer.js component provides animated number counting:\nFeatures:\nScroll-triggered: Animations trigger on scroll Prefix/Suffix Support: Handles formatted numbers (e.g., \u0026ldquo;56,000+\u0026rdquo;) Mobile Optimization: Static display on mobile Smooth Animations: Odometer theme integration Development workflow The project uses Laravel Mix for asset compilation:\n// Development npm run dev // Compile assets npm run watch // Watch for changes npm run hot // Hot module replacement // Production npm run production // Optimized production build BrowserSync integration provides:\nLive reloading during development Synchronized browser testing Proxy configuration for WordPress development Performance optimizations Code splitting: Laravel Mix extracts vendor libraries Asset versioning: Automatic cache busting Image optimization: Lazy loading and responsive images Minification: Production builds are minified and optimized Tree shaking: Unused code elimination in production SVG optimization: Efficient SVG manipulation and rendering Accessibility Semantic HTML structure ARIA labels for interactive elements Keyboard navigation support Focus management in forms and modals Screen reader considerations Proper alt text for images Conclusion and final thoughts Building the ETMday frontend was an excellent opportunity to:\nMaster SVG interactions: Creating complex interactive SVG maps with dynamic tooltips and zones Implement real-time features: Building countdown timers and live updates Build advanced search: Multi-category search with filtering and categorization Handle complex state: Managing filters, favorites, and dynamic content Optimize performance: Implementing efficient animations and lazy loading Ensure scalability: Building components that handle large datasets (thousands of attendees, hundreds of activities) The project demonstrates proficiency in:\nModern JavaScript frameworks (Vue 3) SVG manipulation and interaction Real-time UI updates Advanced filtering and search systems Build tools and asset compilation (Laravel Mix, Webpack) CSS architecture and methodologies (SCSS, BEM) Component-based development Event-driven architecture The integration with WordPress/Themosis backend required careful consideration of server-side rendering, API endpoints, and content management workflows, making this a full-stack frontend implementation for a large-scale event.\nLive website: https://etmday.org/\nFigma Prototype: https://www.figma.com/proto/mt9fJ8P03M5gf0nQwcU99q/EtM-Day-2025---Dise%C3%B1o?node-id=1-2743\u0026m=dev\u0026scaling=scale-down\u0026content-scaling=fixed\u0026page-id=0%3A1\u0026starting-point-node-id=1%3A2743\n","image":"//localhost:1313/images/project/etm/home.png","permalink":"//localhost:1313/projects/etmday-entrepreneurship-event-website/","tags":["Vue 3","Laravel Mix","WordPress","Themosis","SCSS","JavaScript","Interactive Map","SVG"],"title":"ETMday: Entrepreneurship Event Website"},{"categories":["Projects"],"contents":"ISC Chile is an educational consultancy website for study abroad programs, built on top of WordPress with the Themosis framework, featuring GSAP animations, multi-step contact forms, advanced blog filtering, and comprehensive content management using Vue 2, Laravel Mix, and modern frontend technologies.\nOutline The project Design implementation The stack Frontend architecture Key features Conclusion Live website The project ISC Chile is an educational consultancy agency that has been providing study abroad advisory services since 1996. The website serves as the primary platform for showcasing various educational programs including English courses, school exchanges, group travel programs, and Pathways programs for university admission abroad.\nThe frontend development was based on a comprehensive Figma design, requiring pixel-perfect implementation of complex UI components, multi-step forms, animated statistics, and responsive layouts that work seamlessly across all devices.\nDesign implementation The entire frontend was built from a detailed Figma design, ensuring:\nPixel-perfect accuracy: Matching the design specifications precisely (as evidenced by Figma height references in SCSS) Responsive design: Implementing breakpoints and mobile-first approach Component consistency: Maintaining design system patterns throughout Interactive elements: Translating static designs into dynamic, interactive components Animation and transitions: Implementing smooth GSAP-powered animations The stack The frontend stack consists of:\nVue 2.6.12: Reactive framework for building interactive components Laravel Mix 6.0: Asset compilation and bundling SCSS: Advanced styling with a well-organized architecture Vuex 3.6.2: State management for Vue applications Vee-Validate 3.4.14: Form validation GSAP 3.12.5: Professional animation library with ScrollTrigger Axios 0.18: HTTP client for API requests Splide.js 4.1.4: Modern carousel and slider components Slick Carousel 1.8.1: Legacy carousel support LightGallery 2.7.2: Lightbox gallery functionality Odometer 0.4.8: Animated number counting Headroom.js: Header behavior on scroll V-Calendar 2.4.2: Calendar component for date selection V-Mask 2.3.0: Input masking Vue-Select 3.20.2: Custom select component jQuery 3.2: DOM manipulation and legacy support SweetAlert: Alert dialogs Frontend architecture Vue components The application features a comprehensive set of Vue 2 components:\nForm Components:\nContact.vue: Multi-step contact form with validation and reCAPTCHA ContactFormStep1.vue: First step of the contact form ContactFormStep2.vue: Second step of the contact form ContactFormStep3.vue: Third step of the contact form FormBanner.vue: Banner form component Content Components:\nBlog.vue: Blog listing with advanced filtering and search BlogArticleCard.vue \u0026amp; BlogArticleCardLoading.vue: Blog post cards with loading states ExperiencesPanel.vue: Testimonials and experiences display panel ExperiencesFiltersMobile.vue: Mobile filter component for experiences Search Components:\nSearchResults.vue: Search results display component SearchResultCardLoading.vue: Loading skeleton for search results UI Components:\nCheckboxDropdown.vue: Custom checkbox dropdown component CheckboxDropdownFieldset.vue: Fieldset wrapper for checkbox dropdowns EmptyState.vue: Empty state displays Loader.vue \u0026amp; Loading.vue: Loading indicators JavaScript components The application includes 15 specialized JavaScript components:\nAnimation Components:\ngsap.js: GSAP animations with ScrollTrigger for scroll-based reveals scrolltrigger.js: Custom scroll trigger utilities odometer.js: Animated number counting with scroll triggers UI Components:\nheader.js: Header functionality and navigation headroom.js: Header hide/show on scroll megamenu.js: Mega menu functionality mobileMenu.js: Mobile menu interactions searchbar.js: Search bar functionality floating-banner.js: Floating banner component footer.js: Footer functionality Media Components:\nvideo.js: Video player setup lightgallery.js: Lightbox gallery initialization splide.js: Carousel initialization slick.js: Legacy carousel support Interactive Components:\naccordion.js: Accordion interactions tabs.js: Tab functionality cards.js: Card interactions Utilities:\nimg-to-svg.js: SVG image conversion utility SCSS architecture The styling follows a well-organized SCSS architecture:\nscss/ ├── abstracts/ # Variables, mixins, functions │ ├── _mixins.scss │ ├── _mq.scss # Media query mixins │ └── _vendor.scss ├── base/ # Base styles and typography │ ├── _typography.scss │ ├── _colors.scss │ ├── _container.scss │ ├── _globals.scss │ └── fonts/ # Custom TWK Everett font family └── components/ # Component-specific styles └── [45 component files] Key SCSS features:\nBEM methodology: Consistent naming convention throughout Media query mixins: Using sass-mq for responsive design Modular architecture: Each component has its own SCSS file Custom typography: TWK Everett font family with multiple weights Figma references: Direct references to Figma design specifications Key features Multi-step contact form The Contact.vue component implements a sophisticated multi-step form with:\nThree-step navigation: Step-by-step form progression Form validation: Using Vee-Validate with comprehensive rules Date picker: V-Calendar integration for date selection Input masking: V-Mask for phone numbers and formatted inputs reCAPTCHA integration: Spam protection Dynamic fields: Fields that change based on user selections Loading states: Visual feedback during form submission Error handling: Comprehensive error messages and validation Form steps include:\nStep 1: Personal information and contact details Step 2: Educational background and program interests Step 3: Additional information and submission GSAP animations The gsap.js component provides professional animations:\nFeatures:\nScroll-triggered animations: Elements animate on scroll Vertical scroll reveals: Fade and slide animations Horizontal scroll reveals: Staggered animations for grid layouts Timeline management: Complex animation sequences Performance optimized: Efficient animation triggers Animation types:\nFade in with vertical movement Staggered grid animations Scroll-based reveals Smooth transitions Advanced blog system The Blog.vue component provides comprehensive blog functionality:\nFeatures:\nCategory filtering: Filter posts by category Search functionality: Real-time search across blog posts Mobile filters: Dedicated mobile filter interface Pagination: Efficient content pagination Loading states: Skeleton loading screens Empty states: User-friendly empty state messages Experiences/testimonials panel The ExperiencesPanel.vue component displays student testimonials:\nFeatures:\nFilter by type: Filter testimonials (Students/Parents) Dynamic loading: Load testimonials from API Responsive design: Mobile-optimized display Carousel integration: Splide carousel for testimonial display Animated statistics The odometer.js component provides animated number counting:\nFeatures:\nScroll-triggered: Animations trigger on scroll Smooth counting: Odometer theme integration Performance optimized: Efficient scroll detection Mobile support: Optimized for all devices Search functionality The SearchResults.vue component provides comprehensive search:\nFeatures:\nMulti-content search: Search across programs, blog posts, and pages Result categorization: Organized search results Image support: Results with and without images Tag display: Category tags for results Loading states: Skeleton loading screens Custom typography The website features a custom font family, TWK Everett, with:\nMultiple weights: From Hairline to Super Italic variants: All weights include italic versions Optimized formats: WOFF, WOFF2, and OTF formats Performance: Efficient font loading and rendering Development workflow The project uses Laravel Mix for asset compilation:\n// Development npm run dev // Compile assets npm run watch // Watch for changes npm run hot // Hot module replacement // Production npm run production // Optimized production build BrowserSync integration provides:\nLive reloading during development Synchronized browser testing Proxy configuration for WordPress development Performance optimizations Code splitting: Laravel Mix extracts vendor libraries Asset versioning: Automatic cache busting Image optimization: Lazy loading and responsive images Minification: Production builds are minified and optimized Tree shaking: Unused code elimination in production Font optimization: Efficient font loading strategies Accessibility Semantic HTML structure ARIA labels for interactive elements Keyboard navigation support Focus management in forms Screen reader considerations Proper alt text for images Conclusion and final thoughts Building the ISC Chile frontend from a Figma design was an excellent opportunity to:\nMaster Vue 2: Working with Options API, Vuex state management, and Vue 2 patterns Implement GSAP animations: Creating professional scroll-triggered animations Build complex forms: Multi-step forms with validation, date pickers, and input masking Create advanced filtering: Blog filtering with search and category selection Optimize performance: Implementing efficient animations and lazy loading Ensure design fidelity: Translating Figma designs into pixel-perfect implementations (with direct Figma references in code) The project demonstrates proficiency in:\nModern JavaScript frameworks (Vue 2) Animation libraries (GSAP, ScrollTrigger) Form validation and user experience (Vee-Validate, V-Mask, V-Calendar) Build tools and asset compilation (Laravel Mix, Webpack) CSS architecture and methodologies (SCSS, BEM) Component-based development State management (Vuex) Design system implementation The integration with WordPress/Themosis backend required careful consideration of server-side rendering, API endpoints, and content management workflows, making this a full-stack frontend implementation for an educational consultancy platform.\nLive website: https://www.iscchile.cl/\nFigma prototype: https://www.figma.com/proto/BfdKGJlzx7xAnE7rpZ1vda/Dise%C3%B1o-ISC?page-id=314%3A12071\u0026type=design\u0026node-id=314-12072\u0026viewport=-1452%2C930%2C0.29\u0026t=hFYiwcionjRAZ47v-1\u0026scaling=min-zoom\n","image":"//localhost:1313/images/project/isc-chile/home.png","permalink":"//localhost:1313/projects/isc-chile-educational-consultancy-website/","tags":["Vue 2","Laravel Mix","WordPress","Themosis","SCSS","GSAP","JavaScript","Figma"],"title":"ISC Chile: Educational Consultancy Website"},{"categories":["Projects"],"contents":"Chile Nativo is a travel tour website for Patagonia experiences, built on top of WordPress with the Themosis framework, featuring a modern frontend implementation based on a Figma design using Vue 3, Laravel Mix, and a comprehensive SCSS architecture.\nOutline The project Design implementation The stack Frontend architecture Key features Conclusion Live website The project Chile Nativo is a travel company specializing in Patagonia tours, offering experiences in destinations like Torres del Paine, Tierra del Fuego, and Isla Navarino. The website serves as the primary platform for showcasing tours, managing bookings, and providing information about their travel experiences.\nThe frontend development was based on a comprehensive Figma design, requiring pixel-perfect implementation of complex UI components, interactive forms, filtering systems, and responsive layouts that work seamlessly across all devices.\nDesign implementation The entire frontend was built from a detailed Figma design, ensuring:\nPixel-perfect accuracy: Matching the design specifications precisely Responsive design: Implementing breakpoints and mobile-first approach Component consistency: Maintaining design system patterns throughout Interactive elements: Translating static designs into dynamic, interactive components Animation and transitions: Implementing smooth user experience enhancements The stack The frontend stack consists of:\nVue 3.2.4: Modern reactive framework for building interactive components Laravel Mix 6.0: Asset compilation and bundling SCSS: Advanced styling with a well-organized architecture Pinia 2.3.1: State management for Vue applications Vee-Validate 4.15.0: Form validation with Yup schemas Axios 1.6.8: HTTP client for API requests Splide.js 4.1.4: Modern carousel and slider components Headroom.js: Header behavior on scroll Plyr 3.7.8: Video player implementation SweetAlert2: Modern alert dialogs jQuery 3.7.1: Legacy support and DOM manipulation utilities Frontend architecture Vue components The application features a comprehensive set of Vue 3 components organized by functionality:\nFiltering and Search Components:\nToursFilter.vue: Advanced tour filtering with multiple criteria TourDatesFilter.vue: Date-based filtering for tour availability ToursFilterDropdown.vue \u0026amp; ToursFilterDropdownMobile.vue: Responsive filter dropdowns TestimonialsFilter.vue: Filtering system for customer testimonials NewsFilter.vue: Blog and news filtering SearchResults.vue: Search results display with pagination Form Components:\nPersonalizedTripForm.vue: Multi-step form for custom trip requests with validation ContactFormSimple.vue: Contact form with reCAPTCHA integration FormHelp.vue: Help center form FormGiftCard.vue: Gift card purchase form FormCareers.vue: Job application form NewsletterForm.vue: Newsletter subscription Card Components:\nTour.vue \u0026amp; TourLoading.vue: Tour card display with loading states TourDate.vue \u0026amp; TourDateLoading.vue: Tour date selection cards Testimonial.vue \u0026amp; TestimonialLoading.vue: Customer testimonial cards Blog.vue \u0026amp; BlogLoading.vue: Blog post cards Team.vue \u0026amp; TeamLoading.vue: Team member cards ResourceCard.vue \u0026amp; ResourceLoading.vue: Resource display cards Utility Components:\nPagination.vue: Reusable pagination component Select.vue: Custom select dropdown with search Loader.vue \u0026amp; LoaderFullScreen.vue: Loading indicators EmptyState.vue: Empty state displays ContentResources.vue: Resource content management TeamTabsFilter.vue: Tabbed team member filtering SCSS architecture The styling follows a well-organized SCSS architecture:\nscss/ ├── abstracts/ # Variables, mixins, functions │ ├── _functions.scss │ ├── _mixins.scss │ ├── _variables.scss │ ├── _mq.scss # Media query mixins │ └── _keyframes.scss ├── base/ # Base styles and typography │ ├── _typography.scss │ ├── _colors.scss │ ├── _fonts.scss │ └── _reset.scss └── components/ # Component-specific styles └── [125 component files] Key SCSS features:\nBEM methodology: Consistent naming convention throughout Media query mixins: Using sass-mq for responsive design Modular architecture: Each component has its own SCSS file Abstract layer: Reusable variables, mixins, and functions Vue transitions: Custom transition styles for Vue components JavaScript architecture The JavaScript is organized into two main entry points:\nMain application (app.js):\nInitializes core application functionality Sets up jQuery plugins and utilities Handles legacy browser support Vue application (vue/main.js):\nConfigures Vue 3 app with Pinia for state management Registers global Vue components Sets up Vee-Validate configuration Integrates third-party Vue plugins (VueTelInput, etc.) Component utilities (app/components/):\nheader.js: Header behavior and navigation footer.js: Footer functionality splide.js: Carousel initialization slick.js: Legacy carousel support accordions.js: Accordion interactions tabs.js: Tab functionality scrollTrigger.js: Scroll-based animations video.js: Video player setup sticky-sidebar.js: Sticky sidebar behavior Key features Multi-step forms The PersonalizedTripForm.vue component implements a sophisticated multi-step form with:\nStep-by-step navigation with progress indicators Form validation using Vee-Validate and Yup schemas Dynamic form fields based on user selections Phone number input with international support (VueTelInput) reCAPTCHA integration for spam protection Loading states and error handling Advanced filtering system The tour filtering system (ToursFilter.vue) provides:\nMultiple filter criteria (destination, activity type, trip type, month) Real-time filtering with URL parameter synchronization Responsive design with mobile accordion interface Custom select components with search functionality Empty states and loading indicators Integration with WordPress backend via Axios Responsive design The entire website is fully responsive with:\nMobile-first approach Breakpoint management using sass-mq Touch-friendly interactions Optimized images and assets Performance optimizations for mobile devices Performance optimizations Code splitting: Laravel Mix extracts vendor libraries Asset versioning: Automatic cache busting Image optimization: Lazy loading and responsive images Minification: Production builds are minified and optimized Tree shaking: Unused code elimination in production Accessibility Semantic HTML structure ARIA labels where appropriate Keyboard navigation support Focus management in forms Screen reader considerations Development workflow The project uses Laravel Mix for asset compilation:\n// Development npm run dev // Compile assets npm run watch // Watch for changes npm run hot // Hot module replacement // Production npm run production // Optimized production build BrowserSync integration provides:\nLive reloading during development Synchronized browser testing Proxy configuration for WordPress development Conclusion and final thoughts Building the Chile Nativo frontend from a Figma design was an excellent opportunity to:\nMaster Vue 3: Working with the Composition API, reactive systems, and modern Vue patterns Implement complex forms: Multi-step forms with validation, international phone inputs, and reCAPTCHA Build scalable architecture: Organizing 40+ Vue components and 125+ SCSS files in a maintainable structure Optimize performance: Implementing code splitting, lazy loading, and production optimizations Ensure design fidelity: Translating Figma designs into pixel-perfect implementations Handle responsive design: Creating seamless experiences across all device sizes The project demonstrates proficiency in:\nModern JavaScript frameworks (Vue 3) Build tools and asset compilation (Laravel Mix, Webpack) CSS architecture and methodologies (SCSS, BEM) Form validation and user experience Component-based development Design system implementation The integration with WordPress/Themosis backend required careful consideration of server-side rendering, API endpoints, and content management workflows, making this a full-stack frontend implementation.\nLive website: https://chilenativo.travel/\nFigma prototype: https://www.figma.com/proto/ywHPhSP1UfYUAE8eWVQv4L/Dise%C3%B1o-Desktop---Chile-Nativo?node-id=289-3912\u0026m=dev\u0026scaling=min-zoom\u0026content-scaling=fixed\u0026page-id=289%3A3911\u0026starting-point-node-id=289%3A3912\n","image":"//localhost:1313/images/project/chile-nativo/home.png","permalink":"//localhost:1313/projects/chile-nativo-patagonia-travel-website/","tags":["Vue 3","Laravel Mix","WordPress","Themosis","SCSS","JavaScript","Figma"],"title":"Chile Nativo: Patagonia Travel Website"},{"categories":["Projects"],"contents":"Rutieri is a SaaS platform built with Strapi, React Native, Typescript and other technologies.\nOutline The idea Platform features The stack The API The frontend The mobile app Conclusion Landing Page The idea Before starting to write a single line of code, it is generally a good idea to think about the problem, it\u0026rsquo;s limitations and whether or not it has already been solved by someone else (AKA competitors).\nThe problem I was looking into had to do with the way in which public and private transportation companies manage their routes, drivers and users. This process is generally carried out on paper, e.g. not digital, hence this could be problematic in case of new drivers joining the organization or in case of restricting access to data to only specific users.\nAfter a little bit of research, I could only find one platform that provides a similiar solution but for their own company.\nPlatform features and user stories The following user stories illustrates the desired features the platform should have in order to solve the aforementioned problems.\nAs an administrator user, I want to: login in the admin panel. create an organization. create routes in the organization. invite drivers and users to the organization. manage requests to join the organization. assign routes to drivers in the organization. see in real time the drivers and users currently active in the map of the different routes. As a driver, I want to: login in the mobile app. join an organization by entering the code in the search bar. see my route on the map. become visible to passengers on the road. see the passengers waiting on the road. remove my visibility and finish my run. As a passenger, I want to: login in the mobile app. join an organization by entering the code in the search bar. see the different routes of my organization in the map. search for a destination and get the available routes that pass nearby. see the drivers currently active on the routes in real time. become visible to drivers of a route. The requirements The backend requires to handle user authentication, permissions, different data structures as content types and define relations between them. It\u0026rsquo;s also necessary to synchronise passengers and drivers and view them on a map real time in the administration panel as well as in the mobile app.\nThe administration panel is a web page that fetches data from the backend as well as from the real time data provider and it\u0026rsquo;s goal is to provide a way for administrators to manage their organization and users. We\u0026rsquo;re talking about a Single Page Application built in React.\nAs for the mobile application, there isn\u0026rsquo;t a better choice nowadays than React Native and it works just fine in this case.\nThe API Since all of the features involve authentication, permissions and roles, and because there is no need to reinvent the wheel, I chose to use Strapi to build the backend for it\u0026rsquo;s simplicity, ease of use and great developer experience, whereas for realtime data, I used Firebase.\nThe instance of Strapi and the Postgres database it requires was deployed in the cloud hosting platform https://fly.io.\nStrapi is good for managing users, content that\u0026rsquo;s typically updated and fetched via CRUD API, and relations between content types.\nThe platform needs the following content types:\nOrganizations to group routes, drivers and users Routes Two user roles: drivers and users (passengers) Below are some screenshots of the overview of these content types\nAs I said before, Strapi makes the creation of these content types and the relationships between them really straightforward.\nHowever, not everything related to the API can be provided by Strapi. Some realtime features need to be addressed with other solutions, such as geolocation data in real time for drivers and users to synchronise each other, maps and the ability to search for places. Such features were implemented using Firebase, Google Maps and Google Places.\nThe frontend The platform where users are able to login as administrators and manage their organizations and users is a single page web application built in React. Among the features of this project that I think stand out are:\nState managed by Context API Interface styled with Bootstrap React Router for pages Leaflet to display the map GeoFire library to synchronise geolocation data in real time with Firebase Use of localStorage to save user session Below are some sample screenshots of how this app looks like\nThe mobile application This one is by far the most complex part of this project.\nThe project was bootstraped with Infinitered\u0026rsquo;s Ignite, which provides a great boilerplate and surely saved me of what would have been between 1-2 months of work.\nIgnite\u0026rsquo;s boilerplate includes many features out of the box, including:\nReact Native and Typescript (of course) React Navigation MobX-State-Tree for state management Expo SDK for developer experience AsyncStorage for persistence apisauce as REST client And some other libraries and features that make React Native apps super powerful and a joy to work on.\nIt consists of three screens:\nWelcome screen Login screen Map screen In the welcome screen, users are able to go to the login screen if not logged in. Otherwise, if they\u0026rsquo;re in an organisation, it shows their role and org\u0026rsquo;s information, and if they\u0026rsquo;re not, they are able to enter the organisation code and request to join as driver or as passenger.\nWelcome screens Login screens If the user is a driver in an organisation, the welcome screen also shows the route assigned to them. By tapping on it, it takes them to the map, where they can see themselves and start the tour, becoming visible to passengers on the road but being able to see passengers on the road as well.\nDrivers can finish the tour at any time by pressing the button stop.\nIf the user is a passenger in an organisation, the welcome screen shows the different routes available in the organisation. By tapping on them, they are taken to the map where they can see themselves, the route and the drivers on the road.\nPassengers are able to navigate between the available routes and search for the location they want to go to by using the search bar at the top of the map screen, filtering out the routes that pass nearby (less than 200 meters), if there are. Google Places API and turf library work together in this search process.\nPassengers become visible to drivers on the road by pressing the button wait and if they press the button again, they stop waiting and are removed from the driver\u0026rsquo;s map.\nMap screens The start/wait and finish buttons dispatch actions that update their location in firebase, so that passengers are able to see the bus on the map as it moves in real time and viceversa.\nAs for the state management, the project consists of two models and three stores from Mobx-State-Tree library: User and Route models, user-status, route-store and root-store stores.\nUser model Located in /app/models/user/user.ts\nconst OrganizationModel = types.model({ name: types.string, code: types.string, id: types.identifierNumber, drivers: types.number, rutas: types.array(RouteModel) }) const UserModel = types .model(\u0026#34;User\u0026#34;) .props({ id: types.identifierNumber, username: types.string, email: types.string, token: types.string, role: types.union(types.literal(\u0026#34;passenger\u0026#34;), types.literal(\u0026#34;driver\u0026#34;)), ruta: types.maybeNull(RouteModel), organization: types.maybeNull(OrganizationModel), pending_request: types.maybeNull(OrganizationModel), }) Route model Located in /app/models/route/route.ts\nThis model follows the GeoJSON format for routes.\nconst RouteModel = types .model(\u0026#34;Ruta\u0026#34;) .props({ id: types.identifierNumber, name: types.string, latlong: types.maybeNull(types.model({ lat: types.number, longt: types.number })), coords: types.model({ type: FeatureTypes, features: types.array(types.model({ type: types.string, geometry: types.model({ type: types.string, coordinates: types.union(types.array(types.number), types.array(types.array(types.number))) }), properties: types.model({ name: types.string }) })) }) }) user-status store Located in /app/models/user-status/user-status.ts\nThis store is responsible for managing the state of the user. It stores the user once it\u0026rsquo;s logged in and removes it when the user logs out. It also has some views to get the user key for firebase purposes, get the role and get the route in case of a driver.\nThis store has some methods that get the user location from the device\u0026rsquo;s GPS, displays the user icon on the map and sends it to firebase.\nconst UserStatusModel = types .model(\u0026#34;UserStatus\u0026#34;) .extend(withEnvironment) .props({ user: types.maybeNull(UserModel), location: types.maybeNull( types.model({latitude: types.number, longitude: types.number}) ), visibility: types.maybeNull(types.number) }) route-store store Located in /app/models/route-store/route-store.ts\nThis store is responsible for managing the state of the available routes. It stores the routes, drivers and passengers on the different routes. It also has some view methods to filter the routes that pass nearby a destination specified by the user, get passengers waiting on a given route and get drivers active in a specific route.\nThis store initializes a GeoQuery from Geofire library and listens for events to set, update and remove drivers and passengers from the map as they move.\nconst RouteStoreModel = types .model(\u0026#34;RouteStore\u0026#34;) .props({ routes: types.array(RouteModel), passengers: types.map(types.model({ key: types.identifier, location: types.array(types.number) })), drivers: types.map(types.model({ key: types.identifier, location: types.array(types.number) })), destinationAddress: types.maybeNull(types.model({ name: types.string, coords: types.array(types.number) })) }) Conclusion and final thoughts Using a CMS as the backend can make the development a lot faster than building the API from scratch and with Strapi this is specially true. On the other hand, Strapi doesn\u0026rsquo;t really make a good fit for real time applications, therefore, Firebase is the way to go in this case.\nAs of the client side, React always works very good for pretty much any kind of application, and because React Native uses React under the hood, it is so convenient for us React developers and ir works pretty good for almost any kind of application as well.\nHowever, one thing that I didn\u0026rsquo;t mention in this post was the use of Typescript; I find this quote by Brice Wilson pretty good to point out the whole purpose and motivation to learn and use (well) this powerful language and tool ecosystem:\n\u0026ldquo;You won\u0026rsquo;t have to wait for a frustrated user to report the error. All of this means that you provide value to your users faster, and that\u0026rsquo;s really what it\u0026rsquo;s all about.\u0026rdquo;\nAll in all, I got a lot of learning by building this project, both in languages/frameworks used and production stuff such as infrastructure, cloud hosting and cloud-based APIs.\nProject landing page: https://rutieri.netlify.app\n","image":"//localhost:1313/images/project/rutieri/landing/homepage.webp","permalink":"//localhost:1313/projects/saas-platform-rutieri/","tags":["Strapi","React Native","React","Typescript","Firebase"],"title":"SaaS platform: Rutieri"},{"categories":["Tutorial"],"contents":"Enable comments in a Strapi application and display them in the frontend with React\nOutline Introduction Prerequisites What is Strapi Comment Manager? Installation Configuration Display comments on the frontend Installation of Strapi Comments Client Usage of Strapi Comments Client Plugin settings Manage comments Full source code of the frontend Conclusion Introduction A comment system comes in very handy for pretty much any kind of website. In the JAMstack ecosystem, while it\u0026rsquo;s ok to rely on third party solutions hosted on their own platform such as Disqus to enable comments, you usually want to keep your content and all the stuff related to it in the same admin dashboard.\nIn this article, I\u0026rsquo;ll show you how to enable and manage comments for your content very easily using the Comment Manager plugin, and display them in your frontend application.\nPrerequisites You should have a basic understanding of the following.\nBasic knowledge of JavaScript Basic knowledge of React (OPTIONAL) Basic understanding of Strapi - get started here. Your Strapi V4 project setup What is Strapi Comment Manager? Strapi Comment Manager is a plugin that enables comments for pretty much any kind of content. It allows your users to post comments and anyone can get the comments associated with a given slug.\nWith this plugin, admin users can view and manage very easily all the comments from the Strapi administration dashboard. Within the dashboard, you will be able to delete comments and subcomments and leave replies on comments.\nInstallation Once into the Strapi project root, you can install the plugin by running the following command:\nnpm install strapi-plugin-comment-manager Next, build the project to see the new plugin in the dashboard with the following command:\nnpm run build And that\u0026rsquo;s it! If everything runs correctly, the plugin should now be installed.\nConfiguration Now you need to enable some permissions so that the frontend can access the endpoints to post and fetch comments.\nIn your Strapi admin dashboard, head over to Settings, then over to Roles under Users \u0026amp; Permissions Plugin.\nLet\u0026rsquo;s first setup the Public API; click on Public and hit the dropdown button of Comment Manager. Now check count, find and getPageSize, then hit the Save button. Below is a screenshot of a proper configuration:\nNow let\u0026rsquo;s setup the Authenticated API. Go back to Roles and click on Authenticated. Open the dropdown for Comment Manager and mark as checked the option create on both Comment and Subcomment. Below is a screenshot of a proper configuration:\nWith this configuration, the frontend should now be able to make requests to get and post comments.\nDisplay comments on the frontend The plugin exposes an API to get and post comments if you want to have fine-grained control over the workflow of your comments system and you can check the documentation on the package page, but this plugin also comes with a purpose-built React component library that makes it super easy to get up and running without getting your hands dirty.\nThis components library is called strapi-comments-client, fully supports typescript and it handles for you all of the complexity of fetching and posting comments and subcomments for every content ID that you pass to it.\nInstallation of Strapi Comments Client You will need to have installed react ^17.0.2, react-dom ^17.0.2 and react-router-dom ^5.2.0.\nInside of your React project, run this command:\nnpm install strapi-comments-client --save Usage of Strapi Comments Client Using this library is very easy!\nThis library exports three main components:\nCommentsProvider Comments CommentForm And you can import them this way:\nimport { CommentsProvider, Comments, CommentForm } from \u0026#34;strapi-comments-client\u0026#34; All you have to do is wrap your App component into the CommentsProvider component. Then you will be able to place anywhere in your app the Comments component to render a list of comments for a given content ID and the CommentForm component to render a form to post comments.\nFor example, this could be your index.js or main.js file:\nimport React from \u0026#39;react\u0026#39; import ReactDOM from \u0026#39;react-dom\u0026#39; // The address of your strapi backend instance const STRAPI = \u0026#34;http://localhost:1337\u0026#34; ReactDOM.render( \u0026lt;React.StrictMode\u0026gt; \u0026lt;CommentsProvider apiURL={STRAPI}\u0026gt; \u0026lt;App /\u0026gt; \u0026lt;/CommentsProvider\u0026gt; \u0026lt;/React.StrictMode\u0026gt;, document.getElementById(\u0026#39;root\u0026#39;) ) Where apiURL is the URL of your running Strapi application, and this property is required.\nThis way, the comments provider will do all the magic of fetching and posting comments for you!\nThis library also exports an utility React.Context to update some of the parameters for fetching and posting comments:\nimport { CommentsConfigContext } from \u0026#34;strapi-comments-client\u0026#34; This CommentsConfigContext exposes two setter functions: setUser and setContentID\nWith setContentID you can load the comments for a given content and post comments to it. It receives a single parameter of type string and must be URLized, i.e. no spaces.\nWith setUser you can set the credentials of a given user to authorize the posting of comments. It receives a single parameter of type IUser, with the following Typescript interface:\ninterface IUser { username: string, email: string, id: string, token: string // This is a JWT } It\u0026rsquo;s a little confusing but we\u0026rsquo;ll see how to use it in a component:\nconst App = () =\u0026gt; { const { setUser, setContentID } = useContext(CommentsConfigContext) // The following data should come from Strapi Users and Permissions Plugin // for authenticated requests const user = { username: \u0026#34;John Doe\u0026#34;, email: \u0026#34;jhohndoe@gmail.com\u0026#34;, id: 5, token: \u0026#34;this_should_be_a_JWT\u0026#34; } if (user) { setUser(user) } setContentID(\u0026#34;sample-content-1\u0026#34;) // Load comments for this content return ( \u0026lt;\u0026gt; { !user \u0026amp;\u0026amp; \u0026lt;Login /\u0026gt; } \u0026lt;CommentForm /\u0026gt; \u0026lt;Comments /\u0026gt; \u0026lt;/\u0026gt; ) } And that\u0026rsquo;s it!\nAfter setting the content ID through setContentID, CommentsProvider will start loading the comments for the given content ID and the CommentForm will render an input to post comments related to the given content ID if there is a user. Otherwise, it will display the message Login to post a comment.\nHere\u0026rsquo;s how the interface looks like so far:\nThere\u0026rsquo;s also a button to Leave a reply, which will open a form to post a subcomment associated with the parent comment.\nThis library exports one more component: ErrorBox\nimport { ErrorBox } from \u0026#34;strapi-comments-client\u0026#34; .It\u0026rsquo;s useful if you\u0026rsquo;d like to display error messages when things go wrong fetching or posting comments.\nYou can place this component wherever you want, for example in between the CommentForm and the Comments components.\nIf you\u0026rsquo;re wondering how this error box looks like, here you have a sample:\nGeneral settings You can customize the page size, i.e. specify how many comments are returned at once.\nIn the Strapi admin panel, head over to Settings, then select Pagination under Comment Manager Plugin.\nHere you\u0026rsquo;ll find an input to set the page size, which defaults to 10.\nManage comments Once you\u0026rsquo;ve got the plugin up an running, as users start to post comments, you can manage and reply to them as admin from the Comment Manager section of the left sidebar in the Strapi admin dashboard.\nHere you can see two tabs: one for the latest comments and one for comments grouped by content ID.\nIn both of them you can delete comments and subcomments as well as leave replies.\nExample project You can find a full working example of a React App using the Strapi Comments Client Library in this repo\nConclusion With this plugin you can enable and manage comments for any content with little effort and even use a component library to display the comments in your frontend application made with React.\nAnd that\u0026rsquo;s it! The features are pretty basic at the moment but if there\u0026rsquo;s interest, I\u0026rsquo;m willing to work on more features as well as improve the UI/UX.\n","image":"//localhost:1313/images/post/strapilogo.jpg","permalink":"//localhost:1313/blogs/how-to-enable-and-manage-comments-in-your-strapi-application/","tags":["Strapi","Strapi tutorials"],"title":"How To Enable And Manage Comments In Your Strapi Application."},{"categories":["Documentation"],"contents":"Comment Manager is a Strapi plugin to allow your users to post comments.\nWith this plugin you can enable and manage comments for your content very easily!\nRequirements You should have installed an instance of Strapi v4.x.x\nInstallation Run the following command in your project root:\nnpm install strapi-plugin-comment-manager Configurarion For your frontend to have access to the API, enable the following permissions for Comment Manager from Users \u0026amp; Permissions Plugin on your project settings:\nFor public, enable: count, find and getPageSize.\nFor authenticated, enable create on both Comment and Subcomment.\nDisplay comments on the frontend Comments can be displayed in the frontend in two ways:\nUsing the React components library strapi-comments-client (recommended) Build your custom frontend using the API API There are some Typescript interfaces that will help to get an idea of the data structures.\nComments: interface IComment { id: string, from_admin: boolean, createdAt: string, content: string, author: IAuthor | null, subcomments?: ISubcomment[] } Subcomments: interface ISubcomment { id: string, from_admin: boolean, createdAt: string, content: string, author: IAuthor | null, } Authors: IAuthor { username: string, email: string, id: string } The following endpoints are exposed to fetch and post comments and subcomments:\nGet comments for a content ID Method: GET\nPath: /api/comment-manager/comments/:slug\nOptional query parameters: start, ignoreCount\nReturns:\n{ commentsCount?: Number, comments: IComment[] } The parameter start indicates how many comments to skip. This is for pagination purposes.\nThe parameter ignoreCount indicates whether or not to return the total number of comments associated with the given slug.\nGet the number of comments associated with a given content ID Method: GET\nPath: /api/comment-manager/comments/:slug/count\nReturns:\n{ count: Number } Post a comment Method: POST\nPath: /api/comment-manager/comments/:slug\nAuthentication: Bearer token\nPayload:\n{ content: string } Returns:\n{ id: Number } Post a subcomment Method: POST\nPath: /api/comment-manager/subcomments/:parent-id\nAuthentication: Bearer token\nPayload:\n{ content: string } Returns:\n{ id: Number } Get the page size Method: GET\nPath: /api/comment-manager/page-size\nReturns:\n{ pageSize: Number } General settings The plugin allows to set how many comments are returned per page by going to the Pagination section under Comment Manager Plugin on the Settings section.\nThe default page size is 10.\nManagement of comments Admin users are able to delete comments and subcomments as well as leave replies as admins from within the plugin page of the Strapi admin dashboard.\nThe plugin interface has two tabs: one for the latest comments and one for comments by content ID.\nRoadmap and future plans The plugin is pretty basic but it can be improved with more features and a better UI/UX. Collaborations and suggestions are very welcome.\n","image":"//localhost:1313/images/post/strapilogo.jpg","permalink":"//localhost:1313/blogs/strapi-plugin-comment-manager/","tags":["Strapi","Strapi plugins"],"title":"Strapi Plugin Comment Manager"},{"categories":["Projects"],"contents":"In this post I’m going to share my experience on building a SaaS using the headless CMS Strapi as the Backend, React Native and other technologies.\nOutline Introduction What is SaaS? The problem What is Strapi? Developing features in Strapi The frontend: How to get content Conclusion Landing Page Introduction Very often, developers, product and project managers, testers and pretty much the entire team share their ideas to decide what language and which framework they\u0026rsquo;ll use to build their next project. Some considerations must be taken into account, from which in my opinion there are three that are the most important:\nDeveloper experience and ease of use Does the language and framework chosen provide a good developer experience? Is the langauge the same for the backend and frontend?\nDeadlines Is there a deadline to finish the project? if so, there is a good chance to finish the project on time if the team chooses the language they have more experience in.\nMaintainability As there will be usually more than one person working on the same part at the same time, if everything is kept organised, the whole development process will be frictionless.\nWith that in mind, developers and project managers will have a better insight on which language/framework to use.\nOther aspects should also be considered such as what the data structure will look like.\nIn my case, as it is usual, the backend of my project needs a database for users and their roles among other entities and their relations and a dashboard to allow admins to manage the data, and I was lucky to find out Strapi, as it includes a lot of these features out of the box with one single line of command to get started.\nWhat is SaaS? SaaS stands for Software-as-a-Service and it just means that a software is provided as a service in the cloud and it gives a solution to a specific problem, for which the users are willing to pay either monthly or annual subscription.\nThe problem Before starting to write a single line of code, it is generally a good idea to think about the problem, it\u0026rsquo;s limitations and whether or not it has already been solved by someone else (AKA competitors).\nThe problem I was looking into had to do with the way in which public and private transportation companies manage their routes, drivers and users. After a little bit of research, I could only find one platform that provides a similiar solution but for their own company.\nSo the platform I built needed the following content types:\nOrganizations to group routes, drivers and users Routes Two user roles: drivers and users (passengers) As I said before, Strapi makes the creation of these content types and the relationships between them really easy, but let\u0026rsquo;s first see what is Strapi and how it turns the API development into a satisfactory and fun experience.\nWhat is Strapi? Strapi is an open source headless CMS that allows developers to build complete RESTful APIs in just a couple of days instead of months. It includes a lot of useful features as plugins out of the box. Users and Roles management, Media library and an interface to create, view, edit and delete content are just some of them.\nRegarding the API, how does it makes the development faster?\nFirst of all, it enforces a specific folder structure, which helps to keep everything well organised and clean.\nSecondly, all database schemas are generated automatically and queries are made in JSON format, which really saves a lot of time.\nLastly, we can add more features to our Strapi application very easily via plugins from the marketplace.\nIt\u0026rsquo;s also worth noting that Strapi is a self-hosted CMS, which means that we can host it in whatever cloud platform we want, as well as test it locally in our computers before deploying it to the cloud.\nDeveloping features in Strapi Creating and configuring endpoints in Strapi is as straightforward as declaring a JSON in a single file:\nCreating controllers is straightforward as well:\nEvery controller gets all the data related to the request in the ctx parameter and it\u0026rsquo;s also used to send the response. This keeps everything in one place and really helps to improve the readability.\nOnce the API endpoints are defined, the next step is to enable the permissions for the specific user roles to have access to these endpoints:\nThe frontend: how to get content Since Strapi is a headless CMS, it\u0026rsquo;ll only provide content through the API. That means that the content can be consumed from anywhere. In our case, this content will be used in two applications: one for the organization owners and one for the users and drivers.\nThe application for the organization owners is a dashboard where administrators can create organizations, routes, accept drivers and users in the organization and assign routes to drivers. This is just a React Application:\nThe application for drivers and users is a mobile application built in React Native. Firebase was used to synchronise geolocation data in real time between drivers and users and display this information in a Map from Google Maps:\nConclusion Using a CMS as the backend can make the development a lot faster than building the API from scratch and with Strapi this is specially true. Furthermore, this becomes more important when building a brand-new product, as it\u0026rsquo;s usually recommended to launch as soon as possible to gather feedback from the users and validate the idea.\nProject landing page: https://rutieri.netlify.app\n","image":"//localhost:1313/images/post/03.webp","permalink":"//localhost:1313/blogs/how-i-built-a-saas-on-top-of-strapi-and-why-you-should-too/","tags":["Strapi","React Native","Typescript"],"title":"How I Built A SaaS On Top Of Strapi, And Why You Should Too"},{"categories":["Tutorial"],"contents":"Enable User Reviews in a Strapi application and display them in the frontend with React\nOutline Introduction Prerequisites What is Strapi Ratings? Installation Configuration Display user reviews on the frontend Plugin settings Manage user reviews Full source code of the frontend Conclusion Introduction Ratings systems have become a crucial part of any website with ecommerce capabilites, as they allow the users to post reviews on the items they purchase and publish their opinion to the public. A couple of reviews can make the difference between pressing the “Buy” button and moving on to the next website in the Google search results.\nIn this article, I\u0026rsquo;ll show you how to enable and manage user reviews for your content very easily using the Ratings plugin, and display them in your frontend application.\nPrerequisites First of all, you need to have a basic understanding of the following.\nBasic knowledge of JavaScript Basic knowledge of React (OPTIONAL) Basic understanding of Strapi - get started here. Your Strapi V4 project setup What is Strapi Ratings? Strapi Ratings is a plugin that gives your Strapi application the ability to manage ratings for pretty much any kind of content. It allows your users to post reviews and anyone can get the reviews associated with a given slug.\nWith this plugin, admin users can view and manage very easily all the reviews from the Strapi administration dashboard. Within the dashboard, you will be able to see reviews related to content slugs as well as delete reviews.\nInstallation Once into the Strapi project root, you can install the plugin by running the following command:\nnpm install strapi-plugin-ratings Next, build the project to see the new plugin in the dashboard with the following command:\nnpm run build And that\u0026rsquo;s it! If everything runs correctly, the plugin should now be installed.\nConfiguration Now you need to enable some permissions so that the frontend can access the endpoints to post and fetch reviews.\nIn your Strapi admin dashboard, head over to Settings, then over to Roles under Users \u0026amp; Permissions Plugin.\nLet\u0026rsquo;s first setup the Public API; click on Public and hit the dropdown button of Ratings. Now check count, find, getPageSize and getStats, then hit the Save button. Below is a screenshot of a proper configuration:\nNow let\u0026rsquo;s setup the Authenticated API. Go back to Roles and click on Authenticated. Open the dropdown for Ratings and mark as checked the options create, find and getUserReview. Below is a screenshot of a proper configuration:\nWith this configuration, the frontend should now be able to make requests to get and post user reviews.\nDisplay use reviews on the frontend The plugin exposes an API to get and post reviews if you want to have fine-grained control over the workflow of your ratings system and you can check the documentation on the package page, but this plugin also comes with a purpose-built React component library that makes it super easy to get up and running without getting your hands dirty.\nThis components library is called strapi-ratings-client, fully supports typescript and it takes care of all the complexity of fetching and posting user reviews for every content ID that you pass to it.\nInstallation of Strapi Ratings Client You will need to have installed react ^17.0.2, react-dom ^17.0.2, bootstrap ^5.1.3 and @popperjs/core^2.11.2\nInside of your React project, run this command:\nnpm install strapi-ratings-client --save Usage of Strapi Ratings Client Using this library is very easy!\nThis library exports three main components:\nReviewsProvider Reviews ReviewForm And you can import them this way:\nimport { ReviewsProvider, Reviews, ReviewForm } from \u0026#34;strapi-ratings-client\u0026#34; All you have to do is wrap your App component into the ReviewsProvider component. Then you will be able to place anywhere in your app the Reviews component to render a list of user reviews for a given content ID and the ReviewForm component to render a form to allow your users to post reviews.\nFor example, this could be your index.js or main.js file:\nimport React from \u0026#39;react\u0026#39; import ReactDOM from \u0026#39;react-dom\u0026#39; // The address of your strapi backend instance const STRAPI = \u0026#34;http://localhost:1337\u0026#34; ReactDOM.render( \u0026lt;React.StrictMode\u0026gt; \u0026lt;ReviewsProvider apiURL={STRAPI}\u0026gt; \u0026lt;App /\u0026gt; \u0026lt;/ReviewsProvider\u0026gt; \u0026lt;/React.StrictMode\u0026gt;, document.getElementById(\u0026#39;root\u0026#39;) ) Where apiURL is the URL of your running Strapi application, and this property is required.\nThis way, the ratings provider will do all the magic of fetching and posting comments for you!\nThis library also exports an utility React.Context to update some of the parameters for fetching and posting reviews:\nimport { ReviewsConfigContext } from \u0026#34;strapi-ratings-client\u0026#34; This ReviewsConfigContext exposes three setter functions: setUser, setContentID and setCanPostReview.\nWith setContentID you can load the ratings for a given content and post reviews to it. It receives a single parameter of type string and must be URLized, i.e. no spaces.\nWith setUser you can set the credentials of a given user to authorize the posting of reviews. It receives a single parameter of type IUser, with the following Typescript interface:\ninterface IUser { username: string, email: string, id: string, token: string // This is a JWT } With setCanPostReview, you can enable the user to post a review on the given content. This is useful for when you only allow a user to post a review after they purchase the product.\nIt\u0026rsquo;s a little confusing but we\u0026rsquo;ll see how to use it in a component:\nconst App = () =\u0026gt; { const { setUser, setContentID, setCanPostReview } = useContext(ReviewsConfigContext) // The following data should come from Strapi Users and Permissions Plugin // for authenticated requests. const user = { username: \u0026#34;John Doe\u0026#34;, email: \u0026#34;jhohndoe@gmail.com\u0026#34;, id: 5, token: \u0026#34;this_should_be_a_JWT\u0026#34; } if (user) { setUser(user) } setContentID(\u0026#34;sample-content-1\u0026#34;) // Load reviews for this content setCanPostReview(true) // Allow this user to post a review return ( \u0026lt;\u0026gt; { !user \u0026amp;\u0026amp; \u0026lt;Login /\u0026gt; } \u0026lt;ReviewForm /\u0026gt; \u0026lt;Reviews /\u0026gt; \u0026lt;/\u0026gt; ) } And that\u0026rsquo;s it!\nAfter setting the content ID through setContentID, ReviewsProvider will start loading the reviews for the given content ID and the ReviewForm will render an input to post a user review related to the given content ID if there is a user and he’s allowed to post a review. Otherwise, it will display the message Login to post a review or nothing at all if the user is not allowed to post a review.\nHere\u0026rsquo;s how the interface looks like so far:\nThis library exports one more component: ErrorBox\nimport { ErrorBox } from \u0026#34;strapi-ratings-client\u0026#34; .It\u0026rsquo;s useful for when you\u0026rsquo;d like to display error messages when things go wrong fetching or posting reviews.\nYou can place this component wherever you want, for example in between the ReviewForm and the Reviews components.\nIf you\u0026rsquo;re wondering how this error box looks like, here‘s a screenshot:\nGeneral settings You can customize the page size, i.e. specify how many user reviews are showed at once.\nIn the Strapi admin panel, head over to Settings, then select Pagination under Ratings Plugin.\nHere you\u0026rsquo;ll find an input to set the page size, which defaults to 10.\nManage reviews Once you\u0026rsquo;ve got the plugin up an running, as users start to post reviews, you can view them from within the Ratings section of the left sidebar in the Strapi admin dashboard.\nHere you can see two tabs: one for the latest reviews and one for reviews grouped by content ID.\nIn both of them you can delete unwanted reviews.\nExample project You can find a full working example of a React App using the Strapi Ratings Client Library in this repo: https://github.com/luisguve/strapi-ratings-client-example\nConclusion With this plugin you can enable and manage user reviews for any content with little effort and even use a library of components styled with Bootstrap to display the user reviews in your frontend.\nAnd that\u0026rsquo;s it! The features are pretty basic at the moment but if there\u0026rsquo;s interest, I\u0026rsquo;m willing to work on more features as well as improve the UI/UX.\n","image":"//localhost:1313/images/post/tutorial-ratings.webp","permalink":"//localhost:1313/blogs/how-to-enable-and-manage-user-reviews-in-your-strapi-application/","tags":["Strapi","Strapi tutorials"],"title":"How To Enable And Manage User Reviews In Your Strapi Application"},{"categories":["Documentation"],"contents":"Ratings is a Strapi plugin that allows your users to post reviews.\nEnable and manage user reviews for your content very easily!\nRequirements You should have installed an instance of Strapi v4.x.x\nInstallation Run the following command in your project root:\nnpm install strapi-plugin-ratings Then, rebuild the admin dashboard using the following command\nnpm run build Configurarion For your frontend to have access to the API, enable the following permissions for Ratings from Users \u0026amp; Permissions Plugin on your project settings:\nFor public, enable: count, find, getPageSize and getStats.\nFor authenticated, enable create, find and getUserReview.\nDisplay user reviews on the frontend Reviews can be displayed in the frontend in two ways:\nUsing the React components library strapi-ratings-client (recommended) Build your custom frontend using the API endpoints, described as follows: API There are some Typescript interfaces that will help to get an idea of the data structures.\nReviews: interface IReview { id: number, createdAt: string, comment: string | null, author: IAuthor | null, score: number, } Authors: interface IAuthor { username: string, email: string, id: number } Content Stats interface IStats { averageScore: number; reviewsCount: number | null; } The following endpoints are exposed to fetch and post reviews:\nGet reviews for a content ID Method: GET\nPath: /api/ratings/reviews/:slug\nOptional query parameters: start, ignoreCount\nReturns:\n{ reviewsCount: number, averageScore: number, userReview: IReview | null, reviews: IReview[] } The parameter start indicates how many reviews to skip. This is for pagination purposes.\nThe parameter ignoreCount indicates whether or not to return the total number of reviews associated with the given slug.\nGet review stats for a content ID Method: GET\nPath: /api/ratings/reviews/:slug/stats\nReturns:\n{ averageScore: number, reviewsCount: number | null } Get the number of reviews associated with a given content ID Method: GET\nPath: /api/ratings/reviews/:slug/count\nReturns:\n{ count: number } Post a review Method: POST\nPath: /api/ratings/reviews/:slug\nAuthentication: Bearer token\nPayload:\n{ content: string } Returns:\n{ id: number } By default, every authenticated user can post reviews on any content.\nIn order to customize this behavior, e.g. allowing or disallowing a user from posting reviews, you must extend the service userCanPostReview from whithin register function in ./src/index.js. For example:\nstrapi.service(\u0026#34;plugin::ratings.review\u0026#34;).userCanPostReview = async (user, slug) =\u0026gt; { /* Here you will check whether or not the user is allowed to post a review on this content ID and return either true or false. */ return true } Notice that userCanPostReview will receive two parameters: the user from Users \u0026amp; Permissions Plugin, containing it\u0026rsquo;s id, username, confirmed, etc., and the slug, which is a string and refers to the content ID which the review is being posted on.\nIn case this function returns false, the response of the endpoint will be 403 (forbidden) with the text User cannot post a review on this content.\nGet the page size Method: GET\nPath: /api/ratings/page-size\nReturns:\n{ pageSize: number } General settings The plugin allows to set how many reviews are returned per page by going to the Pagination section under Ratings Plugin of the Settings section.\nThe default page size is 10.\nManagement of reviews Admin users are able to delete reviews from within the plugin page of the Strapi admin dashboard.\nThe plugin interface has two tabs: one for the latest reviews and one for reviews by content ID.\nRoadmap and future plans The plugin is pretty basic but it can be improved with more features and a better UI/UX. Collaborations and suggestions are very welcome.\n","image":"//localhost:1313/images/post/ratings.webp","permalink":"//localhost:1313/blogs/strapi-plugin-ratings/","tags":["Strapi","Strapi plugins"],"title":"Strapi Plugin Ratings"},{"categories":null,"contents":"","image":"//localhost:1313/images/post/ratings.webp","permalink":"//localhost:1313/projects/jac-autos/","tags":null,"title":""},{"categories":["Projects"],"contents":"ManyLMS is an e-learning platform built on top of Strapi, React Router 7, Typescript and other technologies.\nOutline The idea Platform features The stack The API The frontend Conclusion Landing Page The idea This project doesn\u0026rsquo;t necessarily bring a huge amount of innovation on the e-learning platforms that already exists, but it\u0026rsquo;s just another way of doing this type of application.\nThe main idea is to apply a JAMstack approach in this application, where the platform is a static website, and the backend is just an API that serves static content only once to build the website and just adds the dynamism that\u0026rsquo;s necessary to allow users to authenticate, create orders, confirm payments and take courses.\nIf we compare this approach to a WordPress website, we are taking out most of the overhead that implies rendering the pages everytime a user visits them. Despite that there are plugins for caching that may improve the performance, it\u0026rsquo;s still never going to be faster and more efficient than just static content served by a CDN. That\u0026rsquo;s why React Router 7 and Headless CMSs are so popular right now.\nPlatform features and user stories The following user stories illustrates the desired features the platform should have.\nAs an administrator, I want to: login in the admin panel. create categories. create courses. upload lectures. organise courses into categories. assign lectures to courses. As a student, I want to: login in the platform. view the available courses. add courses to the shopping cart. review the shopping cart. create an order. pay with credit card or paypal. view the courses i\u0026rsquo;ve purchased in my learning page. go to the course page from my learning page and watch the videos. mark lectures as seen. come back later and resume where I left. The requirements The backend requires to handle user authentication, permissions, different data structures as content types and define relationships between them. It also requires to allow uploading videos to some third party platform that supports streaming on demand.\nThe frontend is a web platform where users can register and login, view and buy courses, leave comments and reviews and take courses.\nThe API Since all of the features involve authentication, permissions and roles, and because there is no need to reinvent the wheel, I chose to use Strapi to build the backend for it\u0026rsquo;s simplicity, ease of use and great developer experience, whereas for streaming videos on demand, I chose to use Mux.com.\nThe instance of Strapi and the Postgres database it requires was deployed in the cloud hosting platform https://fly.io.\nStrapi is good for managing users, content that\u0026rsquo;s typically updated and fetched via CRUD API, and setting up relations between content types.\nThe platform needs the following content types:\nCategory to group courses Course Lecture Module to group lectures Order Student: has many courses Student-Course: stores a student\u0026rsquo;s current lecture of a course Video Strapi makes the creation of these content types and setting up relationships between them really straightforward.\nBelow are some screenshots of these content types and the relationships between them:\nThe frontend The platform where users are able to login, view, buy and view courses is a web application built with React Router 7. Among the features of this application are:\nState managed by Context API Interface styled with Bootstrap Play streaming videos with @mux/mux-player-react library Use of localStorage to save user session Below are some sample screenshots of how this app looks like\nConclusion and final thoughts While building this project, I learned:\nHow streaming on demand works and how to use a streaming provider How to statically build websites with React Router 7 and Strapi How to setup dynamic pages in React Router 7 How to process payments with Stripe and Paypal How to build custom plugins in Strapi How to publish packages to NPM Project source codes: https://github.com/luisguve/maestro-backend\nhttps://github.com/luisguve/new-lms-remix\n","image":"//localhost:1313/images/project/manylms/frontend/course_overview.png","permalink":"//localhost:1313/projects/e-learning-platform-maestro-lms/","tags":["Strapi","React","React Router 7","Typescript","Mux"],"title":"ManyLMS: E-Learning platform"},{"categories":["Projects"],"contents":"ETMday (Emprende tu Mente) is a large-scale entrepreneurship event website built on top of WordPress with the Themosis framework, featuring an interactive SVG map, real-time countdown timers, advanced search functionality, and comprehensive content management using Vue 3, Laravel Mix, and modern frontend technologies.\nOutline The project Key features The stack Frontend architecture Interactive components Conclusion Live website The project ETMday is Chile\u0026rsquo;s premier entrepreneurship event, bringing together thousands of entrepreneurs, startups, corporates, and strategic partners. The website serves as the central hub for event information, featuring speakers, activities, stands, program schedules, and an interactive event map.\nThe frontend development required implementing complex interactive features including an SVG-based interactive map with tooltips, real-time countdown timers, advanced filtering and search systems, and dynamic content displays that handle thousands of attendees and hundreds of activities.\nKey features The website includes several sophisticated features:\nInteractive SVG Map: Custom-built interactive map with clickable zones, tooltips, and dynamic content display Real-time Countdown: Event countdown timer with automatic updates and mobile optimization Advanced Search: Multi-category search across activities, speakers, stands, and content Dynamic Filtering: Complex filtering system with tabs, favorites, and downloadable resources Animated Statistics: Odometer animations for displaying event metrics Content Management: Comprehensive card components for activities, speakers, stands, and blog posts Form Handling: Multi-step forms with validation using Vee-Validate Lightbox Galleries: Image galleries with LightGallery integration Responsive Design: Fully responsive design optimized for all devices The stack The frontend stack consists of:\nVue 3.2.4: Modern reactive framework for building interactive components Laravel Mix 6.0: Asset compilation and bundling SCSS: Advanced styling with organized architecture Vee-Validate 4.15.0: Form validation with Yup schemas Axios 1.6.8: HTTP client for API requests Splide.js 4.1.4: Modern carousel and slider components LightGallery 2.8.3: Lightbox gallery functionality Odometer 0.4.8: Animated number counting Headroom.js: Header behavior on scroll jQuery 3.7.1: DOM manipulation and legacy support SweetAlert2: Modern alert dialogs GLightbox 3.3.1: Alternative lightbox solution Frontend architecture Vue components The application features a comprehensive set of Vue 3 components:\nCard Components:\ncards/activities.vue: Activity cards with favorites functionality cards/speakers.vue: Speaker cards with modal details cards/stands.vue: Stand/exhibitor cards cards/blog.vue: Blog post cards cards/shortcut.vue: Quick access shortcut cards Functional Components:\nSectionCards.vue: Main section component with tabs, filtering, and card display Search.vue: Advanced search component with multi-category results Form.vue: Dynamic form component with validation FormCalendar.vue: Calendar form component CustomFilter.vue: Reusable filter component CustomSelect.vue: Custom select dropdown Pagination.vue: Pagination component JavaScript components The application includes 17 specialized JavaScript components:\nInteractive Features:\ninteractiveMap.js: SVG map interaction with tooltips, zones, and dynamic content countdown.js: Real-time countdown timer with automatic updates odometer.js: Animated number counting with scroll triggers map.js: Map zone interactions and modal displays UI Components:\nheader.js: Header functionality and navigation headroom.js: Header hide/show on scroll accordion.js: Accordion interactions tabs.js: Tab functionality cards.js: Card interactions and modals siteModals.js: Modal management system UI.js: General UI utilities Media Components:\nvideo.js: Video player setup lightgallery.js: Lightbox gallery initialization splide.js: Carousel initialization slick.js: Legacy carousel support Utilities:\nscrollTrigger.js: Scroll-based animations imgToSvg.js: SVG image conversion utility SCSS architecture The styling follows a well-organized SCSS architecture:\nscss/ ├── abstracts/ # Variables, mixins, functions │ ├── _functions.scss │ ├── _mixins.scss │ ├── _variables.scss │ ├── _mq.scss # Media query mixins │ └── _keyframes.scss ├── base/ # Base styles and typography │ ├── _typography.scss │ ├── _container.scss │ └── _reset.scss └── components/ # Component-specific styles └── [52 component files] Key SCSS features:\nBEM methodology: Consistent naming convention Media query mixins: Using sass-mq for responsive design Modular architecture: Each component has its own SCSS file Component organization: 52 component-specific SCSS files Interactive components Interactive SVG Map The interactiveMap.js component implements a sophisticated SVG-based interactive map:\nFeatures:\nSVG Tooltips: Dynamically generated tooltips with text wrapping Zone Interactions: Clickable zones with modal displays Point Markers: Interactive points with icons and labels Dynamic Content: Content loaded based on zone/point selection Responsive Design: Optimized for mobile and desktop Technical Implementation:\nSVG namespace manipulation for tooltip creation Text wrapping algorithm for tooltip content Path generation for tooltip shapes with rounded corners Event delegation for zone and point interactions Smooth animations and transitions Real-time Countdown The countdown.js component provides a real-time countdown timer:\nFeatures:\nAutomatic Updates: Updates every second Multi-unit Display: Days, hours, minutes, and seconds Pluralization: Proper Spanish pluralization (Día/Días, Hora/Horas) Mobile Optimization: Simplified display on mobile devices End State Handling: Automatic transition when countdown ends Advanced Search System The Search.vue component implements a comprehensive search system:\nFeatures:\nMulti-category Search: Searches across activities, speakers, stands, and other content Category Tabs: Quick navigation between result categories Result Counts: Dynamic result counts per category Scroll Navigation: Smooth scrolling to category sections Carousel Display: Splide carousels for result display Loading States: Loading indicators during search Empty States: User-friendly empty state messages Dynamic Filtering System The SectionCards.vue component provides advanced filtering:\nFeatures:\nTab Navigation: Multiple filter tabs Favorites System: Save and filter favorite items Search Integration: Inline search within filters Reset Functionality: Clear all filters with one click Downloadable Resources: Download buttons for resources URL Synchronization: Filter state in URL parameters Responsive Design: Mobile accordion interface Animated Statistics The odometer.js component provides animated number counting:\nFeatures:\nScroll-triggered: Animations trigger on scroll Prefix/Suffix Support: Handles formatted numbers (e.g., \u0026ldquo;56,000+\u0026rdquo;) Mobile Optimization: Static display on mobile Smooth Animations: Odometer theme integration Development workflow The project uses Laravel Mix for asset compilation:\n// Development npm run dev // Compile assets npm run watch // Watch for changes npm run hot // Hot module replacement // Production npm run production // Optimized production build BrowserSync integration provides:\nLive reloading during development Synchronized browser testing Proxy configuration for WordPress development Performance optimizations Code splitting: Laravel Mix extracts vendor libraries Asset versioning: Automatic cache busting Image optimization: Lazy loading and responsive images Minification: Production builds are minified and optimized Tree shaking: Unused code elimination in production SVG optimization: Efficient SVG manipulation and rendering Accessibility Semantic HTML structure ARIA labels for interactive elements Keyboard navigation support Focus management in forms and modals Screen reader considerations Proper alt text for images Conclusion and final thoughts Building the ETMday frontend was an excellent opportunity to:\nMaster SVG interactions: Creating complex interactive SVG maps with dynamic tooltips and zones Implement real-time features: Building countdown timers and live updates Build advanced search: Multi-category search with filtering and categorization Handle complex state: Managing filters, favorites, and dynamic content Optimize performance: Implementing efficient animations and lazy loading Ensure scalability: Building components that handle large datasets (thousands of attendees, hundreds of activities) The project demonstrates proficiency in:\nModern JavaScript frameworks (Vue 3) SVG manipulation and interaction Real-time UI updates Advanced filtering and search systems Build tools and asset compilation (Laravel Mix, Webpack) CSS architecture and methodologies (SCSS, BEM) Component-based development Event-driven architecture The integration with WordPress/Themosis backend required careful consideration of server-side rendering, API endpoints, and content management workflows, making this a full-stack frontend implementation for a large-scale event.\nLive website: https://etmday.org/\nFigma Prototype: https://www.figma.com/proto/mt9fJ8P03M5gf0nQwcU99q/EtM-Day-2025---Dise%C3%B1o?node-id=1-2743\u0026m=dev\u0026scaling=scale-down\u0026content-scaling=fixed\u0026page-id=0%3A1\u0026starting-point-node-id=1%3A2743\n","image":"//localhost:1313/images/project/etm/home.png","permalink":"//localhost:1313/projects/etmday-entrepreneurship-event-website/","tags":["Vue 3","Laravel Mix","WordPress","Themosis","SCSS","JavaScript","Interactive Map","SVG"],"title":"ETMday: Entrepreneurship Event Website"},{"categories":["Projects"],"contents":"JAC Autos Chile is a comprehensive automotive website built on top of WordPress with the Themosis framework, featuring car model comparisons, multi-step quote forms, fleet management, branch listings, and advanced filtering systems using Vue 3, Pinia state management, Laravel Mix, and modern frontend technologies.\nOutline The project Key features The stack Frontend architecture Interactive components Conclusion Live website The project JAC Autos Chile is the official website for JAC Motors in Chile, showcasing SUVs, pickups, commercial vehicles, and electric vehicles. The website serves as the primary platform for vehicle exploration, quoting, dealership location, fleet management, and post-sale services.\nThe frontend development required implementing complex interactive features including car model comparisons, multi-step quote forms with model and version selection, advanced filtering systems, fleet management interfaces, and comprehensive content management.\nKey features The website includes several sophisticated features:\nCar Model Comparator: Side-by-side comparison of multiple vehicle models with difference highlighting Multi-step Quote Form: Comprehensive quote form with model selection, version selection, and customer information Advanced Filtering: Multi-criteria filtering for car models, branches, fleet vehicles, and blog posts Fleet Management: Dedicated fleet vehicle selection and management interface Branch Locator: Filterable dealership/branch listings with location information Blog System: Complete blog with filtering, search, and content management Manuals Listing: User manual and documentation management Search Functionality: Site-wide search with categorized results Sticky Navigation: Section-based sticky navigation for long pages 360° View: Interactive 360-degree vehicle viewing The stack The frontend stack consists of:\nVue 3.2.4: Modern reactive framework with Composition API Pinia 2.2.6: State management for Vue applications Laravel Mix 6.0: Asset compilation and bundling SCSS: Advanced styling with organized architecture Vee-Validate 4.14.6: Form validation with Yup schemas Axios 1.6.8: HTTP client for API requests Splide.js 4.1.4: Modern carousel and slider components @splidejs/vue-splide 0.6.12: Vue 3 wrapper for Splide Maska 3.0.3: Input masking for formatted inputs Vue-Select 4.0.0-beta.6: Custom select component Vue-Recaptcha 2.0.3: reCAPTCHA integration Headroom.js: Header behavior on scroll jQuery 3.7.1: DOM manipulation and legacy support SweetAlert2: Modern alert dialogs @fdograph/rut-utilities: Chilean RUT validation utilities Frontend architecture Vue components The application features a comprehensive set of Vue 3 components (40+ components):\nCar Model Components:\nCar.vue: Car model card component with comparison functionality CarLoading.vue: Loading skeleton for car cards CarVersion.vue: Car version/trim level component CarVersionLoading.vue: Loading skeleton for version cards CarModelsListingStatic.vue: Static car models listing CarModelsListingQuote.vue: Car models listing for quote flow CarVersionsListingQuote.vue: Versions listing for quote flow CarQuote.vue: Car quote display component CarQuoteLoading.vue: Loading skeleton for quote cards Comparison Components:\nComparator.vue: Main car comparison component with Splide integration ComparatorModal.vue: Modal version of comparator CardCompareModel.vue: Comparison card for individual models CardCompareModelLoading.vue: Loading skeleton for comparison cards Quote Components:\nQuote.vue: Main quote component with multi-step flow QuoteForm.vue: Comprehensive quote form with validation Filtering Components:\nFilters.vue: General filtering component FleetFilter.vue: Fleet-specific filtering BranchesFilter.vue: Branch/dealership filtering BlogFilter.vue: Blog post filtering AjaxListWithFilter.vue: AJAX-powered list with filtering Content Components:\nBlog.vue: Blog post card component BlogLoading.vue: Loading skeleton for blog cards Fleet.vue: Fleet vehicle card component Branch.vue: Branch/dealership card component BranchLoading.vue: Loading skeleton for branch cards Manual.vue: Manual/documentation card component ManualLoading.vue: Loading skeleton for manual cards ManualsListing.vue: Manuals listing component Form Components:\nContactForm.vue: Contact form with validation Select.vue: Custom select dropdown component UI Components:\nPagination.vue: Pagination component StickySectionSelector.vue: Sticky navigation for sections EmptyState.vue: Empty state displays Loader.vue: Loading indicator ErrorBoundary.vue: Error boundary component SearchResults.vue: Search results display SearchResultCard.vue \u0026amp; SearchResultCardLoading.vue: Search result cards Service Components:\nCardMaintenance.vue: Maintenance service card CardMaintenanceLoading.vue: Loading skeleton for maintenance cards JavaScript components The application includes 12 specialized JavaScript components:\nUI Components:\nheader.js: Header functionality and navigation headroom.js: Header hide/show on scroll megamenu.js: Mega menu functionality search-modal.js: Search modal functionality scrollUpBottom.js: Scroll to top/bottom functionality social-share.js: Social media sharing Media Components:\nvideo.js: Video player setup splide.js: Carousel initialization slick.js: Legacy carousel support Interactive Components:\naccordion.js: Accordion interactions tabs.js: Tab functionality Utilities:\nimg-to-svg.js: SVG image conversion utility scrollTrigger.js: Scroll-based animations SCSS architecture The styling follows a well-organized SCSS architecture:\nscss/ ├── abstracts/ # Variables, mixins, functions │ ├── _mixins.scss │ ├── _mq.scss # Media query mixins │ └── _vendor.scss ├── base/ # Base styles and typography │ ├── _typography.scss │ ├── _colors.scss │ ├── _container.scss │ └── _globals.scss └── components/ # Component-specific styles ├── [87 component files] └── cards/ # Card component styles └── [20 card-specific files] Key SCSS features:\nBEM methodology: Consistent naming convention throughout Media query mixins: Using sass-mq for responsive design Modular architecture: 106 component-specific SCSS files Card organization: Dedicated card component styles Interactive components Car model comparator The Comparator.vue component provides sophisticated car model comparison:\nFeatures:\nSide-by-side comparison: Compare up to 3 models simultaneously Difference highlighting: Toggle to highlight differences between models Splide integration: Smooth carousel navigation for multiple models Dynamic data loading: Load comparison data via AJAX Responsive design: Optimized for mobile and desktop Modal version: Full-screen modal comparison view Technical Implementation:\nPinia store for comparison state management Splide Vue component for carousel functionality Dynamic component rendering based on selected models Efficient data structure for comparison attributes Multi-step quote form The Quote.vue and QuoteForm.vue components implement a comprehensive quote system:\nFeatures:\nStep-by-step flow: Model selection → Version selection → Customer information Form validation: Using Vee-Validate with Yup schemas RUT validation: Chilean RUT validation using custom directive Input masking: Phone numbers and formatted inputs with Maska reCAPTCHA integration: Spam protection Edit functionality: Ability to go back and edit previous steps Selected vehicle display: Visual representation of selected model/version Loading states: Visual feedback during form submission Form steps include:\nStep 1: Category and model selection Step 2: Version/trim level selection Step 3: Customer information and submission Advanced filtering systems Multiple filtering components provide comprehensive filtering:\nFleet Filter (FleetFilter.vue):\nFilter fleet vehicles by category, price range, and features Real-time filtering with URL parameter synchronization Mobile-optimized interface Branches Filter (BranchesFilter.vue):\nFilter dealerships by location, region, and services Map integration support Contact information display Blog Filter (BlogFilter.vue):\nFilter blog posts by category, date, and tags Search functionality Pagination support Ajax List with Filter (AjaxListWithFilter.vue):\nGeneric AJAX-powered list component Multiple filter criteria Loading states and empty states Sticky section selector The StickySectionSelector.vue component provides section-based navigation:\nFeatures:\nSticky positioning: Stays visible while scrolling Active section highlighting: Highlights current section Smooth scrolling: Smooth scroll to sections Responsive design: Mobile-optimized display State management with Pinia The application uses Pinia for centralized state management:\nStores:\nComparator Store: Manages comparison state, selected models, and comparison data Quote Store: Manages quote flow state, selected model/version, and form data Filter Stores: Manage filter states for different content types Benefits:\nCentralized state management Type-safe state access Efficient reactivity Easy debugging with Vue DevTools Custom directives The application includes custom Vue directives:\nRUT Directive (input-rut):\nChilean RUT (tax ID) validation and formatting Real-time validation as user types Format enforcement (XX.XXX.XXX-X) Development workflow The project uses Laravel Mix for asset compilation:\n// Development npm run dev // Compile assets npm run watch // Watch for changes npm run hot // Hot module replacement // Production npm run production // Optimized production build BrowserSync integration provides:\nLive reloading during development Synchronized browser testing Proxy configuration for WordPress development Performance optimizations Code splitting: Laravel Mix extracts vendor libraries Asset versioning: Automatic cache busting Image optimization: Lazy loading and responsive images Minification: Production builds are minified and optimized Tree shaking: Unused code elimination in production Component lazy loading: Load components on demand Skeleton loading: Better perceived performance with loading states Accessibility Semantic HTML structure ARIA labels for interactive elements Keyboard navigation support Focus management in forms and modals Screen reader considerations Proper alt text for images Color contrast compliance Conclusion and final thoughts Building the JAC Autos Chile frontend was an excellent opportunity to:\nMaster Vue 3: Working with Composition API, Pinia state management, and modern Vue patterns Build complex comparisons: Creating sophisticated car model comparison interfaces Implement multi-step forms: Complex quote forms with validation, RUT formatting, and step navigation Create advanced filtering: Multiple filtering systems for different content types Optimize performance: Implementing efficient state management, lazy loading, and code splitting Handle automotive data: Managing complex vehicle data structures and relationships The project demonstrates proficiency in:\nModern JavaScript frameworks (Vue 3) State management (Pinia) Form validation and user experience (Vee-Validate, Yup, Maska) Build tools and asset compilation (Laravel Mix, Webpack) CSS architecture and methodologies (SCSS, BEM) Component-based development Custom directives Carousel and slider implementations (Splide) AJAX-powered interfaces The integration with WordPress/Themosis backend required careful consideration of server-side rendering, API endpoints, and content management workflows, making this a full-stack frontend implementation for a comprehensive automotive platform.\nLive website: https://jacautoschile.cl/\n","image":"//localhost:1313/images/project/jac-autos/homepage.webp","permalink":"//localhost:1313/projects/jac-autos-chile-automotive-website/","tags":["Vue 3","Pinia","Laravel Mix","WordPress","Themosis","SCSS","JavaScript","Splide"],"title":"JAC Autos Chile: Automotive Website"},{"categories":["Projects"],"contents":"ISC Chile is an educational consultancy website for study abroad programs, built on top of WordPress with the Themosis framework, featuring GSAP animations, multi-step contact forms, advanced blog filtering, and comprehensive content management using Vue 2, Laravel Mix, and modern frontend technologies.\nOutline The project Design implementation The stack Frontend architecture Key features Conclusion Live website The project ISC Chile is an educational consultancy agency that has been providing study abroad advisory services since 1996. The website serves as the primary platform for showcasing various educational programs including English courses, school exchanges, group travel programs, and Pathways programs for university admission abroad.\nThe frontend development was based on a comprehensive Figma design, requiring pixel-perfect implementation of complex UI components, multi-step forms, animated statistics, and responsive layouts that work seamlessly across all devices.\nDesign implementation The entire frontend was built from a detailed Figma design, ensuring:\nPixel-perfect accuracy: Matching the design specifications precisely (as evidenced by Figma height references in SCSS) Responsive design: Implementing breakpoints and mobile-first approach Component consistency: Maintaining design system patterns throughout Interactive elements: Translating static designs into dynamic, interactive components Animation and transitions: Implementing smooth GSAP-powered animations The stack The frontend stack consists of:\nVue 2.6.12: Reactive framework for building interactive components Laravel Mix 6.0: Asset compilation and bundling SCSS: Advanced styling with a well-organized architecture Vuex 3.6.2: State management for Vue applications Vee-Validate 3.4.14: Form validation GSAP 3.12.5: Professional animation library with ScrollTrigger Axios 0.18: HTTP client for API requests Splide.js 4.1.4: Modern carousel and slider components Slick Carousel 1.8.1: Legacy carousel support LightGallery 2.7.2: Lightbox gallery functionality Odometer 0.4.8: Animated number counting Headroom.js: Header behavior on scroll V-Calendar 2.4.2: Calendar component for date selection V-Mask 2.3.0: Input masking Vue-Select 3.20.2: Custom select component jQuery 3.2: DOM manipulation and legacy support SweetAlert: Alert dialogs Frontend architecture Vue components The application features a comprehensive set of Vue 2 components:\nForm Components:\nContact.vue: Multi-step contact form with validation and reCAPTCHA ContactFormStep1.vue: First step of the contact form ContactFormStep2.vue: Second step of the contact form ContactFormStep3.vue: Third step of the contact form FormBanner.vue: Banner form component Content Components:\nBlog.vue: Blog listing with advanced filtering and search BlogArticleCard.vue \u0026amp; BlogArticleCardLoading.vue: Blog post cards with loading states ExperiencesPanel.vue: Testimonials and experiences display panel ExperiencesFiltersMobile.vue: Mobile filter component for experiences Search Components:\nSearchResults.vue: Search results display component SearchResultCardLoading.vue: Loading skeleton for search results UI Components:\nCheckboxDropdown.vue: Custom checkbox dropdown component CheckboxDropdownFieldset.vue: Fieldset wrapper for checkbox dropdowns EmptyState.vue: Empty state displays Loader.vue \u0026amp; Loading.vue: Loading indicators JavaScript components The application includes 15 specialized JavaScript components:\nAnimation Components:\ngsap.js: GSAP animations with ScrollTrigger for scroll-based reveals scrolltrigger.js: Custom scroll trigger utilities odometer.js: Animated number counting with scroll triggers UI Components:\nheader.js: Header functionality and navigation headroom.js: Header hide/show on scroll megamenu.js: Mega menu functionality mobileMenu.js: Mobile menu interactions searchbar.js: Search bar functionality floating-banner.js: Floating banner component footer.js: Footer functionality Media Components:\nvideo.js: Video player setup lightgallery.js: Lightbox gallery initialization splide.js: Carousel initialization slick.js: Legacy carousel support Interactive Components:\naccordion.js: Accordion interactions tabs.js: Tab functionality cards.js: Card interactions Utilities:\nimg-to-svg.js: SVG image conversion utility SCSS architecture The styling follows a well-organized SCSS architecture:\nscss/ ├── abstracts/ # Variables, mixins, functions │ ├── _mixins.scss │ ├── _mq.scss # Media query mixins │ └── _vendor.scss ├── base/ # Base styles and typography │ ├── _typography.scss │ ├── _colors.scss │ ├── _container.scss │ ├── _globals.scss │ └── fonts/ # Custom TWK Everett font family └── components/ # Component-specific styles └── [45 component files] Key SCSS features:\nBEM methodology: Consistent naming convention throughout Media query mixins: Using sass-mq for responsive design Modular architecture: Each component has its own SCSS file Custom typography: TWK Everett font family with multiple weights Figma references: Direct references to Figma design specifications Key features Multi-step contact form The Contact.vue component implements a sophisticated multi-step form with:\nThree-step navigation: Step-by-step form progression Form validation: Using Vee-Validate with comprehensive rules Date picker: V-Calendar integration for date selection Input masking: V-Mask for phone numbers and formatted inputs reCAPTCHA integration: Spam protection Dynamic fields: Fields that change based on user selections Loading states: Visual feedback during form submission Error handling: Comprehensive error messages and validation Form steps include:\nStep 1: Personal information and contact details Step 2: Educational background and program interests Step 3: Additional information and submission GSAP animations The gsap.js component provides professional animations:\nFeatures:\nScroll-triggered animations: Elements animate on scroll Vertical scroll reveals: Fade and slide animations Horizontal scroll reveals: Staggered animations for grid layouts Timeline management: Complex animation sequences Performance optimized: Efficient animation triggers Animation types:\nFade in with vertical movement Staggered grid animations Scroll-based reveals Smooth transitions Advanced blog system The Blog.vue component provides comprehensive blog functionality:\nFeatures:\nCategory filtering: Filter posts by category Search functionality: Real-time search across blog posts Mobile filters: Dedicated mobile filter interface Pagination: Efficient content pagination Loading states: Skeleton loading screens Empty states: User-friendly empty state messages Experiences/testimonials panel The ExperiencesPanel.vue component displays student testimonials:\nFeatures:\nFilter by type: Filter testimonials (Students/Parents) Dynamic loading: Load testimonials from API Responsive design: Mobile-optimized display Carousel integration: Splide carousel for testimonial display Animated statistics The odometer.js component provides animated number counting:\nFeatures:\nScroll-triggered: Animations trigger on scroll Smooth counting: Odometer theme integration Performance optimized: Efficient scroll detection Mobile support: Optimized for all devices Search functionality The SearchResults.vue component provides comprehensive search:\nFeatures:\nMulti-content search: Search across programs, blog posts, and pages Result categorization: Organized search results Image support: Results with and without images Tag display: Category tags for results Loading states: Skeleton loading screens Custom typography The website features a custom font family, TWK Everett, with:\nMultiple weights: From Hairline to Super Italic variants: All weights include italic versions Optimized formats: WOFF, WOFF2, and OTF formats Performance: Efficient font loading and rendering Development workflow The project uses Laravel Mix for asset compilation:\n// Development npm run dev // Compile assets npm run watch // Watch for changes npm run hot // Hot module replacement // Production npm run production // Optimized production build BrowserSync integration provides:\nLive reloading during development Synchronized browser testing Proxy configuration for WordPress development Performance optimizations Code splitting: Laravel Mix extracts vendor libraries Asset versioning: Automatic cache busting Image optimization: Lazy loading and responsive images Minification: Production builds are minified and optimized Tree shaking: Unused code elimination in production Font optimization: Efficient font loading strategies Accessibility Semantic HTML structure ARIA labels for interactive elements Keyboard navigation support Focus management in forms Screen reader considerations Proper alt text for images Conclusion and final thoughts Building the ISC Chile frontend from a Figma design was an excellent opportunity to:\nMaster Vue 2: Working with Options API, Vuex state management, and Vue 2 patterns Implement GSAP animations: Creating professional scroll-triggered animations Build complex forms: Multi-step forms with validation, date pickers, and input masking Create advanced filtering: Blog filtering with search and category selection Optimize performance: Implementing efficient animations and lazy loading Ensure design fidelity: Translating Figma designs into pixel-perfect implementations (with direct Figma references in code) The project demonstrates proficiency in:\nModern JavaScript frameworks (Vue 2) Animation libraries (GSAP, ScrollTrigger) Form validation and user experience (Vee-Validate, V-Mask, V-Calendar) Build tools and asset compilation (Laravel Mix, Webpack) CSS architecture and methodologies (SCSS, BEM) Component-based development State management (Vuex) Design system implementation The integration with WordPress/Themosis backend required careful consideration of server-side rendering, API endpoints, and content management workflows, making this a full-stack frontend implementation for an educational consultancy platform.\nLive website: https://www.iscchile.cl/\nFigma prototype: https://www.figma.com/proto/BfdKGJlzx7xAnE7rpZ1vda/Dise%C3%B1o-ISC?page-id=314%3A12071\u0026type=design\u0026node-id=314-12072\u0026viewport=-1452%2C930%2C0.29\u0026t=hFYiwcionjRAZ47v-1\u0026scaling=min-zoom\n","image":"//localhost:1313/images/project/isc-chile/home.png","permalink":"//localhost:1313/projects/isc-chile-educational-consultancy-website/","tags":["Vue 2","Laravel Mix","WordPress","Themosis","SCSS","GSAP","JavaScript","Figma"],"title":"ISC Chile: Educational Consultancy Website"},{"categories":["Projects"],"contents":"Chile Nativo is a travel tour website for Patagonia experiences, built on top of WordPress with the Themosis framework, featuring a modern frontend implementation based on a Figma design using Vue 3, Laravel Mix, and a comprehensive SCSS architecture.\nOutline The project Design implementation The stack Frontend architecture Key features Conclusion Live website The project Chile Nativo is a travel company specializing in Patagonia tours, offering experiences in destinations like Torres del Paine, Tierra del Fuego, and Isla Navarino. The website serves as the primary platform for showcasing tours, managing bookings, and providing information about their travel experiences.\nThe frontend development was based on a comprehensive Figma design, requiring pixel-perfect implementation of complex UI components, interactive forms, filtering systems, and responsive layouts that work seamlessly across all devices.\nDesign implementation The entire frontend was built from a detailed Figma design, ensuring:\nPixel-perfect accuracy: Matching the design specifications precisely Responsive design: Implementing breakpoints and mobile-first approach Component consistency: Maintaining design system patterns throughout Interactive elements: Translating static designs into dynamic, interactive components Animation and transitions: Implementing smooth user experience enhancements The stack The frontend stack consists of:\nVue 3.2.4: Modern reactive framework for building interactive components Laravel Mix 6.0: Asset compilation and bundling SCSS: Advanced styling with a well-organized architecture Pinia 2.3.1: State management for Vue applications Vee-Validate 4.15.0: Form validation with Yup schemas Axios 1.6.8: HTTP client for API requests Splide.js 4.1.4: Modern carousel and slider components Headroom.js: Header behavior on scroll Plyr 3.7.8: Video player implementation SweetAlert2: Modern alert dialogs jQuery 3.7.1: Legacy support and DOM manipulation utilities Frontend architecture Vue components The application features a comprehensive set of Vue 3 components organized by functionality:\nFiltering and Search Components:\nToursFilter.vue: Advanced tour filtering with multiple criteria TourDatesFilter.vue: Date-based filtering for tour availability ToursFilterDropdown.vue \u0026amp; ToursFilterDropdownMobile.vue: Responsive filter dropdowns TestimonialsFilter.vue: Filtering system for customer testimonials NewsFilter.vue: Blog and news filtering SearchResults.vue: Search results display with pagination Form Components:\nPersonalizedTripForm.vue: Multi-step form for custom trip requests with validation ContactFormSimple.vue: Contact form with reCAPTCHA integration FormHelp.vue: Help center form FormGiftCard.vue: Gift card purchase form FormCareers.vue: Job application form NewsletterForm.vue: Newsletter subscription Card Components:\nTour.vue \u0026amp; TourLoading.vue: Tour card display with loading states TourDate.vue \u0026amp; TourDateLoading.vue: Tour date selection cards Testimonial.vue \u0026amp; TestimonialLoading.vue: Customer testimonial cards Blog.vue \u0026amp; BlogLoading.vue: Blog post cards Team.vue \u0026amp; TeamLoading.vue: Team member cards ResourceCard.vue \u0026amp; ResourceLoading.vue: Resource display cards Utility Components:\nPagination.vue: Reusable pagination component Select.vue: Custom select dropdown with search Loader.vue \u0026amp; LoaderFullScreen.vue: Loading indicators EmptyState.vue: Empty state displays ContentResources.vue: Resource content management TeamTabsFilter.vue: Tabbed team member filtering SCSS architecture The styling follows a well-organized SCSS architecture:\nscss/ ├── abstracts/ # Variables, mixins, functions │ ├── _functions.scss │ ├── _mixins.scss │ ├── _variables.scss │ ├── _mq.scss # Media query mixins │ └── _keyframes.scss ├── base/ # Base styles and typography │ ├── _typography.scss │ ├── _colors.scss │ ├── _fonts.scss │ └── _reset.scss └── components/ # Component-specific styles └── [125 component files] Key SCSS features:\nBEM methodology: Consistent naming convention throughout Media query mixins: Using sass-mq for responsive design Modular architecture: Each component has its own SCSS file Abstract layer: Reusable variables, mixins, and functions Vue transitions: Custom transition styles for Vue components JavaScript architecture The JavaScript is organized into two main entry points:\nMain application (app.js):\nInitializes core application functionality Sets up jQuery plugins and utilities Handles legacy browser support Vue application (vue/main.js):\nConfigures Vue 3 app with Pinia for state management Registers global Vue components Sets up Vee-Validate configuration Integrates third-party Vue plugins (VueTelInput, etc.) Component utilities (app/components/):\nheader.js: Header behavior and navigation footer.js: Footer functionality splide.js: Carousel initialization slick.js: Legacy carousel support accordions.js: Accordion interactions tabs.js: Tab functionality scrollTrigger.js: Scroll-based animations video.js: Video player setup sticky-sidebar.js: Sticky sidebar behavior Key features Multi-step forms The PersonalizedTripForm.vue component implements a sophisticated multi-step form with:\nStep-by-step navigation with progress indicators Form validation using Vee-Validate and Yup schemas Dynamic form fields based on user selections Phone number input with international support (VueTelInput) reCAPTCHA integration for spam protection Loading states and error handling Advanced filtering system The tour filtering system (ToursFilter.vue) provides:\nMultiple filter criteria (destination, activity type, trip type, month) Real-time filtering with URL parameter synchronization Responsive design with mobile accordion interface Custom select components with search functionality Empty states and loading indicators Integration with WordPress backend via Axios Responsive design The entire website is fully responsive with:\nMobile-first approach Breakpoint management using sass-mq Touch-friendly interactions Optimized images and assets Performance optimizations for mobile devices Performance optimizations Code splitting: Laravel Mix extracts vendor libraries Asset versioning: Automatic cache busting Image optimization: Lazy loading and responsive images Minification: Production builds are minified and optimized Tree shaking: Unused code elimination in production Accessibility Semantic HTML structure ARIA labels where appropriate Keyboard navigation support Focus management in forms Screen reader considerations Development workflow The project uses Laravel Mix for asset compilation:\n// Development npm run dev // Compile assets npm run watch // Watch for changes npm run hot // Hot module replacement // Production npm run production // Optimized production build BrowserSync integration provides:\nLive reloading during development Synchronized browser testing Proxy configuration for WordPress development Conclusion and final thoughts Building the Chile Nativo frontend from a Figma design was an excellent opportunity to:\nMaster Vue 3: Working with the Composition API, reactive systems, and modern Vue patterns Implement complex forms: Multi-step forms with validation, international phone inputs, and reCAPTCHA Build scalable architecture: Organizing 40+ Vue components and 125+ SCSS files in a maintainable structure Optimize performance: Implementing code splitting, lazy loading, and production optimizations Ensure design fidelity: Translating Figma designs into pixel-perfect implementations Handle responsive design: Creating seamless experiences across all device sizes The project demonstrates proficiency in:\nModern JavaScript frameworks (Vue 3) Build tools and asset compilation (Laravel Mix, Webpack) CSS architecture and methodologies (SCSS, BEM) Form validation and user experience Component-based development Design system implementation The integration with WordPress/Themosis backend required careful consideration of server-side rendering, API endpoints, and content management workflows, making this a full-stack frontend implementation.\nLive website: https://chilenativo.travel/\nFigma prototype: https://www.figma.com/proto/ywHPhSP1UfYUAE8eWVQv4L/Dise%C3%B1o-Desktop---Chile-Nativo?node-id=289-3912\u0026m=dev\u0026scaling=min-zoom\u0026content-scaling=fixed\u0026page-id=289%3A3911\u0026starting-point-node-id=289%3A3912\n","image":"//localhost:1313/images/project/chile-nativo/home.png","permalink":"//localhost:1313/projects/chile-nativo-patagonia-travel-website/","tags":["Vue 3","Laravel Mix","WordPress","Themosis","SCSS","JavaScript","Figma"],"title":"Chile Nativo: Patagonia Travel Website"},{"categories":["Projects"],"contents":"Rutieri is a SaaS platform built with Strapi, React Native, Typescript and other technologies.\nOutline The idea Platform features The stack The API The frontend The mobile app Conclusion Landing Page The idea Before starting to write a single line of code, it is generally a good idea to think about the problem, it\u0026rsquo;s limitations and whether or not it has already been solved by someone else (AKA competitors).\nThe problem I was looking into had to do with the way in which public and private transportation companies manage their routes, drivers and users. This process is generally carried out on paper, e.g. not digital, hence this could be problematic in case of new drivers joining the organization or in case of restricting access to data to only specific users.\nAfter a little bit of research, I could only find one platform that provides a similiar solution but for their own company.\nPlatform features and user stories The following user stories illustrates the desired features the platform should have in order to solve the aforementioned problems.\nAs an administrator user, I want to: login in the admin panel. create an organization. create routes in the organization. invite drivers and users to the organization. manage requests to join the organization. assign routes to drivers in the organization. see in real time the drivers and users currently active in the map of the different routes. As a driver, I want to: login in the mobile app. join an organization by entering the code in the search bar. see my route on the map. become visible to passengers on the road. see the passengers waiting on the road. remove my visibility and finish my run. As a passenger, I want to: login in the mobile app. join an organization by entering the code in the search bar. see the different routes of my organization in the map. search for a destination and get the available routes that pass nearby. see the drivers currently active on the routes in real time. become visible to drivers of a route. The requirements The backend requires to handle user authentication, permissions, different data structures as content types and define relations between them. It\u0026rsquo;s also necessary to synchronise passengers and drivers and view them on a map real time in the administration panel as well as in the mobile app.\nThe administration panel is a web page that fetches data from the backend as well as from the real time data provider and it\u0026rsquo;s goal is to provide a way for administrators to manage their organization and users. We\u0026rsquo;re talking about a Single Page Application built in React.\nAs for the mobile application, there isn\u0026rsquo;t a better choice nowadays than React Native and it works just fine in this case.\nThe API Since all of the features involve authentication, permissions and roles, and because there is no need to reinvent the wheel, I chose to use Strapi to build the backend for it\u0026rsquo;s simplicity, ease of use and great developer experience, whereas for realtime data, I used Firebase.\nThe instance of Strapi and the Postgres database it requires was deployed in the cloud hosting platform https://fly.io.\nStrapi is good for managing users, content that\u0026rsquo;s typically updated and fetched via CRUD API, and relations between content types.\nThe platform needs the following content types:\nOrganizations to group routes, drivers and users Routes Two user roles: drivers and users (passengers) Below are some screenshots of the overview of these content types\nAs I said before, Strapi makes the creation of these content types and the relationships between them really straightforward.\nHowever, not everything related to the API can be provided by Strapi. Some realtime features need to be addressed with other solutions, such as geolocation data in real time for drivers and users to synchronise each other, maps and the ability to search for places. Such features were implemented using Firebase, Google Maps and Google Places.\nThe frontend The platform where users are able to login as administrators and manage their organizations and users is a single page web application built in React. Among the features of this project that I think stand out are:\nState managed by Context API Interface styled with Bootstrap React Router for pages Leaflet to display the map GeoFire library to synchronise geolocation data in real time with Firebase Use of localStorage to save user session Below are some sample screenshots of how this app looks like\nThe mobile application This one is by far the most complex part of this project.\nThe project was bootstraped with Infinitered\u0026rsquo;s Ignite, which provides a great boilerplate and surely saved me of what would have been between 1-2 months of work.\nIgnite\u0026rsquo;s boilerplate includes many features out of the box, including:\nReact Native and Typescript (of course) React Navigation MobX-State-Tree for state management Expo SDK for developer experience AsyncStorage for persistence apisauce as REST client And some other libraries and features that make React Native apps super powerful and a joy to work on.\nIt consists of three screens:\nWelcome screen Login screen Map screen In the welcome screen, users are able to go to the login screen if not logged in. Otherwise, if they\u0026rsquo;re in an organisation, it shows their role and org\u0026rsquo;s information, and if they\u0026rsquo;re not, they are able to enter the organisation code and request to join as driver or as passenger.\nWelcome screens Login screens If the user is a driver in an organisation, the welcome screen also shows the route assigned to them. By tapping on it, it takes them to the map, where they can see themselves and start the tour, becoming visible to passengers on the road but being able to see passengers on the road as well.\nDrivers can finish the tour at any time by pressing the button stop.\nIf the user is a passenger in an organisation, the welcome screen shows the different routes available in the organisation. By tapping on them, they are taken to the map where they can see themselves, the route and the drivers on the road.\nPassengers are able to navigate between the available routes and search for the location they want to go to by using the search bar at the top of the map screen, filtering out the routes that pass nearby (less than 200 meters), if there are. Google Places API and turf library work together in this search process.\nPassengers become visible to drivers on the road by pressing the button wait and if they press the button again, they stop waiting and are removed from the driver\u0026rsquo;s map.\nMap screens The start/wait and finish buttons dispatch actions that update their location in firebase, so that passengers are able to see the bus on the map as it moves in real time and viceversa.\nAs for the state management, the project consists of two models and three stores from Mobx-State-Tree library: User and Route models, user-status, route-store and root-store stores.\nUser model Located in /app/models/user/user.ts\nconst OrganizationModel = types.model({ name: types.string, code: types.string, id: types.identifierNumber, drivers: types.number, rutas: types.array(RouteModel) }) const UserModel = types .model(\u0026#34;User\u0026#34;) .props({ id: types.identifierNumber, username: types.string, email: types.string, token: types.string, role: types.union(types.literal(\u0026#34;passenger\u0026#34;), types.literal(\u0026#34;driver\u0026#34;)), ruta: types.maybeNull(RouteModel), organization: types.maybeNull(OrganizationModel), pending_request: types.maybeNull(OrganizationModel), }) Route model Located in /app/models/route/route.ts\nThis model follows the GeoJSON format for routes.\nconst RouteModel = types .model(\u0026#34;Ruta\u0026#34;) .props({ id: types.identifierNumber, name: types.string, latlong: types.maybeNull(types.model({ lat: types.number, longt: types.number })), coords: types.model({ type: FeatureTypes, features: types.array(types.model({ type: types.string, geometry: types.model({ type: types.string, coordinates: types.union(types.array(types.number), types.array(types.array(types.number))) }), properties: types.model({ name: types.string }) })) }) }) user-status store Located in /app/models/user-status/user-status.ts\nThis store is responsible for managing the state of the user. It stores the user once it\u0026rsquo;s logged in and removes it when the user logs out. It also has some views to get the user key for firebase purposes, get the role and get the route in case of a driver.\nThis store has some methods that get the user location from the device\u0026rsquo;s GPS, displays the user icon on the map and sends it to firebase.\nconst UserStatusModel = types .model(\u0026#34;UserStatus\u0026#34;) .extend(withEnvironment) .props({ user: types.maybeNull(UserModel), location: types.maybeNull( types.model({latitude: types.number, longitude: types.number}) ), visibility: types.maybeNull(types.number) }) route-store store Located in /app/models/route-store/route-store.ts\nThis store is responsible for managing the state of the available routes. It stores the routes, drivers and passengers on the different routes. It also has some view methods to filter the routes that pass nearby a destination specified by the user, get passengers waiting on a given route and get drivers active in a specific route.\nThis store initializes a GeoQuery from Geofire library and listens for events to set, update and remove drivers and passengers from the map as they move.\nconst RouteStoreModel = types .model(\u0026#34;RouteStore\u0026#34;) .props({ routes: types.array(RouteModel), passengers: types.map(types.model({ key: types.identifier, location: types.array(types.number) })), drivers: types.map(types.model({ key: types.identifier, location: types.array(types.number) })), destinationAddress: types.maybeNull(types.model({ name: types.string, coords: types.array(types.number) })) }) Conclusion and final thoughts Using a CMS as the backend can make the development a lot faster than building the API from scratch and with Strapi this is specially true. On the other hand, Strapi doesn\u0026rsquo;t really make a good fit for real time applications, therefore, Firebase is the way to go in this case.\nAs of the client side, React always works very good for pretty much any kind of application, and because React Native uses React under the hood, it is so convenient for us React developers and ir works pretty good for almost any kind of application as well.\nHowever, one thing that I didn\u0026rsquo;t mention in this post was the use of Typescript; I find this quote by Brice Wilson pretty good to point out the whole purpose and motivation to learn and use (well) this powerful language and tool ecosystem:\n\u0026ldquo;You won\u0026rsquo;t have to wait for a frustrated user to report the error. All of this means that you provide value to your users faster, and that\u0026rsquo;s really what it\u0026rsquo;s all about.\u0026rdquo;\nAll in all, I got a lot of learning by building this project, both in languages/frameworks used and production stuff such as infrastructure, cloud hosting and cloud-based APIs.\nProject landing page: https://rutieri.netlify.app\n","image":"//localhost:1313/images/project/rutieri/landing/homepage.webp","permalink":"//localhost:1313/projects/saas-platform-rutieri/","tags":["Strapi","React Native","React","Typescript","Firebase"],"title":"SaaS platform: Rutieri"},{"categories":["Tutorial"],"contents":"Enable comments in a Strapi application and display them in the frontend with React\nOutline Introduction Prerequisites What is Strapi Comment Manager? Installation Configuration Display comments on the frontend Installation of Strapi Comments Client Usage of Strapi Comments Client Plugin settings Manage comments Full source code of the frontend Conclusion Introduction A comment system comes in very handy for pretty much any kind of website. In the JAMstack ecosystem, while it\u0026rsquo;s ok to rely on third party solutions hosted on their own platform such as Disqus to enable comments, you usually want to keep your content and all the stuff related to it in the same admin dashboard.\nIn this article, I\u0026rsquo;ll show you how to enable and manage comments for your content very easily using the Comment Manager plugin, and display them in your frontend application.\nPrerequisites You should have a basic understanding of the following.\nBasic knowledge of JavaScript Basic knowledge of React (OPTIONAL) Basic understanding of Strapi - get started here. Your Strapi V4 project setup What is Strapi Comment Manager? Strapi Comment Manager is a plugin that enables comments for pretty much any kind of content. It allows your users to post comments and anyone can get the comments associated with a given slug.\nWith this plugin, admin users can view and manage very easily all the comments from the Strapi administration dashboard. Within the dashboard, you will be able to delete comments and subcomments and leave replies on comments.\nInstallation Once into the Strapi project root, you can install the plugin by running the following command:\nnpm install strapi-plugin-comment-manager Next, build the project to see the new plugin in the dashboard with the following command:\nnpm run build And that\u0026rsquo;s it! If everything runs correctly, the plugin should now be installed.\nConfiguration Now you need to enable some permissions so that the frontend can access the endpoints to post and fetch comments.\nIn your Strapi admin dashboard, head over to Settings, then over to Roles under Users \u0026amp; Permissions Plugin.\nLet\u0026rsquo;s first setup the Public API; click on Public and hit the dropdown button of Comment Manager. Now check count, find and getPageSize, then hit the Save button. Below is a screenshot of a proper configuration:\nNow let\u0026rsquo;s setup the Authenticated API. Go back to Roles and click on Authenticated. Open the dropdown for Comment Manager and mark as checked the option create on both Comment and Subcomment. Below is a screenshot of a proper configuration:\nWith this configuration, the frontend should now be able to make requests to get and post comments.\nDisplay comments on the frontend The plugin exposes an API to get and post comments if you want to have fine-grained control over the workflow of your comments system and you can check the documentation on the package page, but this plugin also comes with a purpose-built React component library that makes it super easy to get up and running without getting your hands dirty.\nThis components library is called strapi-comments-client, fully supports typescript and it handles for you all of the complexity of fetching and posting comments and subcomments for every content ID that you pass to it.\nInstallation of Strapi Comments Client You will need to have installed react ^17.0.2, react-dom ^17.0.2 and react-router-dom ^5.2.0.\nInside of your React project, run this command:\nnpm install strapi-comments-client --save Usage of Strapi Comments Client Using this library is very easy!\nThis library exports three main components:\nCommentsProvider Comments CommentForm And you can import them this way:\nimport { CommentsProvider, Comments, CommentForm } from \u0026#34;strapi-comments-client\u0026#34; All you have to do is wrap your App component into the CommentsProvider component. Then you will be able to place anywhere in your app the Comments component to render a list of comments for a given content ID and the CommentForm component to render a form to post comments.\nFor example, this could be your index.js or main.js file:\nimport React from \u0026#39;react\u0026#39; import ReactDOM from \u0026#39;react-dom\u0026#39; // The address of your strapi backend instance const STRAPI = \u0026#34;http://localhost:1337\u0026#34; ReactDOM.render( \u0026lt;React.StrictMode\u0026gt; \u0026lt;CommentsProvider apiURL={STRAPI}\u0026gt; \u0026lt;App /\u0026gt; \u0026lt;/CommentsProvider\u0026gt; \u0026lt;/React.StrictMode\u0026gt;, document.getElementById(\u0026#39;root\u0026#39;) ) Where apiURL is the URL of your running Strapi application, and this property is required.\nThis way, the comments provider will do all the magic of fetching and posting comments for you!\nThis library also exports an utility React.Context to update some of the parameters for fetching and posting comments:\nimport { CommentsConfigContext } from \u0026#34;strapi-comments-client\u0026#34; This CommentsConfigContext exposes two setter functions: setUser and setContentID\nWith setContentID you can load the comments for a given content and post comments to it. It receives a single parameter of type string and must be URLized, i.e. no spaces.\nWith setUser you can set the credentials of a given user to authorize the posting of comments. It receives a single parameter of type IUser, with the following Typescript interface:\ninterface IUser { username: string, email: string, id: string, token: string // This is a JWT } It\u0026rsquo;s a little confusing but we\u0026rsquo;ll see how to use it in a component:\nconst App = () =\u0026gt; { const { setUser, setContentID } = useContext(CommentsConfigContext) // The following data should come from Strapi Users and Permissions Plugin // for authenticated requests const user = { username: \u0026#34;John Doe\u0026#34;, email: \u0026#34;jhohndoe@gmail.com\u0026#34;, id: 5, token: \u0026#34;this_should_be_a_JWT\u0026#34; } if (user) { setUser(user) } setContentID(\u0026#34;sample-content-1\u0026#34;) // Load comments for this content return ( \u0026lt;\u0026gt; { !user \u0026amp;\u0026amp; \u0026lt;Login /\u0026gt; } \u0026lt;CommentForm /\u0026gt; \u0026lt;Comments /\u0026gt; \u0026lt;/\u0026gt; ) } And that\u0026rsquo;s it!\nAfter setting the content ID through setContentID, CommentsProvider will start loading the comments for the given content ID and the CommentForm will render an input to post comments related to the given content ID if there is a user. Otherwise, it will display the message Login to post a comment.\nHere\u0026rsquo;s how the interface looks like so far:\nThere\u0026rsquo;s also a button to Leave a reply, which will open a form to post a subcomment associated with the parent comment.\nThis library exports one more component: ErrorBox\nimport { ErrorBox } from \u0026#34;strapi-comments-client\u0026#34; .It\u0026rsquo;s useful if you\u0026rsquo;d like to display error messages when things go wrong fetching or posting comments.\nYou can place this component wherever you want, for example in between the CommentForm and the Comments components.\nIf you\u0026rsquo;re wondering how this error box looks like, here you have a sample:\nGeneral settings You can customize the page size, i.e. specify how many comments are returned at once.\nIn the Strapi admin panel, head over to Settings, then select Pagination under Comment Manager Plugin.\nHere you\u0026rsquo;ll find an input to set the page size, which defaults to 10.\nManage comments Once you\u0026rsquo;ve got the plugin up an running, as users start to post comments, you can manage and reply to them as admin from the Comment Manager section of the left sidebar in the Strapi admin dashboard.\nHere you can see two tabs: one for the latest comments and one for comments grouped by content ID.\nIn both of them you can delete comments and subcomments as well as leave replies.\nExample project You can find a full working example of a React App using the Strapi Comments Client Library in this repo\nConclusion With this plugin you can enable and manage comments for any content with little effort and even use a component library to display the comments in your frontend application made with React.\nAnd that\u0026rsquo;s it! The features are pretty basic at the moment but if there\u0026rsquo;s interest, I\u0026rsquo;m willing to work on more features as well as improve the UI/UX.\n","image":"//localhost:1313/images/post/strapilogo.jpg","permalink":"//localhost:1313/blogs/how-to-enable-and-manage-comments-in-your-strapi-application/","tags":["Strapi","Strapi tutorials"],"title":"How To Enable And Manage Comments In Your Strapi Application."},{"categories":["Documentation"],"contents":"Comment Manager is a Strapi plugin to allow your users to post comments.\nWith this plugin you can enable and manage comments for your content very easily!\nRequirements You should have installed an instance of Strapi v4.x.x\nInstallation Run the following command in your project root:\nnpm install strapi-plugin-comment-manager Configurarion For your frontend to have access to the API, enable the following permissions for Comment Manager from Users \u0026amp; Permissions Plugin on your project settings:\nFor public, enable: count, find and getPageSize.\nFor authenticated, enable create on both Comment and Subcomment.\nDisplay comments on the frontend Comments can be displayed in the frontend in two ways:\nUsing the React components library strapi-comments-client (recommended) Build your custom frontend using the API API There are some Typescript interfaces that will help to get an idea of the data structures.\nComments: interface IComment { id: string, from_admin: boolean, createdAt: string, content: string, author: IAuthor | null, subcomments?: ISubcomment[] } Subcomments: interface ISubcomment { id: string, from_admin: boolean, createdAt: string, content: string, author: IAuthor | null, } Authors: IAuthor { username: string, email: string, id: string } The following endpoints are exposed to fetch and post comments and subcomments:\nGet comments for a content ID Method: GET\nPath: /api/comment-manager/comments/:slug\nOptional query parameters: start, ignoreCount\nReturns:\n{ commentsCount?: Number, comments: IComment[] } The parameter start indicates how many comments to skip. This is for pagination purposes.\nThe parameter ignoreCount indicates whether or not to return the total number of comments associated with the given slug.\nGet the number of comments associated with a given content ID Method: GET\nPath: /api/comment-manager/comments/:slug/count\nReturns:\n{ count: Number } Post a comment Method: POST\nPath: /api/comment-manager/comments/:slug\nAuthentication: Bearer token\nPayload:\n{ content: string } Returns:\n{ id: Number } Post a subcomment Method: POST\nPath: /api/comment-manager/subcomments/:parent-id\nAuthentication: Bearer token\nPayload:\n{ content: string } Returns:\n{ id: Number } Get the page size Method: GET\nPath: /api/comment-manager/page-size\nReturns:\n{ pageSize: Number } General settings The plugin allows to set how many comments are returned per page by going to the Pagination section under Comment Manager Plugin on the Settings section.\nThe default page size is 10.\nManagement of comments Admin users are able to delete comments and subcomments as well as leave replies as admins from within the plugin page of the Strapi admin dashboard.\nThe plugin interface has two tabs: one for the latest comments and one for comments by content ID.\nRoadmap and future plans The plugin is pretty basic but it can be improved with more features and a better UI/UX. Collaborations and suggestions are very welcome.\n","image":"//localhost:1313/images/post/strapilogo.jpg","permalink":"//localhost:1313/blogs/strapi-plugin-comment-manager/","tags":["Strapi","Strapi plugins"],"title":"Strapi Plugin Comment Manager"},{"categories":["Projects"],"contents":"In this post I’m going to share my experience on building a SaaS using the headless CMS Strapi as the Backend, React Native and other technologies.\nOutline Introduction What is SaaS? The problem What is Strapi? Developing features in Strapi The frontend: How to get content Conclusion Landing Page Introduction Very often, developers, product and project managers, testers and pretty much the entire team share their ideas to decide what language and which framework they\u0026rsquo;ll use to build their next project. Some considerations must be taken into account, from which in my opinion there are three that are the most important:\nDeveloper experience and ease of use Does the language and framework chosen provide a good developer experience? Is the langauge the same for the backend and frontend?\nDeadlines Is there a deadline to finish the project? if so, there is a good chance to finish the project on time if the team chooses the language they have more experience in.\nMaintainability As there will be usually more than one person working on the same part at the same time, if everything is kept organised, the whole development process will be frictionless.\nWith that in mind, developers and project managers will have a better insight on which language/framework to use.\nOther aspects should also be considered such as what the data structure will look like.\nIn my case, as it is usual, the backend of my project needs a database for users and their roles among other entities and their relations and a dashboard to allow admins to manage the data, and I was lucky to find out Strapi, as it includes a lot of these features out of the box with one single line of command to get started.\nWhat is SaaS? SaaS stands for Software-as-a-Service and it just means that a software is provided as a service in the cloud and it gives a solution to a specific problem, for which the users are willing to pay either monthly or annual subscription.\nThe problem Before starting to write a single line of code, it is generally a good idea to think about the problem, it\u0026rsquo;s limitations and whether or not it has already been solved by someone else (AKA competitors).\nThe problem I was looking into had to do with the way in which public and private transportation companies manage their routes, drivers and users. After a little bit of research, I could only find one platform that provides a similiar solution but for their own company.\nSo the platform I built needed the following content types:\nOrganizations to group routes, drivers and users Routes Two user roles: drivers and users (passengers) As I said before, Strapi makes the creation of these content types and the relationships between them really easy, but let\u0026rsquo;s first see what is Strapi and how it turns the API development into a satisfactory and fun experience.\nWhat is Strapi? Strapi is an open source headless CMS that allows developers to build complete RESTful APIs in just a couple of days instead of months. It includes a lot of useful features as plugins out of the box. Users and Roles management, Media library and an interface to create, view, edit and delete content are just some of them.\nRegarding the API, how does it makes the development faster?\nFirst of all, it enforces a specific folder structure, which helps to keep everything well organised and clean.\nSecondly, all database schemas are generated automatically and queries are made in JSON format, which really saves a lot of time.\nLastly, we can add more features to our Strapi application very easily via plugins from the marketplace.\nIt\u0026rsquo;s also worth noting that Strapi is a self-hosted CMS, which means that we can host it in whatever cloud platform we want, as well as test it locally in our computers before deploying it to the cloud.\nDeveloping features in Strapi Creating and configuring endpoints in Strapi is as straightforward as declaring a JSON in a single file:\nCreating controllers is straightforward as well:\nEvery controller gets all the data related to the request in the ctx parameter and it\u0026rsquo;s also used to send the response. This keeps everything in one place and really helps to improve the readability.\nOnce the API endpoints are defined, the next step is to enable the permissions for the specific user roles to have access to these endpoints:\nThe frontend: how to get content Since Strapi is a headless CMS, it\u0026rsquo;ll only provide content through the API. That means that the content can be consumed from anywhere. In our case, this content will be used in two applications: one for the organization owners and one for the users and drivers.\nThe application for the organization owners is a dashboard where administrators can create organizations, routes, accept drivers and users in the organization and assign routes to drivers. This is just a React Application:\nThe application for drivers and users is a mobile application built in React Native. Firebase was used to synchronise geolocation data in real time between drivers and users and display this information in a Map from Google Maps:\nConclusion Using a CMS as the backend can make the development a lot faster than building the API from scratch and with Strapi this is specially true. Furthermore, this becomes more important when building a brand-new product, as it\u0026rsquo;s usually recommended to launch as soon as possible to gather feedback from the users and validate the idea.\nProject landing page: https://rutieri.netlify.app\n","image":"//localhost:1313/images/post/03.webp","permalink":"//localhost:1313/blogs/how-i-built-a-saas-on-top-of-strapi-and-why-you-should-too/","tags":["Strapi","React Native","Typescript"],"title":"How I Built A SaaS On Top Of Strapi, And Why You Should Too"},{"categories":["Tutorial"],"contents":"Enable User Reviews in a Strapi application and display them in the frontend with React\nOutline Introduction Prerequisites What is Strapi Ratings? Installation Configuration Display user reviews on the frontend Plugin settings Manage user reviews Full source code of the frontend Conclusion Introduction Ratings systems have become a crucial part of any website with ecommerce capabilites, as they allow the users to post reviews on the items they purchase and publish their opinion to the public. A couple of reviews can make the difference between pressing the “Buy” button and moving on to the next website in the Google search results.\nIn this article, I\u0026rsquo;ll show you how to enable and manage user reviews for your content very easily using the Ratings plugin, and display them in your frontend application.\nPrerequisites First of all, you need to have a basic understanding of the following.\nBasic knowledge of JavaScript Basic knowledge of React (OPTIONAL) Basic understanding of Strapi - get started here. Your Strapi V4 project setup What is Strapi Ratings? Strapi Ratings is a plugin that gives your Strapi application the ability to manage ratings for pretty much any kind of content. It allows your users to post reviews and anyone can get the reviews associated with a given slug.\nWith this plugin, admin users can view and manage very easily all the reviews from the Strapi administration dashboard. Within the dashboard, you will be able to see reviews related to content slugs as well as delete reviews.\nInstallation Once into the Strapi project root, you can install the plugin by running the following command:\nnpm install strapi-plugin-ratings Next, build the project to see the new plugin in the dashboard with the following command:\nnpm run build And that\u0026rsquo;s it! If everything runs correctly, the plugin should now be installed.\nConfiguration Now you need to enable some permissions so that the frontend can access the endpoints to post and fetch reviews.\nIn your Strapi admin dashboard, head over to Settings, then over to Roles under Users \u0026amp; Permissions Plugin.\nLet\u0026rsquo;s first setup the Public API; click on Public and hit the dropdown button of Ratings. Now check count, find, getPageSize and getStats, then hit the Save button. Below is a screenshot of a proper configuration:\nNow let\u0026rsquo;s setup the Authenticated API. Go back to Roles and click on Authenticated. Open the dropdown for Ratings and mark as checked the options create, find and getUserReview. Below is a screenshot of a proper configuration:\nWith this configuration, the frontend should now be able to make requests to get and post user reviews.\nDisplay use reviews on the frontend The plugin exposes an API to get and post reviews if you want to have fine-grained control over the workflow of your ratings system and you can check the documentation on the package page, but this plugin also comes with a purpose-built React component library that makes it super easy to get up and running without getting your hands dirty.\nThis components library is called strapi-ratings-client, fully supports typescript and it takes care of all the complexity of fetching and posting user reviews for every content ID that you pass to it.\nInstallation of Strapi Ratings Client You will need to have installed react ^17.0.2, react-dom ^17.0.2, bootstrap ^5.1.3 and @popperjs/core^2.11.2\nInside of your React project, run this command:\nnpm install strapi-ratings-client --save Usage of Strapi Ratings Client Using this library is very easy!\nThis library exports three main components:\nReviewsProvider Reviews ReviewForm And you can import them this way:\nimport { ReviewsProvider, Reviews, ReviewForm } from \u0026#34;strapi-ratings-client\u0026#34; All you have to do is wrap your App component into the ReviewsProvider component. Then you will be able to place anywhere in your app the Reviews component to render a list of user reviews for a given content ID and the ReviewForm component to render a form to allow your users to post reviews.\nFor example, this could be your index.js or main.js file:\nimport React from \u0026#39;react\u0026#39; import ReactDOM from \u0026#39;react-dom\u0026#39; // The address of your strapi backend instance const STRAPI = \u0026#34;http://localhost:1337\u0026#34; ReactDOM.render( \u0026lt;React.StrictMode\u0026gt; \u0026lt;ReviewsProvider apiURL={STRAPI}\u0026gt; \u0026lt;App /\u0026gt; \u0026lt;/ReviewsProvider\u0026gt; \u0026lt;/React.StrictMode\u0026gt;, document.getElementById(\u0026#39;root\u0026#39;) ) Where apiURL is the URL of your running Strapi application, and this property is required.\nThis way, the ratings provider will do all the magic of fetching and posting comments for you!\nThis library also exports an utility React.Context to update some of the parameters for fetching and posting reviews:\nimport { ReviewsConfigContext } from \u0026#34;strapi-ratings-client\u0026#34; This ReviewsConfigContext exposes three setter functions: setUser, setContentID and setCanPostReview.\nWith setContentID you can load the ratings for a given content and post reviews to it. It receives a single parameter of type string and must be URLized, i.e. no spaces.\nWith setUser you can set the credentials of a given user to authorize the posting of reviews. It receives a single parameter of type IUser, with the following Typescript interface:\ninterface IUser { username: string, email: string, id: string, token: string // This is a JWT } With setCanPostReview, you can enable the user to post a review on the given content. This is useful for when you only allow a user to post a review after they purchase the product.\nIt\u0026rsquo;s a little confusing but we\u0026rsquo;ll see how to use it in a component:\nconst App = () =\u0026gt; { const { setUser, setContentID, setCanPostReview } = useContext(ReviewsConfigContext) // The following data should come from Strapi Users and Permissions Plugin // for authenticated requests. const user = { username: \u0026#34;John Doe\u0026#34;, email: \u0026#34;jhohndoe@gmail.com\u0026#34;, id: 5, token: \u0026#34;this_should_be_a_JWT\u0026#34; } if (user) { setUser(user) } setContentID(\u0026#34;sample-content-1\u0026#34;) // Load reviews for this content setCanPostReview(true) // Allow this user to post a review return ( \u0026lt;\u0026gt; { !user \u0026amp;\u0026amp; \u0026lt;Login /\u0026gt; } \u0026lt;ReviewForm /\u0026gt; \u0026lt;Reviews /\u0026gt; \u0026lt;/\u0026gt; ) } And that\u0026rsquo;s it!\nAfter setting the content ID through setContentID, ReviewsProvider will start loading the reviews for the given content ID and the ReviewForm will render an input to post a user review related to the given content ID if there is a user and he’s allowed to post a review. Otherwise, it will display the message Login to post a review or nothing at all if the user is not allowed to post a review.\nHere\u0026rsquo;s how the interface looks like so far:\nThis library exports one more component: ErrorBox\nimport { ErrorBox } from \u0026#34;strapi-ratings-client\u0026#34; .It\u0026rsquo;s useful for when you\u0026rsquo;d like to display error messages when things go wrong fetching or posting reviews.\nYou can place this component wherever you want, for example in between the ReviewForm and the Reviews components.\nIf you\u0026rsquo;re wondering how this error box looks like, here‘s a screenshot:\nGeneral settings You can customize the page size, i.e. specify how many user reviews are showed at once.\nIn the Strapi admin panel, head over to Settings, then select Pagination under Ratings Plugin.\nHere you\u0026rsquo;ll find an input to set the page size, which defaults to 10.\nManage reviews Once you\u0026rsquo;ve got the plugin up an running, as users start to post reviews, you can view them from within the Ratings section of the left sidebar in the Strapi admin dashboard.\nHere you can see two tabs: one for the latest reviews and one for reviews grouped by content ID.\nIn both of them you can delete unwanted reviews.\nExample project You can find a full working example of a React App using the Strapi Ratings Client Library in this repo: https://github.com/luisguve/strapi-ratings-client-example\nConclusion With this plugin you can enable and manage user reviews for any content with little effort and even use a library of components styled with Bootstrap to display the user reviews in your frontend.\nAnd that\u0026rsquo;s it! The features are pretty basic at the moment but if there\u0026rsquo;s interest, I\u0026rsquo;m willing to work on more features as well as improve the UI/UX.\n","image":"//localhost:1313/images/post/tutorial-ratings.webp","permalink":"//localhost:1313/blogs/how-to-enable-and-manage-user-reviews-in-your-strapi-application/","tags":["Strapi","Strapi tutorials"],"title":"How To Enable And Manage User Reviews In Your Strapi Application"},{"categories":["Documentation"],"contents":"Ratings is a Strapi plugin that allows your users to post reviews.\nEnable and manage user reviews for your content very easily!\nRequirements You should have installed an instance of Strapi v4.x.x\nInstallation Run the following command in your project root:\nnpm install strapi-plugin-ratings Then, rebuild the admin dashboard using the following command\nnpm run build Configurarion For your frontend to have access to the API, enable the following permissions for Ratings from Users \u0026amp; Permissions Plugin on your project settings:\nFor public, enable: count, find, getPageSize and getStats.\nFor authenticated, enable create, find and getUserReview.\nDisplay user reviews on the frontend Reviews can be displayed in the frontend in two ways:\nUsing the React components library strapi-ratings-client (recommended) Build your custom frontend using the API endpoints, described as follows: API There are some Typescript interfaces that will help to get an idea of the data structures.\nReviews: interface IReview { id: number, createdAt: string, comment: string | null, author: IAuthor | null, score: number, } Authors: interface IAuthor { username: string, email: string, id: number } Content Stats interface IStats { averageScore: number; reviewsCount: number | null; } The following endpoints are exposed to fetch and post reviews:\nGet reviews for a content ID Method: GET\nPath: /api/ratings/reviews/:slug\nOptional query parameters: start, ignoreCount\nReturns:\n{ reviewsCount: number, averageScore: number, userReview: IReview | null, reviews: IReview[] } The parameter start indicates how many reviews to skip. This is for pagination purposes.\nThe parameter ignoreCount indicates whether or not to return the total number of reviews associated with the given slug.\nGet review stats for a content ID Method: GET\nPath: /api/ratings/reviews/:slug/stats\nReturns:\n{ averageScore: number, reviewsCount: number | null } Get the number of reviews associated with a given content ID Method: GET\nPath: /api/ratings/reviews/:slug/count\nReturns:\n{ count: number } Post a review Method: POST\nPath: /api/ratings/reviews/:slug\nAuthentication: Bearer token\nPayload:\n{ content: string } Returns:\n{ id: number } By default, every authenticated user can post reviews on any content.\nIn order to customize this behavior, e.g. allowing or disallowing a user from posting reviews, you must extend the service userCanPostReview from whithin register function in ./src/index.js. For example:\nstrapi.service(\u0026#34;plugin::ratings.review\u0026#34;).userCanPostReview = async (user, slug) =\u0026gt; { /* Here you will check whether or not the user is allowed to post a review on this content ID and return either true or false. */ return true } Notice that userCanPostReview will receive two parameters: the user from Users \u0026amp; Permissions Plugin, containing it\u0026rsquo;s id, username, confirmed, etc., and the slug, which is a string and refers to the content ID which the review is being posted on.\nIn case this function returns false, the response of the endpoint will be 403 (forbidden) with the text User cannot post a review on this content.\nGet the page size Method: GET\nPath: /api/ratings/page-size\nReturns:\n{ pageSize: number } General settings The plugin allows to set how many reviews are returned per page by going to the Pagination section under Ratings Plugin of the Settings section.\nThe default page size is 10.\nManagement of reviews Admin users are able to delete reviews from within the plugin page of the Strapi admin dashboard.\nThe plugin interface has two tabs: one for the latest reviews and one for reviews by content ID.\nRoadmap and future plans The plugin is pretty basic but it can be improved with more features and a better UI/UX. Collaborations and suggestions are very welcome.\n","image":"//localhost:1313/images/post/ratings.webp","permalink":"//localhost:1313/blogs/strapi-plugin-ratings/","tags":["Strapi","Strapi plugins"],"title":"Strapi Plugin Ratings"},{"categories":["Projects"],"contents":"ManyLMS is an e-learning platform built on top of Strapi, React Router 7, Typescript and other technologies.\nOutline The idea Platform features The stack The API The frontend Conclusion Landing Page The idea This project doesn\u0026rsquo;t necessarily bring a huge amount of innovation on the e-learning platforms that already exists, but it\u0026rsquo;s just another way of doing this type of application.\nThe main idea is to apply a JAMstack approach in this application, where the platform is a static website, and the backend is just an API that serves static content only once to build the website and just adds the dynamism that\u0026rsquo;s necessary to allow users to authenticate, create orders, confirm payments and take courses.\nIf we compare this approach to a WordPress website, we are taking out most of the overhead that implies rendering the pages everytime a user visits them. Despite that there are plugins for caching that may improve the performance, it\u0026rsquo;s still never going to be faster and more efficient than just static content served by a CDN. That\u0026rsquo;s why React Router 7 and Headless CMSs are so popular right now.\nPlatform features and user stories The following user stories illustrates the desired features the platform should have.\nAs an administrator, I want to: login in the admin panel. create categories. create courses. upload lectures. organise courses into categories. assign lectures to courses. As a student, I want to: login in the platform. view the available courses. add courses to the shopping cart. review the shopping cart. create an order. pay with credit card or paypal. view the courses i\u0026rsquo;ve purchased in my learning page. go to the course page from my learning page and watch the videos. mark lectures as seen. come back later and resume where I left. The requirements The backend requires to handle user authentication, permissions, different data structures as content types and define relationships between them. It also requires to allow uploading videos to some third party platform that supports streaming on demand.\nThe frontend is a web platform where users can register and login, view and buy courses, leave comments and reviews and take courses.\nThe API Since all of the features involve authentication, permissions and roles, and because there is no need to reinvent the wheel, I chose to use Strapi to build the backend for it\u0026rsquo;s simplicity, ease of use and great developer experience, whereas for streaming videos on demand, I chose to use Mux.com.\nThe instance of Strapi and the Postgres database it requires was deployed in the cloud hosting platform https://fly.io.\nStrapi is good for managing users, content that\u0026rsquo;s typically updated and fetched via CRUD API, and setting up relations between content types.\nThe platform needs the following content types:\nCategory to group courses Course Lecture Module to group lectures Order Student: has many courses Student-Course: stores a student\u0026rsquo;s current lecture of a course Video Strapi makes the creation of these content types and setting up relationships between them really straightforward.\nBelow are some screenshots of these content types and the relationships between them:\nThe frontend The platform where users are able to login, view, buy and view courses is a web application built with React Router 7. Among the features of this application are:\nState managed by Context API Interface styled with Bootstrap Play streaming videos with @mux/mux-player-react library Use of localStorage to save user session Below are some sample screenshots of how this app looks like\nConclusion and final thoughts While building this project, I learned:\nHow streaming on demand works and how to use a streaming provider How to statically build websites with React Router 7 and Strapi How to setup dynamic pages in React Router 7 How to process payments with Stripe and Paypal How to build custom plugins in Strapi How to publish packages to NPM Project source codes: https://github.com/luisguve/maestro-backend\nhttps://github.com/luisguve/new-lms-remix\n","image":"//localhost:1313/images/project/manylms/frontend/course_overview.png","permalink":"//localhost:1313/projects/e-learning-platform-maestro-lms/","tags":["Strapi","React","React Router 7","Typescript","Mux"],"title":"ManyLMS: E-Learning platform"},{"categories":["Projects"],"contents":"ETMday (Emprende tu Mente) is a large-scale entrepreneurship event website built on top of WordPress with the Themosis framework, featuring an interactive SVG map, real-time countdown timers, advanced search functionality, and comprehensive content management using Vue 3, Laravel Mix, and modern frontend technologies.\nOutline The project Key features The stack Frontend architecture Interactive components Conclusion Live website The project ETMday is Chile\u0026rsquo;s premier entrepreneurship event, bringing together thousands of entrepreneurs, startups, corporates, and strategic partners. The website serves as the central hub for event information, featuring speakers, activities, stands, program schedules, and an interactive event map.\nThe frontend development required implementing complex interactive features including an SVG-based interactive map with tooltips, real-time countdown timers, advanced filtering and search systems, and dynamic content displays that handle thousands of attendees and hundreds of activities.\nKey features The website includes several sophisticated features:\nInteractive SVG Map: Custom-built interactive map with clickable zones, tooltips, and dynamic content display Real-time Countdown: Event countdown timer with automatic updates and mobile optimization Advanced Search: Multi-category search across activities, speakers, stands, and content Dynamic Filtering: Complex filtering system with tabs, favorites, and downloadable resources Animated Statistics: Odometer animations for displaying event metrics Content Management: Comprehensive card components for activities, speakers, stands, and blog posts Form Handling: Multi-step forms with validation using Vee-Validate Lightbox Galleries: Image galleries with LightGallery integration Responsive Design: Fully responsive design optimized for all devices The stack The frontend stack consists of:\nVue 3.2.4: Modern reactive framework for building interactive components Laravel Mix 6.0: Asset compilation and bundling SCSS: Advanced styling with organized architecture Vee-Validate 4.15.0: Form validation with Yup schemas Axios 1.6.8: HTTP client for API requests Splide.js 4.1.4: Modern carousel and slider components LightGallery 2.8.3: Lightbox gallery functionality Odometer 0.4.8: Animated number counting Headroom.js: Header behavior on scroll jQuery 3.7.1: DOM manipulation and legacy support SweetAlert2: Modern alert dialogs GLightbox 3.3.1: Alternative lightbox solution Frontend architecture Vue components The application features a comprehensive set of Vue 3 components:\nCard Components:\ncards/activities.vue: Activity cards with favorites functionality cards/speakers.vue: Speaker cards with modal details cards/stands.vue: Stand/exhibitor cards cards/blog.vue: Blog post cards cards/shortcut.vue: Quick access shortcut cards Functional Components:\nSectionCards.vue: Main section component with tabs, filtering, and card display Search.vue: Advanced search component with multi-category results Form.vue: Dynamic form component with validation FormCalendar.vue: Calendar form component CustomFilter.vue: Reusable filter component CustomSelect.vue: Custom select dropdown Pagination.vue: Pagination component JavaScript components The application includes 17 specialized JavaScript components:\nInteractive Features:\ninteractiveMap.js: SVG map interaction with tooltips, zones, and dynamic content countdown.js: Real-time countdown timer with automatic updates odometer.js: Animated number counting with scroll triggers map.js: Map zone interactions and modal displays UI Components:\nheader.js: Header functionality and navigation headroom.js: Header hide/show on scroll accordion.js: Accordion interactions tabs.js: Tab functionality cards.js: Card interactions and modals siteModals.js: Modal management system UI.js: General UI utilities Media Components:\nvideo.js: Video player setup lightgallery.js: Lightbox gallery initialization splide.js: Carousel initialization slick.js: Legacy carousel support Utilities:\nscrollTrigger.js: Scroll-based animations imgToSvg.js: SVG image conversion utility SCSS architecture The styling follows a well-organized SCSS architecture:\nscss/ ├── abstracts/ # Variables, mixins, functions │ ├── _functions.scss │ ├── _mixins.scss │ ├── _variables.scss │ ├── _mq.scss # Media query mixins │ └── _keyframes.scss ├── base/ # Base styles and typography │ ├── _typography.scss │ ├── _container.scss │ └── _reset.scss └── components/ # Component-specific styles └── [52 component files] Key SCSS features:\nBEM methodology: Consistent naming convention Media query mixins: Using sass-mq for responsive design Modular architecture: Each component has its own SCSS file Component organization: 52 component-specific SCSS files Interactive components Interactive SVG Map The interactiveMap.js component implements a sophisticated SVG-based interactive map:\nFeatures:\nSVG Tooltips: Dynamically generated tooltips with text wrapping Zone Interactions: Clickable zones with modal displays Point Markers: Interactive points with icons and labels Dynamic Content: Content loaded based on zone/point selection Responsive Design: Optimized for mobile and desktop Technical Implementation:\nSVG namespace manipulation for tooltip creation Text wrapping algorithm for tooltip content Path generation for tooltip shapes with rounded corners Event delegation for zone and point interactions Smooth animations and transitions Real-time Countdown The countdown.js component provides a real-time countdown timer:\nFeatures:\nAutomatic Updates: Updates every second Multi-unit Display: Days, hours, minutes, and seconds Pluralization: Proper Spanish pluralization (Día/Días, Hora/Horas) Mobile Optimization: Simplified display on mobile devices End State Handling: Automatic transition when countdown ends Advanced Search System The Search.vue component implements a comprehensive search system:\nFeatures:\nMulti-category Search: Searches across activities, speakers, stands, and other content Category Tabs: Quick navigation between result categories Result Counts: Dynamic result counts per category Scroll Navigation: Smooth scrolling to category sections Carousel Display: Splide carousels for result display Loading States: Loading indicators during search Empty States: User-friendly empty state messages Dynamic Filtering System The SectionCards.vue component provides advanced filtering:\nFeatures:\nTab Navigation: Multiple filter tabs Favorites System: Save and filter favorite items Search Integration: Inline search within filters Reset Functionality: Clear all filters with one click Downloadable Resources: Download buttons for resources URL Synchronization: Filter state in URL parameters Responsive Design: Mobile accordion interface Animated Statistics The odometer.js component provides animated number counting:\nFeatures:\nScroll-triggered: Animations trigger on scroll Prefix/Suffix Support: Handles formatted numbers (e.g., \u0026ldquo;56,000+\u0026rdquo;) Mobile Optimization: Static display on mobile Smooth Animations: Odometer theme integration Development workflow The project uses Laravel Mix for asset compilation:\n// Development npm run dev // Compile assets npm run watch // Watch for changes npm run hot // Hot module replacement // Production npm run production // Optimized production build BrowserSync integration provides:\nLive reloading during development Synchronized browser testing Proxy configuration for WordPress development Performance optimizations Code splitting: Laravel Mix extracts vendor libraries Asset versioning: Automatic cache busting Image optimization: Lazy loading and responsive images Minification: Production builds are minified and optimized Tree shaking: Unused code elimination in production SVG optimization: Efficient SVG manipulation and rendering Accessibility Semantic HTML structure ARIA labels for interactive elements Keyboard navigation support Focus management in forms and modals Screen reader considerations Proper alt text for images Conclusion and final thoughts Building the ETMday frontend was an excellent opportunity to:\nMaster SVG interactions: Creating complex interactive SVG maps with dynamic tooltips and zones Implement real-time features: Building countdown timers and live updates Build advanced search: Multi-category search with filtering and categorization Handle complex state: Managing filters, favorites, and dynamic content Optimize performance: Implementing efficient animations and lazy loading Ensure scalability: Building components that handle large datasets (thousands of attendees, hundreds of activities) The project demonstrates proficiency in:\nModern JavaScript frameworks (Vue 3) SVG manipulation and interaction Real-time UI updates Advanced filtering and search systems Build tools and asset compilation (Laravel Mix, Webpack) CSS architecture and methodologies (SCSS, BEM) Component-based development Event-driven architecture The integration with WordPress/Themosis backend required careful consideration of server-side rendering, API endpoints, and content management workflows, making this a full-stack frontend implementation for a large-scale event.\nLive website: https://etmday.org/\nFigma Prototype: https://www.figma.com/proto/mt9fJ8P03M5gf0nQwcU99q/EtM-Day-2025---Dise%C3%B1o?node-id=1-2743\u0026m=dev\u0026scaling=scale-down\u0026content-scaling=fixed\u0026page-id=0%3A1\u0026starting-point-node-id=1%3A2743\n","image":"//localhost:1313/images/project/etm/home.png","permalink":"//localhost:1313/projects/etmday-entrepreneurship-event-website/","tags":["Vue 3","Laravel Mix","WordPress","Themosis","SCSS","JavaScript","Interactive Map","SVG"],"title":"ETMday: Entrepreneurship Event Website"},{"categories":["Projects"],"contents":"JAC Autos Chile is a comprehensive automotive website built on top of WordPress with the Themosis framework, featuring car model comparisons, multi-step quote forms, fleet management, branch listings, and advanced filtering systems using Vue 3, Pinia state management, Laravel Mix, and modern frontend technologies.\nOutline The project Key features The stack Frontend architecture Interactive components Conclusion Live website The project JAC Autos Chile is the official website for JAC Motors in Chile, showcasing SUVs, pickups, commercial vehicles, and electric vehicles. The website serves as the primary platform for vehicle exploration, quoting, dealership location, fleet management, and post-sale services.\nThe frontend development required implementing complex interactive features including car model comparisons, multi-step quote forms with model and version selection, advanced filtering systems, fleet management interfaces, and comprehensive content management.\nKey features The website includes several sophisticated features:\nCar Model Comparator: Side-by-side comparison of multiple vehicle models with difference highlighting Multi-step Quote Form: Comprehensive quote form with model selection, version selection, and customer information Advanced Filtering: Multi-criteria filtering for car models, branches, fleet vehicles, and blog posts Fleet Management: Dedicated fleet vehicle selection and management interface Branch Locator: Filterable dealership/branch listings with location information Blog System: Complete blog with filtering, search, and content management Manuals Listing: User manual and documentation management Search Functionality: Site-wide search with categorized results Sticky Navigation: Section-based sticky navigation for long pages 360° View: Interactive 360-degree vehicle viewing The stack The frontend stack consists of:\nVue 3.2.4: Modern reactive framework with Composition API Pinia 2.2.6: State management for Vue applications Laravel Mix 6.0: Asset compilation and bundling SCSS: Advanced styling with organized architecture Vee-Validate 4.14.6: Form validation with Yup schemas Axios 1.6.8: HTTP client for API requests Splide.js 4.1.4: Modern carousel and slider components @splidejs/vue-splide 0.6.12: Vue 3 wrapper for Splide Maska 3.0.3: Input masking for formatted inputs Vue-Select 4.0.0-beta.6: Custom select component Vue-Recaptcha 2.0.3: reCAPTCHA integration Headroom.js: Header behavior on scroll jQuery 3.7.1: DOM manipulation and legacy support SweetAlert2: Modern alert dialogs @fdograph/rut-utilities: Chilean RUT validation utilities Frontend architecture Vue components The application features a comprehensive set of Vue 3 components (40+ components):\nCar Model Components:\nCar.vue: Car model card component with comparison functionality CarLoading.vue: Loading skeleton for car cards CarVersion.vue: Car version/trim level component CarVersionLoading.vue: Loading skeleton for version cards CarModelsListingStatic.vue: Static car models listing CarModelsListingQuote.vue: Car models listing for quote flow CarVersionsListingQuote.vue: Versions listing for quote flow CarQuote.vue: Car quote display component CarQuoteLoading.vue: Loading skeleton for quote cards Comparison Components:\nComparator.vue: Main car comparison component with Splide integration ComparatorModal.vue: Modal version of comparator CardCompareModel.vue: Comparison card for individual models CardCompareModelLoading.vue: Loading skeleton for comparison cards Quote Components:\nQuote.vue: Main quote component with multi-step flow QuoteForm.vue: Comprehensive quote form with validation Filtering Components:\nFilters.vue: General filtering component FleetFilter.vue: Fleet-specific filtering BranchesFilter.vue: Branch/dealership filtering BlogFilter.vue: Blog post filtering AjaxListWithFilter.vue: AJAX-powered list with filtering Content Components:\nBlog.vue: Blog post card component BlogLoading.vue: Loading skeleton for blog cards Fleet.vue: Fleet vehicle card component Branch.vue: Branch/dealership card component BranchLoading.vue: Loading skeleton for branch cards Manual.vue: Manual/documentation card component ManualLoading.vue: Loading skeleton for manual cards ManualsListing.vue: Manuals listing component Form Components:\nContactForm.vue: Contact form with validation Select.vue: Custom select dropdown component UI Components:\nPagination.vue: Pagination component StickySectionSelector.vue: Sticky navigation for sections EmptyState.vue: Empty state displays Loader.vue: Loading indicator ErrorBoundary.vue: Error boundary component SearchResults.vue: Search results display SearchResultCard.vue \u0026amp; SearchResultCardLoading.vue: Search result cards Service Components:\nCardMaintenance.vue: Maintenance service card CardMaintenanceLoading.vue: Loading skeleton for maintenance cards JavaScript components The application includes 12 specialized JavaScript components:\nUI Components:\nheader.js: Header functionality and navigation headroom.js: Header hide/show on scroll megamenu.js: Mega menu functionality search-modal.js: Search modal functionality scrollUpBottom.js: Scroll to top/bottom functionality social-share.js: Social media sharing Media Components:\nvideo.js: Video player setup splide.js: Carousel initialization slick.js: Legacy carousel support Interactive Components:\naccordion.js: Accordion interactions tabs.js: Tab functionality Utilities:\nimg-to-svg.js: SVG image conversion utility scrollTrigger.js: Scroll-based animations SCSS architecture The styling follows a well-organized SCSS architecture:\nscss/ ├── abstracts/ # Variables, mixins, functions │ ├── _mixins.scss │ ├── _mq.scss # Media query mixins │ └── _vendor.scss ├── base/ # Base styles and typography │ ├── _typography.scss │ ├── _colors.scss │ ├── _container.scss │ └── _globals.scss └── components/ # Component-specific styles ├── [87 component files] └── cards/ # Card component styles └── [20 card-specific files] Key SCSS features:\nBEM methodology: Consistent naming convention throughout Media query mixins: Using sass-mq for responsive design Modular architecture: 106 component-specific SCSS files Card organization: Dedicated card component styles Interactive components Car model comparator The Comparator.vue component provides sophisticated car model comparison:\nFeatures:\nSide-by-side comparison: Compare up to 3 models simultaneously Difference highlighting: Toggle to highlight differences between models Splide integration: Smooth carousel navigation for multiple models Dynamic data loading: Load comparison data via AJAX Responsive design: Optimized for mobile and desktop Modal version: Full-screen modal comparison view Technical Implementation:\nPinia store for comparison state management Splide Vue component for carousel functionality Dynamic component rendering based on selected models Efficient data structure for comparison attributes Multi-step quote form The Quote.vue and QuoteForm.vue components implement a comprehensive quote system:\nFeatures:\nStep-by-step flow: Model selection → Version selection → Customer information Form validation: Using Vee-Validate with Yup schemas RUT validation: Chilean RUT validation using custom directive Input masking: Phone numbers and formatted inputs with Maska reCAPTCHA integration: Spam protection Edit functionality: Ability to go back and edit previous steps Selected vehicle display: Visual representation of selected model/version Loading states: Visual feedback during form submission Form steps include:\nStep 1: Category and model selection Step 2: Version/trim level selection Step 3: Customer information and submission Advanced filtering systems Multiple filtering components provide comprehensive filtering:\nFleet Filter (FleetFilter.vue):\nFilter fleet vehicles by category, price range, and features Real-time filtering with URL parameter synchronization Mobile-optimized interface Branches Filter (BranchesFilter.vue):\nFilter dealerships by location, region, and services Map integration support Contact information display Blog Filter (BlogFilter.vue):\nFilter blog posts by category, date, and tags Search functionality Pagination support Ajax List with Filter (AjaxListWithFilter.vue):\nGeneric AJAX-powered list component Multiple filter criteria Loading states and empty states Sticky section selector The StickySectionSelector.vue component provides section-based navigation:\nFeatures:\nSticky positioning: Stays visible while scrolling Active section highlighting: Highlights current section Smooth scrolling: Smooth scroll to sections Responsive design: Mobile-optimized display State management with Pinia The application uses Pinia for centralized state management:\nStores:\nComparator Store: Manages comparison state, selected models, and comparison data Quote Store: Manages quote flow state, selected model/version, and form data Filter Stores: Manage filter states for different content types Benefits:\nCentralized state management Type-safe state access Efficient reactivity Easy debugging with Vue DevTools Custom directives The application includes custom Vue directives:\nRUT Directive (input-rut):\nChilean RUT (tax ID) validation and formatting Real-time validation as user types Format enforcement (XX.XXX.XXX-X) Development workflow The project uses Laravel Mix for asset compilation:\n// Development npm run dev // Compile assets npm run watch // Watch for changes npm run hot // Hot module replacement // Production npm run production // Optimized production build BrowserSync integration provides:\nLive reloading during development Synchronized browser testing Proxy configuration for WordPress development Performance optimizations Code splitting: Laravel Mix extracts vendor libraries Asset versioning: Automatic cache busting Image optimization: Lazy loading and responsive images Minification: Production builds are minified and optimized Tree shaking: Unused code elimination in production Component lazy loading: Load components on demand Skeleton loading: Better perceived performance with loading states Accessibility Semantic HTML structure ARIA labels for interactive elements Keyboard navigation support Focus management in forms and modals Screen reader considerations Proper alt text for images Color contrast compliance Conclusion and final thoughts Building the JAC Autos Chile frontend was an excellent opportunity to:\nMaster Vue 3: Working with Composition API, Pinia state management, and modern Vue patterns Build complex comparisons: Creating sophisticated car model comparison interfaces Implement multi-step forms: Complex quote forms with validation, RUT formatting, and step navigation Create advanced filtering: Multiple filtering systems for different content types Optimize performance: Implementing efficient state management, lazy loading, and code splitting Handle automotive data: Managing complex vehicle data structures and relationships The project demonstrates proficiency in:\nModern JavaScript frameworks (Vue 3) State management (Pinia) Form validation and user experience (Vee-Validate, Yup, Maska) Build tools and asset compilation (Laravel Mix, Webpack) CSS architecture and methodologies (SCSS, BEM) Component-based development Custom directives Carousel and slider implementations (Splide) AJAX-powered interfaces The integration with WordPress/Themosis backend required careful consideration of server-side rendering, API endpoints, and content management workflows, making this a full-stack frontend implementation for a comprehensive automotive platform.\nLive website: https://jacautoschile.cl/\n","image":"//localhost:1313/images/project/jac-autos/homepage.webp","permalink":"//localhost:1313/projects/jac-autos-chile-automotive-website/","tags":["Vue 3","Pinia","Laravel Mix","WordPress","Themosis","SCSS","JavaScript","Splide"],"title":"JAC Autos Chile: Automotive Website"},{"categories":["Projects"],"contents":"ISC Chile is an educational consultancy website for study abroad programs, built on top of WordPress with the Themosis framework, featuring GSAP animations, multi-step contact forms, advanced blog filtering, and comprehensive content management using Vue 2, Laravel Mix, and modern frontend technologies.\nOutline The project Design implementation The stack Frontend architecture Key features Conclusion Live website The project ISC Chile is an educational consultancy agency that has been providing study abroad advisory services since 1996. The website serves as the primary platform for showcasing various educational programs including English courses, school exchanges, group travel programs, and Pathways programs for university admission abroad.\nThe frontend development was based on a comprehensive Figma design, requiring pixel-perfect implementation of complex UI components, multi-step forms, animated statistics, and responsive layouts that work seamlessly across all devices.\nDesign implementation The entire frontend was built from a detailed Figma design, ensuring:\nPixel-perfect accuracy: Matching the design specifications precisely (as evidenced by Figma height references in SCSS) Responsive design: Implementing breakpoints and mobile-first approach Component consistency: Maintaining design system patterns throughout Interactive elements: Translating static designs into dynamic, interactive components Animation and transitions: Implementing smooth GSAP-powered animations The stack The frontend stack consists of:\nVue 2.6.12: Reactive framework for building interactive components Laravel Mix 6.0: Asset compilation and bundling SCSS: Advanced styling with a well-organized architecture Vuex 3.6.2: State management for Vue applications Vee-Validate 3.4.14: Form validation GSAP 3.12.5: Professional animation library with ScrollTrigger Axios 0.18: HTTP client for API requests Splide.js 4.1.4: Modern carousel and slider components Slick Carousel 1.8.1: Legacy carousel support LightGallery 2.7.2: Lightbox gallery functionality Odometer 0.4.8: Animated number counting Headroom.js: Header behavior on scroll V-Calendar 2.4.2: Calendar component for date selection V-Mask 2.3.0: Input masking Vue-Select 3.20.2: Custom select component jQuery 3.2: DOM manipulation and legacy support SweetAlert: Alert dialogs Frontend architecture Vue components The application features a comprehensive set of Vue 2 components:\nForm Components:\nContact.vue: Multi-step contact form with validation and reCAPTCHA ContactFormStep1.vue: First step of the contact form ContactFormStep2.vue: Second step of the contact form ContactFormStep3.vue: Third step of the contact form FormBanner.vue: Banner form component Content Components:\nBlog.vue: Blog listing with advanced filtering and search BlogArticleCard.vue \u0026amp; BlogArticleCardLoading.vue: Blog post cards with loading states ExperiencesPanel.vue: Testimonials and experiences display panel ExperiencesFiltersMobile.vue: Mobile filter component for experiences Search Components:\nSearchResults.vue: Search results display component SearchResultCardLoading.vue: Loading skeleton for search results UI Components:\nCheckboxDropdown.vue: Custom checkbox dropdown component CheckboxDropdownFieldset.vue: Fieldset wrapper for checkbox dropdowns EmptyState.vue: Empty state displays Loader.vue \u0026amp; Loading.vue: Loading indicators JavaScript components The application includes 15 specialized JavaScript components:\nAnimation Components:\ngsap.js: GSAP animations with ScrollTrigger for scroll-based reveals scrolltrigger.js: Custom scroll trigger utilities odometer.js: Animated number counting with scroll triggers UI Components:\nheader.js: Header functionality and navigation headroom.js: Header hide/show on scroll megamenu.js: Mega menu functionality mobileMenu.js: Mobile menu interactions searchbar.js: Search bar functionality floating-banner.js: Floating banner component footer.js: Footer functionality Media Components:\nvideo.js: Video player setup lightgallery.js: Lightbox gallery initialization splide.js: Carousel initialization slick.js: Legacy carousel support Interactive Components:\naccordion.js: Accordion interactions tabs.js: Tab functionality cards.js: Card interactions Utilities:\nimg-to-svg.js: SVG image conversion utility SCSS architecture The styling follows a well-organized SCSS architecture:\nscss/ ├── abstracts/ # Variables, mixins, functions │ ├── _mixins.scss │ ├── _mq.scss # Media query mixins │ └── _vendor.scss ├── base/ # Base styles and typography │ ├── _typography.scss │ ├── _colors.scss │ ├── _container.scss │ ├── _globals.scss │ └── fonts/ # Custom TWK Everett font family └── components/ # Component-specific styles └── [45 component files] Key SCSS features:\nBEM methodology: Consistent naming convention throughout Media query mixins: Using sass-mq for responsive design Modular architecture: Each component has its own SCSS file Custom typography: TWK Everett font family with multiple weights Figma references: Direct references to Figma design specifications Key features Multi-step contact form The Contact.vue component implements a sophisticated multi-step form with:\nThree-step navigation: Step-by-step form progression Form validation: Using Vee-Validate with comprehensive rules Date picker: V-Calendar integration for date selection Input masking: V-Mask for phone numbers and formatted inputs reCAPTCHA integration: Spam protection Dynamic fields: Fields that change based on user selections Loading states: Visual feedback during form submission Error handling: Comprehensive error messages and validation Form steps include:\nStep 1: Personal information and contact details Step 2: Educational background and program interests Step 3: Additional information and submission GSAP animations The gsap.js component provides professional animations:\nFeatures:\nScroll-triggered animations: Elements animate on scroll Vertical scroll reveals: Fade and slide animations Horizontal scroll reveals: Staggered animations for grid layouts Timeline management: Complex animation sequences Performance optimized: Efficient animation triggers Animation types:\nFade in with vertical movement Staggered grid animations Scroll-based reveals Smooth transitions Advanced blog system The Blog.vue component provides comprehensive blog functionality:\nFeatures:\nCategory filtering: Filter posts by category Search functionality: Real-time search across blog posts Mobile filters: Dedicated mobile filter interface Pagination: Efficient content pagination Loading states: Skeleton loading screens Empty states: User-friendly empty state messages Experiences/testimonials panel The ExperiencesPanel.vue component displays student testimonials:\nFeatures:\nFilter by type: Filter testimonials (Students/Parents) Dynamic loading: Load testimonials from API Responsive design: Mobile-optimized display Carousel integration: Splide carousel for testimonial display Animated statistics The odometer.js component provides animated number counting:\nFeatures:\nScroll-triggered: Animations trigger on scroll Smooth counting: Odometer theme integration Performance optimized: Efficient scroll detection Mobile support: Optimized for all devices Search functionality The SearchResults.vue component provides comprehensive search:\nFeatures:\nMulti-content search: Search across programs, blog posts, and pages Result categorization: Organized search results Image support: Results with and without images Tag display: Category tags for results Loading states: Skeleton loading screens Custom typography The website features a custom font family, TWK Everett, with:\nMultiple weights: From Hairline to Super Italic variants: All weights include italic versions Optimized formats: WOFF, WOFF2, and OTF formats Performance: Efficient font loading and rendering Development workflow The project uses Laravel Mix for asset compilation:\n// Development npm run dev // Compile assets npm run watch // Watch for changes npm run hot // Hot module replacement // Production npm run production // Optimized production build BrowserSync integration provides:\nLive reloading during development Synchronized browser testing Proxy configuration for WordPress development Performance optimizations Code splitting: Laravel Mix extracts vendor libraries Asset versioning: Automatic cache busting Image optimization: Lazy loading and responsive images Minification: Production builds are minified and optimized Tree shaking: Unused code elimination in production Font optimization: Efficient font loading strategies Accessibility Semantic HTML structure ARIA labels for interactive elements Keyboard navigation support Focus management in forms Screen reader considerations Proper alt text for images Conclusion and final thoughts Building the ISC Chile frontend from a Figma design was an excellent opportunity to:\nMaster Vue 2: Working with Options API, Vuex state management, and Vue 2 patterns Implement GSAP animations: Creating professional scroll-triggered animations Build complex forms: Multi-step forms with validation, date pickers, and input masking Create advanced filtering: Blog filtering with search and category selection Optimize performance: Implementing efficient animations and lazy loading Ensure design fidelity: Translating Figma designs into pixel-perfect implementations (with direct Figma references in code) The project demonstrates proficiency in:\nModern JavaScript frameworks (Vue 2) Animation libraries (GSAP, ScrollTrigger) Form validation and user experience (Vee-Validate, V-Mask, V-Calendar) Build tools and asset compilation (Laravel Mix, Webpack) CSS architecture and methodologies (SCSS, BEM) Component-based development State management (Vuex) Design system implementation The integration with WordPress/Themosis backend required careful consideration of server-side rendering, API endpoints, and content management workflows, making this a full-stack frontend implementation for an educational consultancy platform.\nLive website: https://www.iscchile.cl/\nFigma prototype: https://www.figma.com/proto/BfdKGJlzx7xAnE7rpZ1vda/Dise%C3%B1o-ISC?page-id=314%3A12071\u0026type=design\u0026node-id=314-12072\u0026viewport=-1452%2C930%2C0.29\u0026t=hFYiwcionjRAZ47v-1\u0026scaling=min-zoom\n","image":"//localhost:1313/images/project/isc-chile/home.png","permalink":"//localhost:1313/projects/isc-chile-educational-consultancy-website/","tags":["Vue 2","Laravel Mix","WordPress","Themosis","SCSS","GSAP","JavaScript","Figma"],"title":"ISC Chile: Educational Consultancy Website"},{"categories":["Projects"],"contents":"Chile Nativo is a travel tour website for Patagonia experiences, built on top of WordPress with the Themosis framework, featuring a modern frontend implementation based on a Figma design using Vue 3, Laravel Mix, and a comprehensive SCSS architecture.\nOutline The project Design implementation The stack Frontend architecture Key features Conclusion Live website The project Chile Nativo is a travel company specializing in Patagonia tours, offering experiences in destinations like Torres del Paine, Tierra del Fuego, and Isla Navarino. The website serves as the primary platform for showcasing tours, managing bookings, and providing information about their travel experiences.\nThe frontend development was based on a comprehensive Figma design, requiring pixel-perfect implementation of complex UI components, interactive forms, filtering systems, and responsive layouts that work seamlessly across all devices.\nDesign implementation The entire frontend was built from a detailed Figma design, ensuring:\nPixel-perfect accuracy: Matching the design specifications precisely Responsive design: Implementing breakpoints and mobile-first approach Component consistency: Maintaining design system patterns throughout Interactive elements: Translating static designs into dynamic, interactive components Animation and transitions: Implementing smooth user experience enhancements The stack The frontend stack consists of:\nVue 3.2.4: Modern reactive framework for building interactive components Laravel Mix 6.0: Asset compilation and bundling SCSS: Advanced styling with a well-organized architecture Pinia 2.3.1: State management for Vue applications Vee-Validate 4.15.0: Form validation with Yup schemas Axios 1.6.8: HTTP client for API requests Splide.js 4.1.4: Modern carousel and slider components Headroom.js: Header behavior on scroll Plyr 3.7.8: Video player implementation SweetAlert2: Modern alert dialogs jQuery 3.7.1: Legacy support and DOM manipulation utilities Frontend architecture Vue components The application features a comprehensive set of Vue 3 components organized by functionality:\nFiltering and Search Components:\nToursFilter.vue: Advanced tour filtering with multiple criteria TourDatesFilter.vue: Date-based filtering for tour availability ToursFilterDropdown.vue \u0026amp; ToursFilterDropdownMobile.vue: Responsive filter dropdowns TestimonialsFilter.vue: Filtering system for customer testimonials NewsFilter.vue: Blog and news filtering SearchResults.vue: Search results display with pagination Form Components:\nPersonalizedTripForm.vue: Multi-step form for custom trip requests with validation ContactFormSimple.vue: Contact form with reCAPTCHA integration FormHelp.vue: Help center form FormGiftCard.vue: Gift card purchase form FormCareers.vue: Job application form NewsletterForm.vue: Newsletter subscription Card Components:\nTour.vue \u0026amp; TourLoading.vue: Tour card display with loading states TourDate.vue \u0026amp; TourDateLoading.vue: Tour date selection cards Testimonial.vue \u0026amp; TestimonialLoading.vue: Customer testimonial cards Blog.vue \u0026amp; BlogLoading.vue: Blog post cards Team.vue \u0026amp; TeamLoading.vue: Team member cards ResourceCard.vue \u0026amp; ResourceLoading.vue: Resource display cards Utility Components:\nPagination.vue: Reusable pagination component Select.vue: Custom select dropdown with search Loader.vue \u0026amp; LoaderFullScreen.vue: Loading indicators EmptyState.vue: Empty state displays ContentResources.vue: Resource content management TeamTabsFilter.vue: Tabbed team member filtering SCSS architecture The styling follows a well-organized SCSS architecture:\nscss/ ├── abstracts/ # Variables, mixins, functions │ ├── _functions.scss │ ├── _mixins.scss │ ├── _variables.scss │ ├── _mq.scss # Media query mixins │ └── _keyframes.scss ├── base/ # Base styles and typography │ ├── _typography.scss │ ├── _colors.scss │ ├── _fonts.scss │ └── _reset.scss └── components/ # Component-specific styles └── [125 component files] Key SCSS features:\nBEM methodology: Consistent naming convention throughout Media query mixins: Using sass-mq for responsive design Modular architecture: Each component has its own SCSS file Abstract layer: Reusable variables, mixins, and functions Vue transitions: Custom transition styles for Vue components JavaScript architecture The JavaScript is organized into two main entry points:\nMain application (app.js):\nInitializes core application functionality Sets up jQuery plugins and utilities Handles legacy browser support Vue application (vue/main.js):\nConfigures Vue 3 app with Pinia for state management Registers global Vue components Sets up Vee-Validate configuration Integrates third-party Vue plugins (VueTelInput, etc.) Component utilities (app/components/):\nheader.js: Header behavior and navigation footer.js: Footer functionality splide.js: Carousel initialization slick.js: Legacy carousel support accordions.js: Accordion interactions tabs.js: Tab functionality scrollTrigger.js: Scroll-based animations video.js: Video player setup sticky-sidebar.js: Sticky sidebar behavior Key features Multi-step forms The PersonalizedTripForm.vue component implements a sophisticated multi-step form with:\nStep-by-step navigation with progress indicators Form validation using Vee-Validate and Yup schemas Dynamic form fields based on user selections Phone number input with international support (VueTelInput) reCAPTCHA integration for spam protection Loading states and error handling Advanced filtering system The tour filtering system (ToursFilter.vue) provides:\nMultiple filter criteria (destination, activity type, trip type, month) Real-time filtering with URL parameter synchronization Responsive design with mobile accordion interface Custom select components with search functionality Empty states and loading indicators Integration with WordPress backend via Axios Responsive design The entire website is fully responsive with:\nMobile-first approach Breakpoint management using sass-mq Touch-friendly interactions Optimized images and assets Performance optimizations for mobile devices Performance optimizations Code splitting: Laravel Mix extracts vendor libraries Asset versioning: Automatic cache busting Image optimization: Lazy loading and responsive images Minification: Production builds are minified and optimized Tree shaking: Unused code elimination in production Accessibility Semantic HTML structure ARIA labels where appropriate Keyboard navigation support Focus management in forms Screen reader considerations Development workflow The project uses Laravel Mix for asset compilation:\n// Development npm run dev // Compile assets npm run watch // Watch for changes npm run hot // Hot module replacement // Production npm run production // Optimized production build BrowserSync integration provides:\nLive reloading during development Synchronized browser testing Proxy configuration for WordPress development Conclusion and final thoughts Building the Chile Nativo frontend from a Figma design was an excellent opportunity to:\nMaster Vue 3: Working with the Composition API, reactive systems, and modern Vue patterns Implement complex forms: Multi-step forms with validation, international phone inputs, and reCAPTCHA Build scalable architecture: Organizing 40+ Vue components and 125+ SCSS files in a maintainable structure Optimize performance: Implementing code splitting, lazy loading, and production optimizations Ensure design fidelity: Translating Figma designs into pixel-perfect implementations Handle responsive design: Creating seamless experiences across all device sizes The project demonstrates proficiency in:\nModern JavaScript frameworks (Vue 3) Build tools and asset compilation (Laravel Mix, Webpack) CSS architecture and methodologies (SCSS, BEM) Form validation and user experience Component-based development Design system implementation The integration with WordPress/Themosis backend required careful consideration of server-side rendering, API endpoints, and content management workflows, making this a full-stack frontend implementation.\nLive website: https://chilenativo.travel/\nFigma prototype: https://www.figma.com/proto/ywHPhSP1UfYUAE8eWVQv4L/Dise%C3%B1o-Desktop---Chile-Nativo?node-id=289-3912\u0026m=dev\u0026scaling=min-zoom\u0026content-scaling=fixed\u0026page-id=289%3A3911\u0026starting-point-node-id=289%3A3912\n","image":"//localhost:1313/images/project/chile-nativo/home.png","permalink":"//localhost:1313/projects/chile-nativo-patagonia-travel-website/","tags":["Vue 3","Laravel Mix","WordPress","Themosis","SCSS","JavaScript","Figma"],"title":"Chile Nativo: Patagonia Travel Website"},{"categories":["Projects"],"contents":"Rutieri is a SaaS platform built with Strapi, React Native, Typescript and other technologies.\nOutline The idea Platform features The stack The API The frontend The mobile app Conclusion Landing Page The idea Before starting to write a single line of code, it is generally a good idea to think about the problem, it\u0026rsquo;s limitations and whether or not it has already been solved by someone else (AKA competitors).\nThe problem I was looking into had to do with the way in which public and private transportation companies manage their routes, drivers and users. This process is generally carried out on paper, e.g. not digital, hence this could be problematic in case of new drivers joining the organization or in case of restricting access to data to only specific users.\nAfter a little bit of research, I could only find one platform that provides a similiar solution but for their own company.\nPlatform features and user stories The following user stories illustrates the desired features the platform should have in order to solve the aforementioned problems.\nAs an administrator user, I want to: login in the admin panel. create an organization. create routes in the organization. invite drivers and users to the organization. manage requests to join the organization. assign routes to drivers in the organization. see in real time the drivers and users currently active in the map of the different routes. As a driver, I want to: login in the mobile app. join an organization by entering the code in the search bar. see my route on the map. become visible to passengers on the road. see the passengers waiting on the road. remove my visibility and finish my run. As a passenger, I want to: login in the mobile app. join an organization by entering the code in the search bar. see the different routes of my organization in the map. search for a destination and get the available routes that pass nearby. see the drivers currently active on the routes in real time. become visible to drivers of a route. The requirements The backend requires to handle user authentication, permissions, different data structures as content types and define relations between them. It\u0026rsquo;s also necessary to synchronise passengers and drivers and view them on a map real time in the administration panel as well as in the mobile app.\nThe administration panel is a web page that fetches data from the backend as well as from the real time data provider and it\u0026rsquo;s goal is to provide a way for administrators to manage their organization and users. We\u0026rsquo;re talking about a Single Page Application built in React.\nAs for the mobile application, there isn\u0026rsquo;t a better choice nowadays than React Native and it works just fine in this case.\nThe API Since all of the features involve authentication, permissions and roles, and because there is no need to reinvent the wheel, I chose to use Strapi to build the backend for it\u0026rsquo;s simplicity, ease of use and great developer experience, whereas for realtime data, I used Firebase.\nThe instance of Strapi and the Postgres database it requires was deployed in the cloud hosting platform https://fly.io.\nStrapi is good for managing users, content that\u0026rsquo;s typically updated and fetched via CRUD API, and relations between content types.\nThe platform needs the following content types:\nOrganizations to group routes, drivers and users Routes Two user roles: drivers and users (passengers) Below are some screenshots of the overview of these content types\nAs I said before, Strapi makes the creation of these content types and the relationships between them really straightforward.\nHowever, not everything related to the API can be provided by Strapi. Some realtime features need to be addressed with other solutions, such as geolocation data in real time for drivers and users to synchronise each other, maps and the ability to search for places. Such features were implemented using Firebase, Google Maps and Google Places.\nThe frontend The platform where users are able to login as administrators and manage their organizations and users is a single page web application built in React. Among the features of this project that I think stand out are:\nState managed by Context API Interface styled with Bootstrap React Router for pages Leaflet to display the map GeoFire library to synchronise geolocation data in real time with Firebase Use of localStorage to save user session Below are some sample screenshots of how this app looks like\nThe mobile application This one is by far the most complex part of this project.\nThe project was bootstraped with Infinitered\u0026rsquo;s Ignite, which provides a great boilerplate and surely saved me of what would have been between 1-2 months of work.\nIgnite\u0026rsquo;s boilerplate includes many features out of the box, including:\nReact Native and Typescript (of course) React Navigation MobX-State-Tree for state management Expo SDK for developer experience AsyncStorage for persistence apisauce as REST client And some other libraries and features that make React Native apps super powerful and a joy to work on.\nIt consists of three screens:\nWelcome screen Login screen Map screen In the welcome screen, users are able to go to the login screen if not logged in. Otherwise, if they\u0026rsquo;re in an organisation, it shows their role and org\u0026rsquo;s information, and if they\u0026rsquo;re not, they are able to enter the organisation code and request to join as driver or as passenger.\nWelcome screens Login screens If the user is a driver in an organisation, the welcome screen also shows the route assigned to them. By tapping on it, it takes them to the map, where they can see themselves and start the tour, becoming visible to passengers on the road but being able to see passengers on the road as well.\nDrivers can finish the tour at any time by pressing the button stop.\nIf the user is a passenger in an organisation, the welcome screen shows the different routes available in the organisation. By tapping on them, they are taken to the map where they can see themselves, the route and the drivers on the road.\nPassengers are able to navigate between the available routes and search for the location they want to go to by using the search bar at the top of the map screen, filtering out the routes that pass nearby (less than 200 meters), if there are. Google Places API and turf library work together in this search process.\nPassengers become visible to drivers on the road by pressing the button wait and if they press the button again, they stop waiting and are removed from the driver\u0026rsquo;s map.\nMap screens The start/wait and finish buttons dispatch actions that update their location in firebase, so that passengers are able to see the bus on the map as it moves in real time and viceversa.\nAs for the state management, the project consists of two models and three stores from Mobx-State-Tree library: User and Route models, user-status, route-store and root-store stores.\nUser model Located in /app/models/user/user.ts\nconst OrganizationModel = types.model({ name: types.string, code: types.string, id: types.identifierNumber, drivers: types.number, rutas: types.array(RouteModel) }) const UserModel = types .model(\u0026#34;User\u0026#34;) .props({ id: types.identifierNumber, username: types.string, email: types.string, token: types.string, role: types.union(types.literal(\u0026#34;passenger\u0026#34;), types.literal(\u0026#34;driver\u0026#34;)), ruta: types.maybeNull(RouteModel), organization: types.maybeNull(OrganizationModel), pending_request: types.maybeNull(OrganizationModel), }) Route model Located in /app/models/route/route.ts\nThis model follows the GeoJSON format for routes.\nconst RouteModel = types .model(\u0026#34;Ruta\u0026#34;) .props({ id: types.identifierNumber, name: types.string, latlong: types.maybeNull(types.model({ lat: types.number, longt: types.number })), coords: types.model({ type: FeatureTypes, features: types.array(types.model({ type: types.string, geometry: types.model({ type: types.string, coordinates: types.union(types.array(types.number), types.array(types.array(types.number))) }), properties: types.model({ name: types.string }) })) }) }) user-status store Located in /app/models/user-status/user-status.ts\nThis store is responsible for managing the state of the user. It stores the user once it\u0026rsquo;s logged in and removes it when the user logs out. It also has some views to get the user key for firebase purposes, get the role and get the route in case of a driver.\nThis store has some methods that get the user location from the device\u0026rsquo;s GPS, displays the user icon on the map and sends it to firebase.\nconst UserStatusModel = types .model(\u0026#34;UserStatus\u0026#34;) .extend(withEnvironment) .props({ user: types.maybeNull(UserModel), location: types.maybeNull( types.model({latitude: types.number, longitude: types.number}) ), visibility: types.maybeNull(types.number) }) route-store store Located in /app/models/route-store/route-store.ts\nThis store is responsible for managing the state of the available routes. It stores the routes, drivers and passengers on the different routes. It also has some view methods to filter the routes that pass nearby a destination specified by the user, get passengers waiting on a given route and get drivers active in a specific route.\nThis store initializes a GeoQuery from Geofire library and listens for events to set, update and remove drivers and passengers from the map as they move.\nconst RouteStoreModel = types .model(\u0026#34;RouteStore\u0026#34;) .props({ routes: types.array(RouteModel), passengers: types.map(types.model({ key: types.identifier, location: types.array(types.number) })), drivers: types.map(types.model({ key: types.identifier, location: types.array(types.number) })), destinationAddress: types.maybeNull(types.model({ name: types.string, coords: types.array(types.number) })) }) Conclusion and final thoughts Using a CMS as the backend can make the development a lot faster than building the API from scratch and with Strapi this is specially true. On the other hand, Strapi doesn\u0026rsquo;t really make a good fit for real time applications, therefore, Firebase is the way to go in this case.\nAs of the client side, React always works very good for pretty much any kind of application, and because React Native uses React under the hood, it is so convenient for us React developers and ir works pretty good for almost any kind of application as well.\nHowever, one thing that I didn\u0026rsquo;t mention in this post was the use of Typescript; I find this quote by Brice Wilson pretty good to point out the whole purpose and motivation to learn and use (well) this powerful language and tool ecosystem:\n\u0026ldquo;You won\u0026rsquo;t have to wait for a frustrated user to report the error. All of this means that you provide value to your users faster, and that\u0026rsquo;s really what it\u0026rsquo;s all about.\u0026rdquo;\nAll in all, I got a lot of learning by building this project, both in languages/frameworks used and production stuff such as infrastructure, cloud hosting and cloud-based APIs.\nProject landing page: https://rutieri.netlify.app\n","image":"//localhost:1313/images/project/rutieri/landing/homepage.webp","permalink":"//localhost:1313/projects/saas-platform-rutieri/","tags":["Strapi","React Native","React","Typescript","Firebase"],"title":"SaaS platform: Rutieri"},{"categories":["Tutorial"],"contents":"Enable comments in a Strapi application and display them in the frontend with React\nOutline Introduction Prerequisites What is Strapi Comment Manager? Installation Configuration Display comments on the frontend Installation of Strapi Comments Client Usage of Strapi Comments Client Plugin settings Manage comments Full source code of the frontend Conclusion Introduction A comment system comes in very handy for pretty much any kind of website. In the JAMstack ecosystem, while it\u0026rsquo;s ok to rely on third party solutions hosted on their own platform such as Disqus to enable comments, you usually want to keep your content and all the stuff related to it in the same admin dashboard.\nIn this article, I\u0026rsquo;ll show you how to enable and manage comments for your content very easily using the Comment Manager plugin, and display them in your frontend application.\nPrerequisites You should have a basic understanding of the following.\nBasic knowledge of JavaScript Basic knowledge of React (OPTIONAL) Basic understanding of Strapi - get started here. Your Strapi V4 project setup What is Strapi Comment Manager? Strapi Comment Manager is a plugin that enables comments for pretty much any kind of content. It allows your users to post comments and anyone can get the comments associated with a given slug.\nWith this plugin, admin users can view and manage very easily all the comments from the Strapi administration dashboard. Within the dashboard, you will be able to delete comments and subcomments and leave replies on comments.\nInstallation Once into the Strapi project root, you can install the plugin by running the following command:\nnpm install strapi-plugin-comment-manager Next, build the project to see the new plugin in the dashboard with the following command:\nnpm run build And that\u0026rsquo;s it! If everything runs correctly, the plugin should now be installed.\nConfiguration Now you need to enable some permissions so that the frontend can access the endpoints to post and fetch comments.\nIn your Strapi admin dashboard, head over to Settings, then over to Roles under Users \u0026amp; Permissions Plugin.\nLet\u0026rsquo;s first setup the Public API; click on Public and hit the dropdown button of Comment Manager. Now check count, find and getPageSize, then hit the Save button. Below is a screenshot of a proper configuration:\nNow let\u0026rsquo;s setup the Authenticated API. Go back to Roles and click on Authenticated. Open the dropdown for Comment Manager and mark as checked the option create on both Comment and Subcomment. Below is a screenshot of a proper configuration:\nWith this configuration, the frontend should now be able to make requests to get and post comments.\nDisplay comments on the frontend The plugin exposes an API to get and post comments if you want to have fine-grained control over the workflow of your comments system and you can check the documentation on the package page, but this plugin also comes with a purpose-built React component library that makes it super easy to get up and running without getting your hands dirty.\nThis components library is called strapi-comments-client, fully supports typescript and it handles for you all of the complexity of fetching and posting comments and subcomments for every content ID that you pass to it.\nInstallation of Strapi Comments Client You will need to have installed react ^17.0.2, react-dom ^17.0.2 and react-router-dom ^5.2.0.\nInside of your React project, run this command:\nnpm install strapi-comments-client --save Usage of Strapi Comments Client Using this library is very easy!\nThis library exports three main components:\nCommentsProvider Comments CommentForm And you can import them this way:\nimport { CommentsProvider, Comments, CommentForm } from \u0026#34;strapi-comments-client\u0026#34; All you have to do is wrap your App component into the CommentsProvider component. Then you will be able to place anywhere in your app the Comments component to render a list of comments for a given content ID and the CommentForm component to render a form to post comments.\nFor example, this could be your index.js or main.js file:\nimport React from \u0026#39;react\u0026#39; import ReactDOM from \u0026#39;react-dom\u0026#39; // The address of your strapi backend instance const STRAPI = \u0026#34;http://localhost:1337\u0026#34; ReactDOM.render( \u0026lt;React.StrictMode\u0026gt; \u0026lt;CommentsProvider apiURL={STRAPI}\u0026gt; \u0026lt;App /\u0026gt; \u0026lt;/CommentsProvider\u0026gt; \u0026lt;/React.StrictMode\u0026gt;, document.getElementById(\u0026#39;root\u0026#39;) ) Where apiURL is the URL of your running Strapi application, and this property is required.\nThis way, the comments provider will do all the magic of fetching and posting comments for you!\nThis library also exports an utility React.Context to update some of the parameters for fetching and posting comments:\nimport { CommentsConfigContext } from \u0026#34;strapi-comments-client\u0026#34; This CommentsConfigContext exposes two setter functions: setUser and setContentID\nWith setContentID you can load the comments for a given content and post comments to it. It receives a single parameter of type string and must be URLized, i.e. no spaces.\nWith setUser you can set the credentials of a given user to authorize the posting of comments. It receives a single parameter of type IUser, with the following Typescript interface:\ninterface IUser { username: string, email: string, id: string, token: string // This is a JWT } It\u0026rsquo;s a little confusing but we\u0026rsquo;ll see how to use it in a component:\nconst App = () =\u0026gt; { const { setUser, setContentID } = useContext(CommentsConfigContext) // The following data should come from Strapi Users and Permissions Plugin // for authenticated requests const user = { username: \u0026#34;John Doe\u0026#34;, email: \u0026#34;jhohndoe@gmail.com\u0026#34;, id: 5, token: \u0026#34;this_should_be_a_JWT\u0026#34; } if (user) { setUser(user) } setContentID(\u0026#34;sample-content-1\u0026#34;) // Load comments for this content return ( \u0026lt;\u0026gt; { !user \u0026amp;\u0026amp; \u0026lt;Login /\u0026gt; } \u0026lt;CommentForm /\u0026gt; \u0026lt;Comments /\u0026gt; \u0026lt;/\u0026gt; ) } And that\u0026rsquo;s it!\nAfter setting the content ID through setContentID, CommentsProvider will start loading the comments for the given content ID and the CommentForm will render an input to post comments related to the given content ID if there is a user. Otherwise, it will display the message Login to post a comment.\nHere\u0026rsquo;s how the interface looks like so far:\nThere\u0026rsquo;s also a button to Leave a reply, which will open a form to post a subcomment associated with the parent comment.\nThis library exports one more component: ErrorBox\nimport { ErrorBox } from \u0026#34;strapi-comments-client\u0026#34; .It\u0026rsquo;s useful if you\u0026rsquo;d like to display error messages when things go wrong fetching or posting comments.\nYou can place this component wherever you want, for example in between the CommentForm and the Comments components.\nIf you\u0026rsquo;re wondering how this error box looks like, here you have a sample:\nGeneral settings You can customize the page size, i.e. specify how many comments are returned at once.\nIn the Strapi admin panel, head over to Settings, then select Pagination under Comment Manager Plugin.\nHere you\u0026rsquo;ll find an input to set the page size, which defaults to 10.\nManage comments Once you\u0026rsquo;ve got the plugin up an running, as users start to post comments, you can manage and reply to them as admin from the Comment Manager section of the left sidebar in the Strapi admin dashboard.\nHere you can see two tabs: one for the latest comments and one for comments grouped by content ID.\nIn both of them you can delete comments and subcomments as well as leave replies.\nExample project You can find a full working example of a React App using the Strapi Comments Client Library in this repo\nConclusion With this plugin you can enable and manage comments for any content with little effort and even use a component library to display the comments in your frontend application made with React.\nAnd that\u0026rsquo;s it! The features are pretty basic at the moment but if there\u0026rsquo;s interest, I\u0026rsquo;m willing to work on more features as well as improve the UI/UX.\n","image":"//localhost:1313/images/post/strapilogo.jpg","permalink":"//localhost:1313/blogs/how-to-enable-and-manage-comments-in-your-strapi-application/","tags":["Strapi","Strapi tutorials"],"title":"How To Enable And Manage Comments In Your Strapi Application."},{"categories":["Documentation"],"contents":"Comment Manager is a Strapi plugin to allow your users to post comments.\nWith this plugin you can enable and manage comments for your content very easily!\nRequirements You should have installed an instance of Strapi v4.x.x\nInstallation Run the following command in your project root:\nnpm install strapi-plugin-comment-manager Configurarion For your frontend to have access to the API, enable the following permissions for Comment Manager from Users \u0026amp; Permissions Plugin on your project settings:\nFor public, enable: count, find and getPageSize.\nFor authenticated, enable create on both Comment and Subcomment.\nDisplay comments on the frontend Comments can be displayed in the frontend in two ways:\nUsing the React components library strapi-comments-client (recommended) Build your custom frontend using the API API There are some Typescript interfaces that will help to get an idea of the data structures.\nComments: interface IComment { id: string, from_admin: boolean, createdAt: string, content: string, author: IAuthor | null, subcomments?: ISubcomment[] } Subcomments: interface ISubcomment { id: string, from_admin: boolean, createdAt: string, content: string, author: IAuthor | null, } Authors: IAuthor { username: string, email: string, id: string } The following endpoints are exposed to fetch and post comments and subcomments:\nGet comments for a content ID Method: GET\nPath: /api/comment-manager/comments/:slug\nOptional query parameters: start, ignoreCount\nReturns:\n{ commentsCount?: Number, comments: IComment[] } The parameter start indicates how many comments to skip. This is for pagination purposes.\nThe parameter ignoreCount indicates whether or not to return the total number of comments associated with the given slug.\nGet the number of comments associated with a given content ID Method: GET\nPath: /api/comment-manager/comments/:slug/count\nReturns:\n{ count: Number } Post a comment Method: POST\nPath: /api/comment-manager/comments/:slug\nAuthentication: Bearer token\nPayload:\n{ content: string } Returns:\n{ id: Number } Post a subcomment Method: POST\nPath: /api/comment-manager/subcomments/:parent-id\nAuthentication: Bearer token\nPayload:\n{ content: string } Returns:\n{ id: Number } Get the page size Method: GET\nPath: /api/comment-manager/page-size\nReturns:\n{ pageSize: Number } General settings The plugin allows to set how many comments are returned per page by going to the Pagination section under Comment Manager Plugin on the Settings section.\nThe default page size is 10.\nManagement of comments Admin users are able to delete comments and subcomments as well as leave replies as admins from within the plugin page of the Strapi admin dashboard.\nThe plugin interface has two tabs: one for the latest comments and one for comments by content ID.\nRoadmap and future plans The plugin is pretty basic but it can be improved with more features and a better UI/UX. Collaborations and suggestions are very welcome.\n","image":"//localhost:1313/images/post/strapilogo.jpg","permalink":"//localhost:1313/blogs/strapi-plugin-comment-manager/","tags":["Strapi","Strapi plugins"],"title":"Strapi Plugin Comment Manager"},{"categories":["Projects"],"contents":"In this post I’m going to share my experience on building a SaaS using the headless CMS Strapi as the Backend, React Native and other technologies.\nOutline Introduction What is SaaS? The problem What is Strapi? Developing features in Strapi The frontend: How to get content Conclusion Landing Page Introduction Very often, developers, product and project managers, testers and pretty much the entire team share their ideas to decide what language and which framework they\u0026rsquo;ll use to build their next project. Some considerations must be taken into account, from which in my opinion there are three that are the most important:\nDeveloper experience and ease of use Does the language and framework chosen provide a good developer experience? Is the langauge the same for the backend and frontend?\nDeadlines Is there a deadline to finish the project? if so, there is a good chance to finish the project on time if the team chooses the language they have more experience in.\nMaintainability As there will be usually more than one person working on the same part at the same time, if everything is kept organised, the whole development process will be frictionless.\nWith that in mind, developers and project managers will have a better insight on which language/framework to use.\nOther aspects should also be considered such as what the data structure will look like.\nIn my case, as it is usual, the backend of my project needs a database for users and their roles among other entities and their relations and a dashboard to allow admins to manage the data, and I was lucky to find out Strapi, as it includes a lot of these features out of the box with one single line of command to get started.\nWhat is SaaS? SaaS stands for Software-as-a-Service and it just means that a software is provided as a service in the cloud and it gives a solution to a specific problem, for which the users are willing to pay either monthly or annual subscription.\nThe problem Before starting to write a single line of code, it is generally a good idea to think about the problem, it\u0026rsquo;s limitations and whether or not it has already been solved by someone else (AKA competitors).\nThe problem I was looking into had to do with the way in which public and private transportation companies manage their routes, drivers and users. After a little bit of research, I could only find one platform that provides a similiar solution but for their own company.\nSo the platform I built needed the following content types:\nOrganizations to group routes, drivers and users Routes Two user roles: drivers and users (passengers) As I said before, Strapi makes the creation of these content types and the relationships between them really easy, but let\u0026rsquo;s first see what is Strapi and how it turns the API development into a satisfactory and fun experience.\nWhat is Strapi? Strapi is an open source headless CMS that allows developers to build complete RESTful APIs in just a couple of days instead of months. It includes a lot of useful features as plugins out of the box. Users and Roles management, Media library and an interface to create, view, edit and delete content are just some of them.\nRegarding the API, how does it makes the development faster?\nFirst of all, it enforces a specific folder structure, which helps to keep everything well organised and clean.\nSecondly, all database schemas are generated automatically and queries are made in JSON format, which really saves a lot of time.\nLastly, we can add more features to our Strapi application very easily via plugins from the marketplace.\nIt\u0026rsquo;s also worth noting that Strapi is a self-hosted CMS, which means that we can host it in whatever cloud platform we want, as well as test it locally in our computers before deploying it to the cloud.\nDeveloping features in Strapi Creating and configuring endpoints in Strapi is as straightforward as declaring a JSON in a single file:\nCreating controllers is straightforward as well:\nEvery controller gets all the data related to the request in the ctx parameter and it\u0026rsquo;s also used to send the response. This keeps everything in one place and really helps to improve the readability.\nOnce the API endpoints are defined, the next step is to enable the permissions for the specific user roles to have access to these endpoints:\nThe frontend: how to get content Since Strapi is a headless CMS, it\u0026rsquo;ll only provide content through the API. That means that the content can be consumed from anywhere. In our case, this content will be used in two applications: one for the organization owners and one for the users and drivers.\nThe application for the organization owners is a dashboard where administrators can create organizations, routes, accept drivers and users in the organization and assign routes to drivers. This is just a React Application:\nThe application for drivers and users is a mobile application built in React Native. Firebase was used to synchronise geolocation data in real time between drivers and users and display this information in a Map from Google Maps:\nConclusion Using a CMS as the backend can make the development a lot faster than building the API from scratch and with Strapi this is specially true. Furthermore, this becomes more important when building a brand-new product, as it\u0026rsquo;s usually recommended to launch as soon as possible to gather feedback from the users and validate the idea.\nProject landing page: https://rutieri.netlify.app\n","image":"//localhost:1313/images/post/03.webp","permalink":"//localhost:1313/blogs/how-i-built-a-saas-on-top-of-strapi-and-why-you-should-too/","tags":["Strapi","React Native","Typescript"],"title":"How I Built A SaaS On Top Of Strapi, And Why You Should Too"},{"categories":["Tutorial"],"contents":"Enable User Reviews in a Strapi application and display them in the frontend with React\nOutline Introduction Prerequisites What is Strapi Ratings? Installation Configuration Display user reviews on the frontend Plugin settings Manage user reviews Full source code of the frontend Conclusion Introduction Ratings systems have become a crucial part of any website with ecommerce capabilites, as they allow the users to post reviews on the items they purchase and publish their opinion to the public. A couple of reviews can make the difference between pressing the “Buy” button and moving on to the next website in the Google search results.\nIn this article, I\u0026rsquo;ll show you how to enable and manage user reviews for your content very easily using the Ratings plugin, and display them in your frontend application.\nPrerequisites First of all, you need to have a basic understanding of the following.\nBasic knowledge of JavaScript Basic knowledge of React (OPTIONAL) Basic understanding of Strapi - get started here. Your Strapi V4 project setup What is Strapi Ratings? Strapi Ratings is a plugin that gives your Strapi application the ability to manage ratings for pretty much any kind of content. It allows your users to post reviews and anyone can get the reviews associated with a given slug.\nWith this plugin, admin users can view and manage very easily all the reviews from the Strapi administration dashboard. Within the dashboard, you will be able to see reviews related to content slugs as well as delete reviews.\nInstallation Once into the Strapi project root, you can install the plugin by running the following command:\nnpm install strapi-plugin-ratings Next, build the project to see the new plugin in the dashboard with the following command:\nnpm run build And that\u0026rsquo;s it! If everything runs correctly, the plugin should now be installed.\nConfiguration Now you need to enable some permissions so that the frontend can access the endpoints to post and fetch reviews.\nIn your Strapi admin dashboard, head over to Settings, then over to Roles under Users \u0026amp; Permissions Plugin.\nLet\u0026rsquo;s first setup the Public API; click on Public and hit the dropdown button of Ratings. Now check count, find, getPageSize and getStats, then hit the Save button. Below is a screenshot of a proper configuration:\nNow let\u0026rsquo;s setup the Authenticated API. Go back to Roles and click on Authenticated. Open the dropdown for Ratings and mark as checked the options create, find and getUserReview. Below is a screenshot of a proper configuration:\nWith this configuration, the frontend should now be able to make requests to get and post user reviews.\nDisplay use reviews on the frontend The plugin exposes an API to get and post reviews if you want to have fine-grained control over the workflow of your ratings system and you can check the documentation on the package page, but this plugin also comes with a purpose-built React component library that makes it super easy to get up and running without getting your hands dirty.\nThis components library is called strapi-ratings-client, fully supports typescript and it takes care of all the complexity of fetching and posting user reviews for every content ID that you pass to it.\nInstallation of Strapi Ratings Client You will need to have installed react ^17.0.2, react-dom ^17.0.2, bootstrap ^5.1.3 and @popperjs/core^2.11.2\nInside of your React project, run this command:\nnpm install strapi-ratings-client --save Usage of Strapi Ratings Client Using this library is very easy!\nThis library exports three main components:\nReviewsProvider Reviews ReviewForm And you can import them this way:\nimport { ReviewsProvider, Reviews, ReviewForm } from \u0026#34;strapi-ratings-client\u0026#34; All you have to do is wrap your App component into the ReviewsProvider component. Then you will be able to place anywhere in your app the Reviews component to render a list of user reviews for a given content ID and the ReviewForm component to render a form to allow your users to post reviews.\nFor example, this could be your index.js or main.js file:\nimport React from \u0026#39;react\u0026#39; import ReactDOM from \u0026#39;react-dom\u0026#39; // The address of your strapi backend instance const STRAPI = \u0026#34;http://localhost:1337\u0026#34; ReactDOM.render( \u0026lt;React.StrictMode\u0026gt; \u0026lt;ReviewsProvider apiURL={STRAPI}\u0026gt; \u0026lt;App /\u0026gt; \u0026lt;/ReviewsProvider\u0026gt; \u0026lt;/React.StrictMode\u0026gt;, document.getElementById(\u0026#39;root\u0026#39;) ) Where apiURL is the URL of your running Strapi application, and this property is required.\nThis way, the ratings provider will do all the magic of fetching and posting comments for you!\nThis library also exports an utility React.Context to update some of the parameters for fetching and posting reviews:\nimport { ReviewsConfigContext } from \u0026#34;strapi-ratings-client\u0026#34; This ReviewsConfigContext exposes three setter functions: setUser, setContentID and setCanPostReview.\nWith setContentID you can load the ratings for a given content and post reviews to it. It receives a single parameter of type string and must be URLized, i.e. no spaces.\nWith setUser you can set the credentials of a given user to authorize the posting of reviews. It receives a single parameter of type IUser, with the following Typescript interface:\ninterface IUser { username: string, email: string, id: string, token: string // This is a JWT } With setCanPostReview, you can enable the user to post a review on the given content. This is useful for when you only allow a user to post a review after they purchase the product.\nIt\u0026rsquo;s a little confusing but we\u0026rsquo;ll see how to use it in a component:\nconst App = () =\u0026gt; { const { setUser, setContentID, setCanPostReview } = useContext(ReviewsConfigContext) // The following data should come from Strapi Users and Permissions Plugin // for authenticated requests. const user = { username: \u0026#34;John Doe\u0026#34;, email: \u0026#34;jhohndoe@gmail.com\u0026#34;, id: 5, token: \u0026#34;this_should_be_a_JWT\u0026#34; } if (user) { setUser(user) } setContentID(\u0026#34;sample-content-1\u0026#34;) // Load reviews for this content setCanPostReview(true) // Allow this user to post a review return ( \u0026lt;\u0026gt; { !user \u0026amp;\u0026amp; \u0026lt;Login /\u0026gt; } \u0026lt;ReviewForm /\u0026gt; \u0026lt;Reviews /\u0026gt; \u0026lt;/\u0026gt; ) } And that\u0026rsquo;s it!\nAfter setting the content ID through setContentID, ReviewsProvider will start loading the reviews for the given content ID and the ReviewForm will render an input to post a user review related to the given content ID if there is a user and he’s allowed to post a review. Otherwise, it will display the message Login to post a review or nothing at all if the user is not allowed to post a review.\nHere\u0026rsquo;s how the interface looks like so far:\nThis library exports one more component: ErrorBox\nimport { ErrorBox } from \u0026#34;strapi-ratings-client\u0026#34; .It\u0026rsquo;s useful for when you\u0026rsquo;d like to display error messages when things go wrong fetching or posting reviews.\nYou can place this component wherever you want, for example in between the ReviewForm and the Reviews components.\nIf you\u0026rsquo;re wondering how this error box looks like, here‘s a screenshot:\nGeneral settings You can customize the page size, i.e. specify how many user reviews are showed at once.\nIn the Strapi admin panel, head over to Settings, then select Pagination under Ratings Plugin.\nHere you\u0026rsquo;ll find an input to set the page size, which defaults to 10.\nManage reviews Once you\u0026rsquo;ve got the plugin up an running, as users start to post reviews, you can view them from within the Ratings section of the left sidebar in the Strapi admin dashboard.\nHere you can see two tabs: one for the latest reviews and one for reviews grouped by content ID.\nIn both of them you can delete unwanted reviews.\nExample project You can find a full working example of a React App using the Strapi Ratings Client Library in this repo: https://github.com/luisguve/strapi-ratings-client-example\nConclusion With this plugin you can enable and manage user reviews for any content with little effort and even use a library of components styled with Bootstrap to display the user reviews in your frontend.\nAnd that\u0026rsquo;s it! The features are pretty basic at the moment but if there\u0026rsquo;s interest, I\u0026rsquo;m willing to work on more features as well as improve the UI/UX.\n","image":"//localhost:1313/images/post/tutorial-ratings.webp","permalink":"//localhost:1313/blogs/how-to-enable-and-manage-user-reviews-in-your-strapi-application/","tags":["Strapi","Strapi tutorials"],"title":"How To Enable And Manage User Reviews In Your Strapi Application"},{"categories":["Documentation"],"contents":"Ratings is a Strapi plugin that allows your users to post reviews.\nEnable and manage user reviews for your content very easily!\nRequirements You should have installed an instance of Strapi v4.x.x\nInstallation Run the following command in your project root:\nnpm install strapi-plugin-ratings Then, rebuild the admin dashboard using the following command\nnpm run build Configurarion For your frontend to have access to the API, enable the following permissions for Ratings from Users \u0026amp; Permissions Plugin on your project settings:\nFor public, enable: count, find, getPageSize and getStats.\nFor authenticated, enable create, find and getUserReview.\nDisplay user reviews on the frontend Reviews can be displayed in the frontend in two ways:\nUsing the React components library strapi-ratings-client (recommended) Build your custom frontend using the API endpoints, described as follows: API There are some Typescript interfaces that will help to get an idea of the data structures.\nReviews: interface IReview { id: number, createdAt: string, comment: string | null, author: IAuthor | null, score: number, } Authors: interface IAuthor { username: string, email: string, id: number } Content Stats interface IStats { averageScore: number; reviewsCount: number | null; } The following endpoints are exposed to fetch and post reviews:\nGet reviews for a content ID Method: GET\nPath: /api/ratings/reviews/:slug\nOptional query parameters: start, ignoreCount\nReturns:\n{ reviewsCount: number, averageScore: number, userReview: IReview | null, reviews: IReview[] } The parameter start indicates how many reviews to skip. This is for pagination purposes.\nThe parameter ignoreCount indicates whether or not to return the total number of reviews associated with the given slug.\nGet review stats for a content ID Method: GET\nPath: /api/ratings/reviews/:slug/stats\nReturns:\n{ averageScore: number, reviewsCount: number | null } Get the number of reviews associated with a given content ID Method: GET\nPath: /api/ratings/reviews/:slug/count\nReturns:\n{ count: number } Post a review Method: POST\nPath: /api/ratings/reviews/:slug\nAuthentication: Bearer token\nPayload:\n{ content: string } Returns:\n{ id: number } By default, every authenticated user can post reviews on any content.\nIn order to customize this behavior, e.g. allowing or disallowing a user from posting reviews, you must extend the service userCanPostReview from whithin register function in ./src/index.js. For example:\nstrapi.service(\u0026#34;plugin::ratings.review\u0026#34;).userCanPostReview = async (user, slug) =\u0026gt; { /* Here you will check whether or not the user is allowed to post a review on this content ID and return either true or false. */ return true } Notice that userCanPostReview will receive two parameters: the user from Users \u0026amp; Permissions Plugin, containing it\u0026rsquo;s id, username, confirmed, etc., and the slug, which is a string and refers to the content ID which the review is being posted on.\nIn case this function returns false, the response of the endpoint will be 403 (forbidden) with the text User cannot post a review on this content.\nGet the page size Method: GET\nPath: /api/ratings/page-size\nReturns:\n{ pageSize: number } General settings The plugin allows to set how many reviews are returned per page by going to the Pagination section under Ratings Plugin of the Settings section.\nThe default page size is 10.\nManagement of reviews Admin users are able to delete reviews from within the plugin page of the Strapi admin dashboard.\nThe plugin interface has two tabs: one for the latest reviews and one for reviews by content ID.\nRoadmap and future plans The plugin is pretty basic but it can be improved with more features and a better UI/UX. Collaborations and suggestions are very welcome.\n","image":"//localhost:1313/images/post/ratings.webp","permalink":"//localhost:1313/blogs/strapi-plugin-ratings/","tags":["Strapi","Strapi plugins"],"title":"Strapi Plugin Ratings"},{"categories":["Projects"],"contents":"ManyLMS is an e-learning platform built on top of Strapi, React Router 7, Typescript and other technologies.\nOutline The idea Platform features The stack The API The frontend Conclusion Landing Page The idea This project doesn\u0026rsquo;t necessarily bring a huge amount of innovation on the e-learning platforms that already exists, but it\u0026rsquo;s just another way of doing this type of application.\nThe main idea is to apply a JAMstack approach in this application, where the platform is a static website, and the backend is just an API that serves static content only once to build the website and just adds the dynamism that\u0026rsquo;s necessary to allow users to authenticate, create orders, confirm payments and take courses.\nIf we compare this approach to a WordPress website, we are taking out most of the overhead that implies rendering the pages everytime a user visits them. Despite that there are plugins for caching that may improve the performance, it\u0026rsquo;s still never going to be faster and more efficient than just static content served by a CDN. That\u0026rsquo;s why React Router 7 and Headless CMSs are so popular right now.\nPlatform features and user stories The following user stories illustrates the desired features the platform should have.\nAs an administrator, I want to: login in the admin panel. create categories. create courses. upload lectures. organise courses into categories. assign lectures to courses. As a student, I want to: login in the platform. view the available courses. add courses to the shopping cart. review the shopping cart. create an order. pay with credit card or paypal. view the courses i\u0026rsquo;ve purchased in my learning page. go to the course page from my learning page and watch the videos. mark lectures as seen. come back later and resume where I left. The requirements The backend requires to handle user authentication, permissions, different data structures as content types and define relationships between them. It also requires to allow uploading videos to some third party platform that supports streaming on demand.\nThe frontend is a web platform where users can register and login, view and buy courses, leave comments and reviews and take courses.\nThe API Since all of the features involve authentication, permissions and roles, and because there is no need to reinvent the wheel, I chose to use Strapi to build the backend for it\u0026rsquo;s simplicity, ease of use and great developer experience, whereas for streaming videos on demand, I chose to use Mux.com.\nThe instance of Strapi and the Postgres database it requires was deployed in the cloud hosting platform https://fly.io.\nStrapi is good for managing users, content that\u0026rsquo;s typically updated and fetched via CRUD API, and setting up relations between content types.\nThe platform needs the following content types:\nCategory to group courses Course Lecture Module to group lectures Order Student: has many courses Student-Course: stores a student\u0026rsquo;s current lecture of a course Video Strapi makes the creation of these content types and setting up relationships between them really straightforward.\nBelow are some screenshots of these content types and the relationships between them:\nThe frontend The platform where users are able to login, view, buy and view courses is a web application built with React Router 7. Among the features of this application are:\nState managed by Context API Interface styled with Bootstrap Play streaming videos with @mux/mux-player-react library Use of localStorage to save user session Below are some sample screenshots of how this app looks like\nConclusion and final thoughts While building this project, I learned:\nHow streaming on demand works and how to use a streaming provider How to statically build websites with React Router 7 and Strapi How to setup dynamic pages in React Router 7 How to process payments with Stripe and Paypal How to build custom plugins in Strapi How to publish packages to NPM Project source codes: https://github.com/luisguve/maestro-backend\nhttps://github.com/luisguve/new-lms-remix\n","image":"//localhost:1313/images/project/manylms/frontend/course_overview.png","permalink":"//localhost:1313/projects/e-learning-platform-maestro-lms/","tags":["Strapi","React","React Router 7","Typescript","Mux"],"title":"ManyLMS: E-Learning platform"},{"categories":["Projects"],"contents":"ETMday (Emprende tu Mente) is a large-scale entrepreneurship event website built on top of WordPress with the Themosis framework, featuring an interactive SVG map, real-time countdown timers, advanced search functionality, and comprehensive content management using Vue 3, Laravel Mix, and modern frontend technologies.\nOutline The project Key features The stack Frontend architecture Interactive components Conclusion Live website The project ETMday is Chile\u0026rsquo;s premier entrepreneurship event, bringing together thousands of entrepreneurs, startups, corporates, and strategic partners. The website serves as the central hub for event information, featuring speakers, activities, stands, program schedules, and an interactive event map.\nThe frontend development required implementing complex interactive features including an SVG-based interactive map with tooltips, real-time countdown timers, advanced filtering and search systems, and dynamic content displays that handle thousands of attendees and hundreds of activities.\nKey features The website includes several sophisticated features:\nInteractive SVG Map: Custom-built interactive map with clickable zones, tooltips, and dynamic content display Real-time Countdown: Event countdown timer with automatic updates and mobile optimization Advanced Search: Multi-category search across activities, speakers, stands, and content Dynamic Filtering: Complex filtering system with tabs, favorites, and downloadable resources Animated Statistics: Odometer animations for displaying event metrics Content Management: Comprehensive card components for activities, speakers, stands, and blog posts Form Handling: Multi-step forms with validation using Vee-Validate Lightbox Galleries: Image galleries with LightGallery integration Responsive Design: Fully responsive design optimized for all devices The stack The frontend stack consists of:\nVue 3.2.4: Modern reactive framework for building interactive components Laravel Mix 6.0: Asset compilation and bundling SCSS: Advanced styling with organized architecture Vee-Validate 4.15.0: Form validation with Yup schemas Axios 1.6.8: HTTP client for API requests Splide.js 4.1.4: Modern carousel and slider components LightGallery 2.8.3: Lightbox gallery functionality Odometer 0.4.8: Animated number counting Headroom.js: Header behavior on scroll jQuery 3.7.1: DOM manipulation and legacy support SweetAlert2: Modern alert dialogs GLightbox 3.3.1: Alternative lightbox solution Frontend architecture Vue components The application features a comprehensive set of Vue 3 components:\nCard Components:\ncards/activities.vue: Activity cards with favorites functionality cards/speakers.vue: Speaker cards with modal details cards/stands.vue: Stand/exhibitor cards cards/blog.vue: Blog post cards cards/shortcut.vue: Quick access shortcut cards Functional Components:\nSectionCards.vue: Main section component with tabs, filtering, and card display Search.vue: Advanced search component with multi-category results Form.vue: Dynamic form component with validation FormCalendar.vue: Calendar form component CustomFilter.vue: Reusable filter component CustomSelect.vue: Custom select dropdown Pagination.vue: Pagination component JavaScript components The application includes 17 specialized JavaScript components:\nInteractive Features:\ninteractiveMap.js: SVG map interaction with tooltips, zones, and dynamic content countdown.js: Real-time countdown timer with automatic updates odometer.js: Animated number counting with scroll triggers map.js: Map zone interactions and modal displays UI Components:\nheader.js: Header functionality and navigation headroom.js: Header hide/show on scroll accordion.js: Accordion interactions tabs.js: Tab functionality cards.js: Card interactions and modals siteModals.js: Modal management system UI.js: General UI utilities Media Components:\nvideo.js: Video player setup lightgallery.js: Lightbox gallery initialization splide.js: Carousel initialization slick.js: Legacy carousel support Utilities:\nscrollTrigger.js: Scroll-based animations imgToSvg.js: SVG image conversion utility SCSS architecture The styling follows a well-organized SCSS architecture:\nscss/ ├── abstracts/ # Variables, mixins, functions │ ├── _functions.scss │ ├── _mixins.scss │ ├── _variables.scss │ ├── _mq.scss # Media query mixins │ └── _keyframes.scss ├── base/ # Base styles and typography │ ├── _typography.scss │ ├── _container.scss │ └── _reset.scss └── components/ # Component-specific styles └── [52 component files] Key SCSS features:\nBEM methodology: Consistent naming convention Media query mixins: Using sass-mq for responsive design Modular architecture: Each component has its own SCSS file Component organization: 52 component-specific SCSS files Interactive components Interactive SVG Map The interactiveMap.js component implements a sophisticated SVG-based interactive map:\nFeatures:\nSVG Tooltips: Dynamically generated tooltips with text wrapping Zone Interactions: Clickable zones with modal displays Point Markers: Interactive points with icons and labels Dynamic Content: Content loaded based on zone/point selection Responsive Design: Optimized for mobile and desktop Technical Implementation:\nSVG namespace manipulation for tooltip creation Text wrapping algorithm for tooltip content Path generation for tooltip shapes with rounded corners Event delegation for zone and point interactions Smooth animations and transitions Real-time Countdown The countdown.js component provides a real-time countdown timer:\nFeatures:\nAutomatic Updates: Updates every second Multi-unit Display: Days, hours, minutes, and seconds Pluralization: Proper Spanish pluralization (Día/Días, Hora/Horas) Mobile Optimization: Simplified display on mobile devices End State Handling: Automatic transition when countdown ends Advanced Search System The Search.vue component implements a comprehensive search system:\nFeatures:\nMulti-category Search: Searches across activities, speakers, stands, and other content Category Tabs: Quick navigation between result categories Result Counts: Dynamic result counts per category Scroll Navigation: Smooth scrolling to category sections Carousel Display: Splide carousels for result display Loading States: Loading indicators during search Empty States: User-friendly empty state messages Dynamic Filtering System The SectionCards.vue component provides advanced filtering:\nFeatures:\nTab Navigation: Multiple filter tabs Favorites System: Save and filter favorite items Search Integration: Inline search within filters Reset Functionality: Clear all filters with one click Downloadable Resources: Download buttons for resources URL Synchronization: Filter state in URL parameters Responsive Design: Mobile accordion interface Animated Statistics The odometer.js component provides animated number counting:\nFeatures:\nScroll-triggered: Animations trigger on scroll Prefix/Suffix Support: Handles formatted numbers (e.g., \u0026ldquo;56,000+\u0026rdquo;) Mobile Optimization: Static display on mobile Smooth Animations: Odometer theme integration Development workflow The project uses Laravel Mix for asset compilation:\n// Development npm run dev // Compile assets npm run watch // Watch for changes npm run hot // Hot module replacement // Production npm run production // Optimized production build BrowserSync integration provides:\nLive reloading during development Synchronized browser testing Proxy configuration for WordPress development Performance optimizations Code splitting: Laravel Mix extracts vendor libraries Asset versioning: Automatic cache busting Image optimization: Lazy loading and responsive images Minification: Production builds are minified and optimized Tree shaking: Unused code elimination in production SVG optimization: Efficient SVG manipulation and rendering Accessibility Semantic HTML structure ARIA labels for interactive elements Keyboard navigation support Focus management in forms and modals Screen reader considerations Proper alt text for images Conclusion and final thoughts Building the ETMday frontend was an excellent opportunity to:\nMaster SVG interactions: Creating complex interactive SVG maps with dynamic tooltips and zones Implement real-time features: Building countdown timers and live updates Build advanced search: Multi-category search with filtering and categorization Handle complex state: Managing filters, favorites, and dynamic content Optimize performance: Implementing efficient animations and lazy loading Ensure scalability: Building components that handle large datasets (thousands of attendees, hundreds of activities) The project demonstrates proficiency in:\nModern JavaScript frameworks (Vue 3) SVG manipulation and interaction Real-time UI updates Advanced filtering and search systems Build tools and asset compilation (Laravel Mix, Webpack) CSS architecture and methodologies (SCSS, BEM) Component-based development Event-driven architecture The integration with WordPress/Themosis backend required careful consideration of server-side rendering, API endpoints, and content management workflows, making this a full-stack frontend implementation for a large-scale event.\nLive website: https://etmday.org/\nFigma Prototype: https://www.figma.com/proto/mt9fJ8P03M5gf0nQwcU99q/EtM-Day-2025---Dise%C3%B1o?node-id=1-2743\u0026m=dev\u0026scaling=scale-down\u0026content-scaling=fixed\u0026page-id=0%3A1\u0026starting-point-node-id=1%3A2743\n","image":"//localhost:1313/images/project/etm/home.png","permalink":"//localhost:1313/projects/etmday-entrepreneurship-event-website/","tags":["Vue 3","Laravel Mix","WordPress","Themosis","SCSS","JavaScript","Interactive Map","SVG"],"title":"ETMday: Entrepreneurship Event Website"},{"categories":["Projects"],"contents":"JAC Autos Chile is a comprehensive automotive website built on top of WordPress with the Themosis framework, featuring car model comparisons, multi-step quote forms, fleet management, branch listings, and advanced filtering systems using Vue 3, Pinia state management, Laravel Mix, and modern frontend technologies.\nOutline The project Key features The stack Frontend architecture Interactive components Conclusion Live website The project JAC Autos Chile is the official website for JAC Motors in Chile, showcasing SUVs, pickups, commercial vehicles, and electric vehicles. The website serves as the primary platform for vehicle exploration, quoting, dealership location, fleet management, and post-sale services.\nThe frontend development required implementing complex interactive features including car model comparisons, multi-step quote forms with model and version selection, advanced filtering systems, fleet management interfaces, and comprehensive content management.\nKey features The website includes several sophisticated features:\nCar Model Comparator: Side-by-side comparison of multiple vehicle models with difference highlighting Multi-step Quote Form: Comprehensive quote form with model selection, version selection, and customer information Advanced Filtering: Multi-criteria filtering for car models, branches, fleet vehicles, and blog posts Fleet Management: Dedicated fleet vehicle selection and management interface Branch Locator: Filterable dealership/branch listings with location information Blog System: Complete blog with filtering, search, and content management Manuals Listing: User manual and documentation management Search Functionality: Site-wide search with categorized results Sticky Navigation: Section-based sticky navigation for long pages 360° View: Interactive 360-degree vehicle viewing The stack The frontend stack consists of:\nVue 3.2.4: Modern reactive framework with Composition API Pinia 2.2.6: State management for Vue applications Laravel Mix 6.0: Asset compilation and bundling SCSS: Advanced styling with organized architecture Vee-Validate 4.14.6: Form validation with Yup schemas Axios 1.6.8: HTTP client for API requests Splide.js 4.1.4: Modern carousel and slider components @splidejs/vue-splide 0.6.12: Vue 3 wrapper for Splide Maska 3.0.3: Input masking for formatted inputs Vue-Select 4.0.0-beta.6: Custom select component Vue-Recaptcha 2.0.3: reCAPTCHA integration Headroom.js: Header behavior on scroll jQuery 3.7.1: DOM manipulation and legacy support SweetAlert2: Modern alert dialogs @fdograph/rut-utilities: Chilean RUT validation utilities Frontend architecture Vue components The application features a comprehensive set of Vue 3 components (40+ components):\nCar Model Components:\nCar.vue: Car model card component with comparison functionality CarLoading.vue: Loading skeleton for car cards CarVersion.vue: Car version/trim level component CarVersionLoading.vue: Loading skeleton for version cards CarModelsListingStatic.vue: Static car models listing CarModelsListingQuote.vue: Car models listing for quote flow CarVersionsListingQuote.vue: Versions listing for quote flow CarQuote.vue: Car quote display component CarQuoteLoading.vue: Loading skeleton for quote cards Comparison Components:\nComparator.vue: Main car comparison component with Splide integration ComparatorModal.vue: Modal version of comparator CardCompareModel.vue: Comparison card for individual models CardCompareModelLoading.vue: Loading skeleton for comparison cards Quote Components:\nQuote.vue: Main quote component with multi-step flow QuoteForm.vue: Comprehensive quote form with validation Filtering Components:\nFilters.vue: General filtering component FleetFilter.vue: Fleet-specific filtering BranchesFilter.vue: Branch/dealership filtering BlogFilter.vue: Blog post filtering AjaxListWithFilter.vue: AJAX-powered list with filtering Content Components:\nBlog.vue: Blog post card component BlogLoading.vue: Loading skeleton for blog cards Fleet.vue: Fleet vehicle card component Branch.vue: Branch/dealership card component BranchLoading.vue: Loading skeleton for branch cards Manual.vue: Manual/documentation card component ManualLoading.vue: Loading skeleton for manual cards ManualsListing.vue: Manuals listing component Form Components:\nContactForm.vue: Contact form with validation Select.vue: Custom select dropdown component UI Components:\nPagination.vue: Pagination component StickySectionSelector.vue: Sticky navigation for sections EmptyState.vue: Empty state displays Loader.vue: Loading indicator ErrorBoundary.vue: Error boundary component SearchResults.vue: Search results display SearchResultCard.vue \u0026amp; SearchResultCardLoading.vue: Search result cards Service Components:\nCardMaintenance.vue: Maintenance service card CardMaintenanceLoading.vue: Loading skeleton for maintenance cards JavaScript components The application includes 12 specialized JavaScript components:\nUI Components:\nheader.js: Header functionality and navigation headroom.js: Header hide/show on scroll megamenu.js: Mega menu functionality search-modal.js: Search modal functionality scrollUpBottom.js: Scroll to top/bottom functionality social-share.js: Social media sharing Media Components:\nvideo.js: Video player setup splide.js: Carousel initialization slick.js: Legacy carousel support Interactive Components:\naccordion.js: Accordion interactions tabs.js: Tab functionality Utilities:\nimg-to-svg.js: SVG image conversion utility scrollTrigger.js: Scroll-based animations SCSS architecture The styling follows a well-organized SCSS architecture:\nscss/ ├── abstracts/ # Variables, mixins, functions │ ├── _mixins.scss │ ├── _mq.scss # Media query mixins │ └── _vendor.scss ├── base/ # Base styles and typography │ ├── _typography.scss │ ├── _colors.scss │ ├── _container.scss │ └── _globals.scss └── components/ # Component-specific styles ├── [87 component files] └── cards/ # Card component styles └── [20 card-specific files] Key SCSS features:\nBEM methodology: Consistent naming convention throughout Media query mixins: Using sass-mq for responsive design Modular architecture: 106 component-specific SCSS files Card organization: Dedicated card component styles Interactive components Car model comparator The Comparator.vue component provides sophisticated car model comparison:\nFeatures:\nSide-by-side comparison: Compare up to 3 models simultaneously Difference highlighting: Toggle to highlight differences between models Splide integration: Smooth carousel navigation for multiple models Dynamic data loading: Load comparison data via AJAX Responsive design: Optimized for mobile and desktop Modal version: Full-screen modal comparison view Technical Implementation:\nPinia store for comparison state management Splide Vue component for carousel functionality Dynamic component rendering based on selected models Efficient data structure for comparison attributes Multi-step quote form The Quote.vue and QuoteForm.vue components implement a comprehensive quote system:\nFeatures:\nStep-by-step flow: Model selection → Version selection → Customer information Form validation: Using Vee-Validate with Yup schemas RUT validation: Chilean RUT validation using custom directive Input masking: Phone numbers and formatted inputs with Maska reCAPTCHA integration: Spam protection Edit functionality: Ability to go back and edit previous steps Selected vehicle display: Visual representation of selected model/version Loading states: Visual feedback during form submission Form steps include:\nStep 1: Category and model selection Step 2: Version/trim level selection Step 3: Customer information and submission Advanced filtering systems Multiple filtering components provide comprehensive filtering:\nFleet Filter (FleetFilter.vue):\nFilter fleet vehicles by category, price range, and features Real-time filtering with URL parameter synchronization Mobile-optimized interface Branches Filter (BranchesFilter.vue):\nFilter dealerships by location, region, and services Map integration support Contact information display Blog Filter (BlogFilter.vue):\nFilter blog posts by category, date, and tags Search functionality Pagination support Ajax List with Filter (AjaxListWithFilter.vue):\nGeneric AJAX-powered list component Multiple filter criteria Loading states and empty states Sticky section selector The StickySectionSelector.vue component provides section-based navigation:\nFeatures:\nSticky positioning: Stays visible while scrolling Active section highlighting: Highlights current section Smooth scrolling: Smooth scroll to sections Responsive design: Mobile-optimized display State management with Pinia The application uses Pinia for centralized state management:\nStores:\nComparator Store: Manages comparison state, selected models, and comparison data Quote Store: Manages quote flow state, selected model/version, and form data Filter Stores: Manage filter states for different content types Benefits:\nCentralized state management Type-safe state access Efficient reactivity Easy debugging with Vue DevTools Custom directives The application includes custom Vue directives:\nRUT Directive (input-rut):\nChilean RUT (tax ID) validation and formatting Real-time validation as user types Format enforcement (XX.XXX.XXX-X) Development workflow The project uses Laravel Mix for asset compilation:\n// Development npm run dev // Compile assets npm run watch // Watch for changes npm run hot // Hot module replacement // Production npm run production // Optimized production build BrowserSync integration provides:\nLive reloading during development Synchronized browser testing Proxy configuration for WordPress development Performance optimizations Code splitting: Laravel Mix extracts vendor libraries Asset versioning: Automatic cache busting Image optimization: Lazy loading and responsive images Minification: Production builds are minified and optimized Tree shaking: Unused code elimination in production Component lazy loading: Load components on demand Skeleton loading: Better perceived performance with loading states Accessibility Semantic HTML structure ARIA labels for interactive elements Keyboard navigation support Focus management in forms and modals Screen reader considerations Proper alt text for images Color contrast compliance Conclusion and final thoughts Building the JAC Autos Chile frontend was an excellent opportunity to:\nMaster Vue 3: Working with Composition API, Pinia state management, and modern Vue patterns Build complex comparisons: Creating sophisticated car model comparison interfaces Implement multi-step forms: Complex quote forms with validation, RUT formatting, and step navigation Create advanced filtering: Multiple filtering systems for different content types Optimize performance: Implementing efficient state management, lazy loading, and code splitting Handle automotive data: Managing complex vehicle data structures and relationships The project demonstrates proficiency in:\nModern JavaScript frameworks (Vue 3) State management (Pinia) Form validation and user experience (Vee-Validate, Yup, Maska) Build tools and asset compilation (Laravel Mix, Webpack) CSS architecture and methodologies (SCSS, BEM) Component-based development Custom directives Carousel and slider implementations (Splide) AJAX-powered interfaces The integration with WordPress/Themosis backend required careful consideration of server-side rendering, API endpoints, and content management workflows, making this a full-stack frontend implementation for a comprehensive automotive platform.\nLive website: https://jacautoschile.cl/\n","image":"//localhost:1313/images/project/jac-autos/homepage.webp","permalink":"//localhost:1313/projects/jac-autos-chile-automotive-website/","tags":["Vue 3","Pinia","Laravel Mix","WordPress","Themosis","SCSS","JavaScript","Splide"],"title":"JAC Autos Chile: Automotive Website"},{"categories":["Projects"],"contents":"ISC Chile is an educational consultancy website for study abroad programs, built on top of WordPress with the Themosis framework, featuring GSAP animations, multi-step contact forms, advanced blog filtering, and comprehensive content management using Vue 2, Laravel Mix, and modern frontend technologies.\nOutline The project Design implementation The stack Frontend architecture Key features Conclusion Live website The project ISC Chile is an educational consultancy agency that has been providing study abroad advisory services since 1996. The website serves as the primary platform for showcasing various educational programs including English courses, school exchanges, group travel programs, and Pathways programs for university admission abroad.\nThe frontend development was based on a comprehensive Figma design, requiring pixel-perfect implementation of complex UI components, multi-step forms, animated statistics, and responsive layouts that work seamlessly across all devices.\nDesign implementation The entire frontend was built from a detailed Figma design, ensuring:\nPixel-perfect accuracy: Matching the design specifications precisely (as evidenced by Figma height references in SCSS) Responsive design: Implementing breakpoints and mobile-first approach Component consistency: Maintaining design system patterns throughout Interactive elements: Translating static designs into dynamic, interactive components Animation and transitions: Implementing smooth GSAP-powered animations The stack The frontend stack consists of:\nVue 2.6.12: Reactive framework for building interactive components Laravel Mix 6.0: Asset compilation and bundling SCSS: Advanced styling with a well-organized architecture Vuex 3.6.2: State management for Vue applications Vee-Validate 3.4.14: Form validation GSAP 3.12.5: Professional animation library with ScrollTrigger Axios 0.18: HTTP client for API requests Splide.js 4.1.4: Modern carousel and slider components Slick Carousel 1.8.1: Legacy carousel support LightGallery 2.7.2: Lightbox gallery functionality Odometer 0.4.8: Animated number counting Headroom.js: Header behavior on scroll V-Calendar 2.4.2: Calendar component for date selection V-Mask 2.3.0: Input masking Vue-Select 3.20.2: Custom select component jQuery 3.2: DOM manipulation and legacy support SweetAlert: Alert dialogs Frontend architecture Vue components The application features a comprehensive set of Vue 2 components:\nForm Components:\nContact.vue: Multi-step contact form with validation and reCAPTCHA ContactFormStep1.vue: First step of the contact form ContactFormStep2.vue: Second step of the contact form ContactFormStep3.vue: Third step of the contact form FormBanner.vue: Banner form component Content Components:\nBlog.vue: Blog listing with advanced filtering and search BlogArticleCard.vue \u0026amp; BlogArticleCardLoading.vue: Blog post cards with loading states ExperiencesPanel.vue: Testimonials and experiences display panel ExperiencesFiltersMobile.vue: Mobile filter component for experiences Search Components:\nSearchResults.vue: Search results display component SearchResultCardLoading.vue: Loading skeleton for search results UI Components:\nCheckboxDropdown.vue: Custom checkbox dropdown component CheckboxDropdownFieldset.vue: Fieldset wrapper for checkbox dropdowns EmptyState.vue: Empty state displays Loader.vue \u0026amp; Loading.vue: Loading indicators JavaScript components The application includes 15 specialized JavaScript components:\nAnimation Components:\ngsap.js: GSAP animations with ScrollTrigger for scroll-based reveals scrolltrigger.js: Custom scroll trigger utilities odometer.js: Animated number counting with scroll triggers UI Components:\nheader.js: Header functionality and navigation headroom.js: Header hide/show on scroll megamenu.js: Mega menu functionality mobileMenu.js: Mobile menu interactions searchbar.js: Search bar functionality floating-banner.js: Floating banner component footer.js: Footer functionality Media Components:\nvideo.js: Video player setup lightgallery.js: Lightbox gallery initialization splide.js: Carousel initialization slick.js: Legacy carousel support Interactive Components:\naccordion.js: Accordion interactions tabs.js: Tab functionality cards.js: Card interactions Utilities:\nimg-to-svg.js: SVG image conversion utility SCSS architecture The styling follows a well-organized SCSS architecture:\nscss/ ├── abstracts/ # Variables, mixins, functions │ ├── _mixins.scss │ ├── _mq.scss # Media query mixins │ └── _vendor.scss ├── base/ # Base styles and typography │ ├── _typography.scss │ ├── _colors.scss │ ├── _container.scss │ ├── _globals.scss │ └── fonts/ # Custom TWK Everett font family └── components/ # Component-specific styles └── [45 component files] Key SCSS features:\nBEM methodology: Consistent naming convention throughout Media query mixins: Using sass-mq for responsive design Modular architecture: Each component has its own SCSS file Custom typography: TWK Everett font family with multiple weights Figma references: Direct references to Figma design specifications Key features Multi-step contact form The Contact.vue component implements a sophisticated multi-step form with:\nThree-step navigation: Step-by-step form progression Form validation: Using Vee-Validate with comprehensive rules Date picker: V-Calendar integration for date selection Input masking: V-Mask for phone numbers and formatted inputs reCAPTCHA integration: Spam protection Dynamic fields: Fields that change based on user selections Loading states: Visual feedback during form submission Error handling: Comprehensive error messages and validation Form steps include:\nStep 1: Personal information and contact details Step 2: Educational background and program interests Step 3: Additional information and submission GSAP animations The gsap.js component provides professional animations:\nFeatures:\nScroll-triggered animations: Elements animate on scroll Vertical scroll reveals: Fade and slide animations Horizontal scroll reveals: Staggered animations for grid layouts Timeline management: Complex animation sequences Performance optimized: Efficient animation triggers Animation types:\nFade in with vertical movement Staggered grid animations Scroll-based reveals Smooth transitions Advanced blog system The Blog.vue component provides comprehensive blog functionality:\nFeatures:\nCategory filtering: Filter posts by category Search functionality: Real-time search across blog posts Mobile filters: Dedicated mobile filter interface Pagination: Efficient content pagination Loading states: Skeleton loading screens Empty states: User-friendly empty state messages Experiences/testimonials panel The ExperiencesPanel.vue component displays student testimonials:\nFeatures:\nFilter by type: Filter testimonials (Students/Parents) Dynamic loading: Load testimonials from API Responsive design: Mobile-optimized display Carousel integration: Splide carousel for testimonial display Animated statistics The odometer.js component provides animated number counting:\nFeatures:\nScroll-triggered: Animations trigger on scroll Smooth counting: Odometer theme integration Performance optimized: Efficient scroll detection Mobile support: Optimized for all devices Search functionality The SearchResults.vue component provides comprehensive search:\nFeatures:\nMulti-content search: Search across programs, blog posts, and pages Result categorization: Organized search results Image support: Results with and without images Tag display: Category tags for results Loading states: Skeleton loading screens Custom typography The website features a custom font family, TWK Everett, with:\nMultiple weights: From Hairline to Super Italic variants: All weights include italic versions Optimized formats: WOFF, WOFF2, and OTF formats Performance: Efficient font loading and rendering Development workflow The project uses Laravel Mix for asset compilation:\n// Development npm run dev // Compile assets npm run watch // Watch for changes npm run hot // Hot module replacement // Production npm run production // Optimized production build BrowserSync integration provides:\nLive reloading during development Synchronized browser testing Proxy configuration for WordPress development Performance optimizations Code splitting: Laravel Mix extracts vendor libraries Asset versioning: Automatic cache busting Image optimization: Lazy loading and responsive images Minification: Production builds are minified and optimized Tree shaking: Unused code elimination in production Font optimization: Efficient font loading strategies Accessibility Semantic HTML structure ARIA labels for interactive elements Keyboard navigation support Focus management in forms Screen reader considerations Proper alt text for images Conclusion and final thoughts Building the ISC Chile frontend from a Figma design was an excellent opportunity to:\nMaster Vue 2: Working with Options API, Vuex state management, and Vue 2 patterns Implement GSAP animations: Creating professional scroll-triggered animations Build complex forms: Multi-step forms with validation, date pickers, and input masking Create advanced filtering: Blog filtering with search and category selection Optimize performance: Implementing efficient animations and lazy loading Ensure design fidelity: Translating Figma designs into pixel-perfect implementations (with direct Figma references in code) The project demonstrates proficiency in:\nModern JavaScript frameworks (Vue 2) Animation libraries (GSAP, ScrollTrigger) Form validation and user experience (Vee-Validate, V-Mask, V-Calendar) Build tools and asset compilation (Laravel Mix, Webpack) CSS architecture and methodologies (SCSS, BEM) Component-based development State management (Vuex) Design system implementation The integration with WordPress/Themosis backend required careful consideration of server-side rendering, API endpoints, and content management workflows, making this a full-stack frontend implementation for an educational consultancy platform.\nLive website: https://www.iscchile.cl/\nFigma prototype: https://www.figma.com/proto/BfdKGJlzx7xAnE7rpZ1vda/Dise%C3%B1o-ISC?page-id=314%3A12071\u0026type=design\u0026node-id=314-12072\u0026viewport=-1452%2C930%2C0.29\u0026t=hFYiwcionjRAZ47v-1\u0026scaling=min-zoom\n","image":"//localhost:1313/images/project/isc-chile/home.png","permalink":"//localhost:1313/projects/isc-chile-educational-consultancy-website/","tags":["Vue 2","Laravel Mix","WordPress","Themosis","SCSS","GSAP","JavaScript","Figma"],"title":"ISC Chile: Educational Consultancy Website"},{"categories":["Projects"],"contents":"Chile Nativo is a travel tour website for Patagonia experiences, built on top of WordPress with the Themosis framework, featuring a modern frontend implementation based on a Figma design using Vue 3, Laravel Mix, and a comprehensive SCSS architecture.\nOutline The project Design implementation The stack Frontend architecture Key features Conclusion Live website The project Chile Nativo is a travel company specializing in Patagonia tours, offering experiences in destinations like Torres del Paine, Tierra del Fuego, and Isla Navarino. The website serves as the primary platform for showcasing tours, managing bookings, and providing information about their travel experiences.\nThe frontend development was based on a comprehensive Figma design, requiring pixel-perfect implementation of complex UI components, interactive forms, filtering systems, and responsive layouts that work seamlessly across all devices.\nDesign implementation The entire frontend was built from a detailed Figma design, ensuring:\nPixel-perfect accuracy: Matching the design specifications precisely Responsive design: Implementing breakpoints and mobile-first approach Component consistency: Maintaining design system patterns throughout Interactive elements: Translating static designs into dynamic, interactive components Animation and transitions: Implementing smooth user experience enhancements The stack The frontend stack consists of:\nVue 3.2.4: Modern reactive framework for building interactive components Laravel Mix 6.0: Asset compilation and bundling SCSS: Advanced styling with a well-organized architecture Pinia 2.3.1: State management for Vue applications Vee-Validate 4.15.0: Form validation with Yup schemas Axios 1.6.8: HTTP client for API requests Splide.js 4.1.4: Modern carousel and slider components Headroom.js: Header behavior on scroll Plyr 3.7.8: Video player implementation SweetAlert2: Modern alert dialogs jQuery 3.7.1: Legacy support and DOM manipulation utilities Frontend architecture Vue components The application features a comprehensive set of Vue 3 components organized by functionality:\nFiltering and Search Components:\nToursFilter.vue: Advanced tour filtering with multiple criteria TourDatesFilter.vue: Date-based filtering for tour availability ToursFilterDropdown.vue \u0026amp; ToursFilterDropdownMobile.vue: Responsive filter dropdowns TestimonialsFilter.vue: Filtering system for customer testimonials NewsFilter.vue: Blog and news filtering SearchResults.vue: Search results display with pagination Form Components:\nPersonalizedTripForm.vue: Multi-step form for custom trip requests with validation ContactFormSimple.vue: Contact form with reCAPTCHA integration FormHelp.vue: Help center form FormGiftCard.vue: Gift card purchase form FormCareers.vue: Job application form NewsletterForm.vue: Newsletter subscription Card Components:\nTour.vue \u0026amp; TourLoading.vue: Tour card display with loading states TourDate.vue \u0026amp; TourDateLoading.vue: Tour date selection cards Testimonial.vue \u0026amp; TestimonialLoading.vue: Customer testimonial cards Blog.vue \u0026amp; BlogLoading.vue: Blog post cards Team.vue \u0026amp; TeamLoading.vue: Team member cards ResourceCard.vue \u0026amp; ResourceLoading.vue: Resource display cards Utility Components:\nPagination.vue: Reusable pagination component Select.vue: Custom select dropdown with search Loader.vue \u0026amp; LoaderFullScreen.vue: Loading indicators EmptyState.vue: Empty state displays ContentResources.vue: Resource content management TeamTabsFilter.vue: Tabbed team member filtering SCSS architecture The styling follows a well-organized SCSS architecture:\nscss/ ├── abstracts/ # Variables, mixins, functions │ ├── _functions.scss │ ├── _mixins.scss │ ├── _variables.scss │ ├── _mq.scss # Media query mixins │ └── _keyframes.scss ├── base/ # Base styles and typography │ ├── _typography.scss │ ├── _colors.scss │ ├── _fonts.scss │ └── _reset.scss └── components/ # Component-specific styles └── [125 component files] Key SCSS features:\nBEM methodology: Consistent naming convention throughout Media query mixins: Using sass-mq for responsive design Modular architecture: Each component has its own SCSS file Abstract layer: Reusable variables, mixins, and functions Vue transitions: Custom transition styles for Vue components JavaScript architecture The JavaScript is organized into two main entry points:\nMain application (app.js):\nInitializes core application functionality Sets up jQuery plugins and utilities Handles legacy browser support Vue application (vue/main.js):\nConfigures Vue 3 app with Pinia for state management Registers global Vue components Sets up Vee-Validate configuration Integrates third-party Vue plugins (VueTelInput, etc.) Component utilities (app/components/):\nheader.js: Header behavior and navigation footer.js: Footer functionality splide.js: Carousel initialization slick.js: Legacy carousel support accordions.js: Accordion interactions tabs.js: Tab functionality scrollTrigger.js: Scroll-based animations video.js: Video player setup sticky-sidebar.js: Sticky sidebar behavior Key features Multi-step forms The PersonalizedTripForm.vue component implements a sophisticated multi-step form with:\nStep-by-step navigation with progress indicators Form validation using Vee-Validate and Yup schemas Dynamic form fields based on user selections Phone number input with international support (VueTelInput) reCAPTCHA integration for spam protection Loading states and error handling Advanced filtering system The tour filtering system (ToursFilter.vue) provides:\nMultiple filter criteria (destination, activity type, trip type, month) Real-time filtering with URL parameter synchronization Responsive design with mobile accordion interface Custom select components with search functionality Empty states and loading indicators Integration with WordPress backend via Axios Responsive design The entire website is fully responsive with:\nMobile-first approach Breakpoint management using sass-mq Touch-friendly interactions Optimized images and assets Performance optimizations for mobile devices Performance optimizations Code splitting: Laravel Mix extracts vendor libraries Asset versioning: Automatic cache busting Image optimization: Lazy loading and responsive images Minification: Production builds are minified and optimized Tree shaking: Unused code elimination in production Accessibility Semantic HTML structure ARIA labels where appropriate Keyboard navigation support Focus management in forms Screen reader considerations Development workflow The project uses Laravel Mix for asset compilation:\n// Development npm run dev // Compile assets npm run watch // Watch for changes npm run hot // Hot module replacement // Production npm run production // Optimized production build BrowserSync integration provides:\nLive reloading during development Synchronized browser testing Proxy configuration for WordPress development Conclusion and final thoughts Building the Chile Nativo frontend from a Figma design was an excellent opportunity to:\nMaster Vue 3: Working with the Composition API, reactive systems, and modern Vue patterns Implement complex forms: Multi-step forms with validation, international phone inputs, and reCAPTCHA Build scalable architecture: Organizing 40+ Vue components and 125+ SCSS files in a maintainable structure Optimize performance: Implementing code splitting, lazy loading, and production optimizations Ensure design fidelity: Translating Figma designs into pixel-perfect implementations Handle responsive design: Creating seamless experiences across all device sizes The project demonstrates proficiency in:\nModern JavaScript frameworks (Vue 3) Build tools and asset compilation (Laravel Mix, Webpack) CSS architecture and methodologies (SCSS, BEM) Form validation and user experience Component-based development Design system implementation The integration with WordPress/Themosis backend required careful consideration of server-side rendering, API endpoints, and content management workflows, making this a full-stack frontend implementation.\nLive website: https://chilenativo.travel/\nFigma prototype: https://www.figma.com/proto/ywHPhSP1UfYUAE8eWVQv4L/Dise%C3%B1o-Desktop---Chile-Nativo?node-id=289-3912\u0026m=dev\u0026scaling=min-zoom\u0026content-scaling=fixed\u0026page-id=289%3A3911\u0026starting-point-node-id=289%3A3912\n","image":"//localhost:1313/images/project/chile-nativo/home.png","permalink":"//localhost:1313/projects/chile-nativo-patagonia-travel-website/","tags":["Vue 3","Laravel Mix","WordPress","Themosis","SCSS","JavaScript","Figma"],"title":"Chile Nativo: Patagonia Travel Website"},{"categories":["Projects"],"contents":"Rutieri is a SaaS platform built with Strapi, React Native, Typescript and other technologies.\nOutline The idea Platform features The stack The API The frontend The mobile app Conclusion Landing Page The idea Before starting to write a single line of code, it is generally a good idea to think about the problem, it\u0026rsquo;s limitations and whether or not it has already been solved by someone else (AKA competitors).\nThe problem I was looking into had to do with the way in which public and private transportation companies manage their routes, drivers and users. This process is generally carried out on paper, e.g. not digital, hence this could be problematic in case of new drivers joining the organization or in case of restricting access to data to only specific users.\nAfter a little bit of research, I could only find one platform that provides a similiar solution but for their own company.\nPlatform features and user stories The following user stories illustrates the desired features the platform should have in order to solve the aforementioned problems.\nAs an administrator user, I want to: login in the admin panel. create an organization. create routes in the organization. invite drivers and users to the organization. manage requests to join the organization. assign routes to drivers in the organization. see in real time the drivers and users currently active in the map of the different routes. As a driver, I want to: login in the mobile app. join an organization by entering the code in the search bar. see my route on the map. become visible to passengers on the road. see the passengers waiting on the road. remove my visibility and finish my run. As a passenger, I want to: login in the mobile app. join an organization by entering the code in the search bar. see the different routes of my organization in the map. search for a destination and get the available routes that pass nearby. see the drivers currently active on the routes in real time. become visible to drivers of a route. The requirements The backend requires to handle user authentication, permissions, different data structures as content types and define relations between them. It\u0026rsquo;s also necessary to synchronise passengers and drivers and view them on a map real time in the administration panel as well as in the mobile app.\nThe administration panel is a web page that fetches data from the backend as well as from the real time data provider and it\u0026rsquo;s goal is to provide a way for administrators to manage their organization and users. We\u0026rsquo;re talking about a Single Page Application built in React.\nAs for the mobile application, there isn\u0026rsquo;t a better choice nowadays than React Native and it works just fine in this case.\nThe API Since all of the features involve authentication, permissions and roles, and because there is no need to reinvent the wheel, I chose to use Strapi to build the backend for it\u0026rsquo;s simplicity, ease of use and great developer experience, whereas for realtime data, I used Firebase.\nThe instance of Strapi and the Postgres database it requires was deployed in the cloud hosting platform https://fly.io.\nStrapi is good for managing users, content that\u0026rsquo;s typically updated and fetched via CRUD API, and relations between content types.\nThe platform needs the following content types:\nOrganizations to group routes, drivers and users Routes Two user roles: drivers and users (passengers) Below are some screenshots of the overview of these content types\nAs I said before, Strapi makes the creation of these content types and the relationships between them really straightforward.\nHowever, not everything related to the API can be provided by Strapi. Some realtime features need to be addressed with other solutions, such as geolocation data in real time for drivers and users to synchronise each other, maps and the ability to search for places. Such features were implemented using Firebase, Google Maps and Google Places.\nThe frontend The platform where users are able to login as administrators and manage their organizations and users is a single page web application built in React. Among the features of this project that I think stand out are:\nState managed by Context API Interface styled with Bootstrap React Router for pages Leaflet to display the map GeoFire library to synchronise geolocation data in real time with Firebase Use of localStorage to save user session Below are some sample screenshots of how this app looks like\nThe mobile application This one is by far the most complex part of this project.\nThe project was bootstraped with Infinitered\u0026rsquo;s Ignite, which provides a great boilerplate and surely saved me of what would have been between 1-2 months of work.\nIgnite\u0026rsquo;s boilerplate includes many features out of the box, including:\nReact Native and Typescript (of course) React Navigation MobX-State-Tree for state management Expo SDK for developer experience AsyncStorage for persistence apisauce as REST client And some other libraries and features that make React Native apps super powerful and a joy to work on.\nIt consists of three screens:\nWelcome screen Login screen Map screen In the welcome screen, users are able to go to the login screen if not logged in. Otherwise, if they\u0026rsquo;re in an organisation, it shows their role and org\u0026rsquo;s information, and if they\u0026rsquo;re not, they are able to enter the organisation code and request to join as driver or as passenger.\nWelcome screens Login screens If the user is a driver in an organisation, the welcome screen also shows the route assigned to them. By tapping on it, it takes them to the map, where they can see themselves and start the tour, becoming visible to passengers on the road but being able to see passengers on the road as well.\nDrivers can finish the tour at any time by pressing the button stop.\nIf the user is a passenger in an organisation, the welcome screen shows the different routes available in the organisation. By tapping on them, they are taken to the map where they can see themselves, the route and the drivers on the road.\nPassengers are able to navigate between the available routes and search for the location they want to go to by using the search bar at the top of the map screen, filtering out the routes that pass nearby (less than 200 meters), if there are. Google Places API and turf library work together in this search process.\nPassengers become visible to drivers on the road by pressing the button wait and if they press the button again, they stop waiting and are removed from the driver\u0026rsquo;s map.\nMap screens The start/wait and finish buttons dispatch actions that update their location in firebase, so that passengers are able to see the bus on the map as it moves in real time and viceversa.\nAs for the state management, the project consists of two models and three stores from Mobx-State-Tree library: User and Route models, user-status, route-store and root-store stores.\nUser model Located in /app/models/user/user.ts\nconst OrganizationModel = types.model({ name: types.string, code: types.string, id: types.identifierNumber, drivers: types.number, rutas: types.array(RouteModel) }) const UserModel = types .model(\u0026#34;User\u0026#34;) .props({ id: types.identifierNumber, username: types.string, email: types.string, token: types.string, role: types.union(types.literal(\u0026#34;passenger\u0026#34;), types.literal(\u0026#34;driver\u0026#34;)), ruta: types.maybeNull(RouteModel), organization: types.maybeNull(OrganizationModel), pending_request: types.maybeNull(OrganizationModel), }) Route model Located in /app/models/route/route.ts\nThis model follows the GeoJSON format for routes.\nconst RouteModel = types .model(\u0026#34;Ruta\u0026#34;) .props({ id: types.identifierNumber, name: types.string, latlong: types.maybeNull(types.model({ lat: types.number, longt: types.number })), coords: types.model({ type: FeatureTypes, features: types.array(types.model({ type: types.string, geometry: types.model({ type: types.string, coordinates: types.union(types.array(types.number), types.array(types.array(types.number))) }), properties: types.model({ name: types.string }) })) }) }) user-status store Located in /app/models/user-status/user-status.ts\nThis store is responsible for managing the state of the user. It stores the user once it\u0026rsquo;s logged in and removes it when the user logs out. It also has some views to get the user key for firebase purposes, get the role and get the route in case of a driver.\nThis store has some methods that get the user location from the device\u0026rsquo;s GPS, displays the user icon on the map and sends it to firebase.\nconst UserStatusModel = types .model(\u0026#34;UserStatus\u0026#34;) .extend(withEnvironment) .props({ user: types.maybeNull(UserModel), location: types.maybeNull( types.model({latitude: types.number, longitude: types.number}) ), visibility: types.maybeNull(types.number) }) route-store store Located in /app/models/route-store/route-store.ts\nThis store is responsible for managing the state of the available routes. It stores the routes, drivers and passengers on the different routes. It also has some view methods to filter the routes that pass nearby a destination specified by the user, get passengers waiting on a given route and get drivers active in a specific route.\nThis store initializes a GeoQuery from Geofire library and listens for events to set, update and remove drivers and passengers from the map as they move.\nconst RouteStoreModel = types .model(\u0026#34;RouteStore\u0026#34;) .props({ routes: types.array(RouteModel), passengers: types.map(types.model({ key: types.identifier, location: types.array(types.number) })), drivers: types.map(types.model({ key: types.identifier, location: types.array(types.number) })), destinationAddress: types.maybeNull(types.model({ name: types.string, coords: types.array(types.number) })) }) Conclusion and final thoughts Using a CMS as the backend can make the development a lot faster than building the API from scratch and with Strapi this is specially true. On the other hand, Strapi doesn\u0026rsquo;t really make a good fit for real time applications, therefore, Firebase is the way to go in this case.\nAs of the client side, React always works very good for pretty much any kind of application, and because React Native uses React under the hood, it is so convenient for us React developers and ir works pretty good for almost any kind of application as well.\nHowever, one thing that I didn\u0026rsquo;t mention in this post was the use of Typescript; I find this quote by Brice Wilson pretty good to point out the whole purpose and motivation to learn and use (well) this powerful language and tool ecosystem:\n\u0026ldquo;You won\u0026rsquo;t have to wait for a frustrated user to report the error. All of this means that you provide value to your users faster, and that\u0026rsquo;s really what it\u0026rsquo;s all about.\u0026rdquo;\nAll in all, I got a lot of learning by building this project, both in languages/frameworks used and production stuff such as infrastructure, cloud hosting and cloud-based APIs.\nProject landing page: https://rutieri.netlify.app\n","image":"//localhost:1313/images/project/rutieri/landing/homepage.webp","permalink":"//localhost:1313/projects/saas-platform-rutieri/","tags":["Strapi","React Native","React","Typescript","Firebase"],"title":"SaaS platform: Rutieri"},{"categories":["Tutorial"],"contents":"Enable comments in a Strapi application and display them in the frontend with React\nOutline Introduction Prerequisites What is Strapi Comment Manager? Installation Configuration Display comments on the frontend Installation of Strapi Comments Client Usage of Strapi Comments Client Plugin settings Manage comments Full source code of the frontend Conclusion Introduction A comment system comes in very handy for pretty much any kind of website. In the JAMstack ecosystem, while it\u0026rsquo;s ok to rely on third party solutions hosted on their own platform such as Disqus to enable comments, you usually want to keep your content and all the stuff related to it in the same admin dashboard.\nIn this article, I\u0026rsquo;ll show you how to enable and manage comments for your content very easily using the Comment Manager plugin, and display them in your frontend application.\nPrerequisites You should have a basic understanding of the following.\nBasic knowledge of JavaScript Basic knowledge of React (OPTIONAL) Basic understanding of Strapi - get started here. Your Strapi V4 project setup What is Strapi Comment Manager? Strapi Comment Manager is a plugin that enables comments for pretty much any kind of content. It allows your users to post comments and anyone can get the comments associated with a given slug.\nWith this plugin, admin users can view and manage very easily all the comments from the Strapi administration dashboard. Within the dashboard, you will be able to delete comments and subcomments and leave replies on comments.\nInstallation Once into the Strapi project root, you can install the plugin by running the following command:\nnpm install strapi-plugin-comment-manager Next, build the project to see the new plugin in the dashboard with the following command:\nnpm run build And that\u0026rsquo;s it! If everything runs correctly, the plugin should now be installed.\nConfiguration Now you need to enable some permissions so that the frontend can access the endpoints to post and fetch comments.\nIn your Strapi admin dashboard, head over to Settings, then over to Roles under Users \u0026amp; Permissions Plugin.\nLet\u0026rsquo;s first setup the Public API; click on Public and hit the dropdown button of Comment Manager. Now check count, find and getPageSize, then hit the Save button. Below is a screenshot of a proper configuration:\nNow let\u0026rsquo;s setup the Authenticated API. Go back to Roles and click on Authenticated. Open the dropdown for Comment Manager and mark as checked the option create on both Comment and Subcomment. Below is a screenshot of a proper configuration:\nWith this configuration, the frontend should now be able to make requests to get and post comments.\nDisplay comments on the frontend The plugin exposes an API to get and post comments if you want to have fine-grained control over the workflow of your comments system and you can check the documentation on the package page, but this plugin also comes with a purpose-built React component library that makes it super easy to get up and running without getting your hands dirty.\nThis components library is called strapi-comments-client, fully supports typescript and it handles for you all of the complexity of fetching and posting comments and subcomments for every content ID that you pass to it.\nInstallation of Strapi Comments Client You will need to have installed react ^17.0.2, react-dom ^17.0.2 and react-router-dom ^5.2.0.\nInside of your React project, run this command:\nnpm install strapi-comments-client --save Usage of Strapi Comments Client Using this library is very easy!\nThis library exports three main components:\nCommentsProvider Comments CommentForm And you can import them this way:\nimport { CommentsProvider, Comments, CommentForm } from \u0026#34;strapi-comments-client\u0026#34; All you have to do is wrap your App component into the CommentsProvider component. Then you will be able to place anywhere in your app the Comments component to render a list of comments for a given content ID and the CommentForm component to render a form to post comments.\nFor example, this could be your index.js or main.js file:\nimport React from \u0026#39;react\u0026#39; import ReactDOM from \u0026#39;react-dom\u0026#39; // The address of your strapi backend instance const STRAPI = \u0026#34;http://localhost:1337\u0026#34; ReactDOM.render( \u0026lt;React.StrictMode\u0026gt; \u0026lt;CommentsProvider apiURL={STRAPI}\u0026gt; \u0026lt;App /\u0026gt; \u0026lt;/CommentsProvider\u0026gt; \u0026lt;/React.StrictMode\u0026gt;, document.getElementById(\u0026#39;root\u0026#39;) ) Where apiURL is the URL of your running Strapi application, and this property is required.\nThis way, the comments provider will do all the magic of fetching and posting comments for you!\nThis library also exports an utility React.Context to update some of the parameters for fetching and posting comments:\nimport { CommentsConfigContext } from \u0026#34;strapi-comments-client\u0026#34; This CommentsConfigContext exposes two setter functions: setUser and setContentID\nWith setContentID you can load the comments for a given content and post comments to it. It receives a single parameter of type string and must be URLized, i.e. no spaces.\nWith setUser you can set the credentials of a given user to authorize the posting of comments. It receives a single parameter of type IUser, with the following Typescript interface:\ninterface IUser { username: string, email: string, id: string, token: string // This is a JWT } It\u0026rsquo;s a little confusing but we\u0026rsquo;ll see how to use it in a component:\nconst App = () =\u0026gt; { const { setUser, setContentID } = useContext(CommentsConfigContext) // The following data should come from Strapi Users and Permissions Plugin // for authenticated requests const user = { username: \u0026#34;John Doe\u0026#34;, email: \u0026#34;jhohndoe@gmail.com\u0026#34;, id: 5, token: \u0026#34;this_should_be_a_JWT\u0026#34; } if (user) { setUser(user) } setContentID(\u0026#34;sample-content-1\u0026#34;) // Load comments for this content return ( \u0026lt;\u0026gt; { !user \u0026amp;\u0026amp; \u0026lt;Login /\u0026gt; } \u0026lt;CommentForm /\u0026gt; \u0026lt;Comments /\u0026gt; \u0026lt;/\u0026gt; ) } And that\u0026rsquo;s it!\nAfter setting the content ID through setContentID, CommentsProvider will start loading the comments for the given content ID and the CommentForm will render an input to post comments related to the given content ID if there is a user. Otherwise, it will display the message Login to post a comment.\nHere\u0026rsquo;s how the interface looks like so far:\nThere\u0026rsquo;s also a button to Leave a reply, which will open a form to post a subcomment associated with the parent comment.\nThis library exports one more component: ErrorBox\nimport { ErrorBox } from \u0026#34;strapi-comments-client\u0026#34; .It\u0026rsquo;s useful if you\u0026rsquo;d like to display error messages when things go wrong fetching or posting comments.\nYou can place this component wherever you want, for example in between the CommentForm and the Comments components.\nIf you\u0026rsquo;re wondering how this error box looks like, here you have a sample:\nGeneral settings You can customize the page size, i.e. specify how many comments are returned at once.\nIn the Strapi admin panel, head over to Settings, then select Pagination under Comment Manager Plugin.\nHere you\u0026rsquo;ll find an input to set the page size, which defaults to 10.\nManage comments Once you\u0026rsquo;ve got the plugin up an running, as users start to post comments, you can manage and reply to them as admin from the Comment Manager section of the left sidebar in the Strapi admin dashboard.\nHere you can see two tabs: one for the latest comments and one for comments grouped by content ID.\nIn both of them you can delete comments and subcomments as well as leave replies.\nExample project You can find a full working example of a React App using the Strapi Comments Client Library in this repo\nConclusion With this plugin you can enable and manage comments for any content with little effort and even use a component library to display the comments in your frontend application made with React.\nAnd that\u0026rsquo;s it! The features are pretty basic at the moment but if there\u0026rsquo;s interest, I\u0026rsquo;m willing to work on more features as well as improve the UI/UX.\n","image":"//localhost:1313/images/post/strapilogo.jpg","permalink":"//localhost:1313/blogs/how-to-enable-and-manage-comments-in-your-strapi-application/","tags":["Strapi","Strapi tutorials"],"title":"How To Enable And Manage Comments In Your Strapi Application."},{"categories":["Documentation"],"contents":"Comment Manager is a Strapi plugin to allow your users to post comments.\nWith this plugin you can enable and manage comments for your content very easily!\nRequirements You should have installed an instance of Strapi v4.x.x\nInstallation Run the following command in your project root:\nnpm install strapi-plugin-comment-manager Configurarion For your frontend to have access to the API, enable the following permissions for Comment Manager from Users \u0026amp; Permissions Plugin on your project settings:\nFor public, enable: count, find and getPageSize.\nFor authenticated, enable create on both Comment and Subcomment.\nDisplay comments on the frontend Comments can be displayed in the frontend in two ways:\nUsing the React components library strapi-comments-client (recommended) Build your custom frontend using the API API There are some Typescript interfaces that will help to get an idea of the data structures.\nComments: interface IComment { id: string, from_admin: boolean, createdAt: string, content: string, author: IAuthor | null, subcomments?: ISubcomment[] } Subcomments: interface ISubcomment { id: string, from_admin: boolean, createdAt: string, content: string, author: IAuthor | null, } Authors: IAuthor { username: string, email: string, id: string } The following endpoints are exposed to fetch and post comments and subcomments:\nGet comments for a content ID Method: GET\nPath: /api/comment-manager/comments/:slug\nOptional query parameters: start, ignoreCount\nReturns:\n{ commentsCount?: Number, comments: IComment[] } The parameter start indicates how many comments to skip. This is for pagination purposes.\nThe parameter ignoreCount indicates whether or not to return the total number of comments associated with the given slug.\nGet the number of comments associated with a given content ID Method: GET\nPath: /api/comment-manager/comments/:slug/count\nReturns:\n{ count: Number } Post a comment Method: POST\nPath: /api/comment-manager/comments/:slug\nAuthentication: Bearer token\nPayload:\n{ content: string } Returns:\n{ id: Number } Post a subcomment Method: POST\nPath: /api/comment-manager/subcomments/:parent-id\nAuthentication: Bearer token\nPayload:\n{ content: string } Returns:\n{ id: Number } Get the page size Method: GET\nPath: /api/comment-manager/page-size\nReturns:\n{ pageSize: Number } General settings The plugin allows to set how many comments are returned per page by going to the Pagination section under Comment Manager Plugin on the Settings section.\nThe default page size is 10.\nManagement of comments Admin users are able to delete comments and subcomments as well as leave replies as admins from within the plugin page of the Strapi admin dashboard.\nThe plugin interface has two tabs: one for the latest comments and one for comments by content ID.\nRoadmap and future plans The plugin is pretty basic but it can be improved with more features and a better UI/UX. Collaborations and suggestions are very welcome.\n","image":"//localhost:1313/images/post/strapilogo.jpg","permalink":"//localhost:1313/blogs/strapi-plugin-comment-manager/","tags":["Strapi","Strapi plugins"],"title":"Strapi Plugin Comment Manager"},{"categories":["Projects"],"contents":"In this post I’m going to share my experience on building a SaaS using the headless CMS Strapi as the Backend, React Native and other technologies.\nOutline Introduction What is SaaS? The problem What is Strapi? Developing features in Strapi The frontend: How to get content Conclusion Landing Page Introduction Very often, developers, product and project managers, testers and pretty much the entire team share their ideas to decide what language and which framework they\u0026rsquo;ll use to build their next project. Some considerations must be taken into account, from which in my opinion there are three that are the most important:\nDeveloper experience and ease of use Does the language and framework chosen provide a good developer experience? Is the langauge the same for the backend and frontend?\nDeadlines Is there a deadline to finish the project? if so, there is a good chance to finish the project on time if the team chooses the language they have more experience in.\nMaintainability As there will be usually more than one person working on the same part at the same time, if everything is kept organised, the whole development process will be frictionless.\nWith that in mind, developers and project managers will have a better insight on which language/framework to use.\nOther aspects should also be considered such as what the data structure will look like.\nIn my case, as it is usual, the backend of my project needs a database for users and their roles among other entities and their relations and a dashboard to allow admins to manage the data, and I was lucky to find out Strapi, as it includes a lot of these features out of the box with one single line of command to get started.\nWhat is SaaS? SaaS stands for Software-as-a-Service and it just means that a software is provided as a service in the cloud and it gives a solution to a specific problem, for which the users are willing to pay either monthly or annual subscription.\nThe problem Before starting to write a single line of code, it is generally a good idea to think about the problem, it\u0026rsquo;s limitations and whether or not it has already been solved by someone else (AKA competitors).\nThe problem I was looking into had to do with the way in which public and private transportation companies manage their routes, drivers and users. After a little bit of research, I could only find one platform that provides a similiar solution but for their own company.\nSo the platform I built needed the following content types:\nOrganizations to group routes, drivers and users Routes Two user roles: drivers and users (passengers) As I said before, Strapi makes the creation of these content types and the relationships between them really easy, but let\u0026rsquo;s first see what is Strapi and how it turns the API development into a satisfactory and fun experience.\nWhat is Strapi? Strapi is an open source headless CMS that allows developers to build complete RESTful APIs in just a couple of days instead of months. It includes a lot of useful features as plugins out of the box. Users and Roles management, Media library and an interface to create, view, edit and delete content are just some of them.\nRegarding the API, how does it makes the development faster?\nFirst of all, it enforces a specific folder structure, which helps to keep everything well organised and clean.\nSecondly, all database schemas are generated automatically and queries are made in JSON format, which really saves a lot of time.\nLastly, we can add more features to our Strapi application very easily via plugins from the marketplace.\nIt\u0026rsquo;s also worth noting that Strapi is a self-hosted CMS, which means that we can host it in whatever cloud platform we want, as well as test it locally in our computers before deploying it to the cloud.\nDeveloping features in Strapi Creating and configuring endpoints in Strapi is as straightforward as declaring a JSON in a single file:\nCreating controllers is straightforward as well:\nEvery controller gets all the data related to the request in the ctx parameter and it\u0026rsquo;s also used to send the response. This keeps everything in one place and really helps to improve the readability.\nOnce the API endpoints are defined, the next step is to enable the permissions for the specific user roles to have access to these endpoints:\nThe frontend: how to get content Since Strapi is a headless CMS, it\u0026rsquo;ll only provide content through the API. That means that the content can be consumed from anywhere. In our case, this content will be used in two applications: one for the organization owners and one for the users and drivers.\nThe application for the organization owners is a dashboard where administrators can create organizations, routes, accept drivers and users in the organization and assign routes to drivers. This is just a React Application:\nThe application for drivers and users is a mobile application built in React Native. Firebase was used to synchronise geolocation data in real time between drivers and users and display this information in a Map from Google Maps:\nConclusion Using a CMS as the backend can make the development a lot faster than building the API from scratch and with Strapi this is specially true. Furthermore, this becomes more important when building a brand-new product, as it\u0026rsquo;s usually recommended to launch as soon as possible to gather feedback from the users and validate the idea.\nProject landing page: https://rutieri.netlify.app\n","image":"//localhost:1313/images/post/03.webp","permalink":"//localhost:1313/blogs/how-i-built-a-saas-on-top-of-strapi-and-why-you-should-too/","tags":["Strapi","React Native","Typescript"],"title":"How I Built A SaaS On Top Of Strapi, And Why You Should Too"},{"categories":["Tutorial"],"contents":"Enable User Reviews in a Strapi application and display them in the frontend with React\nOutline Introduction Prerequisites What is Strapi Ratings? Installation Configuration Display user reviews on the frontend Plugin settings Manage user reviews Full source code of the frontend Conclusion Introduction Ratings systems have become a crucial part of any website with ecommerce capabilites, as they allow the users to post reviews on the items they purchase and publish their opinion to the public. A couple of reviews can make the difference between pressing the “Buy” button and moving on to the next website in the Google search results.\nIn this article, I\u0026rsquo;ll show you how to enable and manage user reviews for your content very easily using the Ratings plugin, and display them in your frontend application.\nPrerequisites First of all, you need to have a basic understanding of the following.\nBasic knowledge of JavaScript Basic knowledge of React (OPTIONAL) Basic understanding of Strapi - get started here. Your Strapi V4 project setup What is Strapi Ratings? Strapi Ratings is a plugin that gives your Strapi application the ability to manage ratings for pretty much any kind of content. It allows your users to post reviews and anyone can get the reviews associated with a given slug.\nWith this plugin, admin users can view and manage very easily all the reviews from the Strapi administration dashboard. Within the dashboard, you will be able to see reviews related to content slugs as well as delete reviews.\nInstallation Once into the Strapi project root, you can install the plugin by running the following command:\nnpm install strapi-plugin-ratings Next, build the project to see the new plugin in the dashboard with the following command:\nnpm run build And that\u0026rsquo;s it! If everything runs correctly, the plugin should now be installed.\nConfiguration Now you need to enable some permissions so that the frontend can access the endpoints to post and fetch reviews.\nIn your Strapi admin dashboard, head over to Settings, then over to Roles under Users \u0026amp; Permissions Plugin.\nLet\u0026rsquo;s first setup the Public API; click on Public and hit the dropdown button of Ratings. Now check count, find, getPageSize and getStats, then hit the Save button. Below is a screenshot of a proper configuration:\nNow let\u0026rsquo;s setup the Authenticated API. Go back to Roles and click on Authenticated. Open the dropdown for Ratings and mark as checked the options create, find and getUserReview. Below is a screenshot of a proper configuration:\nWith this configuration, the frontend should now be able to make requests to get and post user reviews.\nDisplay use reviews on the frontend The plugin exposes an API to get and post reviews if you want to have fine-grained control over the workflow of your ratings system and you can check the documentation on the package page, but this plugin also comes with a purpose-built React component library that makes it super easy to get up and running without getting your hands dirty.\nThis components library is called strapi-ratings-client, fully supports typescript and it takes care of all the complexity of fetching and posting user reviews for every content ID that you pass to it.\nInstallation of Strapi Ratings Client You will need to have installed react ^17.0.2, react-dom ^17.0.2, bootstrap ^5.1.3 and @popperjs/core^2.11.2\nInside of your React project, run this command:\nnpm install strapi-ratings-client --save Usage of Strapi Ratings Client Using this library is very easy!\nThis library exports three main components:\nReviewsProvider Reviews ReviewForm And you can import them this way:\nimport { ReviewsProvider, Reviews, ReviewForm } from \u0026#34;strapi-ratings-client\u0026#34; All you have to do is wrap your App component into the ReviewsProvider component. Then you will be able to place anywhere in your app the Reviews component to render a list of user reviews for a given content ID and the ReviewForm component to render a form to allow your users to post reviews.\nFor example, this could be your index.js or main.js file:\nimport React from \u0026#39;react\u0026#39; import ReactDOM from \u0026#39;react-dom\u0026#39; // The address of your strapi backend instance const STRAPI = \u0026#34;http://localhost:1337\u0026#34; ReactDOM.render( \u0026lt;React.StrictMode\u0026gt; \u0026lt;ReviewsProvider apiURL={STRAPI}\u0026gt; \u0026lt;App /\u0026gt; \u0026lt;/ReviewsProvider\u0026gt; \u0026lt;/React.StrictMode\u0026gt;, document.getElementById(\u0026#39;root\u0026#39;) ) Where apiURL is the URL of your running Strapi application, and this property is required.\nThis way, the ratings provider will do all the magic of fetching and posting comments for you!\nThis library also exports an utility React.Context to update some of the parameters for fetching and posting reviews:\nimport { ReviewsConfigContext } from \u0026#34;strapi-ratings-client\u0026#34; This ReviewsConfigContext exposes three setter functions: setUser, setContentID and setCanPostReview.\nWith setContentID you can load the ratings for a given content and post reviews to it. It receives a single parameter of type string and must be URLized, i.e. no spaces.\nWith setUser you can set the credentials of a given user to authorize the posting of reviews. It receives a single parameter of type IUser, with the following Typescript interface:\ninterface IUser { username: string, email: string, id: string, token: string // This is a JWT } With setCanPostReview, you can enable the user to post a review on the given content. This is useful for when you only allow a user to post a review after they purchase the product.\nIt\u0026rsquo;s a little confusing but we\u0026rsquo;ll see how to use it in a component:\nconst App = () =\u0026gt; { const { setUser, setContentID, setCanPostReview } = useContext(ReviewsConfigContext) // The following data should come from Strapi Users and Permissions Plugin // for authenticated requests. const user = { username: \u0026#34;John Doe\u0026#34;, email: \u0026#34;jhohndoe@gmail.com\u0026#34;, id: 5, token: \u0026#34;this_should_be_a_JWT\u0026#34; } if (user) { setUser(user) } setContentID(\u0026#34;sample-content-1\u0026#34;) // Load reviews for this content setCanPostReview(true) // Allow this user to post a review return ( \u0026lt;\u0026gt; { !user \u0026amp;\u0026amp; \u0026lt;Login /\u0026gt; } \u0026lt;ReviewForm /\u0026gt; \u0026lt;Reviews /\u0026gt; \u0026lt;/\u0026gt; ) } And that\u0026rsquo;s it!\nAfter setting the content ID through setContentID, ReviewsProvider will start loading the reviews for the given content ID and the ReviewForm will render an input to post a user review related to the given content ID if there is a user and he’s allowed to post a review. Otherwise, it will display the message Login to post a review or nothing at all if the user is not allowed to post a review.\nHere\u0026rsquo;s how the interface looks like so far:\nThis library exports one more component: ErrorBox\nimport { ErrorBox } from \u0026#34;strapi-ratings-client\u0026#34; .It\u0026rsquo;s useful for when you\u0026rsquo;d like to display error messages when things go wrong fetching or posting reviews.\nYou can place this component wherever you want, for example in between the ReviewForm and the Reviews components.\nIf you\u0026rsquo;re wondering how this error box looks like, here‘s a screenshot:\nGeneral settings You can customize the page size, i.e. specify how many user reviews are showed at once.\nIn the Strapi admin panel, head over to Settings, then select Pagination under Ratings Plugin.\nHere you\u0026rsquo;ll find an input to set the page size, which defaults to 10.\nManage reviews Once you\u0026rsquo;ve got the plugin up an running, as users start to post reviews, you can view them from within the Ratings section of the left sidebar in the Strapi admin dashboard.\nHere you can see two tabs: one for the latest reviews and one for reviews grouped by content ID.\nIn both of them you can delete unwanted reviews.\nExample project You can find a full working example of a React App using the Strapi Ratings Client Library in this repo: https://github.com/luisguve/strapi-ratings-client-example\nConclusion With this plugin you can enable and manage user reviews for any content with little effort and even use a library of components styled with Bootstrap to display the user reviews in your frontend.\nAnd that\u0026rsquo;s it! The features are pretty basic at the moment but if there\u0026rsquo;s interest, I\u0026rsquo;m willing to work on more features as well as improve the UI/UX.\n","image":"//localhost:1313/images/post/tutorial-ratings.webp","permalink":"//localhost:1313/blogs/how-to-enable-and-manage-user-reviews-in-your-strapi-application/","tags":["Strapi","Strapi tutorials"],"title":"How To Enable And Manage User Reviews In Your Strapi Application"},{"categories":["Documentation"],"contents":"Ratings is a Strapi plugin that allows your users to post reviews.\nEnable and manage user reviews for your content very easily!\nRequirements You should have installed an instance of Strapi v4.x.x\nInstallation Run the following command in your project root:\nnpm install strapi-plugin-ratings Then, rebuild the admin dashboard using the following command\nnpm run build Configurarion For your frontend to have access to the API, enable the following permissions for Ratings from Users \u0026amp; Permissions Plugin on your project settings:\nFor public, enable: count, find, getPageSize and getStats.\nFor authenticated, enable create, find and getUserReview.\nDisplay user reviews on the frontend Reviews can be displayed in the frontend in two ways:\nUsing the React components library strapi-ratings-client (recommended) Build your custom frontend using the API endpoints, described as follows: API There are some Typescript interfaces that will help to get an idea of the data structures.\nReviews: interface IReview { id: number, createdAt: string, comment: string | null, author: IAuthor | null, score: number, } Authors: interface IAuthor { username: string, email: string, id: number } Content Stats interface IStats { averageScore: number; reviewsCount: number | null; } The following endpoints are exposed to fetch and post reviews:\nGet reviews for a content ID Method: GET\nPath: /api/ratings/reviews/:slug\nOptional query parameters: start, ignoreCount\nReturns:\n{ reviewsCount: number, averageScore: number, userReview: IReview | null, reviews: IReview[] } The parameter start indicates how many reviews to skip. This is for pagination purposes.\nThe parameter ignoreCount indicates whether or not to return the total number of reviews associated with the given slug.\nGet review stats for a content ID Method: GET\nPath: /api/ratings/reviews/:slug/stats\nReturns:\n{ averageScore: number, reviewsCount: number | null } Get the number of reviews associated with a given content ID Method: GET\nPath: /api/ratings/reviews/:slug/count\nReturns:\n{ count: number } Post a review Method: POST\nPath: /api/ratings/reviews/:slug\nAuthentication: Bearer token\nPayload:\n{ content: string } Returns:\n{ id: number } By default, every authenticated user can post reviews on any content.\nIn order to customize this behavior, e.g. allowing or disallowing a user from posting reviews, you must extend the service userCanPostReview from whithin register function in ./src/index.js. For example:\nstrapi.service(\u0026#34;plugin::ratings.review\u0026#34;).userCanPostReview = async (user, slug) =\u0026gt; { /* Here you will check whether or not the user is allowed to post a review on this content ID and return either true or false. */ return true } Notice that userCanPostReview will receive two parameters: the user from Users \u0026amp; Permissions Plugin, containing it\u0026rsquo;s id, username, confirmed, etc., and the slug, which is a string and refers to the content ID which the review is being posted on.\nIn case this function returns false, the response of the endpoint will be 403 (forbidden) with the text User cannot post a review on this content.\nGet the page size Method: GET\nPath: /api/ratings/page-size\nReturns:\n{ pageSize: number } General settings The plugin allows to set how many reviews are returned per page by going to the Pagination section under Ratings Plugin of the Settings section.\nThe default page size is 10.\nManagement of reviews Admin users are able to delete reviews from within the plugin page of the Strapi admin dashboard.\nThe plugin interface has two tabs: one for the latest reviews and one for reviews by content ID.\nRoadmap and future plans The plugin is pretty basic but it can be improved with more features and a better UI/UX. Collaborations and suggestions are very welcome.\n","image":"//localhost:1313/images/post/ratings.webp","permalink":"//localhost:1313/blogs/strapi-plugin-ratings/","tags":["Strapi","Strapi plugins"],"title":"Strapi Plugin Ratings"},{"categories":["Projects"],"contents":"ManyLMS is an e-learning platform built on top of Strapi, React Router 7, Typescript and other technologies.\nOutline The idea Platform features The stack The API The frontend Conclusion Landing Page The idea This project doesn\u0026rsquo;t necessarily bring a huge amount of innovation on the e-learning platforms that already exists, but it\u0026rsquo;s just another way of doing this type of application.\nThe main idea is to apply a JAMstack approach in this application, where the platform is a static website, and the backend is just an API that serves static content only once to build the website and just adds the dynamism that\u0026rsquo;s necessary to allow users to authenticate, create orders, confirm payments and take courses.\nIf we compare this approach to a WordPress website, we are taking out most of the overhead that implies rendering the pages everytime a user visits them. Despite that there are plugins for caching that may improve the performance, it\u0026rsquo;s still never going to be faster and more efficient than just static content served by a CDN. That\u0026rsquo;s why React Router 7 and Headless CMSs are so popular right now.\nPlatform features and user stories The following user stories illustrates the desired features the platform should have.\nAs an administrator, I want to: login in the admin panel. create categories. create courses. upload lectures. organise courses into categories. assign lectures to courses. As a student, I want to: login in the platform. view the available courses. add courses to the shopping cart. review the shopping cart. create an order. pay with credit card or paypal. view the courses i\u0026rsquo;ve purchased in my learning page. go to the course page from my learning page and watch the videos. mark lectures as seen. come back later and resume where I left. The requirements The backend requires to handle user authentication, permissions, different data structures as content types and define relationships between them. It also requires to allow uploading videos to some third party platform that supports streaming on demand.\nThe frontend is a web platform where users can register and login, view and buy courses, leave comments and reviews and take courses.\nThe API Since all of the features involve authentication, permissions and roles, and because there is no need to reinvent the wheel, I chose to use Strapi to build the backend for it\u0026rsquo;s simplicity, ease of use and great developer experience, whereas for streaming videos on demand, I chose to use Mux.com.\nThe instance of Strapi and the Postgres database it requires was deployed in the cloud hosting platform https://fly.io.\nStrapi is good for managing users, content that\u0026rsquo;s typically updated and fetched via CRUD API, and setting up relations between content types.\nThe platform needs the following content types:\nCategory to group courses Course Lecture Module to group lectures Order Student: has many courses Student-Course: stores a student\u0026rsquo;s current lecture of a course Video Strapi makes the creation of these content types and setting up relationships between them really straightforward.\nBelow are some screenshots of these content types and the relationships between them:\nThe frontend The platform where users are able to login, view, buy and view courses is a web application built with React Router 7. Among the features of this application are:\nState managed by Context API Interface styled with Bootstrap Play streaming videos with @mux/mux-player-react library Use of localStorage to save user session Below are some sample screenshots of how this app looks like\nConclusion and final thoughts While building this project, I learned:\nHow streaming on demand works and how to use a streaming provider How to statically build websites with React Router 7 and Strapi How to setup dynamic pages in React Router 7 How to process payments with Stripe and Paypal How to build custom plugins in Strapi How to publish packages to NPM Project source codes: https://github.com/luisguve/maestro-backend\nhttps://github.com/luisguve/new-lms-remix\n","image":"//localhost:1313/images/project/manylms/frontend/course_overview.png","permalink":"//localhost:1313/projects/e-learning-platform-maestro-lms/","tags":["Strapi","React","React Router 7","Typescript","Mux"],"title":"ManyLMS: E-Learning platform"},{"categories":["Projects"],"contents":"ETMday (Emprende tu Mente) is a large-scale entrepreneurship event website built on top of WordPress with the Themosis framework, featuring an interactive SVG map, real-time countdown timers, advanced search functionality, and comprehensive content management using Vue 3, Laravel Mix, and modern frontend technologies.\nOutline The project Key features The stack Frontend architecture Interactive components Conclusion Live website The project ETMday is Chile\u0026rsquo;s premier entrepreneurship event, bringing together thousands of entrepreneurs, startups, corporates, and strategic partners. The website serves as the central hub for event information, featuring speakers, activities, stands, program schedules, and an interactive event map.\nThe frontend development required implementing complex interactive features including an SVG-based interactive map with tooltips, real-time countdown timers, advanced filtering and search systems, and dynamic content displays that handle thousands of attendees and hundreds of activities.\nKey features The website includes several sophisticated features:\nInteractive SVG Map: Custom-built interactive map with clickable zones, tooltips, and dynamic content display Real-time Countdown: Event countdown timer with automatic updates and mobile optimization Advanced Search: Multi-category search across activities, speakers, stands, and content Dynamic Filtering: Complex filtering system with tabs, favorites, and downloadable resources Animated Statistics: Odometer animations for displaying event metrics Content Management: Comprehensive card components for activities, speakers, stands, and blog posts Form Handling: Multi-step forms with validation using Vee-Validate Lightbox Galleries: Image galleries with LightGallery integration Responsive Design: Fully responsive design optimized for all devices The stack The frontend stack consists of:\nVue 3.2.4: Modern reactive framework for building interactive components Laravel Mix 6.0: Asset compilation and bundling SCSS: Advanced styling with organized architecture Vee-Validate 4.15.0: Form validation with Yup schemas Axios 1.6.8: HTTP client for API requests Splide.js 4.1.4: Modern carousel and slider components LightGallery 2.8.3: Lightbox gallery functionality Odometer 0.4.8: Animated number counting Headroom.js: Header behavior on scroll jQuery 3.7.1: DOM manipulation and legacy support SweetAlert2: Modern alert dialogs GLightbox 3.3.1: Alternative lightbox solution Frontend architecture Vue components The application features a comprehensive set of Vue 3 components:\nCard Components:\ncards/activities.vue: Activity cards with favorites functionality cards/speakers.vue: Speaker cards with modal details cards/stands.vue: Stand/exhibitor cards cards/blog.vue: Blog post cards cards/shortcut.vue: Quick access shortcut cards Functional Components:\nSectionCards.vue: Main section component with tabs, filtering, and card display Search.vue: Advanced search component with multi-category results Form.vue: Dynamic form component with validation FormCalendar.vue: Calendar form component CustomFilter.vue: Reusable filter component CustomSelect.vue: Custom select dropdown Pagination.vue: Pagination component JavaScript components The application includes 17 specialized JavaScript components:\nInteractive Features:\ninteractiveMap.js: SVG map interaction with tooltips, zones, and dynamic content countdown.js: Real-time countdown timer with automatic updates odometer.js: Animated number counting with scroll triggers map.js: Map zone interactions and modal displays UI Components:\nheader.js: Header functionality and navigation headroom.js: Header hide/show on scroll accordion.js: Accordion interactions tabs.js: Tab functionality cards.js: Card interactions and modals siteModals.js: Modal management system UI.js: General UI utilities Media Components:\nvideo.js: Video player setup lightgallery.js: Lightbox gallery initialization splide.js: Carousel initialization slick.js: Legacy carousel support Utilities:\nscrollTrigger.js: Scroll-based animations imgToSvg.js: SVG image conversion utility SCSS architecture The styling follows a well-organized SCSS architecture:\nscss/ ├── abstracts/ # Variables, mixins, functions │ ├── _functions.scss │ ├── _mixins.scss │ ├── _variables.scss │ ├── _mq.scss # Media query mixins │ └── _keyframes.scss ├── base/ # Base styles and typography │ ├── _typography.scss │ ├── _container.scss │ └── _reset.scss └── components/ # Component-specific styles └── [52 component files] Key SCSS features:\nBEM methodology: Consistent naming convention Media query mixins: Using sass-mq for responsive design Modular architecture: Each component has its own SCSS file Component organization: 52 component-specific SCSS files Interactive components Interactive SVG Map The interactiveMap.js component implements a sophisticated SVG-based interactive map:\nFeatures:\nSVG Tooltips: Dynamically generated tooltips with text wrapping Zone Interactions: Clickable zones with modal displays Point Markers: Interactive points with icons and labels Dynamic Content: Content loaded based on zone/point selection Responsive Design: Optimized for mobile and desktop Technical Implementation:\nSVG namespace manipulation for tooltip creation Text wrapping algorithm for tooltip content Path generation for tooltip shapes with rounded corners Event delegation for zone and point interactions Smooth animations and transitions Real-time Countdown The countdown.js component provides a real-time countdown timer:\nFeatures:\nAutomatic Updates: Updates every second Multi-unit Display: Days, hours, minutes, and seconds Pluralization: Proper Spanish pluralization (Día/Días, Hora/Horas) Mobile Optimization: Simplified display on mobile devices End State Handling: Automatic transition when countdown ends Advanced Search System The Search.vue component implements a comprehensive search system:\nFeatures:\nMulti-category Search: Searches across activities, speakers, stands, and other content Category Tabs: Quick navigation between result categories Result Counts: Dynamic result counts per category Scroll Navigation: Smooth scrolling to category sections Carousel Display: Splide carousels for result display Loading States: Loading indicators during search Empty States: User-friendly empty state messages Dynamic Filtering System The SectionCards.vue component provides advanced filtering:\nFeatures:\nTab Navigation: Multiple filter tabs Favorites System: Save and filter favorite items Search Integration: Inline search within filters Reset Functionality: Clear all filters with one click Downloadable Resources: Download buttons for resources URL Synchronization: Filter state in URL parameters Responsive Design: Mobile accordion interface Animated Statistics The odometer.js component provides animated number counting:\nFeatures:\nScroll-triggered: Animations trigger on scroll Prefix/Suffix Support: Handles formatted numbers (e.g., \u0026ldquo;56,000+\u0026rdquo;) Mobile Optimization: Static display on mobile Smooth Animations: Odometer theme integration Development workflow The project uses Laravel Mix for asset compilation:\n// Development npm run dev // Compile assets npm run watch // Watch for changes npm run hot // Hot module replacement // Production npm run production // Optimized production build BrowserSync integration provides:\nLive reloading during development Synchronized browser testing Proxy configuration for WordPress development Performance optimizations Code splitting: Laravel Mix extracts vendor libraries Asset versioning: Automatic cache busting Image optimization: Lazy loading and responsive images Minification: Production builds are minified and optimized Tree shaking: Unused code elimination in production SVG optimization: Efficient SVG manipulation and rendering Accessibility Semantic HTML structure ARIA labels for interactive elements Keyboard navigation support Focus management in forms and modals Screen reader considerations Proper alt text for images Conclusion and final thoughts Building the ETMday frontend was an excellent opportunity to:\nMaster SVG interactions: Creating complex interactive SVG maps with dynamic tooltips and zones Implement real-time features: Building countdown timers and live updates Build advanced search: Multi-category search with filtering and categorization Handle complex state: Managing filters, favorites, and dynamic content Optimize performance: Implementing efficient animations and lazy loading Ensure scalability: Building components that handle large datasets (thousands of attendees, hundreds of activities) The project demonstrates proficiency in:\nModern JavaScript frameworks (Vue 3) SVG manipulation and interaction Real-time UI updates Advanced filtering and search systems Build tools and asset compilation (Laravel Mix, Webpack) CSS architecture and methodologies (SCSS, BEM) Component-based development Event-driven architecture The integration with WordPress/Themosis backend required careful consideration of server-side rendering, API endpoints, and content management workflows, making this a full-stack frontend implementation for a large-scale event.\nLive website: https://etmday.org/\nFigma Prototype: https://www.figma.com/proto/mt9fJ8P03M5gf0nQwcU99q/EtM-Day-2025---Dise%C3%B1o?node-id=1-2743\u0026m=dev\u0026scaling=scale-down\u0026content-scaling=fixed\u0026page-id=0%3A1\u0026starting-point-node-id=1%3A2743\n","image":"//localhost:1313/images/project/etm/home.png","permalink":"//localhost:1313/projects/etmday-entrepreneurship-event-website/","tags":["Vue 3","Laravel Mix","WordPress","Themosis","SCSS","JavaScript","Interactive Map","SVG"],"title":"ETMday: Entrepreneurship Event Website"},{"categories":["Projects"],"contents":"JAC Autos Chile is a comprehensive automotive website built on top of WordPress with the Themosis framework, featuring car model comparisons, multi-step quote forms, fleet management, branch listings, and advanced filtering systems using Vue 3, Pinia state management, Laravel Mix, and modern frontend technologies.\nOutline The project Key features The stack Frontend architecture Interactive components Conclusion Live website The project JAC Autos Chile is the official website for JAC Motors in Chile, showcasing SUVs, pickups, commercial vehicles, and electric vehicles. The website serves as the primary platform for vehicle exploration, quoting, dealership location, fleet management, and post-sale services.\nThe frontend development required implementing complex interactive features including car model comparisons, multi-step quote forms with model and version selection, advanced filtering systems, fleet management interfaces, and comprehensive content management.\nKey features The website includes several sophisticated features:\nCar Model Comparator: Side-by-side comparison of multiple vehicle models with difference highlighting Multi-step Quote Form: Comprehensive quote form with model selection, version selection, and customer information Advanced Filtering: Multi-criteria filtering for car models, branches, fleet vehicles, and blog posts Fleet Management: Dedicated fleet vehicle selection and management interface Branch Locator: Filterable dealership/branch listings with location information Blog System: Complete blog with filtering, search, and content management Manuals Listing: User manual and documentation management Search Functionality: Site-wide search with categorized results Sticky Navigation: Section-based sticky navigation for long pages 360° View: Interactive 360-degree vehicle viewing The stack The frontend stack consists of:\nVue 3.2.4: Modern reactive framework with Composition API Pinia 2.2.6: State management for Vue applications Laravel Mix 6.0: Asset compilation and bundling SCSS: Advanced styling with organized architecture Vee-Validate 4.14.6: Form validation with Yup schemas Axios 1.6.8: HTTP client for API requests Splide.js 4.1.4: Modern carousel and slider components @splidejs/vue-splide 0.6.12: Vue 3 wrapper for Splide Maska 3.0.3: Input masking for formatted inputs Vue-Select 4.0.0-beta.6: Custom select component Vue-Recaptcha 2.0.3: reCAPTCHA integration Headroom.js: Header behavior on scroll jQuery 3.7.1: DOM manipulation and legacy support SweetAlert2: Modern alert dialogs @fdograph/rut-utilities: Chilean RUT validation utilities Frontend architecture Vue components The application features a comprehensive set of Vue 3 components (40+ components):\nCar Model Components:\nCar.vue: Car model card component with comparison functionality CarLoading.vue: Loading skeleton for car cards CarVersion.vue: Car version/trim level component CarVersionLoading.vue: Loading skeleton for version cards CarModelsListingStatic.vue: Static car models listing CarModelsListingQuote.vue: Car models listing for quote flow CarVersionsListingQuote.vue: Versions listing for quote flow CarQuote.vue: Car quote display component CarQuoteLoading.vue: Loading skeleton for quote cards Comparison Components:\nComparator.vue: Main car comparison component with Splide integration ComparatorModal.vue: Modal version of comparator CardCompareModel.vue: Comparison card for individual models CardCompareModelLoading.vue: Loading skeleton for comparison cards Quote Components:\nQuote.vue: Main quote component with multi-step flow QuoteForm.vue: Comprehensive quote form with validation Filtering Components:\nFilters.vue: General filtering component FleetFilter.vue: Fleet-specific filtering BranchesFilter.vue: Branch/dealership filtering BlogFilter.vue: Blog post filtering AjaxListWithFilter.vue: AJAX-powered list with filtering Content Components:\nBlog.vue: Blog post card component BlogLoading.vue: Loading skeleton for blog cards Fleet.vue: Fleet vehicle card component Branch.vue: Branch/dealership card component BranchLoading.vue: Loading skeleton for branch cards Manual.vue: Manual/documentation card component ManualLoading.vue: Loading skeleton for manual cards ManualsListing.vue: Manuals listing component Form Components:\nContactForm.vue: Contact form with validation Select.vue: Custom select dropdown component UI Components:\nPagination.vue: Pagination component StickySectionSelector.vue: Sticky navigation for sections EmptyState.vue: Empty state displays Loader.vue: Loading indicator ErrorBoundary.vue: Error boundary component SearchResults.vue: Search results display SearchResultCard.vue \u0026amp; SearchResultCardLoading.vue: Search result cards Service Components:\nCardMaintenance.vue: Maintenance service card CardMaintenanceLoading.vue: Loading skeleton for maintenance cards JavaScript components The application includes 12 specialized JavaScript components:\nUI Components:\nheader.js: Header functionality and navigation headroom.js: Header hide/show on scroll megamenu.js: Mega menu functionality search-modal.js: Search modal functionality scrollUpBottom.js: Scroll to top/bottom functionality social-share.js: Social media sharing Media Components:\nvideo.js: Video player setup splide.js: Carousel initialization slick.js: Legacy carousel support Interactive Components:\naccordion.js: Accordion interactions tabs.js: Tab functionality Utilities:\nimg-to-svg.js: SVG image conversion utility scrollTrigger.js: Scroll-based animations SCSS architecture The styling follows a well-organized SCSS architecture:\nscss/ ├── abstracts/ # Variables, mixins, functions │ ├── _mixins.scss │ ├── _mq.scss # Media query mixins │ └── _vendor.scss ├── base/ # Base styles and typography │ ├── _typography.scss │ ├── _colors.scss │ ├── _container.scss │ └── _globals.scss └── components/ # Component-specific styles ├── [87 component files] └── cards/ # Card component styles └── [20 card-specific files] Key SCSS features:\nBEM methodology: Consistent naming convention throughout Media query mixins: Using sass-mq for responsive design Modular architecture: 106 component-specific SCSS files Card organization: Dedicated card component styles Interactive components Car model comparator The Comparator.vue component provides sophisticated car model comparison:\nFeatures:\nSide-by-side comparison: Compare up to 3 models simultaneously Difference highlighting: Toggle to highlight differences between models Splide integration: Smooth carousel navigation for multiple models Dynamic data loading: Load comparison data via AJAX Responsive design: Optimized for mobile and desktop Modal version: Full-screen modal comparison view Technical Implementation:\nPinia store for comparison state management Splide Vue component for carousel functionality Dynamic component rendering based on selected models Efficient data structure for comparison attributes Multi-step quote form The Quote.vue and QuoteForm.vue components implement a comprehensive quote system:\nFeatures:\nStep-by-step flow: Model selection → Version selection → Customer information Form validation: Using Vee-Validate with Yup schemas RUT validation: Chilean RUT validation using custom directive Input masking: Phone numbers and formatted inputs with Maska reCAPTCHA integration: Spam protection Edit functionality: Ability to go back and edit previous steps Selected vehicle display: Visual representation of selected model/version Loading states: Visual feedback during form submission Form steps include:\nStep 1: Category and model selection Step 2: Version/trim level selection Step 3: Customer information and submission Advanced filtering systems Multiple filtering components provide comprehensive filtering:\nFleet Filter (FleetFilter.vue):\nFilter fleet vehicles by category, price range, and features Real-time filtering with URL parameter synchronization Mobile-optimized interface Branches Filter (BranchesFilter.vue):\nFilter dealerships by location, region, and services Map integration support Contact information display Blog Filter (BlogFilter.vue):\nFilter blog posts by category, date, and tags Search functionality Pagination support Ajax List with Filter (AjaxListWithFilter.vue):\nGeneric AJAX-powered list component Multiple filter criteria Loading states and empty states Sticky section selector The StickySectionSelector.vue component provides section-based navigation:\nFeatures:\nSticky positioning: Stays visible while scrolling Active section highlighting: Highlights current section Smooth scrolling: Smooth scroll to sections Responsive design: Mobile-optimized display State management with Pinia The application uses Pinia for centralized state management:\nStores:\nComparator Store: Manages comparison state, selected models, and comparison data Quote Store: Manages quote flow state, selected model/version, and form data Filter Stores: Manage filter states for different content types Benefits:\nCentralized state management Type-safe state access Efficient reactivity Easy debugging with Vue DevTools Custom directives The application includes custom Vue directives:\nRUT Directive (input-rut):\nChilean RUT (tax ID) validation and formatting Real-time validation as user types Format enforcement (XX.XXX.XXX-X) Development workflow The project uses Laravel Mix for asset compilation:\n// Development npm run dev // Compile assets npm run watch // Watch for changes npm run hot // Hot module replacement // Production npm run production // Optimized production build BrowserSync integration provides:\nLive reloading during development Synchronized browser testing Proxy configuration for WordPress development Performance optimizations Code splitting: Laravel Mix extracts vendor libraries Asset versioning: Automatic cache busting Image optimization: Lazy loading and responsive images Minification: Production builds are minified and optimized Tree shaking: Unused code elimination in production Component lazy loading: Load components on demand Skeleton loading: Better perceived performance with loading states Accessibility Semantic HTML structure ARIA labels for interactive elements Keyboard navigation support Focus management in forms and modals Screen reader considerations Proper alt text for images Color contrast compliance Conclusion and final thoughts Building the JAC Autos Chile frontend was an excellent opportunity to:\nMaster Vue 3: Working with Composition API, Pinia state management, and modern Vue patterns Build complex comparisons: Creating sophisticated car model comparison interfaces Implement multi-step forms: Complex quote forms with validation, RUT formatting, and step navigation Create advanced filtering: Multiple filtering systems for different content types Optimize performance: Implementing efficient state management, lazy loading, and code splitting Handle automotive data: Managing complex vehicle data structures and relationships The project demonstrates proficiency in:\nModern JavaScript frameworks (Vue 3) State management (Pinia) Form validation and user experience (Vee-Validate, Yup, Maska) Build tools and asset compilation (Laravel Mix, Webpack) CSS architecture and methodologies (SCSS, BEM) Component-based development Custom directives Carousel and slider implementations (Splide) AJAX-powered interfaces The integration with WordPress/Themosis backend required careful consideration of server-side rendering, API endpoints, and content management workflows, making this a full-stack frontend implementation for a comprehensive automotive platform.\nLive website: https://jacautoschile.cl/\nFigma Prototype: https://www.figma.com/proto/wfsYoYThSR9VId6TVUGevk/JAC---Dise%C3%B1o-desktop?node-id=1-232\u0026m=dev\u0026scaling=min-zoom\u0026content-scaling=fixed\u0026page-id=0%3A1\u0026starting-point-node-id=62%3A3801\n","image":"//localhost:1313/images/project/jac-autos/homepage.webp","permalink":"//localhost:1313/projects/jac-autos-chile-automotive-website/","tags":["Vue 3","Pinia","Laravel Mix","WordPress","Themosis","SCSS","JavaScript","Splide"],"title":"JAC Autos Chile: Automotive Website"},{"categories":["Projects"],"contents":"ISC Chile is an educational consultancy website for study abroad programs, built on top of WordPress with the Themosis framework, featuring GSAP animations, multi-step contact forms, advanced blog filtering, and comprehensive content management using Vue 2, Laravel Mix, and modern frontend technologies.\nOutline The project Design implementation The stack Frontend architecture Key features Conclusion Live website The project ISC Chile is an educational consultancy agency that has been providing study abroad advisory services since 1996. The website serves as the primary platform for showcasing various educational programs including English courses, school exchanges, group travel programs, and Pathways programs for university admission abroad.\nThe frontend development was based on a comprehensive Figma design, requiring pixel-perfect implementation of complex UI components, multi-step forms, animated statistics, and responsive layouts that work seamlessly across all devices.\nDesign implementation The entire frontend was built from a detailed Figma design, ensuring:\nPixel-perfect accuracy: Matching the design specifications precisely (as evidenced by Figma height references in SCSS) Responsive design: Implementing breakpoints and mobile-first approach Component consistency: Maintaining design system patterns throughout Interactive elements: Translating static designs into dynamic, interactive components Animation and transitions: Implementing smooth GSAP-powered animations The stack The frontend stack consists of:\nVue 2.6.12: Reactive framework for building interactive components Laravel Mix 6.0: Asset compilation and bundling SCSS: Advanced styling with a well-organized architecture Vuex 3.6.2: State management for Vue applications Vee-Validate 3.4.14: Form validation GSAP 3.12.5: Professional animation library with ScrollTrigger Axios 0.18: HTTP client for API requests Splide.js 4.1.4: Modern carousel and slider components Slick Carousel 1.8.1: Legacy carousel support LightGallery 2.7.2: Lightbox gallery functionality Odometer 0.4.8: Animated number counting Headroom.js: Header behavior on scroll V-Calendar 2.4.2: Calendar component for date selection V-Mask 2.3.0: Input masking Vue-Select 3.20.2: Custom select component jQuery 3.2: DOM manipulation and legacy support SweetAlert: Alert dialogs Frontend architecture Vue components The application features a comprehensive set of Vue 2 components:\nForm Components:\nContact.vue: Multi-step contact form with validation and reCAPTCHA ContactFormStep1.vue: First step of the contact form ContactFormStep2.vue: Second step of the contact form ContactFormStep3.vue: Third step of the contact form FormBanner.vue: Banner form component Content Components:\nBlog.vue: Blog listing with advanced filtering and search BlogArticleCard.vue \u0026amp; BlogArticleCardLoading.vue: Blog post cards with loading states ExperiencesPanel.vue: Testimonials and experiences display panel ExperiencesFiltersMobile.vue: Mobile filter component for experiences Search Components:\nSearchResults.vue: Search results display component SearchResultCardLoading.vue: Loading skeleton for search results UI Components:\nCheckboxDropdown.vue: Custom checkbox dropdown component CheckboxDropdownFieldset.vue: Fieldset wrapper for checkbox dropdowns EmptyState.vue: Empty state displays Loader.vue \u0026amp; Loading.vue: Loading indicators JavaScript components The application includes 15 specialized JavaScript components:\nAnimation Components:\ngsap.js: GSAP animations with ScrollTrigger for scroll-based reveals scrolltrigger.js: Custom scroll trigger utilities odometer.js: Animated number counting with scroll triggers UI Components:\nheader.js: Header functionality and navigation headroom.js: Header hide/show on scroll megamenu.js: Mega menu functionality mobileMenu.js: Mobile menu interactions searchbar.js: Search bar functionality floating-banner.js: Floating banner component footer.js: Footer functionality Media Components:\nvideo.js: Video player setup lightgallery.js: Lightbox gallery initialization splide.js: Carousel initialization slick.js: Legacy carousel support Interactive Components:\naccordion.js: Accordion interactions tabs.js: Tab functionality cards.js: Card interactions Utilities:\nimg-to-svg.js: SVG image conversion utility SCSS architecture The styling follows a well-organized SCSS architecture:\nscss/ ├── abstracts/ # Variables, mixins, functions │ ├── _mixins.scss │ ├── _mq.scss # Media query mixins │ └── _vendor.scss ├── base/ # Base styles and typography │ ├── _typography.scss │ ├── _colors.scss │ ├── _container.scss │ ├── _globals.scss │ └── fonts/ # Custom TWK Everett font family └── components/ # Component-specific styles └── [45 component files] Key SCSS features:\nBEM methodology: Consistent naming convention throughout Media query mixins: Using sass-mq for responsive design Modular architecture: Each component has its own SCSS file Custom typography: TWK Everett font family with multiple weights Figma references: Direct references to Figma design specifications Key features Multi-step contact form The Contact.vue component implements a sophisticated multi-step form with:\nThree-step navigation: Step-by-step form progression Form validation: Using Vee-Validate with comprehensive rules Date picker: V-Calendar integration for date selection Input masking: V-Mask for phone numbers and formatted inputs reCAPTCHA integration: Spam protection Dynamic fields: Fields that change based on user selections Loading states: Visual feedback during form submission Error handling: Comprehensive error messages and validation Form steps include:\nStep 1: Personal information and contact details Step 2: Educational background and program interests Step 3: Additional information and submission GSAP animations The gsap.js component provides professional animations:\nFeatures:\nScroll-triggered animations: Elements animate on scroll Vertical scroll reveals: Fade and slide animations Horizontal scroll reveals: Staggered animations for grid layouts Timeline management: Complex animation sequences Performance optimized: Efficient animation triggers Animation types:\nFade in with vertical movement Staggered grid animations Scroll-based reveals Smooth transitions Advanced blog system The Blog.vue component provides comprehensive blog functionality:\nFeatures:\nCategory filtering: Filter posts by category Search functionality: Real-time search across blog posts Mobile filters: Dedicated mobile filter interface Pagination: Efficient content pagination Loading states: Skeleton loading screens Empty states: User-friendly empty state messages Experiences/testimonials panel The ExperiencesPanel.vue component displays student testimonials:\nFeatures:\nFilter by type: Filter testimonials (Students/Parents) Dynamic loading: Load testimonials from API Responsive design: Mobile-optimized display Carousel integration: Splide carousel for testimonial display Animated statistics The odometer.js component provides animated number counting:\nFeatures:\nScroll-triggered: Animations trigger on scroll Smooth counting: Odometer theme integration Performance optimized: Efficient scroll detection Mobile support: Optimized for all devices Search functionality The SearchResults.vue component provides comprehensive search:\nFeatures:\nMulti-content search: Search across programs, blog posts, and pages Result categorization: Organized search results Image support: Results with and without images Tag display: Category tags for results Loading states: Skeleton loading screens Custom typography The website features a custom font family, TWK Everett, with:\nMultiple weights: From Hairline to Super Italic variants: All weights include italic versions Optimized formats: WOFF, WOFF2, and OTF formats Performance: Efficient font loading and rendering Development workflow The project uses Laravel Mix for asset compilation:\n// Development npm run dev // Compile assets npm run watch // Watch for changes npm run hot // Hot module replacement // Production npm run production // Optimized production build BrowserSync integration provides:\nLive reloading during development Synchronized browser testing Proxy configuration for WordPress development Performance optimizations Code splitting: Laravel Mix extracts vendor libraries Asset versioning: Automatic cache busting Image optimization: Lazy loading and responsive images Minification: Production builds are minified and optimized Tree shaking: Unused code elimination in production Font optimization: Efficient font loading strategies Accessibility Semantic HTML structure ARIA labels for interactive elements Keyboard navigation support Focus management in forms Screen reader considerations Proper alt text for images Conclusion and final thoughts Building the ISC Chile frontend from a Figma design was an excellent opportunity to:\nMaster Vue 2: Working with Options API, Vuex state management, and Vue 2 patterns Implement GSAP animations: Creating professional scroll-triggered animations Build complex forms: Multi-step forms with validation, date pickers, and input masking Create advanced filtering: Blog filtering with search and category selection Optimize performance: Implementing efficient animations and lazy loading Ensure design fidelity: Translating Figma designs into pixel-perfect implementations (with direct Figma references in code) The project demonstrates proficiency in:\nModern JavaScript frameworks (Vue 2) Animation libraries (GSAP, ScrollTrigger) Form validation and user experience (Vee-Validate, V-Mask, V-Calendar) Build tools and asset compilation (Laravel Mix, Webpack) CSS architecture and methodologies (SCSS, BEM) Component-based development State management (Vuex) Design system implementation The integration with WordPress/Themosis backend required careful consideration of server-side rendering, API endpoints, and content management workflows, making this a full-stack frontend implementation for an educational consultancy platform.\nLive website: https://www.iscchile.cl/\nFigma prototype: https://www.figma.com/proto/BfdKGJlzx7xAnE7rpZ1vda/Dise%C3%B1o-ISC?page-id=314%3A12071\u0026type=design\u0026node-id=314-12072\u0026viewport=-1452%2C930%2C0.29\u0026t=hFYiwcionjRAZ47v-1\u0026scaling=min-zoom\n","image":"//localhost:1313/images/project/isc-chile/home.png","permalink":"//localhost:1313/projects/isc-chile-educational-consultancy-website/","tags":["Vue 2","Laravel Mix","WordPress","Themosis","SCSS","GSAP","JavaScript","Figma"],"title":"ISC Chile: Educational Consultancy Website"},{"categories":["Projects"],"contents":"Chile Nativo is a travel tour website for Patagonia experiences, built on top of WordPress with the Themosis framework, featuring a modern frontend implementation based on a Figma design using Vue 3, Laravel Mix, and a comprehensive SCSS architecture.\nOutline The project Design implementation The stack Frontend architecture Key features Conclusion Live website The project Chile Nativo is a travel company specializing in Patagonia tours, offering experiences in destinations like Torres del Paine, Tierra del Fuego, and Isla Navarino. The website serves as the primary platform for showcasing tours, managing bookings, and providing information about their travel experiences.\nThe frontend development was based on a comprehensive Figma design, requiring pixel-perfect implementation of complex UI components, interactive forms, filtering systems, and responsive layouts that work seamlessly across all devices.\nDesign implementation The entire frontend was built from a detailed Figma design, ensuring:\nPixel-perfect accuracy: Matching the design specifications precisely Responsive design: Implementing breakpoints and mobile-first approach Component consistency: Maintaining design system patterns throughout Interactive elements: Translating static designs into dynamic, interactive components Animation and transitions: Implementing smooth user experience enhancements The stack The frontend stack consists of:\nVue 3.2.4: Modern reactive framework for building interactive components Laravel Mix 6.0: Asset compilation and bundling SCSS: Advanced styling with a well-organized architecture Pinia 2.3.1: State management for Vue applications Vee-Validate 4.15.0: Form validation with Yup schemas Axios 1.6.8: HTTP client for API requests Splide.js 4.1.4: Modern carousel and slider components Headroom.js: Header behavior on scroll Plyr 3.7.8: Video player implementation SweetAlert2: Modern alert dialogs jQuery 3.7.1: Legacy support and DOM manipulation utilities Frontend architecture Vue components The application features a comprehensive set of Vue 3 components organized by functionality:\nFiltering and Search Components:\nToursFilter.vue: Advanced tour filtering with multiple criteria TourDatesFilter.vue: Date-based filtering for tour availability ToursFilterDropdown.vue \u0026amp; ToursFilterDropdownMobile.vue: Responsive filter dropdowns TestimonialsFilter.vue: Filtering system for customer testimonials NewsFilter.vue: Blog and news filtering SearchResults.vue: Search results display with pagination Form Components:\nPersonalizedTripForm.vue: Multi-step form for custom trip requests with validation ContactFormSimple.vue: Contact form with reCAPTCHA integration FormHelp.vue: Help center form FormGiftCard.vue: Gift card purchase form FormCareers.vue: Job application form NewsletterForm.vue: Newsletter subscription Card Components:\nTour.vue \u0026amp; TourLoading.vue: Tour card display with loading states TourDate.vue \u0026amp; TourDateLoading.vue: Tour date selection cards Testimonial.vue \u0026amp; TestimonialLoading.vue: Customer testimonial cards Blog.vue \u0026amp; BlogLoading.vue: Blog post cards Team.vue \u0026amp; TeamLoading.vue: Team member cards ResourceCard.vue \u0026amp; ResourceLoading.vue: Resource display cards Utility Components:\nPagination.vue: Reusable pagination component Select.vue: Custom select dropdown with search Loader.vue \u0026amp; LoaderFullScreen.vue: Loading indicators EmptyState.vue: Empty state displays ContentResources.vue: Resource content management TeamTabsFilter.vue: Tabbed team member filtering SCSS architecture The styling follows a well-organized SCSS architecture:\nscss/ ├── abstracts/ # Variables, mixins, functions │ ├── _functions.scss │ ├── _mixins.scss │ ├── _variables.scss │ ├── _mq.scss # Media query mixins │ └── _keyframes.scss ├── base/ # Base styles and typography │ ├── _typography.scss │ ├── _colors.scss │ ├── _fonts.scss │ └── _reset.scss └── components/ # Component-specific styles └── [125 component files] Key SCSS features:\nBEM methodology: Consistent naming convention throughout Media query mixins: Using sass-mq for responsive design Modular architecture: Each component has its own SCSS file Abstract layer: Reusable variables, mixins, and functions Vue transitions: Custom transition styles for Vue components JavaScript architecture The JavaScript is organized into two main entry points:\nMain application (app.js):\nInitializes core application functionality Sets up jQuery plugins and utilities Handles legacy browser support Vue application (vue/main.js):\nConfigures Vue 3 app with Pinia for state management Registers global Vue components Sets up Vee-Validate configuration Integrates third-party Vue plugins (VueTelInput, etc.) Component utilities (app/components/):\nheader.js: Header behavior and navigation footer.js: Footer functionality splide.js: Carousel initialization slick.js: Legacy carousel support accordions.js: Accordion interactions tabs.js: Tab functionality scrollTrigger.js: Scroll-based animations video.js: Video player setup sticky-sidebar.js: Sticky sidebar behavior Key features Multi-step forms The PersonalizedTripForm.vue component implements a sophisticated multi-step form with:\nStep-by-step navigation with progress indicators Form validation using Vee-Validate and Yup schemas Dynamic form fields based on user selections Phone number input with international support (VueTelInput) reCAPTCHA integration for spam protection Loading states and error handling Advanced filtering system The tour filtering system (ToursFilter.vue) provides:\nMultiple filter criteria (destination, activity type, trip type, month) Real-time filtering with URL parameter synchronization Responsive design with mobile accordion interface Custom select components with search functionality Empty states and loading indicators Integration with WordPress backend via Axios Responsive design The entire website is fully responsive with:\nMobile-first approach Breakpoint management using sass-mq Touch-friendly interactions Optimized images and assets Performance optimizations for mobile devices Performance optimizations Code splitting: Laravel Mix extracts vendor libraries Asset versioning: Automatic cache busting Image optimization: Lazy loading and responsive images Minification: Production builds are minified and optimized Tree shaking: Unused code elimination in production Accessibility Semantic HTML structure ARIA labels where appropriate Keyboard navigation support Focus management in forms Screen reader considerations Development workflow The project uses Laravel Mix for asset compilation:\n// Development npm run dev // Compile assets npm run watch // Watch for changes npm run hot // Hot module replacement // Production npm run production // Optimized production build BrowserSync integration provides:\nLive reloading during development Synchronized browser testing Proxy configuration for WordPress development Conclusion and final thoughts Building the Chile Nativo frontend from a Figma design was an excellent opportunity to:\nMaster Vue 3: Working with the Composition API, reactive systems, and modern Vue patterns Implement complex forms: Multi-step forms with validation, international phone inputs, and reCAPTCHA Build scalable architecture: Organizing 40+ Vue components and 125+ SCSS files in a maintainable structure Optimize performance: Implementing code splitting, lazy loading, and production optimizations Ensure design fidelity: Translating Figma designs into pixel-perfect implementations Handle responsive design: Creating seamless experiences across all device sizes The project demonstrates proficiency in:\nModern JavaScript frameworks (Vue 3) Build tools and asset compilation (Laravel Mix, Webpack) CSS architecture and methodologies (SCSS, BEM) Form validation and user experience Component-based development Design system implementation The integration with WordPress/Themosis backend required careful consideration of server-side rendering, API endpoints, and content management workflows, making this a full-stack frontend implementation.\nLive website: https://chilenativo.travel/\nFigma prototype: https://www.figma.com/proto/ywHPhSP1UfYUAE8eWVQv4L/Dise%C3%B1o-Desktop---Chile-Nativo?node-id=289-3912\u0026m=dev\u0026scaling=min-zoom\u0026content-scaling=fixed\u0026page-id=289%3A3911\u0026starting-point-node-id=289%3A3912\n","image":"//localhost:1313/images/project/chile-nativo/home.png","permalink":"//localhost:1313/projects/chile-nativo-patagonia-travel-website/","tags":["Vue 3","Laravel Mix","WordPress","Themosis","SCSS","JavaScript","Figma"],"title":"Chile Nativo: Patagonia Travel Website"},{"categories":["Projects"],"contents":"Rutieri is a SaaS platform built with Strapi, React Native, Typescript and other technologies.\nOutline The idea Platform features The stack The API The frontend The mobile app Conclusion Landing Page The idea Before starting to write a single line of code, it is generally a good idea to think about the problem, it\u0026rsquo;s limitations and whether or not it has already been solved by someone else (AKA competitors).\nThe problem I was looking into had to do with the way in which public and private transportation companies manage their routes, drivers and users. This process is generally carried out on paper, e.g. not digital, hence this could be problematic in case of new drivers joining the organization or in case of restricting access to data to only specific users.\nAfter a little bit of research, I could only find one platform that provides a similiar solution but for their own company.\nPlatform features and user stories The following user stories illustrates the desired features the platform should have in order to solve the aforementioned problems.\nAs an administrator user, I want to: login in the admin panel. create an organization. create routes in the organization. invite drivers and users to the organization. manage requests to join the organization. assign routes to drivers in the organization. see in real time the drivers and users currently active in the map of the different routes. As a driver, I want to: login in the mobile app. join an organization by entering the code in the search bar. see my route on the map. become visible to passengers on the road. see the passengers waiting on the road. remove my visibility and finish my run. As a passenger, I want to: login in the mobile app. join an organization by entering the code in the search bar. see the different routes of my organization in the map. search for a destination and get the available routes that pass nearby. see the drivers currently active on the routes in real time. become visible to drivers of a route. The requirements The backend requires to handle user authentication, permissions, different data structures as content types and define relations between them. It\u0026rsquo;s also necessary to synchronise passengers and drivers and view them on a map real time in the administration panel as well as in the mobile app.\nThe administration panel is a web page that fetches data from the backend as well as from the real time data provider and it\u0026rsquo;s goal is to provide a way for administrators to manage their organization and users. We\u0026rsquo;re talking about a Single Page Application built in React.\nAs for the mobile application, there isn\u0026rsquo;t a better choice nowadays than React Native and it works just fine in this case.\nThe API Since all of the features involve authentication, permissions and roles, and because there is no need to reinvent the wheel, I chose to use Strapi to build the backend for it\u0026rsquo;s simplicity, ease of use and great developer experience, whereas for realtime data, I used Firebase.\nThe instance of Strapi and the Postgres database it requires was deployed in the cloud hosting platform https://fly.io.\nStrapi is good for managing users, content that\u0026rsquo;s typically updated and fetched via CRUD API, and relations between content types.\nThe platform needs the following content types:\nOrganizations to group routes, drivers and users Routes Two user roles: drivers and users (passengers) Below are some screenshots of the overview of these content types\nAs I said before, Strapi makes the creation of these content types and the relationships between them really straightforward.\nHowever, not everything related to the API can be provided by Strapi. Some realtime features need to be addressed with other solutions, such as geolocation data in real time for drivers and users to synchronise each other, maps and the ability to search for places. Such features were implemented using Firebase, Google Maps and Google Places.\nThe frontend The platform where users are able to login as administrators and manage their organizations and users is a single page web application built in React. Among the features of this project that I think stand out are:\nState managed by Context API Interface styled with Bootstrap React Router for pages Leaflet to display the map GeoFire library to synchronise geolocation data in real time with Firebase Use of localStorage to save user session Below are some sample screenshots of how this app looks like\nThe mobile application This one is by far the most complex part of this project.\nThe project was bootstraped with Infinitered\u0026rsquo;s Ignite, which provides a great boilerplate and surely saved me of what would have been between 1-2 months of work.\nIgnite\u0026rsquo;s boilerplate includes many features out of the box, including:\nReact Native and Typescript (of course) React Navigation MobX-State-Tree for state management Expo SDK for developer experience AsyncStorage for persistence apisauce as REST client And some other libraries and features that make React Native apps super powerful and a joy to work on.\nIt consists of three screens:\nWelcome screen Login screen Map screen In the welcome screen, users are able to go to the login screen if not logged in. Otherwise, if they\u0026rsquo;re in an organisation, it shows their role and org\u0026rsquo;s information, and if they\u0026rsquo;re not, they are able to enter the organisation code and request to join as driver or as passenger.\nWelcome screens Login screens If the user is a driver in an organisation, the welcome screen also shows the route assigned to them. By tapping on it, it takes them to the map, where they can see themselves and start the tour, becoming visible to passengers on the road but being able to see passengers on the road as well.\nDrivers can finish the tour at any time by pressing the button stop.\nIf the user is a passenger in an organisation, the welcome screen shows the different routes available in the organisation. By tapping on them, they are taken to the map where they can see themselves, the route and the drivers on the road.\nPassengers are able to navigate between the available routes and search for the location they want to go to by using the search bar at the top of the map screen, filtering out the routes that pass nearby (less than 200 meters), if there are. Google Places API and turf library work together in this search process.\nPassengers become visible to drivers on the road by pressing the button wait and if they press the button again, they stop waiting and are removed from the driver\u0026rsquo;s map.\nMap screens The start/wait and finish buttons dispatch actions that update their location in firebase, so that passengers are able to see the bus on the map as it moves in real time and viceversa.\nAs for the state management, the project consists of two models and three stores from Mobx-State-Tree library: User and Route models, user-status, route-store and root-store stores.\nUser model Located in /app/models/user/user.ts\nconst OrganizationModel = types.model({ name: types.string, code: types.string, id: types.identifierNumber, drivers: types.number, rutas: types.array(RouteModel) }) const UserModel = types .model(\u0026#34;User\u0026#34;) .props({ id: types.identifierNumber, username: types.string, email: types.string, token: types.string, role: types.union(types.literal(\u0026#34;passenger\u0026#34;), types.literal(\u0026#34;driver\u0026#34;)), ruta: types.maybeNull(RouteModel), organization: types.maybeNull(OrganizationModel), pending_request: types.maybeNull(OrganizationModel), }) Route model Located in /app/models/route/route.ts\nThis model follows the GeoJSON format for routes.\nconst RouteModel = types .model(\u0026#34;Ruta\u0026#34;) .props({ id: types.identifierNumber, name: types.string, latlong: types.maybeNull(types.model({ lat: types.number, longt: types.number })), coords: types.model({ type: FeatureTypes, features: types.array(types.model({ type: types.string, geometry: types.model({ type: types.string, coordinates: types.union(types.array(types.number), types.array(types.array(types.number))) }), properties: types.model({ name: types.string }) })) }) }) user-status store Located in /app/models/user-status/user-status.ts\nThis store is responsible for managing the state of the user. It stores the user once it\u0026rsquo;s logged in and removes it when the user logs out. It also has some views to get the user key for firebase purposes, get the role and get the route in case of a driver.\nThis store has some methods that get the user location from the device\u0026rsquo;s GPS, displays the user icon on the map and sends it to firebase.\nconst UserStatusModel = types .model(\u0026#34;UserStatus\u0026#34;) .extend(withEnvironment) .props({ user: types.maybeNull(UserModel), location: types.maybeNull( types.model({latitude: types.number, longitude: types.number}) ), visibility: types.maybeNull(types.number) }) route-store store Located in /app/models/route-store/route-store.ts\nThis store is responsible for managing the state of the available routes. It stores the routes, drivers and passengers on the different routes. It also has some view methods to filter the routes that pass nearby a destination specified by the user, get passengers waiting on a given route and get drivers active in a specific route.\nThis store initializes a GeoQuery from Geofire library and listens for events to set, update and remove drivers and passengers from the map as they move.\nconst RouteStoreModel = types .model(\u0026#34;RouteStore\u0026#34;) .props({ routes: types.array(RouteModel), passengers: types.map(types.model({ key: types.identifier, location: types.array(types.number) })), drivers: types.map(types.model({ key: types.identifier, location: types.array(types.number) })), destinationAddress: types.maybeNull(types.model({ name: types.string, coords: types.array(types.number) })) }) Conclusion and final thoughts Using a CMS as the backend can make the development a lot faster than building the API from scratch and with Strapi this is specially true. On the other hand, Strapi doesn\u0026rsquo;t really make a good fit for real time applications, therefore, Firebase is the way to go in this case.\nAs of the client side, React always works very good for pretty much any kind of application, and because React Native uses React under the hood, it is so convenient for us React developers and ir works pretty good for almost any kind of application as well.\nHowever, one thing that I didn\u0026rsquo;t mention in this post was the use of Typescript; I find this quote by Brice Wilson pretty good to point out the whole purpose and motivation to learn and use (well) this powerful language and tool ecosystem:\n\u0026ldquo;You won\u0026rsquo;t have to wait for a frustrated user to report the error. All of this means that you provide value to your users faster, and that\u0026rsquo;s really what it\u0026rsquo;s all about.\u0026rdquo;\nAll in all, I got a lot of learning by building this project, both in languages/frameworks used and production stuff such as infrastructure, cloud hosting and cloud-based APIs.\nProject landing page: https://rutieri.netlify.app\n","image":"//localhost:1313/images/project/rutieri/landing/homepage.webp","permalink":"//localhost:1313/projects/saas-platform-rutieri/","tags":["Strapi","React Native","React","Typescript","Firebase"],"title":"SaaS platform: Rutieri"},{"categories":["Tutorial"],"contents":"Enable comments in a Strapi application and display them in the frontend with React\nOutline Introduction Prerequisites What is Strapi Comment Manager? Installation Configuration Display comments on the frontend Installation of Strapi Comments Client Usage of Strapi Comments Client Plugin settings Manage comments Full source code of the frontend Conclusion Introduction A comment system comes in very handy for pretty much any kind of website. In the JAMstack ecosystem, while it\u0026rsquo;s ok to rely on third party solutions hosted on their own platform such as Disqus to enable comments, you usually want to keep your content and all the stuff related to it in the same admin dashboard.\nIn this article, I\u0026rsquo;ll show you how to enable and manage comments for your content very easily using the Comment Manager plugin, and display them in your frontend application.\nPrerequisites You should have a basic understanding of the following.\nBasic knowledge of JavaScript Basic knowledge of React (OPTIONAL) Basic understanding of Strapi - get started here. Your Strapi V4 project setup What is Strapi Comment Manager? Strapi Comment Manager is a plugin that enables comments for pretty much any kind of content. It allows your users to post comments and anyone can get the comments associated with a given slug.\nWith this plugin, admin users can view and manage very easily all the comments from the Strapi administration dashboard. Within the dashboard, you will be able to delete comments and subcomments and leave replies on comments.\nInstallation Once into the Strapi project root, you can install the plugin by running the following command:\nnpm install strapi-plugin-comment-manager Next, build the project to see the new plugin in the dashboard with the following command:\nnpm run build And that\u0026rsquo;s it! If everything runs correctly, the plugin should now be installed.\nConfiguration Now you need to enable some permissions so that the frontend can access the endpoints to post and fetch comments.\nIn your Strapi admin dashboard, head over to Settings, then over to Roles under Users \u0026amp; Permissions Plugin.\nLet\u0026rsquo;s first setup the Public API; click on Public and hit the dropdown button of Comment Manager. Now check count, find and getPageSize, then hit the Save button. Below is a screenshot of a proper configuration:\nNow let\u0026rsquo;s setup the Authenticated API. Go back to Roles and click on Authenticated. Open the dropdown for Comment Manager and mark as checked the option create on both Comment and Subcomment. Below is a screenshot of a proper configuration:\nWith this configuration, the frontend should now be able to make requests to get and post comments.\nDisplay comments on the frontend The plugin exposes an API to get and post comments if you want to have fine-grained control over the workflow of your comments system and you can check the documentation on the package page, but this plugin also comes with a purpose-built React component library that makes it super easy to get up and running without getting your hands dirty.\nThis components library is called strapi-comments-client, fully supports typescript and it handles for you all of the complexity of fetching and posting comments and subcomments for every content ID that you pass to it.\nInstallation of Strapi Comments Client You will need to have installed react ^17.0.2, react-dom ^17.0.2 and react-router-dom ^5.2.0.\nInside of your React project, run this command:\nnpm install strapi-comments-client --save Usage of Strapi Comments Client Using this library is very easy!\nThis library exports three main components:\nCommentsProvider Comments CommentForm And you can import them this way:\nimport { CommentsProvider, Comments, CommentForm } from \u0026#34;strapi-comments-client\u0026#34; All you have to do is wrap your App component into the CommentsProvider component. Then you will be able to place anywhere in your app the Comments component to render a list of comments for a given content ID and the CommentForm component to render a form to post comments.\nFor example, this could be your index.js or main.js file:\nimport React from \u0026#39;react\u0026#39; import ReactDOM from \u0026#39;react-dom\u0026#39; // The address of your strapi backend instance const STRAPI = \u0026#34;http://localhost:1337\u0026#34; ReactDOM.render( \u0026lt;React.StrictMode\u0026gt; \u0026lt;CommentsProvider apiURL={STRAPI}\u0026gt; \u0026lt;App /\u0026gt; \u0026lt;/CommentsProvider\u0026gt; \u0026lt;/React.StrictMode\u0026gt;, document.getElementById(\u0026#39;root\u0026#39;) ) Where apiURL is the URL of your running Strapi application, and this property is required.\nThis way, the comments provider will do all the magic of fetching and posting comments for you!\nThis library also exports an utility React.Context to update some of the parameters for fetching and posting comments:\nimport { CommentsConfigContext } from \u0026#34;strapi-comments-client\u0026#34; This CommentsConfigContext exposes two setter functions: setUser and setContentID\nWith setContentID you can load the comments for a given content and post comments to it. It receives a single parameter of type string and must be URLized, i.e. no spaces.\nWith setUser you can set the credentials of a given user to authorize the posting of comments. It receives a single parameter of type IUser, with the following Typescript interface:\ninterface IUser { username: string, email: string, id: string, token: string // This is a JWT } It\u0026rsquo;s a little confusing but we\u0026rsquo;ll see how to use it in a component:\nconst App = () =\u0026gt; { const { setUser, setContentID } = useContext(CommentsConfigContext) // The following data should come from Strapi Users and Permissions Plugin // for authenticated requests const user = { username: \u0026#34;John Doe\u0026#34;, email: \u0026#34;jhohndoe@gmail.com\u0026#34;, id: 5, token: \u0026#34;this_should_be_a_JWT\u0026#34; } if (user) { setUser(user) } setContentID(\u0026#34;sample-content-1\u0026#34;) // Load comments for this content return ( \u0026lt;\u0026gt; { !user \u0026amp;\u0026amp; \u0026lt;Login /\u0026gt; } \u0026lt;CommentForm /\u0026gt; \u0026lt;Comments /\u0026gt; \u0026lt;/\u0026gt; ) } And that\u0026rsquo;s it!\nAfter setting the content ID through setContentID, CommentsProvider will start loading the comments for the given content ID and the CommentForm will render an input to post comments related to the given content ID if there is a user. Otherwise, it will display the message Login to post a comment.\nHere\u0026rsquo;s how the interface looks like so far:\nThere\u0026rsquo;s also a button to Leave a reply, which will open a form to post a subcomment associated with the parent comment.\nThis library exports one more component: ErrorBox\nimport { ErrorBox } from \u0026#34;strapi-comments-client\u0026#34; .It\u0026rsquo;s useful if you\u0026rsquo;d like to display error messages when things go wrong fetching or posting comments.\nYou can place this component wherever you want, for example in between the CommentForm and the Comments components.\nIf you\u0026rsquo;re wondering how this error box looks like, here you have a sample:\nGeneral settings You can customize the page size, i.e. specify how many comments are returned at once.\nIn the Strapi admin panel, head over to Settings, then select Pagination under Comment Manager Plugin.\nHere you\u0026rsquo;ll find an input to set the page size, which defaults to 10.\nManage comments Once you\u0026rsquo;ve got the plugin up an running, as users start to post comments, you can manage and reply to them as admin from the Comment Manager section of the left sidebar in the Strapi admin dashboard.\nHere you can see two tabs: one for the latest comments and one for comments grouped by content ID.\nIn both of them you can delete comments and subcomments as well as leave replies.\nExample project You can find a full working example of a React App using the Strapi Comments Client Library in this repo\nConclusion With this plugin you can enable and manage comments for any content with little effort and even use a component library to display the comments in your frontend application made with React.\nAnd that\u0026rsquo;s it! The features are pretty basic at the moment but if there\u0026rsquo;s interest, I\u0026rsquo;m willing to work on more features as well as improve the UI/UX.\n","image":"//localhost:1313/images/post/strapilogo.jpg","permalink":"//localhost:1313/blogs/how-to-enable-and-manage-comments-in-your-strapi-application/","tags":["Strapi","Strapi tutorials"],"title":"How To Enable And Manage Comments In Your Strapi Application."},{"categories":["Documentation"],"contents":"Comment Manager is a Strapi plugin to allow your users to post comments.\nWith this plugin you can enable and manage comments for your content very easily!\nRequirements You should have installed an instance of Strapi v4.x.x\nInstallation Run the following command in your project root:\nnpm install strapi-plugin-comment-manager Configurarion For your frontend to have access to the API, enable the following permissions for Comment Manager from Users \u0026amp; Permissions Plugin on your project settings:\nFor public, enable: count, find and getPageSize.\nFor authenticated, enable create on both Comment and Subcomment.\nDisplay comments on the frontend Comments can be displayed in the frontend in two ways:\nUsing the React components library strapi-comments-client (recommended) Build your custom frontend using the API API There are some Typescript interfaces that will help to get an idea of the data structures.\nComments: interface IComment { id: string, from_admin: boolean, createdAt: string, content: string, author: IAuthor | null, subcomments?: ISubcomment[] } Subcomments: interface ISubcomment { id: string, from_admin: boolean, createdAt: string, content: string, author: IAuthor | null, } Authors: IAuthor { username: string, email: string, id: string } The following endpoints are exposed to fetch and post comments and subcomments:\nGet comments for a content ID Method: GET\nPath: /api/comment-manager/comments/:slug\nOptional query parameters: start, ignoreCount\nReturns:\n{ commentsCount?: Number, comments: IComment[] } The parameter start indicates how many comments to skip. This is for pagination purposes.\nThe parameter ignoreCount indicates whether or not to return the total number of comments associated with the given slug.\nGet the number of comments associated with a given content ID Method: GET\nPath: /api/comment-manager/comments/:slug/count\nReturns:\n{ count: Number } Post a comment Method: POST\nPath: /api/comment-manager/comments/:slug\nAuthentication: Bearer token\nPayload:\n{ content: string } Returns:\n{ id: Number } Post a subcomment Method: POST\nPath: /api/comment-manager/subcomments/:parent-id\nAuthentication: Bearer token\nPayload:\n{ content: string } Returns:\n{ id: Number } Get the page size Method: GET\nPath: /api/comment-manager/page-size\nReturns:\n{ pageSize: Number } General settings The plugin allows to set how many comments are returned per page by going to the Pagination section under Comment Manager Plugin on the Settings section.\nThe default page size is 10.\nManagement of comments Admin users are able to delete comments and subcomments as well as leave replies as admins from within the plugin page of the Strapi admin dashboard.\nThe plugin interface has two tabs: one for the latest comments and one for comments by content ID.\nRoadmap and future plans The plugin is pretty basic but it can be improved with more features and a better UI/UX. Collaborations and suggestions are very welcome.\n","image":"//localhost:1313/images/post/strapilogo.jpg","permalink":"//localhost:1313/blogs/strapi-plugin-comment-manager/","tags":["Strapi","Strapi plugins"],"title":"Strapi Plugin Comment Manager"},{"categories":["Projects"],"contents":"In this post I’m going to share my experience on building a SaaS using the headless CMS Strapi as the Backend, React Native and other technologies.\nOutline Introduction What is SaaS? The problem What is Strapi? Developing features in Strapi The frontend: How to get content Conclusion Landing Page Introduction Very often, developers, product and project managers, testers and pretty much the entire team share their ideas to decide what language and which framework they\u0026rsquo;ll use to build their next project. Some considerations must be taken into account, from which in my opinion there are three that are the most important:\nDeveloper experience and ease of use Does the language and framework chosen provide a good developer experience? Is the langauge the same for the backend and frontend?\nDeadlines Is there a deadline to finish the project? if so, there is a good chance to finish the project on time if the team chooses the language they have more experience in.\nMaintainability As there will be usually more than one person working on the same part at the same time, if everything is kept organised, the whole development process will be frictionless.\nWith that in mind, developers and project managers will have a better insight on which language/framework to use.\nOther aspects should also be considered such as what the data structure will look like.\nIn my case, as it is usual, the backend of my project needs a database for users and their roles among other entities and their relations and a dashboard to allow admins to manage the data, and I was lucky to find out Strapi, as it includes a lot of these features out of the box with one single line of command to get started.\nWhat is SaaS? SaaS stands for Software-as-a-Service and it just means that a software is provided as a service in the cloud and it gives a solution to a specific problem, for which the users are willing to pay either monthly or annual subscription.\nThe problem Before starting to write a single line of code, it is generally a good idea to think about the problem, it\u0026rsquo;s limitations and whether or not it has already been solved by someone else (AKA competitors).\nThe problem I was looking into had to do with the way in which public and private transportation companies manage their routes, drivers and users. After a little bit of research, I could only find one platform that provides a similiar solution but for their own company.\nSo the platform I built needed the following content types:\nOrganizations to group routes, drivers and users Routes Two user roles: drivers and users (passengers) As I said before, Strapi makes the creation of these content types and the relationships between them really easy, but let\u0026rsquo;s first see what is Strapi and how it turns the API development into a satisfactory and fun experience.\nWhat is Strapi? Strapi is an open source headless CMS that allows developers to build complete RESTful APIs in just a couple of days instead of months. It includes a lot of useful features as plugins out of the box. Users and Roles management, Media library and an interface to create, view, edit and delete content are just some of them.\nRegarding the API, how does it makes the development faster?\nFirst of all, it enforces a specific folder structure, which helps to keep everything well organised and clean.\nSecondly, all database schemas are generated automatically and queries are made in JSON format, which really saves a lot of time.\nLastly, we can add more features to our Strapi application very easily via plugins from the marketplace.\nIt\u0026rsquo;s also worth noting that Strapi is a self-hosted CMS, which means that we can host it in whatever cloud platform we want, as well as test it locally in our computers before deploying it to the cloud.\nDeveloping features in Strapi Creating and configuring endpoints in Strapi is as straightforward as declaring a JSON in a single file:\nCreating controllers is straightforward as well:\nEvery controller gets all the data related to the request in the ctx parameter and it\u0026rsquo;s also used to send the response. This keeps everything in one place and really helps to improve the readability.\nOnce the API endpoints are defined, the next step is to enable the permissions for the specific user roles to have access to these endpoints:\nThe frontend: how to get content Since Strapi is a headless CMS, it\u0026rsquo;ll only provide content through the API. That means that the content can be consumed from anywhere. In our case, this content will be used in two applications: one for the organization owners and one for the users and drivers.\nThe application for the organization owners is a dashboard where administrators can create organizations, routes, accept drivers and users in the organization and assign routes to drivers. This is just a React Application:\nThe application for drivers and users is a mobile application built in React Native. Firebase was used to synchronise geolocation data in real time between drivers and users and display this information in a Map from Google Maps:\nConclusion Using a CMS as the backend can make the development a lot faster than building the API from scratch and with Strapi this is specially true. Furthermore, this becomes more important when building a brand-new product, as it\u0026rsquo;s usually recommended to launch as soon as possible to gather feedback from the users and validate the idea.\nProject landing page: https://rutieri.netlify.app\n","image":"//localhost:1313/images/post/03.webp","permalink":"//localhost:1313/blogs/how-i-built-a-saas-on-top-of-strapi-and-why-you-should-too/","tags":["Strapi","React Native","Typescript"],"title":"How I Built A SaaS On Top Of Strapi, And Why You Should Too"},{"categories":["Tutorial"],"contents":"Enable User Reviews in a Strapi application and display them in the frontend with React\nOutline Introduction Prerequisites What is Strapi Ratings? Installation Configuration Display user reviews on the frontend Plugin settings Manage user reviews Full source code of the frontend Conclusion Introduction Ratings systems have become a crucial part of any website with ecommerce capabilites, as they allow the users to post reviews on the items they purchase and publish their opinion to the public. A couple of reviews can make the difference between pressing the “Buy” button and moving on to the next website in the Google search results.\nIn this article, I\u0026rsquo;ll show you how to enable and manage user reviews for your content very easily using the Ratings plugin, and display them in your frontend application.\nPrerequisites First of all, you need to have a basic understanding of the following.\nBasic knowledge of JavaScript Basic knowledge of React (OPTIONAL) Basic understanding of Strapi - get started here. Your Strapi V4 project setup What is Strapi Ratings? Strapi Ratings is a plugin that gives your Strapi application the ability to manage ratings for pretty much any kind of content. It allows your users to post reviews and anyone can get the reviews associated with a given slug.\nWith this plugin, admin users can view and manage very easily all the reviews from the Strapi administration dashboard. Within the dashboard, you will be able to see reviews related to content slugs as well as delete reviews.\nInstallation Once into the Strapi project root, you can install the plugin by running the following command:\nnpm install strapi-plugin-ratings Next, build the project to see the new plugin in the dashboard with the following command:\nnpm run build And that\u0026rsquo;s it! If everything runs correctly, the plugin should now be installed.\nConfiguration Now you need to enable some permissions so that the frontend can access the endpoints to post and fetch reviews.\nIn your Strapi admin dashboard, head over to Settings, then over to Roles under Users \u0026amp; Permissions Plugin.\nLet\u0026rsquo;s first setup the Public API; click on Public and hit the dropdown button of Ratings. Now check count, find, getPageSize and getStats, then hit the Save button. Below is a screenshot of a proper configuration:\nNow let\u0026rsquo;s setup the Authenticated API. Go back to Roles and click on Authenticated. Open the dropdown for Ratings and mark as checked the options create, find and getUserReview. Below is a screenshot of a proper configuration:\nWith this configuration, the frontend should now be able to make requests to get and post user reviews.\nDisplay use reviews on the frontend The plugin exposes an API to get and post reviews if you want to have fine-grained control over the workflow of your ratings system and you can check the documentation on the package page, but this plugin also comes with a purpose-built React component library that makes it super easy to get up and running without getting your hands dirty.\nThis components library is called strapi-ratings-client, fully supports typescript and it takes care of all the complexity of fetching and posting user reviews for every content ID that you pass to it.\nInstallation of Strapi Ratings Client You will need to have installed react ^17.0.2, react-dom ^17.0.2, bootstrap ^5.1.3 and @popperjs/core^2.11.2\nInside of your React project, run this command:\nnpm install strapi-ratings-client --save Usage of Strapi Ratings Client Using this library is very easy!\nThis library exports three main components:\nReviewsProvider Reviews ReviewForm And you can import them this way:\nimport { ReviewsProvider, Reviews, ReviewForm } from \u0026#34;strapi-ratings-client\u0026#34; All you have to do is wrap your App component into the ReviewsProvider component. Then you will be able to place anywhere in your app the Reviews component to render a list of user reviews for a given content ID and the ReviewForm component to render a form to allow your users to post reviews.\nFor example, this could be your index.js or main.js file:\nimport React from \u0026#39;react\u0026#39; import ReactDOM from \u0026#39;react-dom\u0026#39; // The address of your strapi backend instance const STRAPI = \u0026#34;http://localhost:1337\u0026#34; ReactDOM.render( \u0026lt;React.StrictMode\u0026gt; \u0026lt;ReviewsProvider apiURL={STRAPI}\u0026gt; \u0026lt;App /\u0026gt; \u0026lt;/ReviewsProvider\u0026gt; \u0026lt;/React.StrictMode\u0026gt;, document.getElementById(\u0026#39;root\u0026#39;) ) Where apiURL is the URL of your running Strapi application, and this property is required.\nThis way, the ratings provider will do all the magic of fetching and posting comments for you!\nThis library also exports an utility React.Context to update some of the parameters for fetching and posting reviews:\nimport { ReviewsConfigContext } from \u0026#34;strapi-ratings-client\u0026#34; This ReviewsConfigContext exposes three setter functions: setUser, setContentID and setCanPostReview.\nWith setContentID you can load the ratings for a given content and post reviews to it. It receives a single parameter of type string and must be URLized, i.e. no spaces.\nWith setUser you can set the credentials of a given user to authorize the posting of reviews. It receives a single parameter of type IUser, with the following Typescript interface:\ninterface IUser { username: string, email: string, id: string, token: string // This is a JWT } With setCanPostReview, you can enable the user to post a review on the given content. This is useful for when you only allow a user to post a review after they purchase the product.\nIt\u0026rsquo;s a little confusing but we\u0026rsquo;ll see how to use it in a component:\nconst App = () =\u0026gt; { const { setUser, setContentID, setCanPostReview } = useContext(ReviewsConfigContext) // The following data should come from Strapi Users and Permissions Plugin // for authenticated requests. const user = { username: \u0026#34;John Doe\u0026#34;, email: \u0026#34;jhohndoe@gmail.com\u0026#34;, id: 5, token: \u0026#34;this_should_be_a_JWT\u0026#34; } if (user) { setUser(user) } setContentID(\u0026#34;sample-content-1\u0026#34;) // Load reviews for this content setCanPostReview(true) // Allow this user to post a review return ( \u0026lt;\u0026gt; { !user \u0026amp;\u0026amp; \u0026lt;Login /\u0026gt; } \u0026lt;ReviewForm /\u0026gt; \u0026lt;Reviews /\u0026gt; \u0026lt;/\u0026gt; ) } And that\u0026rsquo;s it!\nAfter setting the content ID through setContentID, ReviewsProvider will start loading the reviews for the given content ID and the ReviewForm will render an input to post a user review related to the given content ID if there is a user and he’s allowed to post a review. Otherwise, it will display the message Login to post a review or nothing at all if the user is not allowed to post a review.\nHere\u0026rsquo;s how the interface looks like so far:\nThis library exports one more component: ErrorBox\nimport { ErrorBox } from \u0026#34;strapi-ratings-client\u0026#34; .It\u0026rsquo;s useful for when you\u0026rsquo;d like to display error messages when things go wrong fetching or posting reviews.\nYou can place this component wherever you want, for example in between the ReviewForm and the Reviews components.\nIf you\u0026rsquo;re wondering how this error box looks like, here‘s a screenshot:\nGeneral settings You can customize the page size, i.e. specify how many user reviews are showed at once.\nIn the Strapi admin panel, head over to Settings, then select Pagination under Ratings Plugin.\nHere you\u0026rsquo;ll find an input to set the page size, which defaults to 10.\nManage reviews Once you\u0026rsquo;ve got the plugin up an running, as users start to post reviews, you can view them from within the Ratings section of the left sidebar in the Strapi admin dashboard.\nHere you can see two tabs: one for the latest reviews and one for reviews grouped by content ID.\nIn both of them you can delete unwanted reviews.\nExample project You can find a full working example of a React App using the Strapi Ratings Client Library in this repo: https://github.com/luisguve/strapi-ratings-client-example\nConclusion With this plugin you can enable and manage user reviews for any content with little effort and even use a library of components styled with Bootstrap to display the user reviews in your frontend.\nAnd that\u0026rsquo;s it! The features are pretty basic at the moment but if there\u0026rsquo;s interest, I\u0026rsquo;m willing to work on more features as well as improve the UI/UX.\n","image":"//localhost:1313/images/post/tutorial-ratings.webp","permalink":"//localhost:1313/blogs/how-to-enable-and-manage-user-reviews-in-your-strapi-application/","tags":["Strapi","Strapi tutorials"],"title":"How To Enable And Manage User Reviews In Your Strapi Application"},{"categories":["Documentation"],"contents":"Ratings is a Strapi plugin that allows your users to post reviews.\nEnable and manage user reviews for your content very easily!\nRequirements You should have installed an instance of Strapi v4.x.x\nInstallation Run the following command in your project root:\nnpm install strapi-plugin-ratings Then, rebuild the admin dashboard using the following command\nnpm run build Configurarion For your frontend to have access to the API, enable the following permissions for Ratings from Users \u0026amp; Permissions Plugin on your project settings:\nFor public, enable: count, find, getPageSize and getStats.\nFor authenticated, enable create, find and getUserReview.\nDisplay user reviews on the frontend Reviews can be displayed in the frontend in two ways:\nUsing the React components library strapi-ratings-client (recommended) Build your custom frontend using the API endpoints, described as follows: API There are some Typescript interfaces that will help to get an idea of the data structures.\nReviews: interface IReview { id: number, createdAt: string, comment: string | null, author: IAuthor | null, score: number, } Authors: interface IAuthor { username: string, email: string, id: number } Content Stats interface IStats { averageScore: number; reviewsCount: number | null; } The following endpoints are exposed to fetch and post reviews:\nGet reviews for a content ID Method: GET\nPath: /api/ratings/reviews/:slug\nOptional query parameters: start, ignoreCount\nReturns:\n{ reviewsCount: number, averageScore: number, userReview: IReview | null, reviews: IReview[] } The parameter start indicates how many reviews to skip. This is for pagination purposes.\nThe parameter ignoreCount indicates whether or not to return the total number of reviews associated with the given slug.\nGet review stats for a content ID Method: GET\nPath: /api/ratings/reviews/:slug/stats\nReturns:\n{ averageScore: number, reviewsCount: number | null } Get the number of reviews associated with a given content ID Method: GET\nPath: /api/ratings/reviews/:slug/count\nReturns:\n{ count: number } Post a review Method: POST\nPath: /api/ratings/reviews/:slug\nAuthentication: Bearer token\nPayload:\n{ content: string } Returns:\n{ id: number } By default, every authenticated user can post reviews on any content.\nIn order to customize this behavior, e.g. allowing or disallowing a user from posting reviews, you must extend the service userCanPostReview from whithin register function in ./src/index.js. For example:\nstrapi.service(\u0026#34;plugin::ratings.review\u0026#34;).userCanPostReview = async (user, slug) =\u0026gt; { /* Here you will check whether or not the user is allowed to post a review on this content ID and return either true or false. */ return true } Notice that userCanPostReview will receive two parameters: the user from Users \u0026amp; Permissions Plugin, containing it\u0026rsquo;s id, username, confirmed, etc., and the slug, which is a string and refers to the content ID which the review is being posted on.\nIn case this function returns false, the response of the endpoint will be 403 (forbidden) with the text User cannot post a review on this content.\nGet the page size Method: GET\nPath: /api/ratings/page-size\nReturns:\n{ pageSize: number } General settings The plugin allows to set how many reviews are returned per page by going to the Pagination section under Ratings Plugin of the Settings section.\nThe default page size is 10.\nManagement of reviews Admin users are able to delete reviews from within the plugin page of the Strapi admin dashboard.\nThe plugin interface has two tabs: one for the latest reviews and one for reviews by content ID.\nRoadmap and future plans The plugin is pretty basic but it can be improved with more features and a better UI/UX. Collaborations and suggestions are very welcome.\n","image":"//localhost:1313/images/post/ratings.webp","permalink":"//localhost:1313/blogs/strapi-plugin-ratings/","tags":["Strapi","Strapi plugins"],"title":"Strapi Plugin Ratings"},{"categories":["Projects"],"contents":"ManyLMS is an e-learning platform built on top of Strapi, React Router 7, Typescript and other technologies.\nOutline The idea Platform features The stack The API The frontend Conclusion Landing Page The idea This project doesn\u0026rsquo;t necessarily bring a huge amount of innovation on the e-learning platforms that already exists, but it\u0026rsquo;s just another way of doing this type of application.\nThe main idea is to apply a JAMstack approach in this application, where the platform is a static website, and the backend is just an API that serves static content only once to build the website and just adds the dynamism that\u0026rsquo;s necessary to allow users to authenticate, create orders, confirm payments and take courses.\nIf we compare this approach to a WordPress website, we are taking out most of the overhead that implies rendering the pages everytime a user visits them. Despite that there are plugins for caching that may improve the performance, it\u0026rsquo;s still never going to be faster and more efficient than just static content served by a CDN. That\u0026rsquo;s why React Router 7 and Headless CMSs are so popular right now.\nPlatform features and user stories The following user stories illustrates the desired features the platform should have.\nAs an administrator, I want to: login in the admin panel. create categories. create courses. upload lectures. organise courses into categories. assign lectures to courses. As a student, I want to: login in the platform. view the available courses. add courses to the shopping cart. review the shopping cart. create an order. pay with credit card or paypal. view the courses i\u0026rsquo;ve purchased in my learning page. go to the course page from my learning page and watch the videos. mark lectures as seen. come back later and resume where I left. The requirements The backend requires to handle user authentication, permissions, different data structures as content types and define relationships between them. It also requires to allow uploading videos to some third party platform that supports streaming on demand.\nThe frontend is a web platform where users can register and login, view and buy courses, leave comments and reviews and take courses.\nThe API Since all of the features involve authentication, permissions and roles, and because there is no need to reinvent the wheel, I chose to use Strapi to build the backend for it\u0026rsquo;s simplicity, ease of use and great developer experience, whereas for streaming videos on demand, I chose to use Mux.com.\nThe instance of Strapi and the Postgres database it requires was deployed in the cloud hosting platform https://fly.io.\nStrapi is good for managing users, content that\u0026rsquo;s typically updated and fetched via CRUD API, and setting up relations between content types.\nThe platform needs the following content types:\nCategory to group courses Course Lecture Module to group lectures Order Student: has many courses Student-Course: stores a student\u0026rsquo;s current lecture of a course Video Strapi makes the creation of these content types and setting up relationships between them really straightforward.\nBelow are some screenshots of these content types and the relationships between them:\nThe frontend The platform where users are able to login, view, buy and view courses is a web application built with React Router 7. Among the features of this application are:\nState managed by Context API Interface styled with Bootstrap Play streaming videos with @mux/mux-player-react library Use of localStorage to save user session Below are some sample screenshots of how this app looks like\nConclusion and final thoughts While building this project, I learned:\nHow streaming on demand works and how to use a streaming provider How to statically build websites with React Router 7 and Strapi How to setup dynamic pages in React Router 7 How to process payments with Stripe and Paypal How to build custom plugins in Strapi How to publish packages to NPM Project source codes: https://github.com/luisguve/maestro-backend\nhttps://github.com/luisguve/new-lms-remix\n","image":"//localhost:1313/images/project/manylms/frontend/course_overview.png","permalink":"//localhost:1313/projects/e-learning-platform-maestro-lms/","tags":["Strapi","React","React Router 7","Typescript","Mux"],"title":"ManyLMS: E-Learning platform"},{"categories":["Projects"],"contents":"ETMday (Emprende tu Mente) is a large-scale entrepreneurship event website built on top of WordPress with the Themosis framework, featuring an interactive SVG map, real-time countdown timers, advanced search functionality, and comprehensive content management using Vue 3, Laravel Mix, and modern frontend technologies.\nOutline The project Key features The stack Frontend architecture Interactive components Conclusion Live website The project ETMday is Chile\u0026rsquo;s premier entrepreneurship event, bringing together thousands of entrepreneurs, startups, corporates, and strategic partners. The website serves as the central hub for event information, featuring speakers, activities, stands, program schedules, and an interactive event map.\nThe frontend development required implementing complex interactive features including an SVG-based interactive map with tooltips, real-time countdown timers, advanced filtering and search systems, and dynamic content displays that handle thousands of attendees and hundreds of activities.\nKey features The website includes several sophisticated features:\nInteractive SVG Map: Custom-built interactive map with clickable zones, tooltips, and dynamic content display Real-time Countdown: Event countdown timer with automatic updates and mobile optimization Advanced Search: Multi-category search across activities, speakers, stands, and content Dynamic Filtering: Complex filtering system with tabs, favorites, and downloadable resources Animated Statistics: Odometer animations for displaying event metrics Content Management: Comprehensive card components for activities, speakers, stands, and blog posts Form Handling: Multi-step forms with validation using Vee-Validate Lightbox Galleries: Image galleries with LightGallery integration Responsive Design: Fully responsive design optimized for all devices The stack The frontend stack consists of:\nVue 3.2.4: Modern reactive framework for building interactive components Laravel Mix 6.0: Asset compilation and bundling SCSS: Advanced styling with organized architecture Vee-Validate 4.15.0: Form validation with Yup schemas Axios 1.6.8: HTTP client for API requests Splide.js 4.1.4: Modern carousel and slider components LightGallery 2.8.3: Lightbox gallery functionality Odometer 0.4.8: Animated number counting Headroom.js: Header behavior on scroll jQuery 3.7.1: DOM manipulation and legacy support SweetAlert2: Modern alert dialogs GLightbox 3.3.1: Alternative lightbox solution Frontend architecture Vue components The application features a comprehensive set of Vue 3 components:\nCard Components:\ncards/activities.vue: Activity cards with favorites functionality cards/speakers.vue: Speaker cards with modal details cards/stands.vue: Stand/exhibitor cards cards/blog.vue: Blog post cards cards/shortcut.vue: Quick access shortcut cards Functional Components:\nSectionCards.vue: Main section component with tabs, filtering, and card display Search.vue: Advanced search component with multi-category results Form.vue: Dynamic form component with validation FormCalendar.vue: Calendar form component CustomFilter.vue: Reusable filter component CustomSelect.vue: Custom select dropdown Pagination.vue: Pagination component JavaScript components The application includes 17 specialized JavaScript components:\nInteractive Features:\ninteractiveMap.js: SVG map interaction with tooltips, zones, and dynamic content countdown.js: Real-time countdown timer with automatic updates odometer.js: Animated number counting with scroll triggers map.js: Map zone interactions and modal displays UI Components:\nheader.js: Header functionality and navigation headroom.js: Header hide/show on scroll accordion.js: Accordion interactions tabs.js: Tab functionality cards.js: Card interactions and modals siteModals.js: Modal management system UI.js: General UI utilities Media Components:\nvideo.js: Video player setup lightgallery.js: Lightbox gallery initialization splide.js: Carousel initialization slick.js: Legacy carousel support Utilities:\nscrollTrigger.js: Scroll-based animations imgToSvg.js: SVG image conversion utility SCSS architecture The styling follows a well-organized SCSS architecture:\nscss/ ├── abstracts/ # Variables, mixins, functions │ ├── _functions.scss │ ├── _mixins.scss │ ├── _variables.scss │ ├── _mq.scss # Media query mixins │ └── _keyframes.scss ├── base/ # Base styles and typography │ ├── _typography.scss │ ├── _container.scss │ └── _reset.scss └── components/ # Component-specific styles └── [52 component files] Key SCSS features:\nBEM methodology: Consistent naming convention Media query mixins: Using sass-mq for responsive design Modular architecture: Each component has its own SCSS file Component organization: 52 component-specific SCSS files Interactive components Interactive SVG Map The interactiveMap.js component implements a sophisticated SVG-based interactive map:\nFeatures:\nSVG Tooltips: Dynamically generated tooltips with text wrapping Zone Interactions: Clickable zones with modal displays Point Markers: Interactive points with icons and labels Dynamic Content: Content loaded based on zone/point selection Responsive Design: Optimized for mobile and desktop Technical Implementation:\nSVG namespace manipulation for tooltip creation Text wrapping algorithm for tooltip content Path generation for tooltip shapes with rounded corners Event delegation for zone and point interactions Smooth animations and transitions Real-time Countdown The countdown.js component provides a real-time countdown timer:\nFeatures:\nAutomatic Updates: Updates every second Multi-unit Display: Days, hours, minutes, and seconds Pluralization: Proper Spanish pluralization (Día/Días, Hora/Horas) Mobile Optimization: Simplified display on mobile devices End State Handling: Automatic transition when countdown ends Advanced Search System The Search.vue component implements a comprehensive search system:\nFeatures:\nMulti-category Search: Searches across activities, speakers, stands, and other content Category Tabs: Quick navigation between result categories Result Counts: Dynamic result counts per category Scroll Navigation: Smooth scrolling to category sections Carousel Display: Splide carousels for result display Loading States: Loading indicators during search Empty States: User-friendly empty state messages Dynamic Filtering System The SectionCards.vue component provides advanced filtering:\nFeatures:\nTab Navigation: Multiple filter tabs Favorites System: Save and filter favorite items Search Integration: Inline search within filters Reset Functionality: Clear all filters with one click Downloadable Resources: Download buttons for resources URL Synchronization: Filter state in URL parameters Responsive Design: Mobile accordion interface Animated Statistics The odometer.js component provides animated number counting:\nFeatures:\nScroll-triggered: Animations trigger on scroll Prefix/Suffix Support: Handles formatted numbers (e.g., \u0026ldquo;56,000+\u0026rdquo;) Mobile Optimization: Static display on mobile Smooth Animations: Odometer theme integration Development workflow The project uses Laravel Mix for asset compilation:\n// Development npm run dev // Compile assets npm run watch // Watch for changes npm run hot // Hot module replacement // Production npm run production // Optimized production build BrowserSync integration provides:\nLive reloading during development Synchronized browser testing Proxy configuration for WordPress development Performance optimizations Code splitting: Laravel Mix extracts vendor libraries Asset versioning: Automatic cache busting Image optimization: Lazy loading and responsive images Minification: Production builds are minified and optimized Tree shaking: Unused code elimination in production SVG optimization: Efficient SVG manipulation and rendering Accessibility Semantic HTML structure ARIA labels for interactive elements Keyboard navigation support Focus management in forms and modals Screen reader considerations Proper alt text for images Conclusion and final thoughts Building the ETMday frontend was an excellent opportunity to:\nMaster SVG interactions: Creating complex interactive SVG maps with dynamic tooltips and zones Implement real-time features: Building countdown timers and live updates Build advanced search: Multi-category search with filtering and categorization Handle complex state: Managing filters, favorites, and dynamic content Optimize performance: Implementing efficient animations and lazy loading Ensure scalability: Building components that handle large datasets (thousands of attendees, hundreds of activities) The project demonstrates proficiency in:\nModern JavaScript frameworks (Vue 3) SVG manipulation and interaction Real-time UI updates Advanced filtering and search systems Build tools and asset compilation (Laravel Mix, Webpack) CSS architecture and methodologies (SCSS, BEM) Component-based development Event-driven architecture The integration with WordPress/Themosis backend required careful consideration of server-side rendering, API endpoints, and content management workflows, making this a full-stack frontend implementation for a large-scale event.\nLive website: https://etmday.org/\nFigma Prototype: https://www.figma.com/proto/mt9fJ8P03M5gf0nQwcU99q/EtM-Day-2025---Dise%C3%B1o?node-id=1-2743\u0026m=dev\u0026scaling=scale-down\u0026content-scaling=fixed\u0026page-id=0%3A1\u0026starting-point-node-id=1%3A2743\n","image":"//localhost:1313/images/project/etm/home.png","permalink":"//localhost:1313/projects/etmday-entrepreneurship-event-website/","tags":["Vue 3","Laravel Mix","WordPress","Themosis","SCSS","JavaScript","Interactive Map","SVG"],"title":"ETMday: Entrepreneurship Event Website"},{"categories":["Projects"],"contents":"JAC Autos Chile is a comprehensive automotive website built on top of WordPress with the Themosis framework, featuring car model comparisons, multi-step quote forms, fleet management, branch listings, and advanced filtering systems using Vue 3, Pinia state management, Laravel Mix, and modern frontend technologies.\nOutline The project Key features The stack Frontend architecture Interactive components Conclusion Live website The project JAC Autos Chile is the official website for JAC Motors in Chile, showcasing SUVs, pickups, commercial vehicles, and electric vehicles. The website serves as the primary platform for vehicle exploration, quoting, dealership location, fleet management, and post-sale services.\nThe frontend development required implementing complex interactive features including car model comparisons, multi-step quote forms with model and version selection, advanced filtering systems, fleet management interfaces, and comprehensive content management.\nKey features The website includes several sophisticated features:\nCar Model Comparator: Side-by-side comparison of multiple vehicle models with difference highlighting Multi-step Quote Form: Comprehensive quote form with model selection, version selection, and customer information Advanced Filtering: Multi-criteria filtering for car models, branches, fleet vehicles, and blog posts Fleet Management: Dedicated fleet vehicle selection and management interface Branch Locator: Filterable dealership/branch listings with location information Blog System: Complete blog with filtering, search, and content management Manuals Listing: User manual and documentation management Search Functionality: Site-wide search with categorized results Sticky Navigation: Section-based sticky navigation for long pages 360° View: Interactive 360-degree vehicle viewing The stack The frontend stack consists of:\nVue 3.2.4: Modern reactive framework with Composition API Pinia 2.2.6: State management for Vue applications Laravel Mix 6.0: Asset compilation and bundling SCSS: Advanced styling with organized architecture Vee-Validate 4.14.6: Form validation with Yup schemas Axios 1.6.8: HTTP client for API requests Splide.js 4.1.4: Modern carousel and slider components @splidejs/vue-splide 0.6.12: Vue 3 wrapper for Splide Maska 3.0.3: Input masking for formatted inputs Vue-Select 4.0.0-beta.6: Custom select component Vue-Recaptcha 2.0.3: reCAPTCHA integration Headroom.js: Header behavior on scroll jQuery 3.7.1: DOM manipulation and legacy support SweetAlert2: Modern alert dialogs @fdograph/rut-utilities: Chilean RUT validation utilities Frontend architecture Vue components The application features a comprehensive set of Vue 3 components (40+ components):\nCar Model Components:\nCar.vue: Car model card component with comparison functionality CarLoading.vue: Loading skeleton for car cards CarVersion.vue: Car version/trim level component CarVersionLoading.vue: Loading skeleton for version cards CarModelsListingStatic.vue: Static car models listing CarModelsListingQuote.vue: Car models listing for quote flow CarVersionsListingQuote.vue: Versions listing for quote flow CarQuote.vue: Car quote display component CarQuoteLoading.vue: Loading skeleton for quote cards Comparison Components:\nComparator.vue: Main car comparison component with Splide integration ComparatorModal.vue: Modal version of comparator CardCompareModel.vue: Comparison card for individual models CardCompareModelLoading.vue: Loading skeleton for comparison cards Quote Components:\nQuote.vue: Main quote component with multi-step flow QuoteForm.vue: Comprehensive quote form with validation Filtering Components:\nFilters.vue: General filtering component FleetFilter.vue: Fleet-specific filtering BranchesFilter.vue: Branch/dealership filtering BlogFilter.vue: Blog post filtering AjaxListWithFilter.vue: AJAX-powered list with filtering Content Components:\nBlog.vue: Blog post card component BlogLoading.vue: Loading skeleton for blog cards Fleet.vue: Fleet vehicle card component Branch.vue: Branch/dealership card component BranchLoading.vue: Loading skeleton for branch cards Manual.vue: Manual/documentation card component ManualLoading.vue: Loading skeleton for manual cards ManualsListing.vue: Manuals listing component Form Components:\nContactForm.vue: Contact form with validation Select.vue: Custom select dropdown component UI Components:\nPagination.vue: Pagination component StickySectionSelector.vue: Sticky navigation for sections EmptyState.vue: Empty state displays Loader.vue: Loading indicator ErrorBoundary.vue: Error boundary component SearchResults.vue: Search results display SearchResultCard.vue \u0026amp; SearchResultCardLoading.vue: Search result cards Service Components:\nCardMaintenance.vue: Maintenance service card CardMaintenanceLoading.vue: Loading skeleton for maintenance cards JavaScript components The application includes 12 specialized JavaScript components:\nUI Components:\nheader.js: Header functionality and navigation headroom.js: Header hide/show on scroll megamenu.js: Mega menu functionality search-modal.js: Search modal functionality scrollUpBottom.js: Scroll to top/bottom functionality social-share.js: Social media sharing Media Components:\nvideo.js: Video player setup splide.js: Carousel initialization slick.js: Legacy carousel support Interactive Components:\naccordion.js: Accordion interactions tabs.js: Tab functionality Utilities:\nimg-to-svg.js: SVG image conversion utility scrollTrigger.js: Scroll-based animations SCSS architecture The styling follows a well-organized SCSS architecture:\nscss/ ├── abstracts/ # Variables, mixins, functions │ ├── _mixins.scss │ ├── _mq.scss # Media query mixins │ └── _vendor.scss ├── base/ # Base styles and typography │ ├── _typography.scss │ ├── _colors.scss │ ├── _container.scss │ └── _globals.scss └── components/ # Component-specific styles ├── [87 component files] └── cards/ # Card component styles └── [20 card-specific files] Key SCSS features:\nBEM methodology: Consistent naming convention throughout Media query mixins: Using sass-mq for responsive design Modular architecture: 106 component-specific SCSS files Card organization: Dedicated card component styles Interactive components Car model comparator The Comparator.vue component provides sophisticated car model comparison:\nFeatures:\nSide-by-side comparison: Compare up to 3 models simultaneously Difference highlighting: Toggle to highlight differences between models Splide integration: Smooth carousel navigation for multiple models Dynamic data loading: Load comparison data via AJAX Responsive design: Optimized for mobile and desktop Modal version: Full-screen modal comparison view Technical Implementation:\nPinia store for comparison state management Splide Vue component for carousel functionality Dynamic component rendering based on selected models Efficient data structure for comparison attributes Multi-step quote form The Quote.vue and QuoteForm.vue components implement a comprehensive quote system:\nFeatures:\nStep-by-step flow: Model selection → Version selection → Customer information Form validation: Using Vee-Validate with Yup schemas RUT validation: Chilean RUT validation using custom directive Input masking: Phone numbers and formatted inputs with Maska reCAPTCHA integration: Spam protection Edit functionality: Ability to go back and edit previous steps Selected vehicle display: Visual representation of selected model/version Loading states: Visual feedback during form submission Form steps include:\nStep 1: Category and model selection Step 2: Version/trim level selection Step 3: Customer information and submission Advanced filtering systems Multiple filtering components provide comprehensive filtering:\nFleet Filter (FleetFilter.vue):\nFilter fleet vehicles by category, price range, and features Real-time filtering with URL parameter synchronization Mobile-optimized interface Branches Filter (BranchesFilter.vue):\nFilter dealerships by location, region, and services Map integration support Contact information display Blog Filter (BlogFilter.vue):\nFilter blog posts by category, date, and tags Search functionality Pagination support Ajax List with Filter (AjaxListWithFilter.vue):\nGeneric AJAX-powered list component Multiple filter criteria Loading states and empty states Sticky section selector The StickySectionSelector.vue component provides section-based navigation:\nFeatures:\nSticky positioning: Stays visible while scrolling Active section highlighting: Highlights current section Smooth scrolling: Smooth scroll to sections Responsive design: Mobile-optimized display State management with Pinia The application uses Pinia for centralized state management:\nStores:\nComparator Store: Manages comparison state, selected models, and comparison data Quote Store: Manages quote flow state, selected model/version, and form data Filter Stores: Manage filter states for different content types Benefits:\nCentralized state management Type-safe state access Efficient reactivity Easy debugging with Vue DevTools Custom directives The application includes custom Vue directives:\nRUT Directive (input-rut):\nChilean RUT (tax ID) validation and formatting Real-time validation as user types Format enforcement (XX.XXX.XXX-X) Development workflow The project uses Laravel Mix for asset compilation:\n// Development npm run dev // Compile assets npm run watch // Watch for changes npm run hot // Hot module replacement // Production npm run production // Optimized production build BrowserSync integration provides:\nLive reloading during development Synchronized browser testing Proxy configuration for WordPress development Performance optimizations Code splitting: Laravel Mix extracts vendor libraries Asset versioning: Automatic cache busting Image optimization: Lazy loading and responsive images Minification: Production builds are minified and optimized Tree shaking: Unused code elimination in production Component lazy loading: Load components on demand Skeleton loading: Better perceived performance with loading states Accessibility Semantic HTML structure ARIA labels for interactive elements Keyboard navigation support Focus management in forms and modals Screen reader considerations Proper alt text for images Color contrast compliance Conclusion and final thoughts Building the JAC Autos Chile frontend was an excellent opportunity to:\nMaster Vue 3: Working with Composition API, Pinia state management, and modern Vue patterns Build complex comparisons: Creating sophisticated car model comparison interfaces Implement multi-step forms: Complex quote forms with validation, RUT formatting, and step navigation Create advanced filtering: Multiple filtering systems for different content types Optimize performance: Implementing efficient state management, lazy loading, and code splitting Handle automotive data: Managing complex vehicle data structures and relationships The project demonstrates proficiency in:\nModern JavaScript frameworks (Vue 3) State management (Pinia) Form validation and user experience (Vee-Validate, Yup, Maska) Build tools and asset compilation (Laravel Mix, Webpack) CSS architecture and methodologies (SCSS, BEM) Component-based development Custom directives Carousel and slider implementations (Splide) AJAX-powered interfaces The integration with WordPress/Themosis backend required careful consideration of server-side rendering, API endpoints, and content management workflows, making this a full-stack frontend implementation for a comprehensive automotive platform.\nLive website: https://jacautoschile.cl/\nFigma Prototype: https://www.figma.com/proto/wfsYoYThSR9VId6TVUGevk/JAC---Dise%C3%B1o-desktop?node-id=1-232\u0026m=dev\u0026scaling=min-zoom\u0026content-scaling=fixed\u0026page-id=0%3A1\u0026starting-point-node-id=62%3A3801\n","image":"//localhost:1313/images/project/jac/home.png","permalink":"//localhost:1313/projects/jac-autos-chile-automotive-website/","tags":["Vue 3","Pinia","Laravel Mix","WordPress","Themosis","SCSS","JavaScript","Splide"],"title":"JAC Autos Chile: Automotive Website"},{"categories":["Projects"],"contents":"ISC Chile is an educational consultancy website for study abroad programs, built on top of WordPress with the Themosis framework, featuring GSAP animations, multi-step contact forms, advanced blog filtering, and comprehensive content management using Vue 2, Laravel Mix, and modern frontend technologies.\nOutline The project Design implementation The stack Frontend architecture Key features Conclusion Live website The project ISC Chile is an educational consultancy agency that has been providing study abroad advisory services since 1996. The website serves as the primary platform for showcasing various educational programs including English courses, school exchanges, group travel programs, and Pathways programs for university admission abroad.\nThe frontend development was based on a comprehensive Figma design, requiring pixel-perfect implementation of complex UI components, multi-step forms, animated statistics, and responsive layouts that work seamlessly across all devices.\nDesign implementation The entire frontend was built from a detailed Figma design, ensuring:\nPixel-perfect accuracy: Matching the design specifications precisely (as evidenced by Figma height references in SCSS) Responsive design: Implementing breakpoints and mobile-first approach Component consistency: Maintaining design system patterns throughout Interactive elements: Translating static designs into dynamic, interactive components Animation and transitions: Implementing smooth GSAP-powered animations The stack The frontend stack consists of:\nVue 2.6.12: Reactive framework for building interactive components Laravel Mix 6.0: Asset compilation and bundling SCSS: Advanced styling with a well-organized architecture Vuex 3.6.2: State management for Vue applications Vee-Validate 3.4.14: Form validation GSAP 3.12.5: Professional animation library with ScrollTrigger Axios 0.18: HTTP client for API requests Splide.js 4.1.4: Modern carousel and slider components Slick Carousel 1.8.1: Legacy carousel support LightGallery 2.7.2: Lightbox gallery functionality Odometer 0.4.8: Animated number counting Headroom.js: Header behavior on scroll V-Calendar 2.4.2: Calendar component for date selection V-Mask 2.3.0: Input masking Vue-Select 3.20.2: Custom select component jQuery 3.2: DOM manipulation and legacy support SweetAlert: Alert dialogs Frontend architecture Vue components The application features a comprehensive set of Vue 2 components:\nForm Components:\nContact.vue: Multi-step contact form with validation and reCAPTCHA ContactFormStep1.vue: First step of the contact form ContactFormStep2.vue: Second step of the contact form ContactFormStep3.vue: Third step of the contact form FormBanner.vue: Banner form component Content Components:\nBlog.vue: Blog listing with advanced filtering and search BlogArticleCard.vue \u0026amp; BlogArticleCardLoading.vue: Blog post cards with loading states ExperiencesPanel.vue: Testimonials and experiences display panel ExperiencesFiltersMobile.vue: Mobile filter component for experiences Search Components:\nSearchResults.vue: Search results display component SearchResultCardLoading.vue: Loading skeleton for search results UI Components:\nCheckboxDropdown.vue: Custom checkbox dropdown component CheckboxDropdownFieldset.vue: Fieldset wrapper for checkbox dropdowns EmptyState.vue: Empty state displays Loader.vue \u0026amp; Loading.vue: Loading indicators JavaScript components The application includes 15 specialized JavaScript components:\nAnimation Components:\ngsap.js: GSAP animations with ScrollTrigger for scroll-based reveals scrolltrigger.js: Custom scroll trigger utilities odometer.js: Animated number counting with scroll triggers UI Components:\nheader.js: Header functionality and navigation headroom.js: Header hide/show on scroll megamenu.js: Mega menu functionality mobileMenu.js: Mobile menu interactions searchbar.js: Search bar functionality floating-banner.js: Floating banner component footer.js: Footer functionality Media Components:\nvideo.js: Video player setup lightgallery.js: Lightbox gallery initialization splide.js: Carousel initialization slick.js: Legacy carousel support Interactive Components:\naccordion.js: Accordion interactions tabs.js: Tab functionality cards.js: Card interactions Utilities:\nimg-to-svg.js: SVG image conversion utility SCSS architecture The styling follows a well-organized SCSS architecture:\nscss/ ├── abstracts/ # Variables, mixins, functions │ ├── _mixins.scss │ ├── _mq.scss # Media query mixins │ └── _vendor.scss ├── base/ # Base styles and typography │ ├── _typography.scss │ ├── _colors.scss │ ├── _container.scss │ ├── _globals.scss │ └── fonts/ # Custom TWK Everett font family └── components/ # Component-specific styles └── [45 component files] Key SCSS features:\nBEM methodology: Consistent naming convention throughout Media query mixins: Using sass-mq for responsive design Modular architecture: Each component has its own SCSS file Custom typography: TWK Everett font family with multiple weights Figma references: Direct references to Figma design specifications Key features Multi-step contact form The Contact.vue component implements a sophisticated multi-step form with:\nThree-step navigation: Step-by-step form progression Form validation: Using Vee-Validate with comprehensive rules Date picker: V-Calendar integration for date selection Input masking: V-Mask for phone numbers and formatted inputs reCAPTCHA integration: Spam protection Dynamic fields: Fields that change based on user selections Loading states: Visual feedback during form submission Error handling: Comprehensive error messages and validation Form steps include:\nStep 1: Personal information and contact details Step 2: Educational background and program interests Step 3: Additional information and submission GSAP animations The gsap.js component provides professional animations:\nFeatures:\nScroll-triggered animations: Elements animate on scroll Vertical scroll reveals: Fade and slide animations Horizontal scroll reveals: Staggered animations for grid layouts Timeline management: Complex animation sequences Performance optimized: Efficient animation triggers Animation types:\nFade in with vertical movement Staggered grid animations Scroll-based reveals Smooth transitions Advanced blog system The Blog.vue component provides comprehensive blog functionality:\nFeatures:\nCategory filtering: Filter posts by category Search functionality: Real-time search across blog posts Mobile filters: Dedicated mobile filter interface Pagination: Efficient content pagination Loading states: Skeleton loading screens Empty states: User-friendly empty state messages Experiences/testimonials panel The ExperiencesPanel.vue component displays student testimonials:\nFeatures:\nFilter by type: Filter testimonials (Students/Parents) Dynamic loading: Load testimonials from API Responsive design: Mobile-optimized display Carousel integration: Splide carousel for testimonial display Animated statistics The odometer.js component provides animated number counting:\nFeatures:\nScroll-triggered: Animations trigger on scroll Smooth counting: Odometer theme integration Performance optimized: Efficient scroll detection Mobile support: Optimized for all devices Search functionality The SearchResults.vue component provides comprehensive search:\nFeatures:\nMulti-content search: Search across programs, blog posts, and pages Result categorization: Organized search results Image support: Results with and without images Tag display: Category tags for results Loading states: Skeleton loading screens Custom typography The website features a custom font family, TWK Everett, with:\nMultiple weights: From Hairline to Super Italic variants: All weights include italic versions Optimized formats: WOFF, WOFF2, and OTF formats Performance: Efficient font loading and rendering Development workflow The project uses Laravel Mix for asset compilation:\n// Development npm run dev // Compile assets npm run watch // Watch for changes npm run hot // Hot module replacement // Production npm run production // Optimized production build BrowserSync integration provides:\nLive reloading during development Synchronized browser testing Proxy configuration for WordPress development Performance optimizations Code splitting: Laravel Mix extracts vendor libraries Asset versioning: Automatic cache busting Image optimization: Lazy loading and responsive images Minification: Production builds are minified and optimized Tree shaking: Unused code elimination in production Font optimization: Efficient font loading strategies Accessibility Semantic HTML structure ARIA labels for interactive elements Keyboard navigation support Focus management in forms Screen reader considerations Proper alt text for images Conclusion and final thoughts Building the ISC Chile frontend from a Figma design was an excellent opportunity to:\nMaster Vue 2: Working with Options API, Vuex state management, and Vue 2 patterns Implement GSAP animations: Creating professional scroll-triggered animations Build complex forms: Multi-step forms with validation, date pickers, and input masking Create advanced filtering: Blog filtering with search and category selection Optimize performance: Implementing efficient animations and lazy loading Ensure design fidelity: Translating Figma designs into pixel-perfect implementations (with direct Figma references in code) The project demonstrates proficiency in:\nModern JavaScript frameworks (Vue 2) Animation libraries (GSAP, ScrollTrigger) Form validation and user experience (Vee-Validate, V-Mask, V-Calendar) Build tools and asset compilation (Laravel Mix, Webpack) CSS architecture and methodologies (SCSS, BEM) Component-based development State management (Vuex) Design system implementation The integration with WordPress/Themosis backend required careful consideration of server-side rendering, API endpoints, and content management workflows, making this a full-stack frontend implementation for an educational consultancy platform.\nLive website: https://www.iscchile.cl/\nFigma prototype: https://www.figma.com/proto/BfdKGJlzx7xAnE7rpZ1vda/Dise%C3%B1o-ISC?page-id=314%3A12071\u0026type=design\u0026node-id=314-12072\u0026viewport=-1452%2C930%2C0.29\u0026t=hFYiwcionjRAZ47v-1\u0026scaling=min-zoom\n","image":"//localhost:1313/images/project/isc-chile/home.png","permalink":"//localhost:1313/projects/isc-chile-educational-consultancy-website/","tags":["Vue 2","Laravel Mix","WordPress","Themosis","SCSS","GSAP","JavaScript","Figma"],"title":"ISC Chile: Educational Consultancy Website"},{"categories":["Projects"],"contents":"Chile Nativo is a travel tour website for Patagonia experiences, built on top of WordPress with the Themosis framework, featuring a modern frontend implementation based on a Figma design using Vue 3, Laravel Mix, and a comprehensive SCSS architecture.\nOutline The project Design implementation The stack Frontend architecture Key features Conclusion Live website The project Chile Nativo is a travel company specializing in Patagonia tours, offering experiences in destinations like Torres del Paine, Tierra del Fuego, and Isla Navarino. The website serves as the primary platform for showcasing tours, managing bookings, and providing information about their travel experiences.\nThe frontend development was based on a comprehensive Figma design, requiring pixel-perfect implementation of complex UI components, interactive forms, filtering systems, and responsive layouts that work seamlessly across all devices.\nDesign implementation The entire frontend was built from a detailed Figma design, ensuring:\nPixel-perfect accuracy: Matching the design specifications precisely Responsive design: Implementing breakpoints and mobile-first approach Component consistency: Maintaining design system patterns throughout Interactive elements: Translating static designs into dynamic, interactive components Animation and transitions: Implementing smooth user experience enhancements The stack The frontend stack consists of:\nVue 3.2.4: Modern reactive framework for building interactive components Laravel Mix 6.0: Asset compilation and bundling SCSS: Advanced styling with a well-organized architecture Pinia 2.3.1: State management for Vue applications Vee-Validate 4.15.0: Form validation with Yup schemas Axios 1.6.8: HTTP client for API requests Splide.js 4.1.4: Modern carousel and slider components Headroom.js: Header behavior on scroll Plyr 3.7.8: Video player implementation SweetAlert2: Modern alert dialogs jQuery 3.7.1: Legacy support and DOM manipulation utilities Frontend architecture Vue components The application features a comprehensive set of Vue 3 components organized by functionality:\nFiltering and Search Components:\nToursFilter.vue: Advanced tour filtering with multiple criteria TourDatesFilter.vue: Date-based filtering for tour availability ToursFilterDropdown.vue \u0026amp; ToursFilterDropdownMobile.vue: Responsive filter dropdowns TestimonialsFilter.vue: Filtering system for customer testimonials NewsFilter.vue: Blog and news filtering SearchResults.vue: Search results display with pagination Form Components:\nPersonalizedTripForm.vue: Multi-step form for custom trip requests with validation ContactFormSimple.vue: Contact form with reCAPTCHA integration FormHelp.vue: Help center form FormGiftCard.vue: Gift card purchase form FormCareers.vue: Job application form NewsletterForm.vue: Newsletter subscription Card Components:\nTour.vue \u0026amp; TourLoading.vue: Tour card display with loading states TourDate.vue \u0026amp; TourDateLoading.vue: Tour date selection cards Testimonial.vue \u0026amp; TestimonialLoading.vue: Customer testimonial cards Blog.vue \u0026amp; BlogLoading.vue: Blog post cards Team.vue \u0026amp; TeamLoading.vue: Team member cards ResourceCard.vue \u0026amp; ResourceLoading.vue: Resource display cards Utility Components:\nPagination.vue: Reusable pagination component Select.vue: Custom select dropdown with search Loader.vue \u0026amp; LoaderFullScreen.vue: Loading indicators EmptyState.vue: Empty state displays ContentResources.vue: Resource content management TeamTabsFilter.vue: Tabbed team member filtering SCSS architecture The styling follows a well-organized SCSS architecture:\nscss/ ├── abstracts/ # Variables, mixins, functions │ ├── _functions.scss │ ├── _mixins.scss │ ├── _variables.scss │ ├── _mq.scss # Media query mixins │ └── _keyframes.scss ├── base/ # Base styles and typography │ ├── _typography.scss │ ├── _colors.scss │ ├── _fonts.scss │ └── _reset.scss └── components/ # Component-specific styles └── [125 component files] Key SCSS features:\nBEM methodology: Consistent naming convention throughout Media query mixins: Using sass-mq for responsive design Modular architecture: Each component has its own SCSS file Abstract layer: Reusable variables, mixins, and functions Vue transitions: Custom transition styles for Vue components JavaScript architecture The JavaScript is organized into two main entry points:\nMain application (app.js):\nInitializes core application functionality Sets up jQuery plugins and utilities Handles legacy browser support Vue application (vue/main.js):\nConfigures Vue 3 app with Pinia for state management Registers global Vue components Sets up Vee-Validate configuration Integrates third-party Vue plugins (VueTelInput, etc.) Component utilities (app/components/):\nheader.js: Header behavior and navigation footer.js: Footer functionality splide.js: Carousel initialization slick.js: Legacy carousel support accordions.js: Accordion interactions tabs.js: Tab functionality scrollTrigger.js: Scroll-based animations video.js: Video player setup sticky-sidebar.js: Sticky sidebar behavior Key features Multi-step forms The PersonalizedTripForm.vue component implements a sophisticated multi-step form with:\nStep-by-step navigation with progress indicators Form validation using Vee-Validate and Yup schemas Dynamic form fields based on user selections Phone number input with international support (VueTelInput) reCAPTCHA integration for spam protection Loading states and error handling Advanced filtering system The tour filtering system (ToursFilter.vue) provides:\nMultiple filter criteria (destination, activity type, trip type, month) Real-time filtering with URL parameter synchronization Responsive design with mobile accordion interface Custom select components with search functionality Empty states and loading indicators Integration with WordPress backend via Axios Responsive design The entire website is fully responsive with:\nMobile-first approach Breakpoint management using sass-mq Touch-friendly interactions Optimized images and assets Performance optimizations for mobile devices Performance optimizations Code splitting: Laravel Mix extracts vendor libraries Asset versioning: Automatic cache busting Image optimization: Lazy loading and responsive images Minification: Production builds are minified and optimized Tree shaking: Unused code elimination in production Accessibility Semantic HTML structure ARIA labels where appropriate Keyboard navigation support Focus management in forms Screen reader considerations Development workflow The project uses Laravel Mix for asset compilation:\n// Development npm run dev // Compile assets npm run watch // Watch for changes npm run hot // Hot module replacement // Production npm run production // Optimized production build BrowserSync integration provides:\nLive reloading during development Synchronized browser testing Proxy configuration for WordPress development Conclusion and final thoughts Building the Chile Nativo frontend from a Figma design was an excellent opportunity to:\nMaster Vue 3: Working with the Composition API, reactive systems, and modern Vue patterns Implement complex forms: Multi-step forms with validation, international phone inputs, and reCAPTCHA Build scalable architecture: Organizing 40+ Vue components and 125+ SCSS files in a maintainable structure Optimize performance: Implementing code splitting, lazy loading, and production optimizations Ensure design fidelity: Translating Figma designs into pixel-perfect implementations Handle responsive design: Creating seamless experiences across all device sizes The project demonstrates proficiency in:\nModern JavaScript frameworks (Vue 3) Build tools and asset compilation (Laravel Mix, Webpack) CSS architecture and methodologies (SCSS, BEM) Form validation and user experience Component-based development Design system implementation The integration with WordPress/Themosis backend required careful consideration of server-side rendering, API endpoints, and content management workflows, making this a full-stack frontend implementation.\nLive website: https://chilenativo.travel/\nFigma prototype: https://www.figma.com/proto/ywHPhSP1UfYUAE8eWVQv4L/Dise%C3%B1o-Desktop---Chile-Nativo?node-id=289-3912\u0026m=dev\u0026scaling=min-zoom\u0026content-scaling=fixed\u0026page-id=289%3A3911\u0026starting-point-node-id=289%3A3912\n","image":"//localhost:1313/images/project/chile-nativo/home.png","permalink":"//localhost:1313/projects/chile-nativo-patagonia-travel-website/","tags":["Vue 3","Laravel Mix","WordPress","Themosis","SCSS","JavaScript","Figma"],"title":"Chile Nativo: Patagonia Travel Website"},{"categories":["Projects"],"contents":"Rutieri is a SaaS platform built with Strapi, React Native, Typescript and other technologies.\nOutline The idea Platform features The stack The API The frontend The mobile app Conclusion Landing Page The idea Before starting to write a single line of code, it is generally a good idea to think about the problem, it\u0026rsquo;s limitations and whether or not it has already been solved by someone else (AKA competitors).\nThe problem I was looking into had to do with the way in which public and private transportation companies manage their routes, drivers and users. This process is generally carried out on paper, e.g. not digital, hence this could be problematic in case of new drivers joining the organization or in case of restricting access to data to only specific users.\nAfter a little bit of research, I could only find one platform that provides a similiar solution but for their own company.\nPlatform features and user stories The following user stories illustrates the desired features the platform should have in order to solve the aforementioned problems.\nAs an administrator user, I want to: login in the admin panel. create an organization. create routes in the organization. invite drivers and users to the organization. manage requests to join the organization. assign routes to drivers in the organization. see in real time the drivers and users currently active in the map of the different routes. As a driver, I want to: login in the mobile app. join an organization by entering the code in the search bar. see my route on the map. become visible to passengers on the road. see the passengers waiting on the road. remove my visibility and finish my run. As a passenger, I want to: login in the mobile app. join an organization by entering the code in the search bar. see the different routes of my organization in the map. search for a destination and get the available routes that pass nearby. see the drivers currently active on the routes in real time. become visible to drivers of a route. The requirements The backend requires to handle user authentication, permissions, different data structures as content types and define relations between them. It\u0026rsquo;s also necessary to synchronise passengers and drivers and view them on a map real time in the administration panel as well as in the mobile app.\nThe administration panel is a web page that fetches data from the backend as well as from the real time data provider and it\u0026rsquo;s goal is to provide a way for administrators to manage their organization and users. We\u0026rsquo;re talking about a Single Page Application built in React.\nAs for the mobile application, there isn\u0026rsquo;t a better choice nowadays than React Native and it works just fine in this case.\nThe API Since all of the features involve authentication, permissions and roles, and because there is no need to reinvent the wheel, I chose to use Strapi to build the backend for it\u0026rsquo;s simplicity, ease of use and great developer experience, whereas for realtime data, I used Firebase.\nThe instance of Strapi and the Postgres database it requires was deployed in the cloud hosting platform https://fly.io.\nStrapi is good for managing users, content that\u0026rsquo;s typically updated and fetched via CRUD API, and relations between content types.\nThe platform needs the following content types:\nOrganizations to group routes, drivers and users Routes Two user roles: drivers and users (passengers) Below are some screenshots of the overview of these content types\nAs I said before, Strapi makes the creation of these content types and the relationships between them really straightforward.\nHowever, not everything related to the API can be provided by Strapi. Some realtime features need to be addressed with other solutions, such as geolocation data in real time for drivers and users to synchronise each other, maps and the ability to search for places. Such features were implemented using Firebase, Google Maps and Google Places.\nThe frontend The platform where users are able to login as administrators and manage their organizations and users is a single page web application built in React. Among the features of this project that I think stand out are:\nState managed by Context API Interface styled with Bootstrap React Router for pages Leaflet to display the map GeoFire library to synchronise geolocation data in real time with Firebase Use of localStorage to save user session Below are some sample screenshots of how this app looks like\nThe mobile application This one is by far the most complex part of this project.\nThe project was bootstraped with Infinitered\u0026rsquo;s Ignite, which provides a great boilerplate and surely saved me of what would have been between 1-2 months of work.\nIgnite\u0026rsquo;s boilerplate includes many features out of the box, including:\nReact Native and Typescript (of course) React Navigation MobX-State-Tree for state management Expo SDK for developer experience AsyncStorage for persistence apisauce as REST client And some other libraries and features that make React Native apps super powerful and a joy to work on.\nIt consists of three screens:\nWelcome screen Login screen Map screen In the welcome screen, users are able to go to the login screen if not logged in. Otherwise, if they\u0026rsquo;re in an organisation, it shows their role and org\u0026rsquo;s information, and if they\u0026rsquo;re not, they are able to enter the organisation code and request to join as driver or as passenger.\nWelcome screens Login screens If the user is a driver in an organisation, the welcome screen also shows the route assigned to them. By tapping on it, it takes them to the map, where they can see themselves and start the tour, becoming visible to passengers on the road but being able to see passengers on the road as well.\nDrivers can finish the tour at any time by pressing the button stop.\nIf the user is a passenger in an organisation, the welcome screen shows the different routes available in the organisation. By tapping on them, they are taken to the map where they can see themselves, the route and the drivers on the road.\nPassengers are able to navigate between the available routes and search for the location they want to go to by using the search bar at the top of the map screen, filtering out the routes that pass nearby (less than 200 meters), if there are. Google Places API and turf library work together in this search process.\nPassengers become visible to drivers on the road by pressing the button wait and if they press the button again, they stop waiting and are removed from the driver\u0026rsquo;s map.\nMap screens The start/wait and finish buttons dispatch actions that update their location in firebase, so that passengers are able to see the bus on the map as it moves in real time and viceversa.\nAs for the state management, the project consists of two models and three stores from Mobx-State-Tree library: User and Route models, user-status, route-store and root-store stores.\nUser model Located in /app/models/user/user.ts\nconst OrganizationModel = types.model({ name: types.string, code: types.string, id: types.identifierNumber, drivers: types.number, rutas: types.array(RouteModel) }) const UserModel = types .model(\u0026#34;User\u0026#34;) .props({ id: types.identifierNumber, username: types.string, email: types.string, token: types.string, role: types.union(types.literal(\u0026#34;passenger\u0026#34;), types.literal(\u0026#34;driver\u0026#34;)), ruta: types.maybeNull(RouteModel), organization: types.maybeNull(OrganizationModel), pending_request: types.maybeNull(OrganizationModel), }) Route model Located in /app/models/route/route.ts\nThis model follows the GeoJSON format for routes.\nconst RouteModel = types .model(\u0026#34;Ruta\u0026#34;) .props({ id: types.identifierNumber, name: types.string, latlong: types.maybeNull(types.model({ lat: types.number, longt: types.number })), coords: types.model({ type: FeatureTypes, features: types.array(types.model({ type: types.string, geometry: types.model({ type: types.string, coordinates: types.union(types.array(types.number), types.array(types.array(types.number))) }), properties: types.model({ name: types.string }) })) }) }) user-status store Located in /app/models/user-status/user-status.ts\nThis store is responsible for managing the state of the user. It stores the user once it\u0026rsquo;s logged in and removes it when the user logs out. It also has some views to get the user key for firebase purposes, get the role and get the route in case of a driver.\nThis store has some methods that get the user location from the device\u0026rsquo;s GPS, displays the user icon on the map and sends it to firebase.\nconst UserStatusModel = types .model(\u0026#34;UserStatus\u0026#34;) .extend(withEnvironment) .props({ user: types.maybeNull(UserModel), location: types.maybeNull( types.model({latitude: types.number, longitude: types.number}) ), visibility: types.maybeNull(types.number) }) route-store store Located in /app/models/route-store/route-store.ts\nThis store is responsible for managing the state of the available routes. It stores the routes, drivers and passengers on the different routes. It also has some view methods to filter the routes that pass nearby a destination specified by the user, get passengers waiting on a given route and get drivers active in a specific route.\nThis store initializes a GeoQuery from Geofire library and listens for events to set, update and remove drivers and passengers from the map as they move.\nconst RouteStoreModel = types .model(\u0026#34;RouteStore\u0026#34;) .props({ routes: types.array(RouteModel), passengers: types.map(types.model({ key: types.identifier, location: types.array(types.number) })), drivers: types.map(types.model({ key: types.identifier, location: types.array(types.number) })), destinationAddress: types.maybeNull(types.model({ name: types.string, coords: types.array(types.number) })) }) Conclusion and final thoughts Using a CMS as the backend can make the development a lot faster than building the API from scratch and with Strapi this is specially true. On the other hand, Strapi doesn\u0026rsquo;t really make a good fit for real time applications, therefore, Firebase is the way to go in this case.\nAs of the client side, React always works very good for pretty much any kind of application, and because React Native uses React under the hood, it is so convenient for us React developers and ir works pretty good for almost any kind of application as well.\nHowever, one thing that I didn\u0026rsquo;t mention in this post was the use of Typescript; I find this quote by Brice Wilson pretty good to point out the whole purpose and motivation to learn and use (well) this powerful language and tool ecosystem:\n\u0026ldquo;You won\u0026rsquo;t have to wait for a frustrated user to report the error. All of this means that you provide value to your users faster, and that\u0026rsquo;s really what it\u0026rsquo;s all about.\u0026rdquo;\nAll in all, I got a lot of learning by building this project, both in languages/frameworks used and production stuff such as infrastructure, cloud hosting and cloud-based APIs.\nProject landing page: https://rutieri.netlify.app\n","image":"//localhost:1313/images/project/rutieri/landing/homepage.webp","permalink":"//localhost:1313/projects/saas-platform-rutieri/","tags":["Strapi","React Native","React","Typescript","Firebase"],"title":"SaaS platform: Rutieri"},{"categories":["Tutorial"],"contents":"Enable comments in a Strapi application and display them in the frontend with React\nOutline Introduction Prerequisites What is Strapi Comment Manager? Installation Configuration Display comments on the frontend Installation of Strapi Comments Client Usage of Strapi Comments Client Plugin settings Manage comments Full source code of the frontend Conclusion Introduction A comment system comes in very handy for pretty much any kind of website. In the JAMstack ecosystem, while it\u0026rsquo;s ok to rely on third party solutions hosted on their own platform such as Disqus to enable comments, you usually want to keep your content and all the stuff related to it in the same admin dashboard.\nIn this article, I\u0026rsquo;ll show you how to enable and manage comments for your content very easily using the Comment Manager plugin, and display them in your frontend application.\nPrerequisites You should have a basic understanding of the following.\nBasic knowledge of JavaScript Basic knowledge of React (OPTIONAL) Basic understanding of Strapi - get started here. Your Strapi V4 project setup What is Strapi Comment Manager? Strapi Comment Manager is a plugin that enables comments for pretty much any kind of content. It allows your users to post comments and anyone can get the comments associated with a given slug.\nWith this plugin, admin users can view and manage very easily all the comments from the Strapi administration dashboard. Within the dashboard, you will be able to delete comments and subcomments and leave replies on comments.\nInstallation Once into the Strapi project root, you can install the plugin by running the following command:\nnpm install strapi-plugin-comment-manager Next, build the project to see the new plugin in the dashboard with the following command:\nnpm run build And that\u0026rsquo;s it! If everything runs correctly, the plugin should now be installed.\nConfiguration Now you need to enable some permissions so that the frontend can access the endpoints to post and fetch comments.\nIn your Strapi admin dashboard, head over to Settings, then over to Roles under Users \u0026amp; Permissions Plugin.\nLet\u0026rsquo;s first setup the Public API; click on Public and hit the dropdown button of Comment Manager. Now check count, find and getPageSize, then hit the Save button. Below is a screenshot of a proper configuration:\nNow let\u0026rsquo;s setup the Authenticated API. Go back to Roles and click on Authenticated. Open the dropdown for Comment Manager and mark as checked the option create on both Comment and Subcomment. Below is a screenshot of a proper configuration:\nWith this configuration, the frontend should now be able to make requests to get and post comments.\nDisplay comments on the frontend The plugin exposes an API to get and post comments if you want to have fine-grained control over the workflow of your comments system and you can check the documentation on the package page, but this plugin also comes with a purpose-built React component library that makes it super easy to get up and running without getting your hands dirty.\nThis components library is called strapi-comments-client, fully supports typescript and it handles for you all of the complexity of fetching and posting comments and subcomments for every content ID that you pass to it.\nInstallation of Strapi Comments Client You will need to have installed react ^17.0.2, react-dom ^17.0.2 and react-router-dom ^5.2.0.\nInside of your React project, run this command:\nnpm install strapi-comments-client --save Usage of Strapi Comments Client Using this library is very easy!\nThis library exports three main components:\nCommentsProvider Comments CommentForm And you can import them this way:\nimport { CommentsProvider, Comments, CommentForm } from \u0026#34;strapi-comments-client\u0026#34; All you have to do is wrap your App component into the CommentsProvider component. Then you will be able to place anywhere in your app the Comments component to render a list of comments for a given content ID and the CommentForm component to render a form to post comments.\nFor example, this could be your index.js or main.js file:\nimport React from \u0026#39;react\u0026#39; import ReactDOM from \u0026#39;react-dom\u0026#39; // The address of your strapi backend instance const STRAPI = \u0026#34;http://localhost:1337\u0026#34; ReactDOM.render( \u0026lt;React.StrictMode\u0026gt; \u0026lt;CommentsProvider apiURL={STRAPI}\u0026gt; \u0026lt;App /\u0026gt; \u0026lt;/CommentsProvider\u0026gt; \u0026lt;/React.StrictMode\u0026gt;, document.getElementById(\u0026#39;root\u0026#39;) ) Where apiURL is the URL of your running Strapi application, and this property is required.\nThis way, the comments provider will do all the magic of fetching and posting comments for you!\nThis library also exports an utility React.Context to update some of the parameters for fetching and posting comments:\nimport { CommentsConfigContext } from \u0026#34;strapi-comments-client\u0026#34; This CommentsConfigContext exposes two setter functions: setUser and setContentID\nWith setContentID you can load the comments for a given content and post comments to it. It receives a single parameter of type string and must be URLized, i.e. no spaces.\nWith setUser you can set the credentials of a given user to authorize the posting of comments. It receives a single parameter of type IUser, with the following Typescript interface:\ninterface IUser { username: string, email: string, id: string, token: string // This is a JWT } It\u0026rsquo;s a little confusing but we\u0026rsquo;ll see how to use it in a component:\nconst App = () =\u0026gt; { const { setUser, setContentID } = useContext(CommentsConfigContext) // The following data should come from Strapi Users and Permissions Plugin // for authenticated requests const user = { username: \u0026#34;John Doe\u0026#34;, email: \u0026#34;jhohndoe@gmail.com\u0026#34;, id: 5, token: \u0026#34;this_should_be_a_JWT\u0026#34; } if (user) { setUser(user) } setContentID(\u0026#34;sample-content-1\u0026#34;) // Load comments for this content return ( \u0026lt;\u0026gt; { !user \u0026amp;\u0026amp; \u0026lt;Login /\u0026gt; } \u0026lt;CommentForm /\u0026gt; \u0026lt;Comments /\u0026gt; \u0026lt;/\u0026gt; ) } And that\u0026rsquo;s it!\nAfter setting the content ID through setContentID, CommentsProvider will start loading the comments for the given content ID and the CommentForm will render an input to post comments related to the given content ID if there is a user. Otherwise, it will display the message Login to post a comment.\nHere\u0026rsquo;s how the interface looks like so far:\nThere\u0026rsquo;s also a button to Leave a reply, which will open a form to post a subcomment associated with the parent comment.\nThis library exports one more component: ErrorBox\nimport { ErrorBox } from \u0026#34;strapi-comments-client\u0026#34; .It\u0026rsquo;s useful if you\u0026rsquo;d like to display error messages when things go wrong fetching or posting comments.\nYou can place this component wherever you want, for example in between the CommentForm and the Comments components.\nIf you\u0026rsquo;re wondering how this error box looks like, here you have a sample:\nGeneral settings You can customize the page size, i.e. specify how many comments are returned at once.\nIn the Strapi admin panel, head over to Settings, then select Pagination under Comment Manager Plugin.\nHere you\u0026rsquo;ll find an input to set the page size, which defaults to 10.\nManage comments Once you\u0026rsquo;ve got the plugin up an running, as users start to post comments, you can manage and reply to them as admin from the Comment Manager section of the left sidebar in the Strapi admin dashboard.\nHere you can see two tabs: one for the latest comments and one for comments grouped by content ID.\nIn both of them you can delete comments and subcomments as well as leave replies.\nExample project You can find a full working example of a React App using the Strapi Comments Client Library in this repo\nConclusion With this plugin you can enable and manage comments for any content with little effort and even use a component library to display the comments in your frontend application made with React.\nAnd that\u0026rsquo;s it! The features are pretty basic at the moment but if there\u0026rsquo;s interest, I\u0026rsquo;m willing to work on more features as well as improve the UI/UX.\n","image":"//localhost:1313/images/post/strapilogo.jpg","permalink":"//localhost:1313/blogs/how-to-enable-and-manage-comments-in-your-strapi-application/","tags":["Strapi","Strapi tutorials"],"title":"How To Enable And Manage Comments In Your Strapi Application."},{"categories":["Documentation"],"contents":"Comment Manager is a Strapi plugin to allow your users to post comments.\nWith this plugin you can enable and manage comments for your content very easily!\nRequirements You should have installed an instance of Strapi v4.x.x\nInstallation Run the following command in your project root:\nnpm install strapi-plugin-comment-manager Configurarion For your frontend to have access to the API, enable the following permissions for Comment Manager from Users \u0026amp; Permissions Plugin on your project settings:\nFor public, enable: count, find and getPageSize.\nFor authenticated, enable create on both Comment and Subcomment.\nDisplay comments on the frontend Comments can be displayed in the frontend in two ways:\nUsing the React components library strapi-comments-client (recommended) Build your custom frontend using the API API There are some Typescript interfaces that will help to get an idea of the data structures.\nComments: interface IComment { id: string, from_admin: boolean, createdAt: string, content: string, author: IAuthor | null, subcomments?: ISubcomment[] } Subcomments: interface ISubcomment { id: string, from_admin: boolean, createdAt: string, content: string, author: IAuthor | null, } Authors: IAuthor { username: string, email: string, id: string } The following endpoints are exposed to fetch and post comments and subcomments:\nGet comments for a content ID Method: GET\nPath: /api/comment-manager/comments/:slug\nOptional query parameters: start, ignoreCount\nReturns:\n{ commentsCount?: Number, comments: IComment[] } The parameter start indicates how many comments to skip. This is for pagination purposes.\nThe parameter ignoreCount indicates whether or not to return the total number of comments associated with the given slug.\nGet the number of comments associated with a given content ID Method: GET\nPath: /api/comment-manager/comments/:slug/count\nReturns:\n{ count: Number } Post a comment Method: POST\nPath: /api/comment-manager/comments/:slug\nAuthentication: Bearer token\nPayload:\n{ content: string } Returns:\n{ id: Number } Post a subcomment Method: POST\nPath: /api/comment-manager/subcomments/:parent-id\nAuthentication: Bearer token\nPayload:\n{ content: string } Returns:\n{ id: Number } Get the page size Method: GET\nPath: /api/comment-manager/page-size\nReturns:\n{ pageSize: Number } General settings The plugin allows to set how many comments are returned per page by going to the Pagination section under Comment Manager Plugin on the Settings section.\nThe default page size is 10.\nManagement of comments Admin users are able to delete comments and subcomments as well as leave replies as admins from within the plugin page of the Strapi admin dashboard.\nThe plugin interface has two tabs: one for the latest comments and one for comments by content ID.\nRoadmap and future plans The plugin is pretty basic but it can be improved with more features and a better UI/UX. Collaborations and suggestions are very welcome.\n","image":"//localhost:1313/images/post/strapilogo.jpg","permalink":"//localhost:1313/blogs/strapi-plugin-comment-manager/","tags":["Strapi","Strapi plugins"],"title":"Strapi Plugin Comment Manager"},{"categories":["Projects"],"contents":"In this post I’m going to share my experience on building a SaaS using the headless CMS Strapi as the Backend, React Native and other technologies.\nOutline Introduction What is SaaS? The problem What is Strapi? Developing features in Strapi The frontend: How to get content Conclusion Landing Page Introduction Very often, developers, product and project managers, testers and pretty much the entire team share their ideas to decide what language and which framework they\u0026rsquo;ll use to build their next project. Some considerations must be taken into account, from which in my opinion there are three that are the most important:\nDeveloper experience and ease of use Does the language and framework chosen provide a good developer experience? Is the langauge the same for the backend and frontend?\nDeadlines Is there a deadline to finish the project? if so, there is a good chance to finish the project on time if the team chooses the language they have more experience in.\nMaintainability As there will be usually more than one person working on the same part at the same time, if everything is kept organised, the whole development process will be frictionless.\nWith that in mind, developers and project managers will have a better insight on which language/framework to use.\nOther aspects should also be considered such as what the data structure will look like.\nIn my case, as it is usual, the backend of my project needs a database for users and their roles among other entities and their relations and a dashboard to allow admins to manage the data, and I was lucky to find out Strapi, as it includes a lot of these features out of the box with one single line of command to get started.\nWhat is SaaS? SaaS stands for Software-as-a-Service and it just means that a software is provided as a service in the cloud and it gives a solution to a specific problem, for which the users are willing to pay either monthly or annual subscription.\nThe problem Before starting to write a single line of code, it is generally a good idea to think about the problem, it\u0026rsquo;s limitations and whether or not it has already been solved by someone else (AKA competitors).\nThe problem I was looking into had to do with the way in which public and private transportation companies manage their routes, drivers and users. After a little bit of research, I could only find one platform that provides a similiar solution but for their own company.\nSo the platform I built needed the following content types:\nOrganizations to group routes, drivers and users Routes Two user roles: drivers and users (passengers) As I said before, Strapi makes the creation of these content types and the relationships between them really easy, but let\u0026rsquo;s first see what is Strapi and how it turns the API development into a satisfactory and fun experience.\nWhat is Strapi? Strapi is an open source headless CMS that allows developers to build complete RESTful APIs in just a couple of days instead of months. It includes a lot of useful features as plugins out of the box. Users and Roles management, Media library and an interface to create, view, edit and delete content are just some of them.\nRegarding the API, how does it makes the development faster?\nFirst of all, it enforces a specific folder structure, which helps to keep everything well organised and clean.\nSecondly, all database schemas are generated automatically and queries are made in JSON format, which really saves a lot of time.\nLastly, we can add more features to our Strapi application very easily via plugins from the marketplace.\nIt\u0026rsquo;s also worth noting that Strapi is a self-hosted CMS, which means that we can host it in whatever cloud platform we want, as well as test it locally in our computers before deploying it to the cloud.\nDeveloping features in Strapi Creating and configuring endpoints in Strapi is as straightforward as declaring a JSON in a single file:\nCreating controllers is straightforward as well:\nEvery controller gets all the data related to the request in the ctx parameter and it\u0026rsquo;s also used to send the response. This keeps everything in one place and really helps to improve the readability.\nOnce the API endpoints are defined, the next step is to enable the permissions for the specific user roles to have access to these endpoints:\nThe frontend: how to get content Since Strapi is a headless CMS, it\u0026rsquo;ll only provide content through the API. That means that the content can be consumed from anywhere. In our case, this content will be used in two applications: one for the organization owners and one for the users and drivers.\nThe application for the organization owners is a dashboard where administrators can create organizations, routes, accept drivers and users in the organization and assign routes to drivers. This is just a React Application:\nThe application for drivers and users is a mobile application built in React Native. Firebase was used to synchronise geolocation data in real time between drivers and users and display this information in a Map from Google Maps:\nConclusion Using a CMS as the backend can make the development a lot faster than building the API from scratch and with Strapi this is specially true. Furthermore, this becomes more important when building a brand-new product, as it\u0026rsquo;s usually recommended to launch as soon as possible to gather feedback from the users and validate the idea.\nProject landing page: https://rutieri.netlify.app\n","image":"//localhost:1313/images/post/03.webp","permalink":"//localhost:1313/blogs/how-i-built-a-saas-on-top-of-strapi-and-why-you-should-too/","tags":["Strapi","React Native","Typescript"],"title":"How I Built A SaaS On Top Of Strapi, And Why You Should Too"},{"categories":["Tutorial"],"contents":"Enable User Reviews in a Strapi application and display them in the frontend with React\nOutline Introduction Prerequisites What is Strapi Ratings? Installation Configuration Display user reviews on the frontend Plugin settings Manage user reviews Full source code of the frontend Conclusion Introduction Ratings systems have become a crucial part of any website with ecommerce capabilites, as they allow the users to post reviews on the items they purchase and publish their opinion to the public. A couple of reviews can make the difference between pressing the “Buy” button and moving on to the next website in the Google search results.\nIn this article, I\u0026rsquo;ll show you how to enable and manage user reviews for your content very easily using the Ratings plugin, and display them in your frontend application.\nPrerequisites First of all, you need to have a basic understanding of the following.\nBasic knowledge of JavaScript Basic knowledge of React (OPTIONAL) Basic understanding of Strapi - get started here. Your Strapi V4 project setup What is Strapi Ratings? Strapi Ratings is a plugin that gives your Strapi application the ability to manage ratings for pretty much any kind of content. It allows your users to post reviews and anyone can get the reviews associated with a given slug.\nWith this plugin, admin users can view and manage very easily all the reviews from the Strapi administration dashboard. Within the dashboard, you will be able to see reviews related to content slugs as well as delete reviews.\nInstallation Once into the Strapi project root, you can install the plugin by running the following command:\nnpm install strapi-plugin-ratings Next, build the project to see the new plugin in the dashboard with the following command:\nnpm run build And that\u0026rsquo;s it! If everything runs correctly, the plugin should now be installed.\nConfiguration Now you need to enable some permissions so that the frontend can access the endpoints to post and fetch reviews.\nIn your Strapi admin dashboard, head over to Settings, then over to Roles under Users \u0026amp; Permissions Plugin.\nLet\u0026rsquo;s first setup the Public API; click on Public and hit the dropdown button of Ratings. Now check count, find, getPageSize and getStats, then hit the Save button. Below is a screenshot of a proper configuration:\nNow let\u0026rsquo;s setup the Authenticated API. Go back to Roles and click on Authenticated. Open the dropdown for Ratings and mark as checked the options create, find and getUserReview. Below is a screenshot of a proper configuration:\nWith this configuration, the frontend should now be able to make requests to get and post user reviews.\nDisplay use reviews on the frontend The plugin exposes an API to get and post reviews if you want to have fine-grained control over the workflow of your ratings system and you can check the documentation on the package page, but this plugin also comes with a purpose-built React component library that makes it super easy to get up and running without getting your hands dirty.\nThis components library is called strapi-ratings-client, fully supports typescript and it takes care of all the complexity of fetching and posting user reviews for every content ID that you pass to it.\nInstallation of Strapi Ratings Client You will need to have installed react ^17.0.2, react-dom ^17.0.2, bootstrap ^5.1.3 and @popperjs/core^2.11.2\nInside of your React project, run this command:\nnpm install strapi-ratings-client --save Usage of Strapi Ratings Client Using this library is very easy!\nThis library exports three main components:\nReviewsProvider Reviews ReviewForm And you can import them this way:\nimport { ReviewsProvider, Reviews, ReviewForm } from \u0026#34;strapi-ratings-client\u0026#34; All you have to do is wrap your App component into the ReviewsProvider component. Then you will be able to place anywhere in your app the Reviews component to render a list of user reviews for a given content ID and the ReviewForm component to render a form to allow your users to post reviews.\nFor example, this could be your index.js or main.js file:\nimport React from \u0026#39;react\u0026#39; import ReactDOM from \u0026#39;react-dom\u0026#39; // The address of your strapi backend instance const STRAPI = \u0026#34;http://localhost:1337\u0026#34; ReactDOM.render( \u0026lt;React.StrictMode\u0026gt; \u0026lt;ReviewsProvider apiURL={STRAPI}\u0026gt; \u0026lt;App /\u0026gt; \u0026lt;/ReviewsProvider\u0026gt; \u0026lt;/React.StrictMode\u0026gt;, document.getElementById(\u0026#39;root\u0026#39;) ) Where apiURL is the URL of your running Strapi application, and this property is required.\nThis way, the ratings provider will do all the magic of fetching and posting comments for you!\nThis library also exports an utility React.Context to update some of the parameters for fetching and posting reviews:\nimport { ReviewsConfigContext } from \u0026#34;strapi-ratings-client\u0026#34; This ReviewsConfigContext exposes three setter functions: setUser, setContentID and setCanPostReview.\nWith setContentID you can load the ratings for a given content and post reviews to it. It receives a single parameter of type string and must be URLized, i.e. no spaces.\nWith setUser you can set the credentials of a given user to authorize the posting of reviews. It receives a single parameter of type IUser, with the following Typescript interface:\ninterface IUser { username: string, email: string, id: string, token: string // This is a JWT } With setCanPostReview, you can enable the user to post a review on the given content. This is useful for when you only allow a user to post a review after they purchase the product.\nIt\u0026rsquo;s a little confusing but we\u0026rsquo;ll see how to use it in a component:\nconst App = () =\u0026gt; { const { setUser, setContentID, setCanPostReview } = useContext(ReviewsConfigContext) // The following data should come from Strapi Users and Permissions Plugin // for authenticated requests. const user = { username: \u0026#34;John Doe\u0026#34;, email: \u0026#34;jhohndoe@gmail.com\u0026#34;, id: 5, token: \u0026#34;this_should_be_a_JWT\u0026#34; } if (user) { setUser(user) } setContentID(\u0026#34;sample-content-1\u0026#34;) // Load reviews for this content setCanPostReview(true) // Allow this user to post a review return ( \u0026lt;\u0026gt; { !user \u0026amp;\u0026amp; \u0026lt;Login /\u0026gt; } \u0026lt;ReviewForm /\u0026gt; \u0026lt;Reviews /\u0026gt; \u0026lt;/\u0026gt; ) } And that\u0026rsquo;s it!\nAfter setting the content ID through setContentID, ReviewsProvider will start loading the reviews for the given content ID and the ReviewForm will render an input to post a user review related to the given content ID if there is a user and he’s allowed to post a review. Otherwise, it will display the message Login to post a review or nothing at all if the user is not allowed to post a review.\nHere\u0026rsquo;s how the interface looks like so far:\nThis library exports one more component: ErrorBox\nimport { ErrorBox } from \u0026#34;strapi-ratings-client\u0026#34; .It\u0026rsquo;s useful for when you\u0026rsquo;d like to display error messages when things go wrong fetching or posting reviews.\nYou can place this component wherever you want, for example in between the ReviewForm and the Reviews components.\nIf you\u0026rsquo;re wondering how this error box looks like, here‘s a screenshot:\nGeneral settings You can customize the page size, i.e. specify how many user reviews are showed at once.\nIn the Strapi admin panel, head over to Settings, then select Pagination under Ratings Plugin.\nHere you\u0026rsquo;ll find an input to set the page size, which defaults to 10.\nManage reviews Once you\u0026rsquo;ve got the plugin up an running, as users start to post reviews, you can view them from within the Ratings section of the left sidebar in the Strapi admin dashboard.\nHere you can see two tabs: one for the latest reviews and one for reviews grouped by content ID.\nIn both of them you can delete unwanted reviews.\nExample project You can find a full working example of a React App using the Strapi Ratings Client Library in this repo: https://github.com/luisguve/strapi-ratings-client-example\nConclusion With this plugin you can enable and manage user reviews for any content with little effort and even use a library of components styled with Bootstrap to display the user reviews in your frontend.\nAnd that\u0026rsquo;s it! The features are pretty basic at the moment but if there\u0026rsquo;s interest, I\u0026rsquo;m willing to work on more features as well as improve the UI/UX.\n","image":"//localhost:1313/images/post/tutorial-ratings.webp","permalink":"//localhost:1313/blogs/how-to-enable-and-manage-user-reviews-in-your-strapi-application/","tags":["Strapi","Strapi tutorials"],"title":"How To Enable And Manage User Reviews In Your Strapi Application"},{"categories":["Documentation"],"contents":"Ratings is a Strapi plugin that allows your users to post reviews.\nEnable and manage user reviews for your content very easily!\nRequirements You should have installed an instance of Strapi v4.x.x\nInstallation Run the following command in your project root:\nnpm install strapi-plugin-ratings Then, rebuild the admin dashboard using the following command\nnpm run build Configurarion For your frontend to have access to the API, enable the following permissions for Ratings from Users \u0026amp; Permissions Plugin on your project settings:\nFor public, enable: count, find, getPageSize and getStats.\nFor authenticated, enable create, find and getUserReview.\nDisplay user reviews on the frontend Reviews can be displayed in the frontend in two ways:\nUsing the React components library strapi-ratings-client (recommended) Build your custom frontend using the API endpoints, described as follows: API There are some Typescript interfaces that will help to get an idea of the data structures.\nReviews: interface IReview { id: number, createdAt: string, comment: string | null, author: IAuthor | null, score: number, } Authors: interface IAuthor { username: string, email: string, id: number } Content Stats interface IStats { averageScore: number; reviewsCount: number | null; } The following endpoints are exposed to fetch and post reviews:\nGet reviews for a content ID Method: GET\nPath: /api/ratings/reviews/:slug\nOptional query parameters: start, ignoreCount\nReturns:\n{ reviewsCount: number, averageScore: number, userReview: IReview | null, reviews: IReview[] } The parameter start indicates how many reviews to skip. This is for pagination purposes.\nThe parameter ignoreCount indicates whether or not to return the total number of reviews associated with the given slug.\nGet review stats for a content ID Method: GET\nPath: /api/ratings/reviews/:slug/stats\nReturns:\n{ averageScore: number, reviewsCount: number | null } Get the number of reviews associated with a given content ID Method: GET\nPath: /api/ratings/reviews/:slug/count\nReturns:\n{ count: number } Post a review Method: POST\nPath: /api/ratings/reviews/:slug\nAuthentication: Bearer token\nPayload:\n{ content: string } Returns:\n{ id: number } By default, every authenticated user can post reviews on any content.\nIn order to customize this behavior, e.g. allowing or disallowing a user from posting reviews, you must extend the service userCanPostReview from whithin register function in ./src/index.js. For example:\nstrapi.service(\u0026#34;plugin::ratings.review\u0026#34;).userCanPostReview = async (user, slug) =\u0026gt; { /* Here you will check whether or not the user is allowed to post a review on this content ID and return either true or false. */ return true } Notice that userCanPostReview will receive two parameters: the user from Users \u0026amp; Permissions Plugin, containing it\u0026rsquo;s id, username, confirmed, etc., and the slug, which is a string and refers to the content ID which the review is being posted on.\nIn case this function returns false, the response of the endpoint will be 403 (forbidden) with the text User cannot post a review on this content.\nGet the page size Method: GET\nPath: /api/ratings/page-size\nReturns:\n{ pageSize: number } General settings The plugin allows to set how many reviews are returned per page by going to the Pagination section under Ratings Plugin of the Settings section.\nThe default page size is 10.\nManagement of reviews Admin users are able to delete reviews from within the plugin page of the Strapi admin dashboard.\nThe plugin interface has two tabs: one for the latest reviews and one for reviews by content ID.\nRoadmap and future plans The plugin is pretty basic but it can be improved with more features and a better UI/UX. Collaborations and suggestions are very welcome.\n","image":"//localhost:1313/images/post/ratings.webp","permalink":"//localhost:1313/blogs/strapi-plugin-ratings/","tags":["Strapi","Strapi plugins"],"title":"Strapi Plugin Ratings"},{"categories":["Projects"],"contents":"ManyLMS is an e-learning platform built on top of Strapi, React Router 7, Typescript and other technologies.\nOutline The idea Platform features The stack The API The frontend Conclusion Landing Page The idea This project doesn\u0026rsquo;t necessarily bring a huge amount of innovation on the e-learning platforms that already exists, but it\u0026rsquo;s just another way of doing this type of application.\nThe main idea is to apply a JAMstack approach in this application, where the platform is a static website, and the backend is just an API that serves static content only once to build the website and just adds the dynamism that\u0026rsquo;s necessary to allow users to authenticate, create orders, confirm payments and take courses.\nIf we compare this approach to a WordPress website, we are taking out most of the overhead that implies rendering the pages everytime a user visits them. Despite that there are plugins for caching that may improve the performance, it\u0026rsquo;s still never going to be faster and more efficient than just static content served by a CDN. That\u0026rsquo;s why React Router 7 and Headless CMSs are so popular right now.\nPlatform features and user stories The following user stories illustrates the desired features the platform should have.\nAs an administrator, I want to: login in the admin panel. create categories. create courses. upload lectures. organise courses into categories. assign lectures to courses. As a student, I want to: login in the platform. view the available courses. add courses to the shopping cart. review the shopping cart. create an order. pay with credit card or paypal. view the courses i\u0026rsquo;ve purchased in my learning page. go to the course page from my learning page and watch the videos. mark lectures as seen. come back later and resume where I left. The requirements The backend requires to handle user authentication, permissions, different data structures as content types and define relationships between them. It also requires to allow uploading videos to some third party platform that supports streaming on demand.\nThe frontend is a web platform where users can register and login, view and buy courses, leave comments and reviews and take courses.\nThe API Since all of the features involve authentication, permissions and roles, and because there is no need to reinvent the wheel, I chose to use Strapi to build the backend for it\u0026rsquo;s simplicity, ease of use and great developer experience, whereas for streaming videos on demand, I chose to use Mux.com.\nThe instance of Strapi and the Postgres database it requires was deployed in the cloud hosting platform https://fly.io.\nStrapi is good for managing users, content that\u0026rsquo;s typically updated and fetched via CRUD API, and setting up relations between content types.\nThe platform needs the following content types:\nCategory to group courses Course Lecture Module to group lectures Order Student: has many courses Student-Course: stores a student\u0026rsquo;s current lecture of a course Video Strapi makes the creation of these content types and setting up relationships between them really straightforward.\nBelow are some screenshots of these content types and the relationships between them:\nThe frontend The platform where users are able to login, view, buy and view courses is a web application built with React Router 7. Among the features of this application are:\nState managed by Context API Interface styled with Bootstrap Play streaming videos with @mux/mux-player-react library Use of localStorage to save user session Below are some sample screenshots of how this app looks like\nConclusion and final thoughts While building this project, I learned:\nHow streaming on demand works and how to use a streaming provider How to statically build websites with React Router 7 and Strapi How to setup dynamic pages in React Router 7 How to process payments with Stripe and Paypal How to build custom plugins in Strapi How to publish packages to NPM Project source codes: https://github.com/luisguve/maestro-backend\nhttps://github.com/luisguve/new-lms-remix\n","image":"//localhost:1313/images/project/manylms/frontend/course_overview.png","permalink":"//localhost:1313/projects/e-learning-platform-maestro-lms/","tags":["Strapi","React","React Router 7","Typescript","Mux"],"title":"ManyLMS: E-Learning platform"},{"categories":["Projects"],"contents":"Chile Nativo is a travel tour website for Patagonia experiences, built on top of WordPress with the Themosis framework, featuring a modern frontend implementation based on a Figma design using Vue 3, Laravel Mix, and a comprehensive SCSS architecture.\nOutline The project Design implementation The stack Frontend architecture Key features Conclusion Live website The project Chile Nativo is a travel company specializing in Patagonia tours, offering experiences in destinations like Torres del Paine, Tierra del Fuego, and Isla Navarino. The website serves as the primary platform for showcasing tours, managing bookings, and providing information about their travel experiences.\nThe frontend development was based on a comprehensive Figma design, requiring pixel-perfect implementation of complex UI components, interactive forms, filtering systems, and responsive layouts that work seamlessly across all devices.\nDesign implementation The entire frontend was built from a detailed Figma design, ensuring:\nPixel-perfect accuracy: Matching the design specifications precisely Responsive design: Implementing breakpoints and mobile-first approach Component consistency: Maintaining design system patterns throughout Interactive elements: Translating static designs into dynamic, interactive components Animation and transitions: Implementing smooth user experience enhancements The stack The frontend stack consists of:\nVue 3.2.4: Modern reactive framework for building interactive components Laravel Mix 6.0: Asset compilation and bundling SCSS: Advanced styling with a well-organized architecture Pinia 2.3.1: State management for Vue applications Vee-Validate 4.15.0: Form validation with Yup schemas Axios 1.6.8: HTTP client for API requests Splide.js 4.1.4: Modern carousel and slider components Headroom.js: Header behavior on scroll Plyr 3.7.8: Video player implementation SweetAlert2: Modern alert dialogs jQuery 3.7.1: Legacy support and DOM manipulation utilities Frontend architecture Vue components The application features a comprehensive set of Vue 3 components organized by functionality:\nFiltering and Search Components:\nToursFilter.vue: Advanced tour filtering with multiple criteria TourDatesFilter.vue: Date-based filtering for tour availability ToursFilterDropdown.vue \u0026amp; ToursFilterDropdownMobile.vue: Responsive filter dropdowns TestimonialsFilter.vue: Filtering system for customer testimonials NewsFilter.vue: Blog and news filtering SearchResults.vue: Search results display with pagination Form Components:\nPersonalizedTripForm.vue: Multi-step form for custom trip requests with validation ContactFormSimple.vue: Contact form with reCAPTCHA integration FormHelp.vue: Help center form FormGiftCard.vue: Gift card purchase form FormCareers.vue: Job application form NewsletterForm.vue: Newsletter subscription Card Components:\nTour.vue \u0026amp; TourLoading.vue: Tour card display with loading states TourDate.vue \u0026amp; TourDateLoading.vue: Tour date selection cards Testimonial.vue \u0026amp; TestimonialLoading.vue: Customer testimonial cards Blog.vue \u0026amp; BlogLoading.vue: Blog post cards Team.vue \u0026amp; TeamLoading.vue: Team member cards ResourceCard.vue \u0026amp; ResourceLoading.vue: Resource display cards Utility Components:\nPagination.vue: Reusable pagination component Select.vue: Custom select dropdown with search Loader.vue \u0026amp; LoaderFullScreen.vue: Loading indicators EmptyState.vue: Empty state displays ContentResources.vue: Resource content management TeamTabsFilter.vue: Tabbed team member filtering SCSS architecture The styling follows a well-organized SCSS architecture:\nscss/ ├── abstracts/ # Variables, mixins, functions │ ├── _functions.scss │ ├── _mixins.scss │ ├── _variables.scss │ ├── _mq.scss # Media query mixins │ └── _keyframes.scss ├── base/ # Base styles and typography │ ├── _typography.scss │ ├── _colors.scss │ ├── _fonts.scss │ └── _reset.scss └── components/ # Component-specific styles └── [125 component files] Key SCSS features:\nBEM methodology: Consistent naming convention throughout Media query mixins: Using sass-mq for responsive design Modular architecture: Each component has its own SCSS file Abstract layer: Reusable variables, mixins, and functions Vue transitions: Custom transition styles for Vue components JavaScript architecture The JavaScript is organized into two main entry points:\nMain application (app.js):\nInitializes core application functionality Sets up jQuery plugins and utilities Handles legacy browser support Vue application (vue/main.js):\nConfigures Vue 3 app with Pinia for state management Registers global Vue components Sets up Vee-Validate configuration Integrates third-party Vue plugins (VueTelInput, etc.) Component utilities (app/components/):\nheader.js: Header behavior and navigation footer.js: Footer functionality splide.js: Carousel initialization slick.js: Legacy carousel support accordions.js: Accordion interactions tabs.js: Tab functionality scrollTrigger.js: Scroll-based animations video.js: Video player setup sticky-sidebar.js: Sticky sidebar behavior Key features Multi-step forms The PersonalizedTripForm.vue component implements a sophisticated multi-step form with:\nStep-by-step navigation with progress indicators Form validation using Vee-Validate and Yup schemas Dynamic form fields based on user selections Phone number input with international support (VueTelInput) reCAPTCHA integration for spam protection Loading states and error handling Advanced filtering system The tour filtering system (ToursFilter.vue) provides:\nMultiple filter criteria (destination, activity type, trip type, month) Real-time filtering with URL parameter synchronization Responsive design with mobile accordion interface Custom select components with search functionality Empty states and loading indicators Integration with WordPress backend via Axios Responsive design The entire website is fully responsive with:\nMobile-first approach Breakpoint management using sass-mq Touch-friendly interactions Optimized images and assets Performance optimizations for mobile devices Performance optimizations Code splitting: Laravel Mix extracts vendor libraries Asset versioning: Automatic cache busting Image optimization: Lazy loading and responsive images Minification: Production builds are minified and optimized Tree shaking: Unused code elimination in production Accessibility Semantic HTML structure ARIA labels where appropriate Keyboard navigation support Focus management in forms Screen reader considerations Development workflow The project uses Laravel Mix for asset compilation:\n// Development npm run dev // Compile assets npm run watch // Watch for changes npm run hot // Hot module replacement // Production npm run production // Optimized production build BrowserSync integration provides:\nLive reloading during development Synchronized browser testing Proxy configuration for WordPress development Conclusion and final thoughts Building the Chile Nativo frontend from a Figma design was an excellent opportunity to:\nMaster Vue 3: Working with the Composition API, reactive systems, and modern Vue patterns Implement complex forms: Multi-step forms with validation, international phone inputs, and reCAPTCHA Build scalable architecture: Organizing 40+ Vue components and 125+ SCSS files in a maintainable structure Optimize performance: Implementing code splitting, lazy loading, and production optimizations Ensure design fidelity: Translating Figma designs into pixel-perfect implementations Handle responsive design: Creating seamless experiences across all device sizes The project demonstrates proficiency in:\nModern JavaScript frameworks (Vue 3) Build tools and asset compilation (Laravel Mix, Webpack) CSS architecture and methodologies (SCSS, BEM) Form validation and user experience Component-based development Design system implementation The integration with WordPress/Themosis backend required careful consideration of server-side rendering, API endpoints, and content management workflows, making this a full-stack frontend implementation.\nLive website: https://chilenativo.travel/\nFigma prototype: https://www.figma.com/proto/ywHPhSP1UfYUAE8eWVQv4L/Dise%C3%B1o-Desktop---Chile-Nativo?node-id=289-3912\u0026m=dev\u0026scaling=min-zoom\u0026content-scaling=fixed\u0026page-id=289%3A3911\u0026starting-point-node-id=289%3A3912\n","image":"//localhost:1313/images/project/chile-nativo/home.png","permalink":"//localhost:1313/projects/chile-nativo-patagonia-travel-website/","tags":["Vue 3","Laravel Mix","WordPress","Themosis","SCSS","JavaScript","Figma"],"title":"Chile Nativo: Patagonia Travel Website"},{"categories":["Projects"],"contents":"ETMday (Emprende tu Mente) is a large-scale entrepreneurship event website built on top of WordPress with the Themosis framework, featuring an interactive SVG map, real-time countdown timers, advanced search functionality, and comprehensive content management using Vue 3, Laravel Mix, and modern frontend technologies.\nOutline The project Key features The stack Frontend architecture Interactive components Conclusion Live website The project ETMday is Chile\u0026rsquo;s premier entrepreneurship event, bringing together thousands of entrepreneurs, startups, corporates, and strategic partners. The website serves as the central hub for event information, featuring speakers, activities, stands, program schedules, and an interactive event map.\nThe frontend development required implementing complex interactive features including an SVG-based interactive map with tooltips, real-time countdown timers, advanced filtering and search systems, and dynamic content displays that handle thousands of attendees and hundreds of activities.\nKey features The website includes several sophisticated features:\nInteractive SVG Map: Custom-built interactive map with clickable zones, tooltips, and dynamic content display Real-time Countdown: Event countdown timer with automatic updates and mobile optimization Advanced Search: Multi-category search across activities, speakers, stands, and content Dynamic Filtering: Complex filtering system with tabs, favorites, and downloadable resources Animated Statistics: Odometer animations for displaying event metrics Content Management: Comprehensive card components for activities, speakers, stands, and blog posts Form Handling: Multi-step forms with validation using Vee-Validate Lightbox Galleries: Image galleries with LightGallery integration Responsive Design: Fully responsive design optimized for all devices The stack The frontend stack consists of:\nVue 3.2.4: Modern reactive framework for building interactive components Laravel Mix 6.0: Asset compilation and bundling SCSS: Advanced styling with organized architecture Vee-Validate 4.15.0: Form validation with Yup schemas Axios 1.6.8: HTTP client for API requests Splide.js 4.1.4: Modern carousel and slider components LightGallery 2.8.3: Lightbox gallery functionality Odometer 0.4.8: Animated number counting Headroom.js: Header behavior on scroll jQuery 3.7.1: DOM manipulation and legacy support SweetAlert2: Modern alert dialogs GLightbox 3.3.1: Alternative lightbox solution Frontend architecture Vue components The application features a comprehensive set of Vue 3 components:\nCard Components:\ncards/activities.vue: Activity cards with favorites functionality cards/speakers.vue: Speaker cards with modal details cards/stands.vue: Stand/exhibitor cards cards/blog.vue: Blog post cards cards/shortcut.vue: Quick access shortcut cards Functional Components:\nSectionCards.vue: Main section component with tabs, filtering, and card display Search.vue: Advanced search component with multi-category results Form.vue: Dynamic form component with validation FormCalendar.vue: Calendar form component CustomFilter.vue: Reusable filter component CustomSelect.vue: Custom select dropdown Pagination.vue: Pagination component JavaScript components The application includes 17 specialized JavaScript components:\nInteractive Features:\ninteractiveMap.js: SVG map interaction with tooltips, zones, and dynamic content countdown.js: Real-time countdown timer with automatic updates odometer.js: Animated number counting with scroll triggers map.js: Map zone interactions and modal displays UI Components:\nheader.js: Header functionality and navigation headroom.js: Header hide/show on scroll accordion.js: Accordion interactions tabs.js: Tab functionality cards.js: Card interactions and modals siteModals.js: Modal management system UI.js: General UI utilities Media Components:\nvideo.js: Video player setup lightgallery.js: Lightbox gallery initialization splide.js: Carousel initialization slick.js: Legacy carousel support Utilities:\nscrollTrigger.js: Scroll-based animations imgToSvg.js: SVG image conversion utility SCSS architecture The styling follows a well-organized SCSS architecture:\nscss/ ├── abstracts/ # Variables, mixins, functions │ ├── _functions.scss │ ├── _mixins.scss │ ├── _variables.scss │ ├── _mq.scss # Media query mixins │ └── _keyframes.scss ├── base/ # Base styles and typography │ ├── _typography.scss │ ├── _container.scss │ └── _reset.scss └── components/ # Component-specific styles └── [52 component files] Key SCSS features:\nBEM methodology: Consistent naming convention Media query mixins: Using sass-mq for responsive design Modular architecture: Each component has its own SCSS file Component organization: 52 component-specific SCSS files Interactive components Interactive SVG Map The interactiveMap.js component implements a sophisticated SVG-based interactive map:\nFeatures:\nSVG Tooltips: Dynamically generated tooltips with text wrapping Zone Interactions: Clickable zones with modal displays Point Markers: Interactive points with icons and labels Dynamic Content: Content loaded based on zone/point selection Responsive Design: Optimized for mobile and desktop Technical Implementation:\nSVG namespace manipulation for tooltip creation Text wrapping algorithm for tooltip content Path generation for tooltip shapes with rounded corners Event delegation for zone and point interactions Smooth animations and transitions Real-time Countdown The countdown.js component provides a real-time countdown timer:\nFeatures:\nAutomatic Updates: Updates every second Multi-unit Display: Days, hours, minutes, and seconds Pluralization: Proper Spanish pluralization (Día/Días, Hora/Horas) Mobile Optimization: Simplified display on mobile devices End State Handling: Automatic transition when countdown ends Advanced Search System The Search.vue component implements a comprehensive search system:\nFeatures:\nMulti-category Search: Searches across activities, speakers, stands, and other content Category Tabs: Quick navigation between result categories Result Counts: Dynamic result counts per category Scroll Navigation: Smooth scrolling to category sections Carousel Display: Splide carousels for result display Loading States: Loading indicators during search Empty States: User-friendly empty state messages Dynamic Filtering System The SectionCards.vue component provides advanced filtering:\nFeatures:\nTab Navigation: Multiple filter tabs Favorites System: Save and filter favorite items Search Integration: Inline search within filters Reset Functionality: Clear all filters with one click Downloadable Resources: Download buttons for resources URL Synchronization: Filter state in URL parameters Responsive Design: Mobile accordion interface Animated Statistics The odometer.js component provides animated number counting:\nFeatures:\nScroll-triggered: Animations trigger on scroll Prefix/Suffix Support: Handles formatted numbers (e.g., \u0026ldquo;56,000+\u0026rdquo;) Mobile Optimization: Static display on mobile Smooth Animations: Odometer theme integration Development workflow The project uses Laravel Mix for asset compilation:\n// Development npm run dev // Compile assets npm run watch // Watch for changes npm run hot // Hot module replacement // Production npm run production // Optimized production build BrowserSync integration provides:\nLive reloading during development Synchronized browser testing Proxy configuration for WordPress development Performance optimizations Code splitting: Laravel Mix extracts vendor libraries Asset versioning: Automatic cache busting Image optimization: Lazy loading and responsive images Minification: Production builds are minified and optimized Tree shaking: Unused code elimination in production SVG optimization: Efficient SVG manipulation and rendering Accessibility Semantic HTML structure ARIA labels for interactive elements Keyboard navigation support Focus management in forms and modals Screen reader considerations Proper alt text for images Conclusion and final thoughts Building the ETMday frontend was an excellent opportunity to:\nMaster SVG interactions: Creating complex interactive SVG maps with dynamic tooltips and zones Implement real-time features: Building countdown timers and live updates Build advanced search: Multi-category search with filtering and categorization Handle complex state: Managing filters, favorites, and dynamic content Optimize performance: Implementing efficient animations and lazy loading Ensure scalability: Building components that handle large datasets (thousands of attendees, hundreds of activities) The project demonstrates proficiency in:\nModern JavaScript frameworks (Vue 3) SVG manipulation and interaction Real-time UI updates Advanced filtering and search systems Build tools and asset compilation (Laravel Mix, Webpack) CSS architecture and methodologies (SCSS, BEM) Component-based development Event-driven architecture The integration with WordPress/Themosis backend required careful consideration of server-side rendering, API endpoints, and content management workflows, making this a full-stack frontend implementation for a large-scale event.\nLive website: https://etmday.org/\nFigma Prototype: https://www.figma.com/proto/mt9fJ8P03M5gf0nQwcU99q/EtM-Day-2025---Dise%C3%B1o?node-id=1-2743\u0026m=dev\u0026scaling=scale-down\u0026content-scaling=fixed\u0026page-id=0%3A1\u0026starting-point-node-id=1%3A2743\n","image":"//localhost:1313/images/project/etm/home.png","permalink":"//localhost:1313/projects/etmday-entrepreneurship-event-website/","tags":["Vue 3","Laravel Mix","WordPress","Themosis","SCSS","JavaScript","Interactive Map","SVG"],"title":"ETMday: Entrepreneurship Event Website"},{"categories":["Projects"],"contents":"JAC Autos Chile is a comprehensive automotive website built on top of WordPress with the Themosis framework, featuring car model comparisons, multi-step quote forms, fleet management, branch listings, and advanced filtering systems using Vue 3, Pinia state management, Laravel Mix, and modern frontend technologies.\nOutline The project Key features The stack Frontend architecture Interactive components Conclusion Live website The project JAC Autos Chile is the official website for JAC Motors in Chile, showcasing SUVs, pickups, commercial vehicles, and electric vehicles. The website serves as the primary platform for vehicle exploration, quoting, dealership location, fleet management, and post-sale services.\nThe frontend development required implementing complex interactive features including car model comparisons, multi-step quote forms with model and version selection, advanced filtering systems, fleet management interfaces, and comprehensive content management.\nKey features The website includes several sophisticated features:\nCar Model Comparator: Side-by-side comparison of multiple vehicle models with difference highlighting Multi-step Quote Form: Comprehensive quote form with model selection, version selection, and customer information Advanced Filtering: Multi-criteria filtering for car models, branches, fleet vehicles, and blog posts Fleet Management: Dedicated fleet vehicle selection and management interface Branch Locator: Filterable dealership/branch listings with location information Blog System: Complete blog with filtering, search, and content management Manuals Listing: User manual and documentation management Search Functionality: Site-wide search with categorized results Sticky Navigation: Section-based sticky navigation for long pages 360° View: Interactive 360-degree vehicle viewing The stack The frontend stack consists of:\nVue 3.2.4: Modern reactive framework with Composition API Pinia 2.2.6: State management for Vue applications Laravel Mix 6.0: Asset compilation and bundling SCSS: Advanced styling with organized architecture Vee-Validate 4.14.6: Form validation with Yup schemas Axios 1.6.8: HTTP client for API requests Splide.js 4.1.4: Modern carousel and slider components @splidejs/vue-splide 0.6.12: Vue 3 wrapper for Splide Maska 3.0.3: Input masking for formatted inputs Vue-Select 4.0.0-beta.6: Custom select component Vue-Recaptcha 2.0.3: reCAPTCHA integration Headroom.js: Header behavior on scroll jQuery 3.7.1: DOM manipulation and legacy support SweetAlert2: Modern alert dialogs @fdograph/rut-utilities: Chilean RUT validation utilities Frontend architecture Vue components The application features a comprehensive set of Vue 3 components (40+ components):\nCar Model Components:\nCar.vue: Car model card component with comparison functionality CarLoading.vue: Loading skeleton for car cards CarVersion.vue: Car version/trim level component CarVersionLoading.vue: Loading skeleton for version cards CarModelsListingStatic.vue: Static car models listing CarModelsListingQuote.vue: Car models listing for quote flow CarVersionsListingQuote.vue: Versions listing for quote flow CarQuote.vue: Car quote display component CarQuoteLoading.vue: Loading skeleton for quote cards Comparison Components:\nComparator.vue: Main car comparison component with Splide integration ComparatorModal.vue: Modal version of comparator CardCompareModel.vue: Comparison card for individual models CardCompareModelLoading.vue: Loading skeleton for comparison cards Quote Components:\nQuote.vue: Main quote component with multi-step flow QuoteForm.vue: Comprehensive quote form with validation Filtering Components:\nFilters.vue: General filtering component FleetFilter.vue: Fleet-specific filtering BranchesFilter.vue: Branch/dealership filtering BlogFilter.vue: Blog post filtering AjaxListWithFilter.vue: AJAX-powered list with filtering Content Components:\nBlog.vue: Blog post card component BlogLoading.vue: Loading skeleton for blog cards Fleet.vue: Fleet vehicle card component Branch.vue: Branch/dealership card component BranchLoading.vue: Loading skeleton for branch cards Manual.vue: Manual/documentation card component ManualLoading.vue: Loading skeleton for manual cards ManualsListing.vue: Manuals listing component Form Components:\nContactForm.vue: Contact form with validation Select.vue: Custom select dropdown component UI Components:\nPagination.vue: Pagination component StickySectionSelector.vue: Sticky navigation for sections EmptyState.vue: Empty state displays Loader.vue: Loading indicator ErrorBoundary.vue: Error boundary component SearchResults.vue: Search results display SearchResultCard.vue \u0026amp; SearchResultCardLoading.vue: Search result cards Service Components:\nCardMaintenance.vue: Maintenance service card CardMaintenanceLoading.vue: Loading skeleton for maintenance cards JavaScript components The application includes 12 specialized JavaScript components:\nUI Components:\nheader.js: Header functionality and navigation headroom.js: Header hide/show on scroll megamenu.js: Mega menu functionality search-modal.js: Search modal functionality scrollUpBottom.js: Scroll to top/bottom functionality social-share.js: Social media sharing Media Components:\nvideo.js: Video player setup splide.js: Carousel initialization slick.js: Legacy carousel support Interactive Components:\naccordion.js: Accordion interactions tabs.js: Tab functionality Utilities:\nimg-to-svg.js: SVG image conversion utility scrollTrigger.js: Scroll-based animations SCSS architecture The styling follows a well-organized SCSS architecture:\nscss/ ├── abstracts/ # Variables, mixins, functions │ ├── _mixins.scss │ ├── _mq.scss # Media query mixins │ └── _vendor.scss ├── base/ # Base styles and typography │ ├── _typography.scss │ ├── _colors.scss │ ├── _container.scss │ └── _globals.scss └── components/ # Component-specific styles ├── [87 component files] └── cards/ # Card component styles └── [20 card-specific files] Key SCSS features:\nBEM methodology: Consistent naming convention throughout Media query mixins: Using sass-mq for responsive design Modular architecture: 106 component-specific SCSS files Card organization: Dedicated card component styles Interactive components Car model comparator The Comparator.vue component provides sophisticated car model comparison:\nFeatures:\nSide-by-side comparison: Compare up to 3 models simultaneously Difference highlighting: Toggle to highlight differences between models Splide integration: Smooth carousel navigation for multiple models Dynamic data loading: Load comparison data via AJAX Responsive design: Optimized for mobile and desktop Modal version: Full-screen modal comparison view Technical Implementation:\nPinia store for comparison state management Splide Vue component for carousel functionality Dynamic component rendering based on selected models Efficient data structure for comparison attributes Multi-step quote form The Quote.vue and QuoteForm.vue components implement a comprehensive quote system:\nFeatures:\nStep-by-step flow: Model selection → Version selection → Customer information Form validation: Using Vee-Validate with Yup schemas RUT validation: Chilean RUT validation using custom directive Input masking: Phone numbers and formatted inputs with Maska reCAPTCHA integration: Spam protection Edit functionality: Ability to go back and edit previous steps Selected vehicle display: Visual representation of selected model/version Loading states: Visual feedback during form submission Form steps include:\nStep 1: Category and model selection Step 2: Version/trim level selection Step 3: Customer information and submission Advanced filtering systems Multiple filtering components provide comprehensive filtering:\nFleet Filter (FleetFilter.vue):\nFilter fleet vehicles by category, price range, and features Real-time filtering with URL parameter synchronization Mobile-optimized interface Branches Filter (BranchesFilter.vue):\nFilter dealerships by location, region, and services Map integration support Contact information display Blog Filter (BlogFilter.vue):\nFilter blog posts by category, date, and tags Search functionality Pagination support Ajax List with Filter (AjaxListWithFilter.vue):\nGeneric AJAX-powered list component Multiple filter criteria Loading states and empty states Sticky section selector The StickySectionSelector.vue component provides section-based navigation:\nFeatures:\nSticky positioning: Stays visible while scrolling Active section highlighting: Highlights current section Smooth scrolling: Smooth scroll to sections Responsive design: Mobile-optimized display State management with Pinia The application uses Pinia for centralized state management:\nStores:\nComparator Store: Manages comparison state, selected models, and comparison data Quote Store: Manages quote flow state, selected model/version, and form data Filter Stores: Manage filter states for different content types Benefits:\nCentralized state management Type-safe state access Efficient reactivity Easy debugging with Vue DevTools Custom directives The application includes custom Vue directives:\nRUT Directive (input-rut):\nChilean RUT (tax ID) validation and formatting Real-time validation as user types Format enforcement (XX.XXX.XXX-X) Development workflow The project uses Laravel Mix for asset compilation:\n// Development npm run dev // Compile assets npm run watch // Watch for changes npm run hot // Hot module replacement // Production npm run production // Optimized production build BrowserSync integration provides:\nLive reloading during development Synchronized browser testing Proxy configuration for WordPress development Performance optimizations Code splitting: Laravel Mix extracts vendor libraries Asset versioning: Automatic cache busting Image optimization: Lazy loading and responsive images Minification: Production builds are minified and optimized Tree shaking: Unused code elimination in production Component lazy loading: Load components on demand Skeleton loading: Better perceived performance with loading states Accessibility Semantic HTML structure ARIA labels for interactive elements Keyboard navigation support Focus management in forms and modals Screen reader considerations Proper alt text for images Color contrast compliance Conclusion and final thoughts Building the JAC Autos Chile frontend was an excellent opportunity to:\nMaster Vue 3: Working with Composition API, Pinia state management, and modern Vue patterns Build complex comparisons: Creating sophisticated car model comparison interfaces Implement multi-step forms: Complex quote forms with validation, RUT formatting, and step navigation Create advanced filtering: Multiple filtering systems for different content types Optimize performance: Implementing efficient state management, lazy loading, and code splitting Handle automotive data: Managing complex vehicle data structures and relationships The project demonstrates proficiency in:\nModern JavaScript frameworks (Vue 3) State management (Pinia) Form validation and user experience (Vee-Validate, Yup, Maska) Build tools and asset compilation (Laravel Mix, Webpack) CSS architecture and methodologies (SCSS, BEM) Component-based development Custom directives Carousel and slider implementations (Splide) AJAX-powered interfaces The integration with WordPress/Themosis backend required careful consideration of server-side rendering, API endpoints, and content management workflows, making this a full-stack frontend implementation for a comprehensive automotive platform.\nLive website: https://jacautoschile.cl/\nFigma Prototype: https://www.figma.com/proto/wfsYoYThSR9VId6TVUGevk/JAC---Dise%C3%B1o-desktop?node-id=1-232\u0026m=dev\u0026scaling=min-zoom\u0026content-scaling=fixed\u0026page-id=0%3A1\u0026starting-point-node-id=62%3A3801\n","image":"//localhost:1313/images/project/jac/home.png","permalink":"//localhost:1313/projects/jac-autos-chile-automotive-website/","tags":["Vue 3","Pinia","Laravel Mix","WordPress","Themosis","SCSS","JavaScript","Splide"],"title":"JAC Autos Chile: Automotive Website"},{"categories":["Projects"],"contents":"ISC Chile is an educational consultancy website for study abroad programs, built on top of WordPress with the Themosis framework, featuring GSAP animations, multi-step contact forms, advanced blog filtering, and comprehensive content management using Vue 2, Laravel Mix, and modern frontend technologies.\nOutline The project Design implementation The stack Frontend architecture Key features Conclusion Live website The project ISC Chile is an educational consultancy agency that has been providing study abroad advisory services since 1996. The website serves as the primary platform for showcasing various educational programs including English courses, school exchanges, group travel programs, and Pathways programs for university admission abroad.\nThe frontend development was based on a comprehensive Figma design, requiring pixel-perfect implementation of complex UI components, multi-step forms, animated statistics, and responsive layouts that work seamlessly across all devices.\nDesign implementation The entire frontend was built from a detailed Figma design, ensuring:\nPixel-perfect accuracy: Matching the design specifications precisely (as evidenced by Figma height references in SCSS) Responsive design: Implementing breakpoints and mobile-first approach Component consistency: Maintaining design system patterns throughout Interactive elements: Translating static designs into dynamic, interactive components Animation and transitions: Implementing smooth GSAP-powered animations The stack The frontend stack consists of:\nVue 2.6.12: Reactive framework for building interactive components Laravel Mix 6.0: Asset compilation and bundling SCSS: Advanced styling with a well-organized architecture Vuex 3.6.2: State management for Vue applications Vee-Validate 3.4.14: Form validation GSAP 3.12.5: Professional animation library with ScrollTrigger Axios 0.18: HTTP client for API requests Splide.js 4.1.4: Modern carousel and slider components Slick Carousel 1.8.1: Legacy carousel support LightGallery 2.7.2: Lightbox gallery functionality Odometer 0.4.8: Animated number counting Headroom.js: Header behavior on scroll V-Calendar 2.4.2: Calendar component for date selection V-Mask 2.3.0: Input masking Vue-Select 3.20.2: Custom select component jQuery 3.2: DOM manipulation and legacy support SweetAlert: Alert dialogs Frontend architecture Vue components The application features a comprehensive set of Vue 2 components:\nForm Components:\nContact.vue: Multi-step contact form with validation and reCAPTCHA ContactFormStep1.vue: First step of the contact form ContactFormStep2.vue: Second step of the contact form ContactFormStep3.vue: Third step of the contact form FormBanner.vue: Banner form component Content Components:\nBlog.vue: Blog listing with advanced filtering and search BlogArticleCard.vue \u0026amp; BlogArticleCardLoading.vue: Blog post cards with loading states ExperiencesPanel.vue: Testimonials and experiences display panel ExperiencesFiltersMobile.vue: Mobile filter component for experiences Search Components:\nSearchResults.vue: Search results display component SearchResultCardLoading.vue: Loading skeleton for search results UI Components:\nCheckboxDropdown.vue: Custom checkbox dropdown component CheckboxDropdownFieldset.vue: Fieldset wrapper for checkbox dropdowns EmptyState.vue: Empty state displays Loader.vue \u0026amp; Loading.vue: Loading indicators JavaScript components The application includes 15 specialized JavaScript components:\nAnimation Components:\ngsap.js: GSAP animations with ScrollTrigger for scroll-based reveals scrolltrigger.js: Custom scroll trigger utilities odometer.js: Animated number counting with scroll triggers UI Components:\nheader.js: Header functionality and navigation headroom.js: Header hide/show on scroll megamenu.js: Mega menu functionality mobileMenu.js: Mobile menu interactions searchbar.js: Search bar functionality floating-banner.js: Floating banner component footer.js: Footer functionality Media Components:\nvideo.js: Video player setup lightgallery.js: Lightbox gallery initialization splide.js: Carousel initialization slick.js: Legacy carousel support Interactive Components:\naccordion.js: Accordion interactions tabs.js: Tab functionality cards.js: Card interactions Utilities:\nimg-to-svg.js: SVG image conversion utility SCSS architecture The styling follows a well-organized SCSS architecture:\nscss/ ├── abstracts/ # Variables, mixins, functions │ ├── _mixins.scss │ ├── _mq.scss # Media query mixins │ └── _vendor.scss ├── base/ # Base styles and typography │ ├── _typography.scss │ ├── _colors.scss │ ├── _container.scss │ ├── _globals.scss │ └── fonts/ # Custom TWK Everett font family └── components/ # Component-specific styles └── [45 component files] Key SCSS features:\nBEM methodology: Consistent naming convention throughout Media query mixins: Using sass-mq for responsive design Modular architecture: Each component has its own SCSS file Custom typography: TWK Everett font family with multiple weights Figma references: Direct references to Figma design specifications Key features Multi-step contact form The Contact.vue component implements a sophisticated multi-step form with:\nThree-step navigation: Step-by-step form progression Form validation: Using Vee-Validate with comprehensive rules Date picker: V-Calendar integration for date selection Input masking: V-Mask for phone numbers and formatted inputs reCAPTCHA integration: Spam protection Dynamic fields: Fields that change based on user selections Loading states: Visual feedback during form submission Error handling: Comprehensive error messages and validation Form steps include:\nStep 1: Personal information and contact details Step 2: Educational background and program interests Step 3: Additional information and submission GSAP animations The gsap.js component provides professional animations:\nFeatures:\nScroll-triggered animations: Elements animate on scroll Vertical scroll reveals: Fade and slide animations Horizontal scroll reveals: Staggered animations for grid layouts Timeline management: Complex animation sequences Performance optimized: Efficient animation triggers Animation types:\nFade in with vertical movement Staggered grid animations Scroll-based reveals Smooth transitions Advanced blog system The Blog.vue component provides comprehensive blog functionality:\nFeatures:\nCategory filtering: Filter posts by category Search functionality: Real-time search across blog posts Mobile filters: Dedicated mobile filter interface Pagination: Efficient content pagination Loading states: Skeleton loading screens Empty states: User-friendly empty state messages Experiences/testimonials panel The ExperiencesPanel.vue component displays student testimonials:\nFeatures:\nFilter by type: Filter testimonials (Students/Parents) Dynamic loading: Load testimonials from API Responsive design: Mobile-optimized display Carousel integration: Splide carousel for testimonial display Animated statistics The odometer.js component provides animated number counting:\nFeatures:\nScroll-triggered: Animations trigger on scroll Smooth counting: Odometer theme integration Performance optimized: Efficient scroll detection Mobile support: Optimized for all devices Search functionality The SearchResults.vue component provides comprehensive search:\nFeatures:\nMulti-content search: Search across programs, blog posts, and pages Result categorization: Organized search results Image support: Results with and without images Tag display: Category tags for results Loading states: Skeleton loading screens Custom typography The website features a custom font family, TWK Everett, with:\nMultiple weights: From Hairline to Super Italic variants: All weights include italic versions Optimized formats: WOFF, WOFF2, and OTF formats Performance: Efficient font loading and rendering Development workflow The project uses Laravel Mix for asset compilation:\n// Development npm run dev // Compile assets npm run watch // Watch for changes npm run hot // Hot module replacement // Production npm run production // Optimized production build BrowserSync integration provides:\nLive reloading during development Synchronized browser testing Proxy configuration for WordPress development Performance optimizations Code splitting: Laravel Mix extracts vendor libraries Asset versioning: Automatic cache busting Image optimization: Lazy loading and responsive images Minification: Production builds are minified and optimized Tree shaking: Unused code elimination in production Font optimization: Efficient font loading strategies Accessibility Semantic HTML structure ARIA labels for interactive elements Keyboard navigation support Focus management in forms Screen reader considerations Proper alt text for images Conclusion and final thoughts Building the ISC Chile frontend from a Figma design was an excellent opportunity to:\nMaster Vue 2: Working with Options API, Vuex state management, and Vue 2 patterns Implement GSAP animations: Creating professional scroll-triggered animations Build complex forms: Multi-step forms with validation, date pickers, and input masking Create advanced filtering: Blog filtering with search and category selection Optimize performance: Implementing efficient animations and lazy loading Ensure design fidelity: Translating Figma designs into pixel-perfect implementations (with direct Figma references in code) The project demonstrates proficiency in:\nModern JavaScript frameworks (Vue 2) Animation libraries (GSAP, ScrollTrigger) Form validation and user experience (Vee-Validate, V-Mask, V-Calendar) Build tools and asset compilation (Laravel Mix, Webpack) CSS architecture and methodologies (SCSS, BEM) Component-based development State management (Vuex) Design system implementation The integration with WordPress/Themosis backend required careful consideration of server-side rendering, API endpoints, and content management workflows, making this a full-stack frontend implementation for an educational consultancy platform.\nLive website: https://www.iscchile.cl/\nFigma prototype: https://www.figma.com/proto/BfdKGJlzx7xAnE7rpZ1vda/Dise%C3%B1o-ISC?page-id=314%3A12071\u0026type=design\u0026node-id=314-12072\u0026viewport=-1452%2C930%2C0.29\u0026t=hFYiwcionjRAZ47v-1\u0026scaling=min-zoom\n","image":"//localhost:1313/images/project/isc-chile/home.png","permalink":"//localhost:1313/projects/isc-chile-educational-consultancy-website/","tags":["Vue 2","Laravel Mix","WordPress","Themosis","SCSS","GSAP","JavaScript","Figma"],"title":"ISC Chile: Educational Consultancy Website"},{"categories":["Projects"],"contents":"Rutieri is a SaaS platform built with Strapi, React Native, Typescript and other technologies.\nOutline The idea Platform features The stack The API The frontend The mobile app Conclusion Landing Page The idea Before starting to write a single line of code, it is generally a good idea to think about the problem, it\u0026rsquo;s limitations and whether or not it has already been solved by someone else (AKA competitors).\nThe problem I was looking into had to do with the way in which public and private transportation companies manage their routes, drivers and users. This process is generally carried out on paper, e.g. not digital, hence this could be problematic in case of new drivers joining the organization or in case of restricting access to data to only specific users.\nAfter a little bit of research, I could only find one platform that provides a similiar solution but for their own company.\nPlatform features and user stories The following user stories illustrates the desired features the platform should have in order to solve the aforementioned problems.\nAs an administrator user, I want to: login in the admin panel. create an organization. create routes in the organization. invite drivers and users to the organization. manage requests to join the organization. assign routes to drivers in the organization. see in real time the drivers and users currently active in the map of the different routes. As a driver, I want to: login in the mobile app. join an organization by entering the code in the search bar. see my route on the map. become visible to passengers on the road. see the passengers waiting on the road. remove my visibility and finish my run. As a passenger, I want to: login in the mobile app. join an organization by entering the code in the search bar. see the different routes of my organization in the map. search for a destination and get the available routes that pass nearby. see the drivers currently active on the routes in real time. become visible to drivers of a route. The requirements The backend requires to handle user authentication, permissions, different data structures as content types and define relations between them. It\u0026rsquo;s also necessary to synchronise passengers and drivers and view them on a map real time in the administration panel as well as in the mobile app.\nThe administration panel is a web page that fetches data from the backend as well as from the real time data provider and it\u0026rsquo;s goal is to provide a way for administrators to manage their organization and users. We\u0026rsquo;re talking about a Single Page Application built in React.\nAs for the mobile application, there isn\u0026rsquo;t a better choice nowadays than React Native and it works just fine in this case.\nThe API Since all of the features involve authentication, permissions and roles, and because there is no need to reinvent the wheel, I chose to use Strapi to build the backend for it\u0026rsquo;s simplicity, ease of use and great developer experience, whereas for realtime data, I used Firebase.\nThe instance of Strapi and the Postgres database it requires was deployed in the cloud hosting platform https://fly.io.\nStrapi is good for managing users, content that\u0026rsquo;s typically updated and fetched via CRUD API, and relations between content types.\nThe platform needs the following content types:\nOrganizations to group routes, drivers and users Routes Two user roles: drivers and users (passengers) Below are some screenshots of the overview of these content types\nAs I said before, Strapi makes the creation of these content types and the relationships between them really straightforward.\nHowever, not everything related to the API can be provided by Strapi. Some realtime features need to be addressed with other solutions, such as geolocation data in real time for drivers and users to synchronise each other, maps and the ability to search for places. Such features were implemented using Firebase, Google Maps and Google Places.\nThe frontend The platform where users are able to login as administrators and manage their organizations and users is a single page web application built in React. Among the features of this project that I think stand out are:\nState managed by Context API Interface styled with Bootstrap React Router for pages Leaflet to display the map GeoFire library to synchronise geolocation data in real time with Firebase Use of localStorage to save user session Below are some sample screenshots of how this app looks like\nThe mobile application This one is by far the most complex part of this project.\nThe project was bootstraped with Infinitered\u0026rsquo;s Ignite, which provides a great boilerplate and surely saved me of what would have been between 1-2 months of work.\nIgnite\u0026rsquo;s boilerplate includes many features out of the box, including:\nReact Native and Typescript (of course) React Navigation MobX-State-Tree for state management Expo SDK for developer experience AsyncStorage for persistence apisauce as REST client And some other libraries and features that make React Native apps super powerful and a joy to work on.\nIt consists of three screens:\nWelcome screen Login screen Map screen In the welcome screen, users are able to go to the login screen if not logged in. Otherwise, if they\u0026rsquo;re in an organisation, it shows their role and org\u0026rsquo;s information, and if they\u0026rsquo;re not, they are able to enter the organisation code and request to join as driver or as passenger.\nWelcome screens Login screens If the user is a driver in an organisation, the welcome screen also shows the route assigned to them. By tapping on it, it takes them to the map, where they can see themselves and start the tour, becoming visible to passengers on the road but being able to see passengers on the road as well.\nDrivers can finish the tour at any time by pressing the button stop.\nIf the user is a passenger in an organisation, the welcome screen shows the different routes available in the organisation. By tapping on them, they are taken to the map where they can see themselves, the route and the drivers on the road.\nPassengers are able to navigate between the available routes and search for the location they want to go to by using the search bar at the top of the map screen, filtering out the routes that pass nearby (less than 200 meters), if there are. Google Places API and turf library work together in this search process.\nPassengers become visible to drivers on the road by pressing the button wait and if they press the button again, they stop waiting and are removed from the driver\u0026rsquo;s map.\nMap screens The start/wait and finish buttons dispatch actions that update their location in firebase, so that passengers are able to see the bus on the map as it moves in real time and viceversa.\nAs for the state management, the project consists of two models and three stores from Mobx-State-Tree library: User and Route models, user-status, route-store and root-store stores.\nUser model Located in /app/models/user/user.ts\nconst OrganizationModel = types.model({ name: types.string, code: types.string, id: types.identifierNumber, drivers: types.number, rutas: types.array(RouteModel) }) const UserModel = types .model(\u0026#34;User\u0026#34;) .props({ id: types.identifierNumber, username: types.string, email: types.string, token: types.string, role: types.union(types.literal(\u0026#34;passenger\u0026#34;), types.literal(\u0026#34;driver\u0026#34;)), ruta: types.maybeNull(RouteModel), organization: types.maybeNull(OrganizationModel), pending_request: types.maybeNull(OrganizationModel), }) Route model Located in /app/models/route/route.ts\nThis model follows the GeoJSON format for routes.\nconst RouteModel = types .model(\u0026#34;Ruta\u0026#34;) .props({ id: types.identifierNumber, name: types.string, latlong: types.maybeNull(types.model({ lat: types.number, longt: types.number })), coords: types.model({ type: FeatureTypes, features: types.array(types.model({ type: types.string, geometry: types.model({ type: types.string, coordinates: types.union(types.array(types.number), types.array(types.array(types.number))) }), properties: types.model({ name: types.string }) })) }) }) user-status store Located in /app/models/user-status/user-status.ts\nThis store is responsible for managing the state of the user. It stores the user once it\u0026rsquo;s logged in and removes it when the user logs out. It also has some views to get the user key for firebase purposes, get the role and get the route in case of a driver.\nThis store has some methods that get the user location from the device\u0026rsquo;s GPS, displays the user icon on the map and sends it to firebase.\nconst UserStatusModel = types .model(\u0026#34;UserStatus\u0026#34;) .extend(withEnvironment) .props({ user: types.maybeNull(UserModel), location: types.maybeNull( types.model({latitude: types.number, longitude: types.number}) ), visibility: types.maybeNull(types.number) }) route-store store Located in /app/models/route-store/route-store.ts\nThis store is responsible for managing the state of the available routes. It stores the routes, drivers and passengers on the different routes. It also has some view methods to filter the routes that pass nearby a destination specified by the user, get passengers waiting on a given route and get drivers active in a specific route.\nThis store initializes a GeoQuery from Geofire library and listens for events to set, update and remove drivers and passengers from the map as they move.\nconst RouteStoreModel = types .model(\u0026#34;RouteStore\u0026#34;) .props({ routes: types.array(RouteModel), passengers: types.map(types.model({ key: types.identifier, location: types.array(types.number) })), drivers: types.map(types.model({ key: types.identifier, location: types.array(types.number) })), destinationAddress: types.maybeNull(types.model({ name: types.string, coords: types.array(types.number) })) }) Conclusion and final thoughts Using a CMS as the backend can make the development a lot faster than building the API from scratch and with Strapi this is specially true. On the other hand, Strapi doesn\u0026rsquo;t really make a good fit for real time applications, therefore, Firebase is the way to go in this case.\nAs of the client side, React always works very good for pretty much any kind of application, and because React Native uses React under the hood, it is so convenient for us React developers and ir works pretty good for almost any kind of application as well.\nHowever, one thing that I didn\u0026rsquo;t mention in this post was the use of Typescript; I find this quote by Brice Wilson pretty good to point out the whole purpose and motivation to learn and use (well) this powerful language and tool ecosystem:\n\u0026ldquo;You won\u0026rsquo;t have to wait for a frustrated user to report the error. All of this means that you provide value to your users faster, and that\u0026rsquo;s really what it\u0026rsquo;s all about.\u0026rdquo;\nAll in all, I got a lot of learning by building this project, both in languages/frameworks used and production stuff such as infrastructure, cloud hosting and cloud-based APIs.\nProject landing page: https://rutieri.netlify.app\n","image":"//localhost:1313/images/project/rutieri/landing/homepage.webp","permalink":"//localhost:1313/projects/saas-platform-rutieri/","tags":["Strapi","React Native","React","Typescript","Firebase"],"title":"SaaS platform: Rutieri"},{"categories":["Tutorial"],"contents":"Enable comments in a Strapi application and display them in the frontend with React\nOutline Introduction Prerequisites What is Strapi Comment Manager? Installation Configuration Display comments on the frontend Installation of Strapi Comments Client Usage of Strapi Comments Client Plugin settings Manage comments Full source code of the frontend Conclusion Introduction A comment system comes in very handy for pretty much any kind of website. In the JAMstack ecosystem, while it\u0026rsquo;s ok to rely on third party solutions hosted on their own platform such as Disqus to enable comments, you usually want to keep your content and all the stuff related to it in the same admin dashboard.\nIn this article, I\u0026rsquo;ll show you how to enable and manage comments for your content very easily using the Comment Manager plugin, and display them in your frontend application.\nPrerequisites You should have a basic understanding of the following.\nBasic knowledge of JavaScript Basic knowledge of React (OPTIONAL) Basic understanding of Strapi - get started here. Your Strapi V4 project setup What is Strapi Comment Manager? Strapi Comment Manager is a plugin that enables comments for pretty much any kind of content. It allows your users to post comments and anyone can get the comments associated with a given slug.\nWith this plugin, admin users can view and manage very easily all the comments from the Strapi administration dashboard. Within the dashboard, you will be able to delete comments and subcomments and leave replies on comments.\nInstallation Once into the Strapi project root, you can install the plugin by running the following command:\nnpm install strapi-plugin-comment-manager Next, build the project to see the new plugin in the dashboard with the following command:\nnpm run build And that\u0026rsquo;s it! If everything runs correctly, the plugin should now be installed.\nConfiguration Now you need to enable some permissions so that the frontend can access the endpoints to post and fetch comments.\nIn your Strapi admin dashboard, head over to Settings, then over to Roles under Users \u0026amp; Permissions Plugin.\nLet\u0026rsquo;s first setup the Public API; click on Public and hit the dropdown button of Comment Manager. Now check count, find and getPageSize, then hit the Save button. Below is a screenshot of a proper configuration:\nNow let\u0026rsquo;s setup the Authenticated API. Go back to Roles and click on Authenticated. Open the dropdown for Comment Manager and mark as checked the option create on both Comment and Subcomment. Below is a screenshot of a proper configuration:\nWith this configuration, the frontend should now be able to make requests to get and post comments.\nDisplay comments on the frontend The plugin exposes an API to get and post comments if you want to have fine-grained control over the workflow of your comments system and you can check the documentation on the package page, but this plugin also comes with a purpose-built React component library that makes it super easy to get up and running without getting your hands dirty.\nThis components library is called strapi-comments-client, fully supports typescript and it handles for you all of the complexity of fetching and posting comments and subcomments for every content ID that you pass to it.\nInstallation of Strapi Comments Client You will need to have installed react ^17.0.2, react-dom ^17.0.2 and react-router-dom ^5.2.0.\nInside of your React project, run this command:\nnpm install strapi-comments-client --save Usage of Strapi Comments Client Using this library is very easy!\nThis library exports three main components:\nCommentsProvider Comments CommentForm And you can import them this way:\nimport { CommentsProvider, Comments, CommentForm } from \u0026#34;strapi-comments-client\u0026#34; All you have to do is wrap your App component into the CommentsProvider component. Then you will be able to place anywhere in your app the Comments component to render a list of comments for a given content ID and the CommentForm component to render a form to post comments.\nFor example, this could be your index.js or main.js file:\nimport React from \u0026#39;react\u0026#39; import ReactDOM from \u0026#39;react-dom\u0026#39; // The address of your strapi backend instance const STRAPI = \u0026#34;http://localhost:1337\u0026#34; ReactDOM.render( \u0026lt;React.StrictMode\u0026gt; \u0026lt;CommentsProvider apiURL={STRAPI}\u0026gt; \u0026lt;App /\u0026gt; \u0026lt;/CommentsProvider\u0026gt; \u0026lt;/React.StrictMode\u0026gt;, document.getElementById(\u0026#39;root\u0026#39;) ) Where apiURL is the URL of your running Strapi application, and this property is required.\nThis way, the comments provider will do all the magic of fetching and posting comments for you!\nThis library also exports an utility React.Context to update some of the parameters for fetching and posting comments:\nimport { CommentsConfigContext } from \u0026#34;strapi-comments-client\u0026#34; This CommentsConfigContext exposes two setter functions: setUser and setContentID\nWith setContentID you can load the comments for a given content and post comments to it. It receives a single parameter of type string and must be URLized, i.e. no spaces.\nWith setUser you can set the credentials of a given user to authorize the posting of comments. It receives a single parameter of type IUser, with the following Typescript interface:\ninterface IUser { username: string, email: string, id: string, token: string // This is a JWT } It\u0026rsquo;s a little confusing but we\u0026rsquo;ll see how to use it in a component:\nconst App = () =\u0026gt; { const { setUser, setContentID } = useContext(CommentsConfigContext) // The following data should come from Strapi Users and Permissions Plugin // for authenticated requests const user = { username: \u0026#34;John Doe\u0026#34;, email: \u0026#34;jhohndoe@gmail.com\u0026#34;, id: 5, token: \u0026#34;this_should_be_a_JWT\u0026#34; } if (user) { setUser(user) } setContentID(\u0026#34;sample-content-1\u0026#34;) // Load comments for this content return ( \u0026lt;\u0026gt; { !user \u0026amp;\u0026amp; \u0026lt;Login /\u0026gt; } \u0026lt;CommentForm /\u0026gt; \u0026lt;Comments /\u0026gt; \u0026lt;/\u0026gt; ) } And that\u0026rsquo;s it!\nAfter setting the content ID through setContentID, CommentsProvider will start loading the comments for the given content ID and the CommentForm will render an input to post comments related to the given content ID if there is a user. Otherwise, it will display the message Login to post a comment.\nHere\u0026rsquo;s how the interface looks like so far:\nThere\u0026rsquo;s also a button to Leave a reply, which will open a form to post a subcomment associated with the parent comment.\nThis library exports one more component: ErrorBox\nimport { ErrorBox } from \u0026#34;strapi-comments-client\u0026#34; .It\u0026rsquo;s useful if you\u0026rsquo;d like to display error messages when things go wrong fetching or posting comments.\nYou can place this component wherever you want, for example in between the CommentForm and the Comments components.\nIf you\u0026rsquo;re wondering how this error box looks like, here you have a sample:\nGeneral settings You can customize the page size, i.e. specify how many comments are returned at once.\nIn the Strapi admin panel, head over to Settings, then select Pagination under Comment Manager Plugin.\nHere you\u0026rsquo;ll find an input to set the page size, which defaults to 10.\nManage comments Once you\u0026rsquo;ve got the plugin up an running, as users start to post comments, you can manage and reply to them as admin from the Comment Manager section of the left sidebar in the Strapi admin dashboard.\nHere you can see two tabs: one for the latest comments and one for comments grouped by content ID.\nIn both of them you can delete comments and subcomments as well as leave replies.\nExample project You can find a full working example of a React App using the Strapi Comments Client Library in this repo\nConclusion With this plugin you can enable and manage comments for any content with little effort and even use a component library to display the comments in your frontend application made with React.\nAnd that\u0026rsquo;s it! The features are pretty basic at the moment but if there\u0026rsquo;s interest, I\u0026rsquo;m willing to work on more features as well as improve the UI/UX.\n","image":"//localhost:1313/images/post/strapilogo.jpg","permalink":"//localhost:1313/blogs/how-to-enable-and-manage-comments-in-your-strapi-application/","tags":["Strapi","Strapi tutorials"],"title":"How To Enable And Manage Comments In Your Strapi Application."},{"categories":["Documentation"],"contents":"Comment Manager is a Strapi plugin to allow your users to post comments.\nWith this plugin you can enable and manage comments for your content very easily!\nRequirements You should have installed an instance of Strapi v4.x.x\nInstallation Run the following command in your project root:\nnpm install strapi-plugin-comment-manager Configurarion For your frontend to have access to the API, enable the following permissions for Comment Manager from Users \u0026amp; Permissions Plugin on your project settings:\nFor public, enable: count, find and getPageSize.\nFor authenticated, enable create on both Comment and Subcomment.\nDisplay comments on the frontend Comments can be displayed in the frontend in two ways:\nUsing the React components library strapi-comments-client (recommended) Build your custom frontend using the API API There are some Typescript interfaces that will help to get an idea of the data structures.\nComments: interface IComment { id: string, from_admin: boolean, createdAt: string, content: string, author: IAuthor | null, subcomments?: ISubcomment[] } Subcomments: interface ISubcomment { id: string, from_admin: boolean, createdAt: string, content: string, author: IAuthor | null, } Authors: IAuthor { username: string, email: string, id: string } The following endpoints are exposed to fetch and post comments and subcomments:\nGet comments for a content ID Method: GET\nPath: /api/comment-manager/comments/:slug\nOptional query parameters: start, ignoreCount\nReturns:\n{ commentsCount?: Number, comments: IComment[] } The parameter start indicates how many comments to skip. This is for pagination purposes.\nThe parameter ignoreCount indicates whether or not to return the total number of comments associated with the given slug.\nGet the number of comments associated with a given content ID Method: GET\nPath: /api/comment-manager/comments/:slug/count\nReturns:\n{ count: Number } Post a comment Method: POST\nPath: /api/comment-manager/comments/:slug\nAuthentication: Bearer token\nPayload:\n{ content: string } Returns:\n{ id: Number } Post a subcomment Method: POST\nPath: /api/comment-manager/subcomments/:parent-id\nAuthentication: Bearer token\nPayload:\n{ content: string } Returns:\n{ id: Number } Get the page size Method: GET\nPath: /api/comment-manager/page-size\nReturns:\n{ pageSize: Number } General settings The plugin allows to set how many comments are returned per page by going to the Pagination section under Comment Manager Plugin on the Settings section.\nThe default page size is 10.\nManagement of comments Admin users are able to delete comments and subcomments as well as leave replies as admins from within the plugin page of the Strapi admin dashboard.\nThe plugin interface has two tabs: one for the latest comments and one for comments by content ID.\nRoadmap and future plans The plugin is pretty basic but it can be improved with more features and a better UI/UX. Collaborations and suggestions are very welcome.\n","image":"//localhost:1313/images/post/strapilogo.jpg","permalink":"//localhost:1313/blogs/strapi-plugin-comment-manager/","tags":["Strapi","Strapi plugins"],"title":"Strapi Plugin Comment Manager"},{"categories":["Projects"],"contents":"In this post I’m going to share my experience on building a SaaS using the headless CMS Strapi as the Backend, React Native and other technologies.\nOutline Introduction What is SaaS? The problem What is Strapi? Developing features in Strapi The frontend: How to get content Conclusion Landing Page Introduction Very often, developers, product and project managers, testers and pretty much the entire team share their ideas to decide what language and which framework they\u0026rsquo;ll use to build their next project. Some considerations must be taken into account, from which in my opinion there are three that are the most important:\nDeveloper experience and ease of use Does the language and framework chosen provide a good developer experience? Is the langauge the same for the backend and frontend?\nDeadlines Is there a deadline to finish the project? if so, there is a good chance to finish the project on time if the team chooses the language they have more experience in.\nMaintainability As there will be usually more than one person working on the same part at the same time, if everything is kept organised, the whole development process will be frictionless.\nWith that in mind, developers and project managers will have a better insight on which language/framework to use.\nOther aspects should also be considered such as what the data structure will look like.\nIn my case, as it is usual, the backend of my project needs a database for users and their roles among other entities and their relations and a dashboard to allow admins to manage the data, and I was lucky to find out Strapi, as it includes a lot of these features out of the box with one single line of command to get started.\nWhat is SaaS? SaaS stands for Software-as-a-Service and it just means that a software is provided as a service in the cloud and it gives a solution to a specific problem, for which the users are willing to pay either monthly or annual subscription.\nThe problem Before starting to write a single line of code, it is generally a good idea to think about the problem, it\u0026rsquo;s limitations and whether or not it has already been solved by someone else (AKA competitors).\nThe problem I was looking into had to do with the way in which public and private transportation companies manage their routes, drivers and users. After a little bit of research, I could only find one platform that provides a similiar solution but for their own company.\nSo the platform I built needed the following content types:\nOrganizations to group routes, drivers and users Routes Two user roles: drivers and users (passengers) As I said before, Strapi makes the creation of these content types and the relationships between them really easy, but let\u0026rsquo;s first see what is Strapi and how it turns the API development into a satisfactory and fun experience.\nWhat is Strapi? Strapi is an open source headless CMS that allows developers to build complete RESTful APIs in just a couple of days instead of months. It includes a lot of useful features as plugins out of the box. Users and Roles management, Media library and an interface to create, view, edit and delete content are just some of them.\nRegarding the API, how does it makes the development faster?\nFirst of all, it enforces a specific folder structure, which helps to keep everything well organised and clean.\nSecondly, all database schemas are generated automatically and queries are made in JSON format, which really saves a lot of time.\nLastly, we can add more features to our Strapi application very easily via plugins from the marketplace.\nIt\u0026rsquo;s also worth noting that Strapi is a self-hosted CMS, which means that we can host it in whatever cloud platform we want, as well as test it locally in our computers before deploying it to the cloud.\nDeveloping features in Strapi Creating and configuring endpoints in Strapi is as straightforward as declaring a JSON in a single file:\nCreating controllers is straightforward as well:\nEvery controller gets all the data related to the request in the ctx parameter and it\u0026rsquo;s also used to send the response. This keeps everything in one place and really helps to improve the readability.\nOnce the API endpoints are defined, the next step is to enable the permissions for the specific user roles to have access to these endpoints:\nThe frontend: how to get content Since Strapi is a headless CMS, it\u0026rsquo;ll only provide content through the API. That means that the content can be consumed from anywhere. In our case, this content will be used in two applications: one for the organization owners and one for the users and drivers.\nThe application for the organization owners is a dashboard where administrators can create organizations, routes, accept drivers and users in the organization and assign routes to drivers. This is just a React Application:\nThe application for drivers and users is a mobile application built in React Native. Firebase was used to synchronise geolocation data in real time between drivers and users and display this information in a Map from Google Maps:\nConclusion Using a CMS as the backend can make the development a lot faster than building the API from scratch and with Strapi this is specially true. Furthermore, this becomes more important when building a brand-new product, as it\u0026rsquo;s usually recommended to launch as soon as possible to gather feedback from the users and validate the idea.\nProject landing page: https://rutieri.netlify.app\n","image":"//localhost:1313/images/post/03.webp","permalink":"//localhost:1313/blogs/how-i-built-a-saas-on-top-of-strapi-and-why-you-should-too/","tags":["Strapi","React Native","Typescript"],"title":"How I Built A SaaS On Top Of Strapi, And Why You Should Too"},{"categories":["Tutorial"],"contents":"Enable User Reviews in a Strapi application and display them in the frontend with React\nOutline Introduction Prerequisites What is Strapi Ratings? Installation Configuration Display user reviews on the frontend Plugin settings Manage user reviews Full source code of the frontend Conclusion Introduction Ratings systems have become a crucial part of any website with ecommerce capabilites, as they allow the users to post reviews on the items they purchase and publish their opinion to the public. A couple of reviews can make the difference between pressing the “Buy” button and moving on to the next website in the Google search results.\nIn this article, I\u0026rsquo;ll show you how to enable and manage user reviews for your content very easily using the Ratings plugin, and display them in your frontend application.\nPrerequisites First of all, you need to have a basic understanding of the following.\nBasic knowledge of JavaScript Basic knowledge of React (OPTIONAL) Basic understanding of Strapi - get started here. Your Strapi V4 project setup What is Strapi Ratings? Strapi Ratings is a plugin that gives your Strapi application the ability to manage ratings for pretty much any kind of content. It allows your users to post reviews and anyone can get the reviews associated with a given slug.\nWith this plugin, admin users can view and manage very easily all the reviews from the Strapi administration dashboard. Within the dashboard, you will be able to see reviews related to content slugs as well as delete reviews.\nInstallation Once into the Strapi project root, you can install the plugin by running the following command:\nnpm install strapi-plugin-ratings Next, build the project to see the new plugin in the dashboard with the following command:\nnpm run build And that\u0026rsquo;s it! If everything runs correctly, the plugin should now be installed.\nConfiguration Now you need to enable some permissions so that the frontend can access the endpoints to post and fetch reviews.\nIn your Strapi admin dashboard, head over to Settings, then over to Roles under Users \u0026amp; Permissions Plugin.\nLet\u0026rsquo;s first setup the Public API; click on Public and hit the dropdown button of Ratings. Now check count, find, getPageSize and getStats, then hit the Save button. Below is a screenshot of a proper configuration:\nNow let\u0026rsquo;s setup the Authenticated API. Go back to Roles and click on Authenticated. Open the dropdown for Ratings and mark as checked the options create, find and getUserReview. Below is a screenshot of a proper configuration:\nWith this configuration, the frontend should now be able to make requests to get and post user reviews.\nDisplay use reviews on the frontend The plugin exposes an API to get and post reviews if you want to have fine-grained control over the workflow of your ratings system and you can check the documentation on the package page, but this plugin also comes with a purpose-built React component library that makes it super easy to get up and running without getting your hands dirty.\nThis components library is called strapi-ratings-client, fully supports typescript and it takes care of all the complexity of fetching and posting user reviews for every content ID that you pass to it.\nInstallation of Strapi Ratings Client You will need to have installed react ^17.0.2, react-dom ^17.0.2, bootstrap ^5.1.3 and @popperjs/core^2.11.2\nInside of your React project, run this command:\nnpm install strapi-ratings-client --save Usage of Strapi Ratings Client Using this library is very easy!\nThis library exports three main components:\nReviewsProvider Reviews ReviewForm And you can import them this way:\nimport { ReviewsProvider, Reviews, ReviewForm } from \u0026#34;strapi-ratings-client\u0026#34; All you have to do is wrap your App component into the ReviewsProvider component. Then you will be able to place anywhere in your app the Reviews component to render a list of user reviews for a given content ID and the ReviewForm component to render a form to allow your users to post reviews.\nFor example, this could be your index.js or main.js file:\nimport React from \u0026#39;react\u0026#39; import ReactDOM from \u0026#39;react-dom\u0026#39; // The address of your strapi backend instance const STRAPI = \u0026#34;http://localhost:1337\u0026#34; ReactDOM.render( \u0026lt;React.StrictMode\u0026gt; \u0026lt;ReviewsProvider apiURL={STRAPI}\u0026gt; \u0026lt;App /\u0026gt; \u0026lt;/ReviewsProvider\u0026gt; \u0026lt;/React.StrictMode\u0026gt;, document.getElementById(\u0026#39;root\u0026#39;) ) Where apiURL is the URL of your running Strapi application, and this property is required.\nThis way, the ratings provider will do all the magic of fetching and posting comments for you!\nThis library also exports an utility React.Context to update some of the parameters for fetching and posting reviews:\nimport { ReviewsConfigContext } from \u0026#34;strapi-ratings-client\u0026#34; This ReviewsConfigContext exposes three setter functions: setUser, setContentID and setCanPostReview.\nWith setContentID you can load the ratings for a given content and post reviews to it. It receives a single parameter of type string and must be URLized, i.e. no spaces.\nWith setUser you can set the credentials of a given user to authorize the posting of reviews. It receives a single parameter of type IUser, with the following Typescript interface:\ninterface IUser { username: string, email: string, id: string, token: string // This is a JWT } With setCanPostReview, you can enable the user to post a review on the given content. This is useful for when you only allow a user to post a review after they purchase the product.\nIt\u0026rsquo;s a little confusing but we\u0026rsquo;ll see how to use it in a component:\nconst App = () =\u0026gt; { const { setUser, setContentID, setCanPostReview } = useContext(ReviewsConfigContext) // The following data should come from Strapi Users and Permissions Plugin // for authenticated requests. const user = { username: \u0026#34;John Doe\u0026#34;, email: \u0026#34;jhohndoe@gmail.com\u0026#34;, id: 5, token: \u0026#34;this_should_be_a_JWT\u0026#34; } if (user) { setUser(user) } setContentID(\u0026#34;sample-content-1\u0026#34;) // Load reviews for this content setCanPostReview(true) // Allow this user to post a review return ( \u0026lt;\u0026gt; { !user \u0026amp;\u0026amp; \u0026lt;Login /\u0026gt; } \u0026lt;ReviewForm /\u0026gt; \u0026lt;Reviews /\u0026gt; \u0026lt;/\u0026gt; ) } And that\u0026rsquo;s it!\nAfter setting the content ID through setContentID, ReviewsProvider will start loading the reviews for the given content ID and the ReviewForm will render an input to post a user review related to the given content ID if there is a user and he’s allowed to post a review. Otherwise, it will display the message Login to post a review or nothing at all if the user is not allowed to post a review.\nHere\u0026rsquo;s how the interface looks like so far:\nThis library exports one more component: ErrorBox\nimport { ErrorBox } from \u0026#34;strapi-ratings-client\u0026#34; .It\u0026rsquo;s useful for when you\u0026rsquo;d like to display error messages when things go wrong fetching or posting reviews.\nYou can place this component wherever you want, for example in between the ReviewForm and the Reviews components.\nIf you\u0026rsquo;re wondering how this error box looks like, here‘s a screenshot:\nGeneral settings You can customize the page size, i.e. specify how many user reviews are showed at once.\nIn the Strapi admin panel, head over to Settings, then select Pagination under Ratings Plugin.\nHere you\u0026rsquo;ll find an input to set the page size, which defaults to 10.\nManage reviews Once you\u0026rsquo;ve got the plugin up an running, as users start to post reviews, you can view them from within the Ratings section of the left sidebar in the Strapi admin dashboard.\nHere you can see two tabs: one for the latest reviews and one for reviews grouped by content ID.\nIn both of them you can delete unwanted reviews.\nExample project You can find a full working example of a React App using the Strapi Ratings Client Library in this repo: https://github.com/luisguve/strapi-ratings-client-example\nConclusion With this plugin you can enable and manage user reviews for any content with little effort and even use a library of components styled with Bootstrap to display the user reviews in your frontend.\nAnd that\u0026rsquo;s it! The features are pretty basic at the moment but if there\u0026rsquo;s interest, I\u0026rsquo;m willing to work on more features as well as improve the UI/UX.\n","image":"//localhost:1313/images/post/tutorial-ratings.webp","permalink":"//localhost:1313/blogs/how-to-enable-and-manage-user-reviews-in-your-strapi-application/","tags":["Strapi","Strapi tutorials"],"title":"How To Enable And Manage User Reviews In Your Strapi Application"},{"categories":["Documentation"],"contents":"Ratings is a Strapi plugin that allows your users to post reviews.\nEnable and manage user reviews for your content very easily!\nRequirements You should have installed an instance of Strapi v4.x.x\nInstallation Run the following command in your project root:\nnpm install strapi-plugin-ratings Then, rebuild the admin dashboard using the following command\nnpm run build Configurarion For your frontend to have access to the API, enable the following permissions for Ratings from Users \u0026amp; Permissions Plugin on your project settings:\nFor public, enable: count, find, getPageSize and getStats.\nFor authenticated, enable create, find and getUserReview.\nDisplay user reviews on the frontend Reviews can be displayed in the frontend in two ways:\nUsing the React components library strapi-ratings-client (recommended) Build your custom frontend using the API endpoints, described as follows: API There are some Typescript interfaces that will help to get an idea of the data structures.\nReviews: interface IReview { id: number, createdAt: string, comment: string | null, author: IAuthor | null, score: number, } Authors: interface IAuthor { username: string, email: string, id: number } Content Stats interface IStats { averageScore: number; reviewsCount: number | null; } The following endpoints are exposed to fetch and post reviews:\nGet reviews for a content ID Method: GET\nPath: /api/ratings/reviews/:slug\nOptional query parameters: start, ignoreCount\nReturns:\n{ reviewsCount: number, averageScore: number, userReview: IReview | null, reviews: IReview[] } The parameter start indicates how many reviews to skip. This is for pagination purposes.\nThe parameter ignoreCount indicates whether or not to return the total number of reviews associated with the given slug.\nGet review stats for a content ID Method: GET\nPath: /api/ratings/reviews/:slug/stats\nReturns:\n{ averageScore: number, reviewsCount: number | null } Get the number of reviews associated with a given content ID Method: GET\nPath: /api/ratings/reviews/:slug/count\nReturns:\n{ count: number } Post a review Method: POST\nPath: /api/ratings/reviews/:slug\nAuthentication: Bearer token\nPayload:\n{ content: string } Returns:\n{ id: number } By default, every authenticated user can post reviews on any content.\nIn order to customize this behavior, e.g. allowing or disallowing a user from posting reviews, you must extend the service userCanPostReview from whithin register function in ./src/index.js. For example:\nstrapi.service(\u0026#34;plugin::ratings.review\u0026#34;).userCanPostReview = async (user, slug) =\u0026gt; { /* Here you will check whether or not the user is allowed to post a review on this content ID and return either true or false. */ return true } Notice that userCanPostReview will receive two parameters: the user from Users \u0026amp; Permissions Plugin, containing it\u0026rsquo;s id, username, confirmed, etc., and the slug, which is a string and refers to the content ID which the review is being posted on.\nIn case this function returns false, the response of the endpoint will be 403 (forbidden) with the text User cannot post a review on this content.\nGet the page size Method: GET\nPath: /api/ratings/page-size\nReturns:\n{ pageSize: number } General settings The plugin allows to set how many reviews are returned per page by going to the Pagination section under Ratings Plugin of the Settings section.\nThe default page size is 10.\nManagement of reviews Admin users are able to delete reviews from within the plugin page of the Strapi admin dashboard.\nThe plugin interface has two tabs: one for the latest reviews and one for reviews by content ID.\nRoadmap and future plans The plugin is pretty basic but it can be improved with more features and a better UI/UX. Collaborations and suggestions are very welcome.\n","image":"//localhost:1313/images/post/ratings.webp","permalink":"//localhost:1313/blogs/strapi-plugin-ratings/","tags":["Strapi","Strapi plugins"],"title":"Strapi Plugin Ratings"},{"categories":["Projects"],"contents":"ManyLMS is an e-learning platform built on top of Strapi, React Router 7, Typescript and other technologies.\nOutline The idea Platform features The stack The API The frontend Conclusion Landing Page The idea This project doesn\u0026rsquo;t necessarily bring a huge amount of innovation on the e-learning platforms that already exists, but it\u0026rsquo;s just another way of doing this type of application.\nThe main idea is to apply a JAMstack approach in this application, where the platform is a static website, and the backend is just an API that serves static content only once to build the website and just adds the dynamism that\u0026rsquo;s necessary to allow users to authenticate, create orders, confirm payments and take courses.\nIf we compare this approach to a WordPress website, we are taking out most of the overhead that implies rendering the pages everytime a user visits them. Despite that there are plugins for caching that may improve the performance, it\u0026rsquo;s still never going to be faster and more efficient than just static content served by a CDN. That\u0026rsquo;s why React Router 7 and Headless CMSs are so popular right now.\nPlatform features and user stories The following user stories illustrates the desired features the platform should have.\nAs an administrator, I want to: login in the admin panel. create categories. create courses. upload lectures. organise courses into categories. assign lectures to courses. As a student, I want to: login in the platform. view the available courses. add courses to the shopping cart. review the shopping cart. create an order. pay with credit card or paypal. view the courses i\u0026rsquo;ve purchased in my learning page. go to the course page from my learning page and watch the videos. mark lectures as seen. come back later and resume where I left. The requirements The backend requires to handle user authentication, permissions, different data structures as content types and define relationships between them. It also requires to allow uploading videos to some third party platform that supports streaming on demand.\nThe frontend is a web platform where users can register and login, view and buy courses, leave comments and reviews and take courses.\nThe API Since all of the features involve authentication, permissions and roles, and because there is no need to reinvent the wheel, I chose to use Strapi to build the backend for it\u0026rsquo;s simplicity, ease of use and great developer experience, whereas for streaming videos on demand, I chose to use Mux.com.\nThe instance of Strapi and the Postgres database it requires was deployed in the cloud hosting platform https://fly.io.\nStrapi is good for managing users, content that\u0026rsquo;s typically updated and fetched via CRUD API, and setting up relations between content types.\nThe platform needs the following content types:\nCategory to group courses Course Lecture Module to group lectures Order Student: has many courses Student-Course: stores a student\u0026rsquo;s current lecture of a course Video Strapi makes the creation of these content types and setting up relationships between them really straightforward.\nBelow are some screenshots of these content types and the relationships between them:\nThe frontend The platform where users are able to login, view, buy and view courses is a web application built with React Router 7. Among the features of this application are:\nState managed by Context API Interface styled with Bootstrap Play streaming videos with @mux/mux-player-react library Use of localStorage to save user session Below are some sample screenshots of how this app looks like\nConclusion and final thoughts While building this project, I learned:\nHow streaming on demand works and how to use a streaming provider How to statically build websites with React Router 7 and Strapi How to setup dynamic pages in React Router 7 How to process payments with Stripe and Paypal How to build custom plugins in Strapi How to publish packages to NPM Project source codes: https://github.com/luisguve/maestro-backend\nhttps://github.com/luisguve/new-lms-remix\n","image":"//localhost:1313/images/project/manylms/frontend/course_overview.png","permalink":"//localhost:1313/projects/e-learning-platform-maestro-lms/","tags":["Strapi","React","React Router 7","Typescript","Mux"],"title":"ManyLMS: E-Learning platform"},{"categories":["Projects"],"contents":"ETMday (Emprende tu Mente) is a large-scale entrepreneurship event website built on top of WordPress with the Themosis framework, featuring an interactive SVG map, real-time countdown timers, advanced search functionality, and comprehensive content management using Vue 3, Laravel Mix, and modern frontend technologies.\nOutline The project Key features The stack Frontend architecture Interactive components Conclusion Live website The project ETMday is Chile\u0026rsquo;s premier entrepreneurship event, bringing together thousands of entrepreneurs, startups, corporates, and strategic partners. The website serves as the central hub for event information, featuring speakers, activities, stands, program schedules, and an interactive event map.\nThe frontend development required implementing complex interactive features including an SVG-based interactive map with tooltips, real-time countdown timers, advanced filtering and search systems, and dynamic content displays that handle thousands of attendees and hundreds of activities.\nKey features The website includes several sophisticated features:\nInteractive SVG Map: Custom-built interactive map with clickable zones, tooltips, and dynamic content display Real-time Countdown: Event countdown timer with automatic updates and mobile optimization Advanced Search: Multi-category search across activities, speakers, stands, and content Dynamic Filtering: Complex filtering system with tabs, favorites, and downloadable resources Animated Statistics: Odometer animations for displaying event metrics Content Management: Comprehensive card components for activities, speakers, stands, and blog posts Form Handling: Multi-step forms with validation using Vee-Validate Lightbox Galleries: Image galleries with LightGallery integration Responsive Design: Fully responsive design optimized for all devices The stack The frontend stack consists of:\nVue 3.2.4: Modern reactive framework for building interactive components Laravel Mix 6.0: Asset compilation and bundling SCSS: Advanced styling with organized architecture Vee-Validate 4.15.0: Form validation with Yup schemas Axios 1.6.8: HTTP client for API requests Splide.js 4.1.4: Modern carousel and slider components LightGallery 2.8.3: Lightbox gallery functionality Odometer 0.4.8: Animated number counting Headroom.js: Header behavior on scroll jQuery 3.7.1: DOM manipulation and legacy support SweetAlert2: Modern alert dialogs GLightbox 3.3.1: Alternative lightbox solution Frontend architecture Vue components The application features a comprehensive set of Vue 3 components:\nCard Components:\ncards/activities.vue: Activity cards with favorites functionality cards/speakers.vue: Speaker cards with modal details cards/stands.vue: Stand/exhibitor cards cards/blog.vue: Blog post cards cards/shortcut.vue: Quick access shortcut cards Functional Components:\nSectionCards.vue: Main section component with tabs, filtering, and card display Search.vue: Advanced search component with multi-category results Form.vue: Dynamic form component with validation FormCalendar.vue: Calendar form component CustomFilter.vue: Reusable filter component CustomSelect.vue: Custom select dropdown Pagination.vue: Pagination component JavaScript components The application includes 17 specialized JavaScript components:\nInteractive Features:\ninteractiveMap.js: SVG map interaction with tooltips, zones, and dynamic content countdown.js: Real-time countdown timer with automatic updates odometer.js: Animated number counting with scroll triggers map.js: Map zone interactions and modal displays UI Components:\nheader.js: Header functionality and navigation headroom.js: Header hide/show on scroll accordion.js: Accordion interactions tabs.js: Tab functionality cards.js: Card interactions and modals siteModals.js: Modal management system UI.js: General UI utilities Media Components:\nvideo.js: Video player setup lightgallery.js: Lightbox gallery initialization splide.js: Carousel initialization slick.js: Legacy carousel support Utilities:\nscrollTrigger.js: Scroll-based animations imgToSvg.js: SVG image conversion utility SCSS architecture The styling follows a well-organized SCSS architecture:\nscss/ ├── abstracts/ # Variables, mixins, functions │ ├── _functions.scss │ ├── _mixins.scss │ ├── _variables.scss │ ├── _mq.scss # Media query mixins │ └── _keyframes.scss ├── base/ # Base styles and typography │ ├── _typography.scss │ ├── _container.scss │ └── _reset.scss └── components/ # Component-specific styles └── [52 component files] Key SCSS features:\nBEM methodology: Consistent naming convention Media query mixins: Using sass-mq for responsive design Modular architecture: Each component has its own SCSS file Component organization: 52 component-specific SCSS files Interactive components Interactive SVG Map The interactiveMap.js component implements a sophisticated SVG-based interactive map:\nFeatures:\nSVG Tooltips: Dynamically generated tooltips with text wrapping Zone Interactions: Clickable zones with modal displays Point Markers: Interactive points with icons and labels Dynamic Content: Content loaded based on zone/point selection Responsive Design: Optimized for mobile and desktop Technical Implementation:\nSVG namespace manipulation for tooltip creation Text wrapping algorithm for tooltip content Path generation for tooltip shapes with rounded corners Event delegation for zone and point interactions Smooth animations and transitions Real-time Countdown The countdown.js component provides a real-time countdown timer:\nFeatures:\nAutomatic Updates: Updates every second Multi-unit Display: Days, hours, minutes, and seconds Pluralization: Proper Spanish pluralization (Día/Días, Hora/Horas) Mobile Optimization: Simplified display on mobile devices End State Handling: Automatic transition when countdown ends Advanced Search System The Search.vue component implements a comprehensive search system:\nFeatures:\nMulti-category Search: Searches across activities, speakers, stands, and other content Category Tabs: Quick navigation between result categories Result Counts: Dynamic result counts per category Scroll Navigation: Smooth scrolling to category sections Carousel Display: Splide carousels for result display Loading States: Loading indicators during search Empty States: User-friendly empty state messages Dynamic Filtering System The SectionCards.vue component provides advanced filtering:\nFeatures:\nTab Navigation: Multiple filter tabs Favorites System: Save and filter favorite items Search Integration: Inline search within filters Reset Functionality: Clear all filters with one click Downloadable Resources: Download buttons for resources URL Synchronization: Filter state in URL parameters Responsive Design: Mobile accordion interface Animated Statistics The odometer.js component provides animated number counting:\nFeatures:\nScroll-triggered: Animations trigger on scroll Prefix/Suffix Support: Handles formatted numbers (e.g., \u0026ldquo;56,000+\u0026rdquo;) Mobile Optimization: Static display on mobile Smooth Animations: Odometer theme integration Development workflow The project uses Laravel Mix for asset compilation:\n// Development npm run dev // Compile assets npm run watch // Watch for changes npm run hot // Hot module replacement // Production npm run production // Optimized production build BrowserSync integration provides:\nLive reloading during development Synchronized browser testing Proxy configuration for WordPress development Performance optimizations Code splitting: Laravel Mix extracts vendor libraries Asset versioning: Automatic cache busting Image optimization: Lazy loading and responsive images Minification: Production builds are minified and optimized Tree shaking: Unused code elimination in production SVG optimization: Efficient SVG manipulation and rendering Accessibility Semantic HTML structure ARIA labels for interactive elements Keyboard navigation support Focus management in forms and modals Screen reader considerations Proper alt text for images Conclusion and final thoughts Building the ETMday frontend was an excellent opportunity to:\nMaster SVG interactions: Creating complex interactive SVG maps with dynamic tooltips and zones Implement real-time features: Building countdown timers and live updates Build advanced search: Multi-category search with filtering and categorization Handle complex state: Managing filters, favorites, and dynamic content Optimize performance: Implementing efficient animations and lazy loading Ensure scalability: Building components that handle large datasets (thousands of attendees, hundreds of activities) The project demonstrates proficiency in:\nModern JavaScript frameworks (Vue 3) SVG manipulation and interaction Real-time UI updates Advanced filtering and search systems Build tools and asset compilation (Laravel Mix, Webpack) CSS architecture and methodologies (SCSS, BEM) Component-based development Event-driven architecture The integration with WordPress/Themosis backend required careful consideration of server-side rendering, API endpoints, and content management workflows, making this a full-stack frontend implementation for a large-scale event.\nLive website: https://etmday.org/\nFigma Prototype: https://www.figma.com/proto/mt9fJ8P03M5gf0nQwcU99q/EtM-Day-2025---Dise%C3%B1o?node-id=1-2743\u0026m=dev\u0026scaling=scale-down\u0026content-scaling=fixed\u0026page-id=0%3A1\u0026starting-point-node-id=1%3A2743\n","image":"//localhost:1313/images/project/etm/home.png","permalink":"//localhost:1313/projects/etmday-entrepreneurship-event-website/","tags":["Vue 3","Laravel Mix","WordPress","Themosis","SCSS","JavaScript","Interactive Map","SVG"],"title":"ETMday: Entrepreneurship Event Website"},{"categories":["Projects"],"contents":"Chile Nativo is a travel tour website for Patagonia experiences, built on top of WordPress with the Themosis framework, featuring a modern frontend implementation based on a Figma design using Vue 3, Laravel Mix, and a comprehensive SCSS architecture.\nOutline The project Design implementation The stack Frontend architecture Key features Conclusion Live website The project Chile Nativo is a travel company specializing in Patagonia tours, offering experiences in destinations like Torres del Paine, Tierra del Fuego, and Isla Navarino. The website serves as the primary platform for showcasing tours, managing bookings, and providing information about their travel experiences.\nThe frontend development was based on a comprehensive Figma design, requiring pixel-perfect implementation of complex UI components, interactive forms, filtering systems, and responsive layouts that work seamlessly across all devices.\nDesign implementation The entire frontend was built from a detailed Figma design, ensuring:\nPixel-perfect accuracy: Matching the design specifications precisely Responsive design: Implementing breakpoints and mobile-first approach Component consistency: Maintaining design system patterns throughout Interactive elements: Translating static designs into dynamic, interactive components Animation and transitions: Implementing smooth user experience enhancements The stack The frontend stack consists of:\nVue 3.2.4: Modern reactive framework for building interactive components Laravel Mix 6.0: Asset compilation and bundling SCSS: Advanced styling with a well-organized architecture Pinia 2.3.1: State management for Vue applications Vee-Validate 4.15.0: Form validation with Yup schemas Axios 1.6.8: HTTP client for API requests Splide.js 4.1.4: Modern carousel and slider components Headroom.js: Header behavior on scroll Plyr 3.7.8: Video player implementation SweetAlert2: Modern alert dialogs jQuery 3.7.1: Legacy support and DOM manipulation utilities Frontend architecture Vue components The application features a comprehensive set of Vue 3 components organized by functionality:\nFiltering and Search Components:\nToursFilter.vue: Advanced tour filtering with multiple criteria TourDatesFilter.vue: Date-based filtering for tour availability ToursFilterDropdown.vue \u0026amp; ToursFilterDropdownMobile.vue: Responsive filter dropdowns TestimonialsFilter.vue: Filtering system for customer testimonials NewsFilter.vue: Blog and news filtering SearchResults.vue: Search results display with pagination Form Components:\nPersonalizedTripForm.vue: Multi-step form for custom trip requests with validation ContactFormSimple.vue: Contact form with reCAPTCHA integration FormHelp.vue: Help center form FormGiftCard.vue: Gift card purchase form FormCareers.vue: Job application form NewsletterForm.vue: Newsletter subscription Card Components:\nTour.vue \u0026amp; TourLoading.vue: Tour card display with loading states TourDate.vue \u0026amp; TourDateLoading.vue: Tour date selection cards Testimonial.vue \u0026amp; TestimonialLoading.vue: Customer testimonial cards Blog.vue \u0026amp; BlogLoading.vue: Blog post cards Team.vue \u0026amp; TeamLoading.vue: Team member cards ResourceCard.vue \u0026amp; ResourceLoading.vue: Resource display cards Utility Components:\nPagination.vue: Reusable pagination component Select.vue: Custom select dropdown with search Loader.vue \u0026amp; LoaderFullScreen.vue: Loading indicators EmptyState.vue: Empty state displays ContentResources.vue: Resource content management TeamTabsFilter.vue: Tabbed team member filtering SCSS architecture The styling follows a well-organized SCSS architecture:\nscss/ ├── abstracts/ # Variables, mixins, functions │ ├── _functions.scss │ ├── _mixins.scss │ ├── _variables.scss │ ├── _mq.scss # Media query mixins │ └── _keyframes.scss ├── base/ # Base styles and typography │ ├── _typography.scss │ ├── _colors.scss │ ├── _fonts.scss │ └── _reset.scss └── components/ # Component-specific styles └── [125 component files] Key SCSS features:\nBEM methodology: Consistent naming convention throughout Media query mixins: Using sass-mq for responsive design Modular architecture: Each component has its own SCSS file Abstract layer: Reusable variables, mixins, and functions Vue transitions: Custom transition styles for Vue components JavaScript architecture The JavaScript is organized into two main entry points:\nMain application (app.js):\nInitializes core application functionality Sets up jQuery plugins and utilities Handles legacy browser support Vue application (vue/main.js):\nConfigures Vue 3 app with Pinia for state management Registers global Vue components Sets up Vee-Validate configuration Integrates third-party Vue plugins (VueTelInput, etc.) Component utilities (app/components/):\nheader.js: Header behavior and navigation footer.js: Footer functionality splide.js: Carousel initialization slick.js: Legacy carousel support accordions.js: Accordion interactions tabs.js: Tab functionality scrollTrigger.js: Scroll-based animations video.js: Video player setup sticky-sidebar.js: Sticky sidebar behavior Key features Multi-step forms The PersonalizedTripForm.vue component implements a sophisticated multi-step form with:\nStep-by-step navigation with progress indicators Form validation using Vee-Validate and Yup schemas Dynamic form fields based on user selections Phone number input with international support (VueTelInput) reCAPTCHA integration for spam protection Loading states and error handling Advanced filtering system The tour filtering system (ToursFilter.vue) provides:\nMultiple filter criteria (destination, activity type, trip type, month) Real-time filtering with URL parameter synchronization Responsive design with mobile accordion interface Custom select components with search functionality Empty states and loading indicators Integration with WordPress backend via Axios Responsive design The entire website is fully responsive with:\nMobile-first approach Breakpoint management using sass-mq Touch-friendly interactions Optimized images and assets Performance optimizations for mobile devices Performance optimizations Code splitting: Laravel Mix extracts vendor libraries Asset versioning: Automatic cache busting Image optimization: Lazy loading and responsive images Minification: Production builds are minified and optimized Tree shaking: Unused code elimination in production Accessibility Semantic HTML structure ARIA labels where appropriate Keyboard navigation support Focus management in forms Screen reader considerations Development workflow The project uses Laravel Mix for asset compilation:\n// Development npm run dev // Compile assets npm run watch // Watch for changes npm run hot // Hot module replacement // Production npm run production // Optimized production build BrowserSync integration provides:\nLive reloading during development Synchronized browser testing Proxy configuration for WordPress development Conclusion and final thoughts Building the Chile Nativo frontend from a Figma design was an excellent opportunity to:\nMaster Vue 3: Working with the Composition API, reactive systems, and modern Vue patterns Implement complex forms: Multi-step forms with validation, international phone inputs, and reCAPTCHA Build scalable architecture: Organizing 40+ Vue components and 125+ SCSS files in a maintainable structure Optimize performance: Implementing code splitting, lazy loading, and production optimizations Ensure design fidelity: Translating Figma designs into pixel-perfect implementations Handle responsive design: Creating seamless experiences across all device sizes The project demonstrates proficiency in:\nModern JavaScript frameworks (Vue 3) Build tools and asset compilation (Laravel Mix, Webpack) CSS architecture and methodologies (SCSS, BEM) Form validation and user experience Component-based development Design system implementation The integration with WordPress/Themosis backend required careful consideration of server-side rendering, API endpoints, and content management workflows, making this a full-stack frontend implementation.\nLive website: https://chilenativo.travel/\nFigma prototype: https://www.figma.com/proto/ywHPhSP1UfYUAE8eWVQv4L/Dise%C3%B1o-Desktop---Chile-Nativo?node-id=289-3912\u0026m=dev\u0026scaling=min-zoom\u0026content-scaling=fixed\u0026page-id=289%3A3911\u0026starting-point-node-id=289%3A3912\n","image":"//localhost:1313/images/project/chile-nativo/home.png","permalink":"//localhost:1313/projects/chile-nativo-patagonia-travel-website/","tags":["Vue 3","Laravel Mix","WordPress","Themosis","SCSS","JavaScript","Figma"],"title":"Chile Nativo: Patagonia Travel Website"},{"categories":["Projects"],"contents":"JAC Autos Chile is a comprehensive automotive website built on top of WordPress with the Themosis framework, featuring car model comparisons, multi-step quote forms, fleet management, branch listings, and advanced filtering systems using Vue 3, Pinia state management, Laravel Mix, and modern frontend technologies.\nOutline The project Key features The stack Frontend architecture Interactive components Conclusion Live website The project JAC Autos Chile is the official website for JAC Motors in Chile, showcasing SUVs, pickups, commercial vehicles, and electric vehicles. The website serves as the primary platform for vehicle exploration, quoting, dealership location, fleet management, and post-sale services.\nThe frontend development required implementing complex interactive features including car model comparisons, multi-step quote forms with model and version selection, advanced filtering systems, fleet management interfaces, and comprehensive content management.\nKey features The website includes several sophisticated features:\nCar Model Comparator: Side-by-side comparison of multiple vehicle models with difference highlighting Multi-step Quote Form: Comprehensive quote form with model selection, version selection, and customer information Advanced Filtering: Multi-criteria filtering for car models, branches, fleet vehicles, and blog posts Fleet Management: Dedicated fleet vehicle selection and management interface Branch Locator: Filterable dealership/branch listings with location information Blog System: Complete blog with filtering, search, and content management Manuals Listing: User manual and documentation management Search Functionality: Site-wide search with categorized results Sticky Navigation: Section-based sticky navigation for long pages 360° View: Interactive 360-degree vehicle viewing The stack The frontend stack consists of:\nVue 3.2.4: Modern reactive framework with Composition API Pinia 2.2.6: State management for Vue applications Laravel Mix 6.0: Asset compilation and bundling SCSS: Advanced styling with organized architecture Vee-Validate 4.14.6: Form validation with Yup schemas Axios 1.6.8: HTTP client for API requests Splide.js 4.1.4: Modern carousel and slider components @splidejs/vue-splide 0.6.12: Vue 3 wrapper for Splide Maska 3.0.3: Input masking for formatted inputs Vue-Select 4.0.0-beta.6: Custom select component Vue-Recaptcha 2.0.3: reCAPTCHA integration Headroom.js: Header behavior on scroll jQuery 3.7.1: DOM manipulation and legacy support SweetAlert2: Modern alert dialogs @fdograph/rut-utilities: Chilean RUT validation utilities Frontend architecture Vue components The application features a comprehensive set of Vue 3 components (40+ components):\nCar Model Components:\nCar.vue: Car model card component with comparison functionality CarLoading.vue: Loading skeleton for car cards CarVersion.vue: Car version/trim level component CarVersionLoading.vue: Loading skeleton for version cards CarModelsListingStatic.vue: Static car models listing CarModelsListingQuote.vue: Car models listing for quote flow CarVersionsListingQuote.vue: Versions listing for quote flow CarQuote.vue: Car quote display component CarQuoteLoading.vue: Loading skeleton for quote cards Comparison Components:\nComparator.vue: Main car comparison component with Splide integration ComparatorModal.vue: Modal version of comparator CardCompareModel.vue: Comparison card for individual models CardCompareModelLoading.vue: Loading skeleton for comparison cards Quote Components:\nQuote.vue: Main quote component with multi-step flow QuoteForm.vue: Comprehensive quote form with validation Filtering Components:\nFilters.vue: General filtering component FleetFilter.vue: Fleet-specific filtering BranchesFilter.vue: Branch/dealership filtering BlogFilter.vue: Blog post filtering AjaxListWithFilter.vue: AJAX-powered list with filtering Content Components:\nBlog.vue: Blog post card component BlogLoading.vue: Loading skeleton for blog cards Fleet.vue: Fleet vehicle card component Branch.vue: Branch/dealership card component BranchLoading.vue: Loading skeleton for branch cards Manual.vue: Manual/documentation card component ManualLoading.vue: Loading skeleton for manual cards ManualsListing.vue: Manuals listing component Form Components:\nContactForm.vue: Contact form with validation Select.vue: Custom select dropdown component UI Components:\nPagination.vue: Pagination component StickySectionSelector.vue: Sticky navigation for sections EmptyState.vue: Empty state displays Loader.vue: Loading indicator ErrorBoundary.vue: Error boundary component SearchResults.vue: Search results display SearchResultCard.vue \u0026amp; SearchResultCardLoading.vue: Search result cards Service Components:\nCardMaintenance.vue: Maintenance service card CardMaintenanceLoading.vue: Loading skeleton for maintenance cards JavaScript components The application includes 12 specialized JavaScript components:\nUI Components:\nheader.js: Header functionality and navigation headroom.js: Header hide/show on scroll megamenu.js: Mega menu functionality search-modal.js: Search modal functionality scrollUpBottom.js: Scroll to top/bottom functionality social-share.js: Social media sharing Media Components:\nvideo.js: Video player setup splide.js: Carousel initialization slick.js: Legacy carousel support Interactive Components:\naccordion.js: Accordion interactions tabs.js: Tab functionality Utilities:\nimg-to-svg.js: SVG image conversion utility scrollTrigger.js: Scroll-based animations SCSS architecture The styling follows a well-organized SCSS architecture:\nscss/ ├── abstracts/ # Variables, mixins, functions │ ├── _mixins.scss │ ├── _mq.scss # Media query mixins │ └── _vendor.scss ├── base/ # Base styles and typography │ ├── _typography.scss │ ├── _colors.scss │ ├── _container.scss │ └── _globals.scss └── components/ # Component-specific styles ├── [87 component files] └── cards/ # Card component styles └── [20 card-specific files] Key SCSS features:\nBEM methodology: Consistent naming convention throughout Media query mixins: Using sass-mq for responsive design Modular architecture: 106 component-specific SCSS files Card organization: Dedicated card component styles Interactive components Car model comparator The Comparator.vue component provides sophisticated car model comparison:\nFeatures:\nSide-by-side comparison: Compare up to 3 models simultaneously Difference highlighting: Toggle to highlight differences between models Splide integration: Smooth carousel navigation for multiple models Dynamic data loading: Load comparison data via AJAX Responsive design: Optimized for mobile and desktop Modal version: Full-screen modal comparison view Technical Implementation:\nPinia store for comparison state management Splide Vue component for carousel functionality Dynamic component rendering based on selected models Efficient data structure for comparison attributes Multi-step quote form The Quote.vue and QuoteForm.vue components implement a comprehensive quote system:\nFeatures:\nStep-by-step flow: Model selection → Version selection → Customer information Form validation: Using Vee-Validate with Yup schemas RUT validation: Chilean RUT validation using custom directive Input masking: Phone numbers and formatted inputs with Maska reCAPTCHA integration: Spam protection Edit functionality: Ability to go back and edit previous steps Selected vehicle display: Visual representation of selected model/version Loading states: Visual feedback during form submission Form steps include:\nStep 1: Category and model selection Step 2: Version/trim level selection Step 3: Customer information and submission Advanced filtering systems Multiple filtering components provide comprehensive filtering:\nFleet Filter (FleetFilter.vue):\nFilter fleet vehicles by category, price range, and features Real-time filtering with URL parameter synchronization Mobile-optimized interface Branches Filter (BranchesFilter.vue):\nFilter dealerships by location, region, and services Map integration support Contact information display Blog Filter (BlogFilter.vue):\nFilter blog posts by category, date, and tags Search functionality Pagination support Ajax List with Filter (AjaxListWithFilter.vue):\nGeneric AJAX-powered list component Multiple filter criteria Loading states and empty states Sticky section selector The StickySectionSelector.vue component provides section-based navigation:\nFeatures:\nSticky positioning: Stays visible while scrolling Active section highlighting: Highlights current section Smooth scrolling: Smooth scroll to sections Responsive design: Mobile-optimized display State management with Pinia The application uses Pinia for centralized state management:\nStores:\nComparator Store: Manages comparison state, selected models, and comparison data Quote Store: Manages quote flow state, selected model/version, and form data Filter Stores: Manage filter states for different content types Benefits:\nCentralized state management Type-safe state access Efficient reactivity Easy debugging with Vue DevTools Custom directives The application includes custom Vue directives:\nRUT Directive (input-rut):\nChilean RUT (tax ID) validation and formatting Real-time validation as user types Format enforcement (XX.XXX.XXX-X) Development workflow The project uses Laravel Mix for asset compilation:\n// Development npm run dev // Compile assets npm run watch // Watch for changes npm run hot // Hot module replacement // Production npm run production // Optimized production build BrowserSync integration provides:\nLive reloading during development Synchronized browser testing Proxy configuration for WordPress development Performance optimizations Code splitting: Laravel Mix extracts vendor libraries Asset versioning: Automatic cache busting Image optimization: Lazy loading and responsive images Minification: Production builds are minified and optimized Tree shaking: Unused code elimination in production Component lazy loading: Load components on demand Skeleton loading: Better perceived performance with loading states Accessibility Semantic HTML structure ARIA labels for interactive elements Keyboard navigation support Focus management in forms and modals Screen reader considerations Proper alt text for images Color contrast compliance Conclusion and final thoughts Building the JAC Autos Chile frontend was an excellent opportunity to:\nMaster Vue 3: Working with Composition API, Pinia state management, and modern Vue patterns Build complex comparisons: Creating sophisticated car model comparison interfaces Implement multi-step forms: Complex quote forms with validation, RUT formatting, and step navigation Create advanced filtering: Multiple filtering systems for different content types Optimize performance: Implementing efficient state management, lazy loading, and code splitting Handle automotive data: Managing complex vehicle data structures and relationships The project demonstrates proficiency in:\nModern JavaScript frameworks (Vue 3) State management (Pinia) Form validation and user experience (Vee-Validate, Yup, Maska) Build tools and asset compilation (Laravel Mix, Webpack) CSS architecture and methodologies (SCSS, BEM) Component-based development Custom directives Carousel and slider implementations (Splide) AJAX-powered interfaces The integration with WordPress/Themosis backend required careful consideration of server-side rendering, API endpoints, and content management workflows, making this a full-stack frontend implementation for a comprehensive automotive platform.\nLive website: https://jacautoschile.cl/\nFigma Prototype: https://www.figma.com/proto/wfsYoYThSR9VId6TVUGevk/JAC---Dise%C3%B1o-desktop?node-id=1-232\u0026m=dev\u0026scaling=min-zoom\u0026content-scaling=fixed\u0026page-id=0%3A1\u0026starting-point-node-id=62%3A3801\n","image":"//localhost:1313/images/project/jac/home.png","permalink":"//localhost:1313/projects/jac-autos-chile-automotive-website/","tags":["Vue 3","Pinia","Laravel Mix","WordPress","Themosis","SCSS","JavaScript","Splide"],"title":"JAC Autos Chile: Automotive Website"},{"categories":["Projects"],"contents":"ISC Chile is an educational consultancy website for study abroad programs, built on top of WordPress with the Themosis framework, featuring GSAP animations, multi-step contact forms, advanced blog filtering, and comprehensive content management using Vue 2, Laravel Mix, and modern frontend technologies.\nOutline The project Design implementation The stack Frontend architecture Key features Conclusion Live website The project ISC Chile is an educational consultancy agency that has been providing study abroad advisory services since 1996. The website serves as the primary platform for showcasing various educational programs including English courses, school exchanges, group travel programs, and Pathways programs for university admission abroad.\nThe frontend development was based on a comprehensive Figma design, requiring pixel-perfect implementation of complex UI components, multi-step forms, animated statistics, and responsive layouts that work seamlessly across all devices.\nDesign implementation The entire frontend was built from a detailed Figma design, ensuring:\nPixel-perfect accuracy: Matching the design specifications precisely (as evidenced by Figma height references in SCSS) Responsive design: Implementing breakpoints and mobile-first approach Component consistency: Maintaining design system patterns throughout Interactive elements: Translating static designs into dynamic, interactive components Animation and transitions: Implementing smooth GSAP-powered animations The stack The frontend stack consists of:\nVue 2.6.12: Reactive framework for building interactive components Laravel Mix 6.0: Asset compilation and bundling SCSS: Advanced styling with a well-organized architecture Vuex 3.6.2: State management for Vue applications Vee-Validate 3.4.14: Form validation GSAP 3.12.5: Professional animation library with ScrollTrigger Axios 0.18: HTTP client for API requests Splide.js 4.1.4: Modern carousel and slider components Slick Carousel 1.8.1: Legacy carousel support LightGallery 2.7.2: Lightbox gallery functionality Odometer 0.4.8: Animated number counting Headroom.js: Header behavior on scroll V-Calendar 2.4.2: Calendar component for date selection V-Mask 2.3.0: Input masking Vue-Select 3.20.2: Custom select component jQuery 3.2: DOM manipulation and legacy support SweetAlert: Alert dialogs Frontend architecture Vue components The application features a comprehensive set of Vue 2 components:\nForm Components:\nContact.vue: Multi-step contact form with validation and reCAPTCHA ContactFormStep1.vue: First step of the contact form ContactFormStep2.vue: Second step of the contact form ContactFormStep3.vue: Third step of the contact form FormBanner.vue: Banner form component Content Components:\nBlog.vue: Blog listing with advanced filtering and search BlogArticleCard.vue \u0026amp; BlogArticleCardLoading.vue: Blog post cards with loading states ExperiencesPanel.vue: Testimonials and experiences display panel ExperiencesFiltersMobile.vue: Mobile filter component for experiences Search Components:\nSearchResults.vue: Search results display component SearchResultCardLoading.vue: Loading skeleton for search results UI Components:\nCheckboxDropdown.vue: Custom checkbox dropdown component CheckboxDropdownFieldset.vue: Fieldset wrapper for checkbox dropdowns EmptyState.vue: Empty state displays Loader.vue \u0026amp; Loading.vue: Loading indicators JavaScript components The application includes 15 specialized JavaScript components:\nAnimation Components:\ngsap.js: GSAP animations with ScrollTrigger for scroll-based reveals scrolltrigger.js: Custom scroll trigger utilities odometer.js: Animated number counting with scroll triggers UI Components:\nheader.js: Header functionality and navigation headroom.js: Header hide/show on scroll megamenu.js: Mega menu functionality mobileMenu.js: Mobile menu interactions searchbar.js: Search bar functionality floating-banner.js: Floating banner component footer.js: Footer functionality Media Components:\nvideo.js: Video player setup lightgallery.js: Lightbox gallery initialization splide.js: Carousel initialization slick.js: Legacy carousel support Interactive Components:\naccordion.js: Accordion interactions tabs.js: Tab functionality cards.js: Card interactions Utilities:\nimg-to-svg.js: SVG image conversion utility SCSS architecture The styling follows a well-organized SCSS architecture:\nscss/ ├── abstracts/ # Variables, mixins, functions │ ├── _mixins.scss │ ├── _mq.scss # Media query mixins │ └── _vendor.scss ├── base/ # Base styles and typography │ ├── _typography.scss │ ├── _colors.scss │ ├── _container.scss │ ├── _globals.scss │ └── fonts/ # Custom TWK Everett font family └── components/ # Component-specific styles └── [45 component files] Key SCSS features:\nBEM methodology: Consistent naming convention throughout Media query mixins: Using sass-mq for responsive design Modular architecture: Each component has its own SCSS file Custom typography: TWK Everett font family with multiple weights Figma references: Direct references to Figma design specifications Key features Multi-step contact form The Contact.vue component implements a sophisticated multi-step form with:\nThree-step navigation: Step-by-step form progression Form validation: Using Vee-Validate with comprehensive rules Date picker: V-Calendar integration for date selection Input masking: V-Mask for phone numbers and formatted inputs reCAPTCHA integration: Spam protection Dynamic fields: Fields that change based on user selections Loading states: Visual feedback during form submission Error handling: Comprehensive error messages and validation Form steps include:\nStep 1: Personal information and contact details Step 2: Educational background and program interests Step 3: Additional information and submission GSAP animations The gsap.js component provides professional animations:\nFeatures:\nScroll-triggered animations: Elements animate on scroll Vertical scroll reveals: Fade and slide animations Horizontal scroll reveals: Staggered animations for grid layouts Timeline management: Complex animation sequences Performance optimized: Efficient animation triggers Animation types:\nFade in with vertical movement Staggered grid animations Scroll-based reveals Smooth transitions Advanced blog system The Blog.vue component provides comprehensive blog functionality:\nFeatures:\nCategory filtering: Filter posts by category Search functionality: Real-time search across blog posts Mobile filters: Dedicated mobile filter interface Pagination: Efficient content pagination Loading states: Skeleton loading screens Empty states: User-friendly empty state messages Experiences/testimonials panel The ExperiencesPanel.vue component displays student testimonials:\nFeatures:\nFilter by type: Filter testimonials (Students/Parents) Dynamic loading: Load testimonials from API Responsive design: Mobile-optimized display Carousel integration: Splide carousel for testimonial display Animated statistics The odometer.js component provides animated number counting:\nFeatures:\nScroll-triggered: Animations trigger on scroll Smooth counting: Odometer theme integration Performance optimized: Efficient scroll detection Mobile support: Optimized for all devices Search functionality The SearchResults.vue component provides comprehensive search:\nFeatures:\nMulti-content search: Search across programs, blog posts, and pages Result categorization: Organized search results Image support: Results with and without images Tag display: Category tags for results Loading states: Skeleton loading screens Custom typography The website features a custom font family, TWK Everett, with:\nMultiple weights: From Hairline to Super Italic variants: All weights include italic versions Optimized formats: WOFF, WOFF2, and OTF formats Performance: Efficient font loading and rendering Development workflow The project uses Laravel Mix for asset compilation:\n// Development npm run dev // Compile assets npm run watch // Watch for changes npm run hot // Hot module replacement // Production npm run production // Optimized production build BrowserSync integration provides:\nLive reloading during development Synchronized browser testing Proxy configuration for WordPress development Performance optimizations Code splitting: Laravel Mix extracts vendor libraries Asset versioning: Automatic cache busting Image optimization: Lazy loading and responsive images Minification: Production builds are minified and optimized Tree shaking: Unused code elimination in production Font optimization: Efficient font loading strategies Accessibility Semantic HTML structure ARIA labels for interactive elements Keyboard navigation support Focus management in forms Screen reader considerations Proper alt text for images Conclusion and final thoughts Building the ISC Chile frontend from a Figma design was an excellent opportunity to:\nMaster Vue 2: Working with Options API, Vuex state management, and Vue 2 patterns Implement GSAP animations: Creating professional scroll-triggered animations Build complex forms: Multi-step forms with validation, date pickers, and input masking Create advanced filtering: Blog filtering with search and category selection Optimize performance: Implementing efficient animations and lazy loading Ensure design fidelity: Translating Figma designs into pixel-perfect implementations (with direct Figma references in code) The project demonstrates proficiency in:\nModern JavaScript frameworks (Vue 2) Animation libraries (GSAP, ScrollTrigger) Form validation and user experience (Vee-Validate, V-Mask, V-Calendar) Build tools and asset compilation (Laravel Mix, Webpack) CSS architecture and methodologies (SCSS, BEM) Component-based development State management (Vuex) Design system implementation The integration with WordPress/Themosis backend required careful consideration of server-side rendering, API endpoints, and content management workflows, making this a full-stack frontend implementation for an educational consultancy platform.\nLive website: https://www.iscchile.cl/\nFigma prototype: https://www.figma.com/proto/BfdKGJlzx7xAnE7rpZ1vda/Dise%C3%B1o-ISC?page-id=314%3A12071\u0026type=design\u0026node-id=314-12072\u0026viewport=-1452%2C930%2C0.29\u0026t=hFYiwcionjRAZ47v-1\u0026scaling=min-zoom\n","image":"//localhost:1313/images/project/isc-chile/home.png","permalink":"//localhost:1313/projects/isc-chile-educational-consultancy-website/","tags":["Vue 2","Laravel Mix","WordPress","Themosis","SCSS","GSAP","JavaScript","Figma"],"title":"ISC Chile: Educational Consultancy Website"},{"categories":["Projects"],"contents":"Rutieri is a SaaS platform built with Strapi, React Native, Typescript and other technologies.\nOutline The idea Platform features The stack The API The frontend The mobile app Conclusion Landing Page The idea Before starting to write a single line of code, it is generally a good idea to think about the problem, it\u0026rsquo;s limitations and whether or not it has already been solved by someone else (AKA competitors).\nThe problem I was looking into had to do with the way in which public and private transportation companies manage their routes, drivers and users. This process is generally carried out on paper, e.g. not digital, hence this could be problematic in case of new drivers joining the organization or in case of restricting access to data to only specific users.\nAfter a little bit of research, I could only find one platform that provides a similiar solution but for their own company.\nPlatform features and user stories The following user stories illustrates the desired features the platform should have in order to solve the aforementioned problems.\nAs an administrator user, I want to: login in the admin panel. create an organization. create routes in the organization. invite drivers and users to the organization. manage requests to join the organization. assign routes to drivers in the organization. see in real time the drivers and users currently active in the map of the different routes. As a driver, I want to: login in the mobile app. join an organization by entering the code in the search bar. see my route on the map. become visible to passengers on the road. see the passengers waiting on the road. remove my visibility and finish my run. As a passenger, I want to: login in the mobile app. join an organization by entering the code in the search bar. see the different routes of my organization in the map. search for a destination and get the available routes that pass nearby. see the drivers currently active on the routes in real time. become visible to drivers of a route. The requirements The backend requires to handle user authentication, permissions, different data structures as content types and define relations between them. It\u0026rsquo;s also necessary to synchronise passengers and drivers and view them on a map real time in the administration panel as well as in the mobile app.\nThe administration panel is a web page that fetches data from the backend as well as from the real time data provider and it\u0026rsquo;s goal is to provide a way for administrators to manage their organization and users. We\u0026rsquo;re talking about a Single Page Application built in React.\nAs for the mobile application, there isn\u0026rsquo;t a better choice nowadays than React Native and it works just fine in this case.\nThe API Since all of the features involve authentication, permissions and roles, and because there is no need to reinvent the wheel, I chose to use Strapi to build the backend for it\u0026rsquo;s simplicity, ease of use and great developer experience, whereas for realtime data, I used Firebase.\nThe instance of Strapi and the Postgres database it requires was deployed in the cloud hosting platform https://fly.io.\nStrapi is good for managing users, content that\u0026rsquo;s typically updated and fetched via CRUD API, and relations between content types.\nThe platform needs the following content types:\nOrganizations to group routes, drivers and users Routes Two user roles: drivers and users (passengers) Below are some screenshots of the overview of these content types\nAs I said before, Strapi makes the creation of these content types and the relationships between them really straightforward.\nHowever, not everything related to the API can be provided by Strapi. Some realtime features need to be addressed with other solutions, such as geolocation data in real time for drivers and users to synchronise each other, maps and the ability to search for places. Such features were implemented using Firebase, Google Maps and Google Places.\nThe frontend The platform where users are able to login as administrators and manage their organizations and users is a single page web application built in React. Among the features of this project that I think stand out are:\nState managed by Context API Interface styled with Bootstrap React Router for pages Leaflet to display the map GeoFire library to synchronise geolocation data in real time with Firebase Use of localStorage to save user session Below are some sample screenshots of how this app looks like\nThe mobile application This one is by far the most complex part of this project.\nThe project was bootstraped with Infinitered\u0026rsquo;s Ignite, which provides a great boilerplate and surely saved me of what would have been between 1-2 months of work.\nIgnite\u0026rsquo;s boilerplate includes many features out of the box, including:\nReact Native and Typescript (of course) React Navigation MobX-State-Tree for state management Expo SDK for developer experience AsyncStorage for persistence apisauce as REST client And some other libraries and features that make React Native apps super powerful and a joy to work on.\nIt consists of three screens:\nWelcome screen Login screen Map screen In the welcome screen, users are able to go to the login screen if not logged in. Otherwise, if they\u0026rsquo;re in an organisation, it shows their role and org\u0026rsquo;s information, and if they\u0026rsquo;re not, they are able to enter the organisation code and request to join as driver or as passenger.\nWelcome screens Login screens If the user is a driver in an organisation, the welcome screen also shows the route assigned to them. By tapping on it, it takes them to the map, where they can see themselves and start the tour, becoming visible to passengers on the road but being able to see passengers on the road as well.\nDrivers can finish the tour at any time by pressing the button stop.\nIf the user is a passenger in an organisation, the welcome screen shows the different routes available in the organisation. By tapping on them, they are taken to the map where they can see themselves, the route and the drivers on the road.\nPassengers are able to navigate between the available routes and search for the location they want to go to by using the search bar at the top of the map screen, filtering out the routes that pass nearby (less than 200 meters), if there are. Google Places API and turf library work together in this search process.\nPassengers become visible to drivers on the road by pressing the button wait and if they press the button again, they stop waiting and are removed from the driver\u0026rsquo;s map.\nMap screens The start/wait and finish buttons dispatch actions that update their location in firebase, so that passengers are able to see the bus on the map as it moves in real time and viceversa.\nAs for the state management, the project consists of two models and three stores from Mobx-State-Tree library: User and Route models, user-status, route-store and root-store stores.\nUser model Located in /app/models/user/user.ts\nconst OrganizationModel = types.model({ name: types.string, code: types.string, id: types.identifierNumber, drivers: types.number, rutas: types.array(RouteModel) }) const UserModel = types .model(\u0026#34;User\u0026#34;) .props({ id: types.identifierNumber, username: types.string, email: types.string, token: types.string, role: types.union(types.literal(\u0026#34;passenger\u0026#34;), types.literal(\u0026#34;driver\u0026#34;)), ruta: types.maybeNull(RouteModel), organization: types.maybeNull(OrganizationModel), pending_request: types.maybeNull(OrganizationModel), }) Route model Located in /app/models/route/route.ts\nThis model follows the GeoJSON format for routes.\nconst RouteModel = types .model(\u0026#34;Ruta\u0026#34;) .props({ id: types.identifierNumber, name: types.string, latlong: types.maybeNull(types.model({ lat: types.number, longt: types.number })), coords: types.model({ type: FeatureTypes, features: types.array(types.model({ type: types.string, geometry: types.model({ type: types.string, coordinates: types.union(types.array(types.number), types.array(types.array(types.number))) }), properties: types.model({ name: types.string }) })) }) }) user-status store Located in /app/models/user-status/user-status.ts\nThis store is responsible for managing the state of the user. It stores the user once it\u0026rsquo;s logged in and removes it when the user logs out. It also has some views to get the user key for firebase purposes, get the role and get the route in case of a driver.\nThis store has some methods that get the user location from the device\u0026rsquo;s GPS, displays the user icon on the map and sends it to firebase.\nconst UserStatusModel = types .model(\u0026#34;UserStatus\u0026#34;) .extend(withEnvironment) .props({ user: types.maybeNull(UserModel), location: types.maybeNull( types.model({latitude: types.number, longitude: types.number}) ), visibility: types.maybeNull(types.number) }) route-store store Located in /app/models/route-store/route-store.ts\nThis store is responsible for managing the state of the available routes. It stores the routes, drivers and passengers on the different routes. It also has some view methods to filter the routes that pass nearby a destination specified by the user, get passengers waiting on a given route and get drivers active in a specific route.\nThis store initializes a GeoQuery from Geofire library and listens for events to set, update and remove drivers and passengers from the map as they move.\nconst RouteStoreModel = types .model(\u0026#34;RouteStore\u0026#34;) .props({ routes: types.array(RouteModel), passengers: types.map(types.model({ key: types.identifier, location: types.array(types.number) })), drivers: types.map(types.model({ key: types.identifier, location: types.array(types.number) })), destinationAddress: types.maybeNull(types.model({ name: types.string, coords: types.array(types.number) })) }) Conclusion and final thoughts Using a CMS as the backend can make the development a lot faster than building the API from scratch and with Strapi this is specially true. On the other hand, Strapi doesn\u0026rsquo;t really make a good fit for real time applications, therefore, Firebase is the way to go in this case.\nAs of the client side, React always works very good for pretty much any kind of application, and because React Native uses React under the hood, it is so convenient for us React developers and ir works pretty good for almost any kind of application as well.\nHowever, one thing that I didn\u0026rsquo;t mention in this post was the use of Typescript; I find this quote by Brice Wilson pretty good to point out the whole purpose and motivation to learn and use (well) this powerful language and tool ecosystem:\n\u0026ldquo;You won\u0026rsquo;t have to wait for a frustrated user to report the error. All of this means that you provide value to your users faster, and that\u0026rsquo;s really what it\u0026rsquo;s all about.\u0026rdquo;\nAll in all, I got a lot of learning by building this project, both in languages/frameworks used and production stuff such as infrastructure, cloud hosting and cloud-based APIs.\nProject landing page: https://rutieri.netlify.app\n","image":"//localhost:1313/images/project/rutieri/landing/homepage.webp","permalink":"//localhost:1313/projects/saas-platform-rutieri/","tags":["Strapi","React Native","React","Typescript","Firebase"],"title":"SaaS platform: Rutieri"},{"categories":["Tutorial"],"contents":"Enable comments in a Strapi application and display them in the frontend with React\nOutline Introduction Prerequisites What is Strapi Comment Manager? Installation Configuration Display comments on the frontend Installation of Strapi Comments Client Usage of Strapi Comments Client Plugin settings Manage comments Full source code of the frontend Conclusion Introduction A comment system comes in very handy for pretty much any kind of website. In the JAMstack ecosystem, while it\u0026rsquo;s ok to rely on third party solutions hosted on their own platform such as Disqus to enable comments, you usually want to keep your content and all the stuff related to it in the same admin dashboard.\nIn this article, I\u0026rsquo;ll show you how to enable and manage comments for your content very easily using the Comment Manager plugin, and display them in your frontend application.\nPrerequisites You should have a basic understanding of the following.\nBasic knowledge of JavaScript Basic knowledge of React (OPTIONAL) Basic understanding of Strapi - get started here. Your Strapi V4 project setup What is Strapi Comment Manager? Strapi Comment Manager is a plugin that enables comments for pretty much any kind of content. It allows your users to post comments and anyone can get the comments associated with a given slug.\nWith this plugin, admin users can view and manage very easily all the comments from the Strapi administration dashboard. Within the dashboard, you will be able to delete comments and subcomments and leave replies on comments.\nInstallation Once into the Strapi project root, you can install the plugin by running the following command:\nnpm install strapi-plugin-comment-manager Next, build the project to see the new plugin in the dashboard with the following command:\nnpm run build And that\u0026rsquo;s it! If everything runs correctly, the plugin should now be installed.\nConfiguration Now you need to enable some permissions so that the frontend can access the endpoints to post and fetch comments.\nIn your Strapi admin dashboard, head over to Settings, then over to Roles under Users \u0026amp; Permissions Plugin.\nLet\u0026rsquo;s first setup the Public API; click on Public and hit the dropdown button of Comment Manager. Now check count, find and getPageSize, then hit the Save button. Below is a screenshot of a proper configuration:\nNow let\u0026rsquo;s setup the Authenticated API. Go back to Roles and click on Authenticated. Open the dropdown for Comment Manager and mark as checked the option create on both Comment and Subcomment. Below is a screenshot of a proper configuration:\nWith this configuration, the frontend should now be able to make requests to get and post comments.\nDisplay comments on the frontend The plugin exposes an API to get and post comments if you want to have fine-grained control over the workflow of your comments system and you can check the documentation on the package page, but this plugin also comes with a purpose-built React component library that makes it super easy to get up and running without getting your hands dirty.\nThis components library is called strapi-comments-client, fully supports typescript and it handles for you all of the complexity of fetching and posting comments and subcomments for every content ID that you pass to it.\nInstallation of Strapi Comments Client You will need to have installed react ^17.0.2, react-dom ^17.0.2 and react-router-dom ^5.2.0.\nInside of your React project, run this command:\nnpm install strapi-comments-client --save Usage of Strapi Comments Client Using this library is very easy!\nThis library exports three main components:\nCommentsProvider Comments CommentForm And you can import them this way:\nimport { CommentsProvider, Comments, CommentForm } from \u0026#34;strapi-comments-client\u0026#34; All you have to do is wrap your App component into the CommentsProvider component. Then you will be able to place anywhere in your app the Comments component to render a list of comments for a given content ID and the CommentForm component to render a form to post comments.\nFor example, this could be your index.js or main.js file:\nimport React from \u0026#39;react\u0026#39; import ReactDOM from \u0026#39;react-dom\u0026#39; // The address of your strapi backend instance const STRAPI = \u0026#34;http://localhost:1337\u0026#34; ReactDOM.render( \u0026lt;React.StrictMode\u0026gt; \u0026lt;CommentsProvider apiURL={STRAPI}\u0026gt; \u0026lt;App /\u0026gt; \u0026lt;/CommentsProvider\u0026gt; \u0026lt;/React.StrictMode\u0026gt;, document.getElementById(\u0026#39;root\u0026#39;) ) Where apiURL is the URL of your running Strapi application, and this property is required.\nThis way, the comments provider will do all the magic of fetching and posting comments for you!\nThis library also exports an utility React.Context to update some of the parameters for fetching and posting comments:\nimport { CommentsConfigContext } from \u0026#34;strapi-comments-client\u0026#34; This CommentsConfigContext exposes two setter functions: setUser and setContentID\nWith setContentID you can load the comments for a given content and post comments to it. It receives a single parameter of type string and must be URLized, i.e. no spaces.\nWith setUser you can set the credentials of a given user to authorize the posting of comments. It receives a single parameter of type IUser, with the following Typescript interface:\ninterface IUser { username: string, email: string, id: string, token: string // This is a JWT } It\u0026rsquo;s a little confusing but we\u0026rsquo;ll see how to use it in a component:\nconst App = () =\u0026gt; { const { setUser, setContentID } = useContext(CommentsConfigContext) // The following data should come from Strapi Users and Permissions Plugin // for authenticated requests const user = { username: \u0026#34;John Doe\u0026#34;, email: \u0026#34;jhohndoe@gmail.com\u0026#34;, id: 5, token: \u0026#34;this_should_be_a_JWT\u0026#34; } if (user) { setUser(user) } setContentID(\u0026#34;sample-content-1\u0026#34;) // Load comments for this content return ( \u0026lt;\u0026gt; { !user \u0026amp;\u0026amp; \u0026lt;Login /\u0026gt; } \u0026lt;CommentForm /\u0026gt; \u0026lt;Comments /\u0026gt; \u0026lt;/\u0026gt; ) } And that\u0026rsquo;s it!\nAfter setting the content ID through setContentID, CommentsProvider will start loading the comments for the given content ID and the CommentForm will render an input to post comments related to the given content ID if there is a user. Otherwise, it will display the message Login to post a comment.\nHere\u0026rsquo;s how the interface looks like so far:\nThere\u0026rsquo;s also a button to Leave a reply, which will open a form to post a subcomment associated with the parent comment.\nThis library exports one more component: ErrorBox\nimport { ErrorBox } from \u0026#34;strapi-comments-client\u0026#34; .It\u0026rsquo;s useful if you\u0026rsquo;d like to display error messages when things go wrong fetching or posting comments.\nYou can place this component wherever you want, for example in between the CommentForm and the Comments components.\nIf you\u0026rsquo;re wondering how this error box looks like, here you have a sample:\nGeneral settings You can customize the page size, i.e. specify how many comments are returned at once.\nIn the Strapi admin panel, head over to Settings, then select Pagination under Comment Manager Plugin.\nHere you\u0026rsquo;ll find an input to set the page size, which defaults to 10.\nManage comments Once you\u0026rsquo;ve got the plugin up an running, as users start to post comments, you can manage and reply to them as admin from the Comment Manager section of the left sidebar in the Strapi admin dashboard.\nHere you can see two tabs: one for the latest comments and one for comments grouped by content ID.\nIn both of them you can delete comments and subcomments as well as leave replies.\nExample project You can find a full working example of a React App using the Strapi Comments Client Library in this repo\nConclusion With this plugin you can enable and manage comments for any content with little effort and even use a component library to display the comments in your frontend application made with React.\nAnd that\u0026rsquo;s it! The features are pretty basic at the moment but if there\u0026rsquo;s interest, I\u0026rsquo;m willing to work on more features as well as improve the UI/UX.\n","image":"//localhost:1313/images/post/strapilogo.jpg","permalink":"//localhost:1313/blogs/how-to-enable-and-manage-comments-in-your-strapi-application/","tags":["Strapi","Strapi tutorials"],"title":"How To Enable And Manage Comments In Your Strapi Application."},{"categories":["Documentation"],"contents":"Comment Manager is a Strapi plugin to allow your users to post comments.\nWith this plugin you can enable and manage comments for your content very easily!\nRequirements You should have installed an instance of Strapi v4.x.x\nInstallation Run the following command in your project root:\nnpm install strapi-plugin-comment-manager Configurarion For your frontend to have access to the API, enable the following permissions for Comment Manager from Users \u0026amp; Permissions Plugin on your project settings:\nFor public, enable: count, find and getPageSize.\nFor authenticated, enable create on both Comment and Subcomment.\nDisplay comments on the frontend Comments can be displayed in the frontend in two ways:\nUsing the React components library strapi-comments-client (recommended) Build your custom frontend using the API API There are some Typescript interfaces that will help to get an idea of the data structures.\nComments: interface IComment { id: string, from_admin: boolean, createdAt: string, content: string, author: IAuthor | null, subcomments?: ISubcomment[] } Subcomments: interface ISubcomment { id: string, from_admin: boolean, createdAt: string, content: string, author: IAuthor | null, } Authors: IAuthor { username: string, email: string, id: string } The following endpoints are exposed to fetch and post comments and subcomments:\nGet comments for a content ID Method: GET\nPath: /api/comment-manager/comments/:slug\nOptional query parameters: start, ignoreCount\nReturns:\n{ commentsCount?: Number, comments: IComment[] } The parameter start indicates how many comments to skip. This is for pagination purposes.\nThe parameter ignoreCount indicates whether or not to return the total number of comments associated with the given slug.\nGet the number of comments associated with a given content ID Method: GET\nPath: /api/comment-manager/comments/:slug/count\nReturns:\n{ count: Number } Post a comment Method: POST\nPath: /api/comment-manager/comments/:slug\nAuthentication: Bearer token\nPayload:\n{ content: string } Returns:\n{ id: Number } Post a subcomment Method: POST\nPath: /api/comment-manager/subcomments/:parent-id\nAuthentication: Bearer token\nPayload:\n{ content: string } Returns:\n{ id: Number } Get the page size Method: GET\nPath: /api/comment-manager/page-size\nReturns:\n{ pageSize: Number } General settings The plugin allows to set how many comments are returned per page by going to the Pagination section under Comment Manager Plugin on the Settings section.\nThe default page size is 10.\nManagement of comments Admin users are able to delete comments and subcomments as well as leave replies as admins from within the plugin page of the Strapi admin dashboard.\nThe plugin interface has two tabs: one for the latest comments and one for comments by content ID.\nRoadmap and future plans The plugin is pretty basic but it can be improved with more features and a better UI/UX. Collaborations and suggestions are very welcome.\n","image":"//localhost:1313/images/post/strapilogo.jpg","permalink":"//localhost:1313/blogs/strapi-plugin-comment-manager/","tags":["Strapi","Strapi plugins"],"title":"Strapi Plugin Comment Manager"},{"categories":["Projects"],"contents":"In this post I’m going to share my experience on building a SaaS using the headless CMS Strapi as the Backend, React Native and other technologies.\nOutline Introduction What is SaaS? The problem What is Strapi? Developing features in Strapi The frontend: How to get content Conclusion Landing Page Introduction Very often, developers, product and project managers, testers and pretty much the entire team share their ideas to decide what language and which framework they\u0026rsquo;ll use to build their next project. Some considerations must be taken into account, from which in my opinion there are three that are the most important:\nDeveloper experience and ease of use Does the language and framework chosen provide a good developer experience? Is the langauge the same for the backend and frontend?\nDeadlines Is there a deadline to finish the project? if so, there is a good chance to finish the project on time if the team chooses the language they have more experience in.\nMaintainability As there will be usually more than one person working on the same part at the same time, if everything is kept organised, the whole development process will be frictionless.\nWith that in mind, developers and project managers will have a better insight on which language/framework to use.\nOther aspects should also be considered such as what the data structure will look like.\nIn my case, as it is usual, the backend of my project needs a database for users and their roles among other entities and their relations and a dashboard to allow admins to manage the data, and I was lucky to find out Strapi, as it includes a lot of these features out of the box with one single line of command to get started.\nWhat is SaaS? SaaS stands for Software-as-a-Service and it just means that a software is provided as a service in the cloud and it gives a solution to a specific problem, for which the users are willing to pay either monthly or annual subscription.\nThe problem Before starting to write a single line of code, it is generally a good idea to think about the problem, it\u0026rsquo;s limitations and whether or not it has already been solved by someone else (AKA competitors).\nThe problem I was looking into had to do with the way in which public and private transportation companies manage their routes, drivers and users. After a little bit of research, I could only find one platform that provides a similiar solution but for their own company.\nSo the platform I built needed the following content types:\nOrganizations to group routes, drivers and users Routes Two user roles: drivers and users (passengers) As I said before, Strapi makes the creation of these content types and the relationships between them really easy, but let\u0026rsquo;s first see what is Strapi and how it turns the API development into a satisfactory and fun experience.\nWhat is Strapi? Strapi is an open source headless CMS that allows developers to build complete RESTful APIs in just a couple of days instead of months. It includes a lot of useful features as plugins out of the box. Users and Roles management, Media library and an interface to create, view, edit and delete content are just some of them.\nRegarding the API, how does it makes the development faster?\nFirst of all, it enforces a specific folder structure, which helps to keep everything well organised and clean.\nSecondly, all database schemas are generated automatically and queries are made in JSON format, which really saves a lot of time.\nLastly, we can add more features to our Strapi application very easily via plugins from the marketplace.\nIt\u0026rsquo;s also worth noting that Strapi is a self-hosted CMS, which means that we can host it in whatever cloud platform we want, as well as test it locally in our computers before deploying it to the cloud.\nDeveloping features in Strapi Creating and configuring endpoints in Strapi is as straightforward as declaring a JSON in a single file:\nCreating controllers is straightforward as well:\nEvery controller gets all the data related to the request in the ctx parameter and it\u0026rsquo;s also used to send the response. This keeps everything in one place and really helps to improve the readability.\nOnce the API endpoints are defined, the next step is to enable the permissions for the specific user roles to have access to these endpoints:\nThe frontend: how to get content Since Strapi is a headless CMS, it\u0026rsquo;ll only provide content through the API. That means that the content can be consumed from anywhere. In our case, this content will be used in two applications: one for the organization owners and one for the users and drivers.\nThe application for the organization owners is a dashboard where administrators can create organizations, routes, accept drivers and users in the organization and assign routes to drivers. This is just a React Application:\nThe application for drivers and users is a mobile application built in React Native. Firebase was used to synchronise geolocation data in real time between drivers and users and display this information in a Map from Google Maps:\nConclusion Using a CMS as the backend can make the development a lot faster than building the API from scratch and with Strapi this is specially true. Furthermore, this becomes more important when building a brand-new product, as it\u0026rsquo;s usually recommended to launch as soon as possible to gather feedback from the users and validate the idea.\nProject landing page: https://rutieri.netlify.app\n","image":"//localhost:1313/images/post/03.webp","permalink":"//localhost:1313/blogs/how-i-built-a-saas-on-top-of-strapi-and-why-you-should-too/","tags":["Strapi","React Native","Typescript"],"title":"How I Built A SaaS On Top Of Strapi, And Why You Should Too"},{"categories":["Tutorial"],"contents":"Enable User Reviews in a Strapi application and display them in the frontend with React\nOutline Introduction Prerequisites What is Strapi Ratings? Installation Configuration Display user reviews on the frontend Plugin settings Manage user reviews Full source code of the frontend Conclusion Introduction Ratings systems have become a crucial part of any website with ecommerce capabilites, as they allow the users to post reviews on the items they purchase and publish their opinion to the public. A couple of reviews can make the difference between pressing the “Buy” button and moving on to the next website in the Google search results.\nIn this article, I\u0026rsquo;ll show you how to enable and manage user reviews for your content very easily using the Ratings plugin, and display them in your frontend application.\nPrerequisites First of all, you need to have a basic understanding of the following.\nBasic knowledge of JavaScript Basic knowledge of React (OPTIONAL) Basic understanding of Strapi - get started here. Your Strapi V4 project setup What is Strapi Ratings? Strapi Ratings is a plugin that gives your Strapi application the ability to manage ratings for pretty much any kind of content. It allows your users to post reviews and anyone can get the reviews associated with a given slug.\nWith this plugin, admin users can view and manage very easily all the reviews from the Strapi administration dashboard. Within the dashboard, you will be able to see reviews related to content slugs as well as delete reviews.\nInstallation Once into the Strapi project root, you can install the plugin by running the following command:\nnpm install strapi-plugin-ratings Next, build the project to see the new plugin in the dashboard with the following command:\nnpm run build And that\u0026rsquo;s it! If everything runs correctly, the plugin should now be installed.\nConfiguration Now you need to enable some permissions so that the frontend can access the endpoints to post and fetch reviews.\nIn your Strapi admin dashboard, head over to Settings, then over to Roles under Users \u0026amp; Permissions Plugin.\nLet\u0026rsquo;s first setup the Public API; click on Public and hit the dropdown button of Ratings. Now check count, find, getPageSize and getStats, then hit the Save button. Below is a screenshot of a proper configuration:\nNow let\u0026rsquo;s setup the Authenticated API. Go back to Roles and click on Authenticated. Open the dropdown for Ratings and mark as checked the options create, find and getUserReview. Below is a screenshot of a proper configuration:\nWith this configuration, the frontend should now be able to make requests to get and post user reviews.\nDisplay use reviews on the frontend The plugin exposes an API to get and post reviews if you want to have fine-grained control over the workflow of your ratings system and you can check the documentation on the package page, but this plugin also comes with a purpose-built React component library that makes it super easy to get up and running without getting your hands dirty.\nThis components library is called strapi-ratings-client, fully supports typescript and it takes care of all the complexity of fetching and posting user reviews for every content ID that you pass to it.\nInstallation of Strapi Ratings Client You will need to have installed react ^17.0.2, react-dom ^17.0.2, bootstrap ^5.1.3 and @popperjs/core^2.11.2\nInside of your React project, run this command:\nnpm install strapi-ratings-client --save Usage of Strapi Ratings Client Using this library is very easy!\nThis library exports three main components:\nReviewsProvider Reviews ReviewForm And you can import them this way:\nimport { ReviewsProvider, Reviews, ReviewForm } from \u0026#34;strapi-ratings-client\u0026#34; All you have to do is wrap your App component into the ReviewsProvider component. Then you will be able to place anywhere in your app the Reviews component to render a list of user reviews for a given content ID and the ReviewForm component to render a form to allow your users to post reviews.\nFor example, this could be your index.js or main.js file:\nimport React from \u0026#39;react\u0026#39; import ReactDOM from \u0026#39;react-dom\u0026#39; // The address of your strapi backend instance const STRAPI = \u0026#34;http://localhost:1337\u0026#34; ReactDOM.render( \u0026lt;React.StrictMode\u0026gt; \u0026lt;ReviewsProvider apiURL={STRAPI}\u0026gt; \u0026lt;App /\u0026gt; \u0026lt;/ReviewsProvider\u0026gt; \u0026lt;/React.StrictMode\u0026gt;, document.getElementById(\u0026#39;root\u0026#39;) ) Where apiURL is the URL of your running Strapi application, and this property is required.\nThis way, the ratings provider will do all the magic of fetching and posting comments for you!\nThis library also exports an utility React.Context to update some of the parameters for fetching and posting reviews:\nimport { ReviewsConfigContext } from \u0026#34;strapi-ratings-client\u0026#34; This ReviewsConfigContext exposes three setter functions: setUser, setContentID and setCanPostReview.\nWith setContentID you can load the ratings for a given content and post reviews to it. It receives a single parameter of type string and must be URLized, i.e. no spaces.\nWith setUser you can set the credentials of a given user to authorize the posting of reviews. It receives a single parameter of type IUser, with the following Typescript interface:\ninterface IUser { username: string, email: string, id: string, token: string // This is a JWT } With setCanPostReview, you can enable the user to post a review on the given content. This is useful for when you only allow a user to post a review after they purchase the product.\nIt\u0026rsquo;s a little confusing but we\u0026rsquo;ll see how to use it in a component:\nconst App = () =\u0026gt; { const { setUser, setContentID, setCanPostReview } = useContext(ReviewsConfigContext) // The following data should come from Strapi Users and Permissions Plugin // for authenticated requests. const user = { username: \u0026#34;John Doe\u0026#34;, email: \u0026#34;jhohndoe@gmail.com\u0026#34;, id: 5, token: \u0026#34;this_should_be_a_JWT\u0026#34; } if (user) { setUser(user) } setContentID(\u0026#34;sample-content-1\u0026#34;) // Load reviews for this content setCanPostReview(true) // Allow this user to post a review return ( \u0026lt;\u0026gt; { !user \u0026amp;\u0026amp; \u0026lt;Login /\u0026gt; } \u0026lt;ReviewForm /\u0026gt; \u0026lt;Reviews /\u0026gt; \u0026lt;/\u0026gt; ) } And that\u0026rsquo;s it!\nAfter setting the content ID through setContentID, ReviewsProvider will start loading the reviews for the given content ID and the ReviewForm will render an input to post a user review related to the given content ID if there is a user and he’s allowed to post a review. Otherwise, it will display the message Login to post a review or nothing at all if the user is not allowed to post a review.\nHere\u0026rsquo;s how the interface looks like so far:\nThis library exports one more component: ErrorBox\nimport { ErrorBox } from \u0026#34;strapi-ratings-client\u0026#34; .It\u0026rsquo;s useful for when you\u0026rsquo;d like to display error messages when things go wrong fetching or posting reviews.\nYou can place this component wherever you want, for example in between the ReviewForm and the Reviews components.\nIf you\u0026rsquo;re wondering how this error box looks like, here‘s a screenshot:\nGeneral settings You can customize the page size, i.e. specify how many user reviews are showed at once.\nIn the Strapi admin panel, head over to Settings, then select Pagination under Ratings Plugin.\nHere you\u0026rsquo;ll find an input to set the page size, which defaults to 10.\nManage reviews Once you\u0026rsquo;ve got the plugin up an running, as users start to post reviews, you can view them from within the Ratings section of the left sidebar in the Strapi admin dashboard.\nHere you can see two tabs: one for the latest reviews and one for reviews grouped by content ID.\nIn both of them you can delete unwanted reviews.\nExample project You can find a full working example of a React App using the Strapi Ratings Client Library in this repo: https://github.com/luisguve/strapi-ratings-client-example\nConclusion With this plugin you can enable and manage user reviews for any content with little effort and even use a library of components styled with Bootstrap to display the user reviews in your frontend.\nAnd that\u0026rsquo;s it! The features are pretty basic at the moment but if there\u0026rsquo;s interest, I\u0026rsquo;m willing to work on more features as well as improve the UI/UX.\n","image":"//localhost:1313/images/post/tutorial-ratings.webp","permalink":"//localhost:1313/blogs/how-to-enable-and-manage-user-reviews-in-your-strapi-application/","tags":["Strapi","Strapi tutorials"],"title":"How To Enable And Manage User Reviews In Your Strapi Application"},{"categories":["Documentation"],"contents":"Ratings is a Strapi plugin that allows your users to post reviews.\nEnable and manage user reviews for your content very easily!\nRequirements You should have installed an instance of Strapi v4.x.x\nInstallation Run the following command in your project root:\nnpm install strapi-plugin-ratings Then, rebuild the admin dashboard using the following command\nnpm run build Configurarion For your frontend to have access to the API, enable the following permissions for Ratings from Users \u0026amp; Permissions Plugin on your project settings:\nFor public, enable: count, find, getPageSize and getStats.\nFor authenticated, enable create, find and getUserReview.\nDisplay user reviews on the frontend Reviews can be displayed in the frontend in two ways:\nUsing the React components library strapi-ratings-client (recommended) Build your custom frontend using the API endpoints, described as follows: API There are some Typescript interfaces that will help to get an idea of the data structures.\nReviews: interface IReview { id: number, createdAt: string, comment: string | null, author: IAuthor | null, score: number, } Authors: interface IAuthor { username: string, email: string, id: number } Content Stats interface IStats { averageScore: number; reviewsCount: number | null; } The following endpoints are exposed to fetch and post reviews:\nGet reviews for a content ID Method: GET\nPath: /api/ratings/reviews/:slug\nOptional query parameters: start, ignoreCount\nReturns:\n{ reviewsCount: number, averageScore: number, userReview: IReview | null, reviews: IReview[] } The parameter start indicates how many reviews to skip. This is for pagination purposes.\nThe parameter ignoreCount indicates whether or not to return the total number of reviews associated with the given slug.\nGet review stats for a content ID Method: GET\nPath: /api/ratings/reviews/:slug/stats\nReturns:\n{ averageScore: number, reviewsCount: number | null } Get the number of reviews associated with a given content ID Method: GET\nPath: /api/ratings/reviews/:slug/count\nReturns:\n{ count: number } Post a review Method: POST\nPath: /api/ratings/reviews/:slug\nAuthentication: Bearer token\nPayload:\n{ content: string } Returns:\n{ id: number } By default, every authenticated user can post reviews on any content.\nIn order to customize this behavior, e.g. allowing or disallowing a user from posting reviews, you must extend the service userCanPostReview from whithin register function in ./src/index.js. For example:\nstrapi.service(\u0026#34;plugin::ratings.review\u0026#34;).userCanPostReview = async (user, slug) =\u0026gt; { /* Here you will check whether or not the user is allowed to post a review on this content ID and return either true or false. */ return true } Notice that userCanPostReview will receive two parameters: the user from Users \u0026amp; Permissions Plugin, containing it\u0026rsquo;s id, username, confirmed, etc., and the slug, which is a string and refers to the content ID which the review is being posted on.\nIn case this function returns false, the response of the endpoint will be 403 (forbidden) with the text User cannot post a review on this content.\nGet the page size Method: GET\nPath: /api/ratings/page-size\nReturns:\n{ pageSize: number } General settings The plugin allows to set how many reviews are returned per page by going to the Pagination section under Ratings Plugin of the Settings section.\nThe default page size is 10.\nManagement of reviews Admin users are able to delete reviews from within the plugin page of the Strapi admin dashboard.\nThe plugin interface has two tabs: one for the latest reviews and one for reviews by content ID.\nRoadmap and future plans The plugin is pretty basic but it can be improved with more features and a better UI/UX. Collaborations and suggestions are very welcome.\n","image":"//localhost:1313/images/post/ratings.webp","permalink":"//localhost:1313/blogs/strapi-plugin-ratings/","tags":["Strapi","Strapi plugins"],"title":"Strapi Plugin Ratings"},{"categories":["Projects"],"contents":"ManyLMS is an e-learning platform built on top of Strapi, React Router 7, Typescript and other technologies.\nOutline The idea Platform features The stack The API The frontend Conclusion Landing Page The idea This project doesn\u0026rsquo;t necessarily bring a huge amount of innovation on the e-learning platforms that already exists, but it\u0026rsquo;s just another way of doing this type of application.\nThe main idea is to apply a JAMstack approach in this application, where the platform is a static website, and the backend is just an API that serves static content only once to build the website and just adds the dynamism that\u0026rsquo;s necessary to allow users to authenticate, create orders, confirm payments and take courses.\nIf we compare this approach to a WordPress website, we are taking out most of the overhead that implies rendering the pages everytime a user visits them. Despite that there are plugins for caching that may improve the performance, it\u0026rsquo;s still never going to be faster and more efficient than just static content served by a CDN. That\u0026rsquo;s why React Router 7 and Headless CMSs are so popular right now.\nPlatform features and user stories The following user stories illustrates the desired features the platform should have.\nAs an administrator, I want to: login in the admin panel. create categories. create courses. upload lectures. organise courses into categories. assign lectures to courses. As a student, I want to: login in the platform. view the available courses. add courses to the shopping cart. review the shopping cart. create an order. pay with credit card or paypal. view the courses i\u0026rsquo;ve purchased in my learning page. go to the course page from my learning page and watch the videos. mark lectures as seen. come back later and resume where I left. The requirements The backend requires to handle user authentication, permissions, different data structures as content types and define relationships between them. It also requires to allow uploading videos to some third party platform that supports streaming on demand.\nThe frontend is a web platform where users can register and login, view and buy courses, leave comments and reviews and take courses.\nThe API Since all of the features involve authentication, permissions and roles, and because there is no need to reinvent the wheel, I chose to use Strapi to build the backend for it\u0026rsquo;s simplicity, ease of use and great developer experience, whereas for streaming videos on demand, I chose to use Mux.com.\nThe instance of Strapi and the Postgres database it requires was deployed in the cloud hosting platform https://fly.io.\nStrapi is good for managing users, content that\u0026rsquo;s typically updated and fetched via CRUD API, and setting up relations between content types.\nThe platform needs the following content types:\nCategory to group courses Course Lecture Module to group lectures Order Student: has many courses Student-Course: stores a student\u0026rsquo;s current lecture of a course Video Strapi makes the creation of these content types and setting up relationships between them really straightforward.\nBelow are some screenshots of these content types and the relationships between them:\nThe frontend The platform where users are able to login, view, buy and view courses is a web application built with React Router 7. Among the features of this application are:\nState managed by Context API Interface styled with Bootstrap Play streaming videos with @mux/mux-player-react library Use of localStorage to save user session Below are some sample screenshots of how this app looks like\nConclusion and final thoughts While building this project, I learned:\nHow streaming on demand works and how to use a streaming provider How to statically build websites with React Router 7 and Strapi How to setup dynamic pages in React Router 7 How to process payments with Stripe and Paypal How to build custom plugins in Strapi How to publish packages to NPM Project source codes: https://github.com/luisguve/maestro-backend\nhttps://github.com/luisguve/new-lms-remix\n","image":"//localhost:1313/images/project/manylms/frontend/course_overview.png","permalink":"//localhost:1313/projects/e-learning-platform-maestro-lms/","tags":["Strapi","React","React Router 7","Typescript","Mux"],"title":"ManyLMS: E-Learning platform"},{"categories":["Projects"],"contents":"ETMday (Emprende tu Mente) is a large-scale entrepreneurship event website built on top of WordPress with the Themosis framework, featuring an interactive SVG map, real-time countdown timers, advanced search functionality, and comprehensive content management using Vue 3, Laravel Mix, and modern frontend technologies.\nOutline The project Key features The stack Frontend architecture Interactive components Conclusion Live website The project ETMday is Chile\u0026rsquo;s premier entrepreneurship event, bringing together thousands of entrepreneurs, startups, corporates, and strategic partners. The website serves as the central hub for event information, featuring speakers, activities, stands, program schedules, and an interactive event map.\nThe frontend development required implementing complex interactive features including an SVG-based interactive map with tooltips, real-time countdown timers, advanced filtering and search systems, and dynamic content displays that handle thousands of attendees and hundreds of activities.\nKey features The website includes several sophisticated features:\nInteractive SVG Map: Custom-built interactive map with clickable zones, tooltips, and dynamic content display Real-time Countdown: Event countdown timer with automatic updates and mobile optimization Advanced Search: Multi-category search across activities, speakers, stands, and content Dynamic Filtering: Complex filtering system with tabs, favorites, and downloadable resources Animated Statistics: Odometer animations for displaying event metrics Content Management: Comprehensive card components for activities, speakers, stands, and blog posts Form Handling: Multi-step forms with validation using Vee-Validate Lightbox Galleries: Image galleries with LightGallery integration Responsive Design: Fully responsive design optimized for all devices The stack The frontend stack consists of:\nVue 3.2.4: Modern reactive framework for building interactive components Laravel Mix 6.0: Asset compilation and bundling SCSS: Advanced styling with organized architecture Vee-Validate 4.15.0: Form validation with Yup schemas Axios 1.6.8: HTTP client for API requests Splide.js 4.1.4: Modern carousel and slider components LightGallery 2.8.3: Lightbox gallery functionality Odometer 0.4.8: Animated number counting Headroom.js: Header behavior on scroll jQuery 3.7.1: DOM manipulation and legacy support SweetAlert2: Modern alert dialogs GLightbox 3.3.1: Alternative lightbox solution Frontend architecture Vue components The application features a comprehensive set of Vue 3 components:\nCard Components:\ncards/activities.vue: Activity cards with favorites functionality cards/speakers.vue: Speaker cards with modal details cards/stands.vue: Stand/exhibitor cards cards/blog.vue: Blog post cards cards/shortcut.vue: Quick access shortcut cards Functional Components:\nSectionCards.vue: Main section component with tabs, filtering, and card display Search.vue: Advanced search component with multi-category results Form.vue: Dynamic form component with validation FormCalendar.vue: Calendar form component CustomFilter.vue: Reusable filter component CustomSelect.vue: Custom select dropdown Pagination.vue: Pagination component JavaScript components The application includes 17 specialized JavaScript components:\nInteractive Features:\ninteractiveMap.js: SVG map interaction with tooltips, zones, and dynamic content countdown.js: Real-time countdown timer with automatic updates odometer.js: Animated number counting with scroll triggers map.js: Map zone interactions and modal displays UI Components:\nheader.js: Header functionality and navigation headroom.js: Header hide/show on scroll accordion.js: Accordion interactions tabs.js: Tab functionality cards.js: Card interactions and modals siteModals.js: Modal management system UI.js: General UI utilities Media Components:\nvideo.js: Video player setup lightgallery.js: Lightbox gallery initialization splide.js: Carousel initialization slick.js: Legacy carousel support Utilities:\nscrollTrigger.js: Scroll-based animations imgToSvg.js: SVG image conversion utility SCSS architecture The styling follows a well-organized SCSS architecture:\nscss/ ├── abstracts/ # Variables, mixins, functions │ ├── _functions.scss │ ├── _mixins.scss │ ├── _variables.scss │ ├── _mq.scss # Media query mixins │ └── _keyframes.scss ├── base/ # Base styles and typography │ ├── _typography.scss │ ├── _container.scss │ └── _reset.scss └── components/ # Component-specific styles └── [52 component files] Key SCSS features:\nBEM methodology: Consistent naming convention Media query mixins: Using sass-mq for responsive design Modular architecture: Each component has its own SCSS file Component organization: 52 component-specific SCSS files Interactive components Interactive SVG Map The interactiveMap.js component implements a sophisticated SVG-based interactive map:\nFeatures:\nSVG Tooltips: Dynamically generated tooltips with text wrapping Zone Interactions: Clickable zones with modal displays Point Markers: Interactive points with icons and labels Dynamic Content: Content loaded based on zone/point selection Responsive Design: Optimized for mobile and desktop Technical Implementation:\nSVG namespace manipulation for tooltip creation Text wrapping algorithm for tooltip content Path generation for tooltip shapes with rounded corners Event delegation for zone and point interactions Smooth animations and transitions Real-time Countdown The countdown.js component provides a real-time countdown timer:\nFeatures:\nAutomatic Updates: Updates every second Multi-unit Display: Days, hours, minutes, and seconds Pluralization: Proper Spanish pluralization (Día/Días, Hora/Horas) Mobile Optimization: Simplified display on mobile devices End State Handling: Automatic transition when countdown ends Advanced Search System The Search.vue component implements a comprehensive search system:\nFeatures:\nMulti-category Search: Searches across activities, speakers, stands, and other content Category Tabs: Quick navigation between result categories Result Counts: Dynamic result counts per category Scroll Navigation: Smooth scrolling to category sections Carousel Display: Splide carousels for result display Loading States: Loading indicators during search Empty States: User-friendly empty state messages Dynamic Filtering System The SectionCards.vue component provides advanced filtering:\nFeatures:\nTab Navigation: Multiple filter tabs Favorites System: Save and filter favorite items Search Integration: Inline search within filters Reset Functionality: Clear all filters with one click Downloadable Resources: Download buttons for resources URL Synchronization: Filter state in URL parameters Responsive Design: Mobile accordion interface Animated Statistics The odometer.js component provides animated number counting:\nFeatures:\nScroll-triggered: Animations trigger on scroll Prefix/Suffix Support: Handles formatted numbers (e.g., \u0026ldquo;56,000+\u0026rdquo;) Mobile Optimization: Static display on mobile Smooth Animations: Odometer theme integration Development workflow The project uses Laravel Mix for asset compilation:\n// Development npm run dev // Compile assets npm run watch // Watch for changes npm run hot // Hot module replacement // Production npm run production // Optimized production build BrowserSync integration provides:\nLive reloading during development Synchronized browser testing Proxy configuration for WordPress development Performance optimizations Code splitting: Laravel Mix extracts vendor libraries Asset versioning: Automatic cache busting Image optimization: Lazy loading and responsive images Minification: Production builds are minified and optimized Tree shaking: Unused code elimination in production SVG optimization: Efficient SVG manipulation and rendering Accessibility Semantic HTML structure ARIA labels for interactive elements Keyboard navigation support Focus management in forms and modals Screen reader considerations Proper alt text for images Conclusion and final thoughts Building the ETMday frontend was an excellent opportunity to:\nMaster SVG interactions: Creating complex interactive SVG maps with dynamic tooltips and zones Implement real-time features: Building countdown timers and live updates Build advanced search: Multi-category search with filtering and categorization Handle complex state: Managing filters, favorites, and dynamic content Optimize performance: Implementing efficient animations and lazy loading Ensure scalability: Building components that handle large datasets (thousands of attendees, hundreds of activities) The project demonstrates proficiency in:\nModern JavaScript frameworks (Vue 3) SVG manipulation and interaction Real-time UI updates Advanced filtering and search systems Build tools and asset compilation (Laravel Mix, Webpack) CSS architecture and methodologies (SCSS, BEM) Component-based development Event-driven architecture The integration with WordPress/Themosis backend required careful consideration of server-side rendering, API endpoints, and content management workflows, making this a full-stack frontend implementation for a large-scale event.\nLive website: https://etmday.org/\nFigma Prototype: https://www.figma.com/proto/mt9fJ8P03M5gf0nQwcU99q/EtM-Day-2025---Dise%C3%B1o?node-id=1-2743\u0026m=dev\u0026scaling=scale-down\u0026content-scaling=fixed\u0026page-id=0%3A1\u0026starting-point-node-id=1%3A2743\n","image":"//localhost:1313/images/project/etm/home.png","permalink":"//localhost:1313/projects/etmday-entrepreneurship-event-website/","tags":["Vue 3","Laravel Mix","WordPress","Themosis","SCSS","JavaScript","Interactive Map","SVG"],"title":"ETMday: Entrepreneurship Event Website"},{"categories":["Projects"],"contents":"Chile Nativo is a travel tour website for Patagonia experiences, built on top of WordPress with the Themosis framework, featuring a modern frontend implementation based on a Figma design using Vue 3, Laravel Mix, and a comprehensive SCSS architecture.\nOutline The project Design implementation The stack Frontend architecture Key features Conclusion Live website The project Chile Nativo is a travel company specializing in Patagonia tours, offering experiences in destinations like Torres del Paine, Tierra del Fuego, and Isla Navarino. The website serves as the primary platform for showcasing tours, managing bookings, and providing information about their travel experiences.\nThe frontend development was based on a comprehensive Figma design, requiring pixel-perfect implementation of complex UI components, interactive forms, filtering systems, and responsive layouts that work seamlessly across all devices.\nDesign implementation The entire frontend was built from a detailed Figma design, ensuring:\nPixel-perfect accuracy: Matching the design specifications precisely Responsive design: Implementing breakpoints and mobile-first approach Component consistency: Maintaining design system patterns throughout Interactive elements: Translating static designs into dynamic, interactive components Animation and transitions: Implementing smooth user experience enhancements The stack The frontend stack consists of:\nVue 3.2.4: Modern reactive framework for building interactive components Laravel Mix 6.0: Asset compilation and bundling SCSS: Advanced styling with a well-organized architecture Pinia 2.3.1: State management for Vue applications Vee-Validate 4.15.0: Form validation with Yup schemas Axios 1.6.8: HTTP client for API requests Splide.js 4.1.4: Modern carousel and slider components Headroom.js: Header behavior on scroll Plyr 3.7.8: Video player implementation SweetAlert2: Modern alert dialogs jQuery 3.7.1: Legacy support and DOM manipulation utilities Frontend architecture Vue components The application features a comprehensive set of Vue 3 components organized by functionality:\nFiltering and Search Components:\nToursFilter.vue: Advanced tour filtering with multiple criteria TourDatesFilter.vue: Date-based filtering for tour availability ToursFilterDropdown.vue \u0026amp; ToursFilterDropdownMobile.vue: Responsive filter dropdowns TestimonialsFilter.vue: Filtering system for customer testimonials NewsFilter.vue: Blog and news filtering SearchResults.vue: Search results display with pagination Form Components:\nPersonalizedTripForm.vue: Multi-step form for custom trip requests with validation ContactFormSimple.vue: Contact form with reCAPTCHA integration FormHelp.vue: Help center form FormGiftCard.vue: Gift card purchase form FormCareers.vue: Job application form NewsletterForm.vue: Newsletter subscription Card Components:\nTour.vue \u0026amp; TourLoading.vue: Tour card display with loading states TourDate.vue \u0026amp; TourDateLoading.vue: Tour date selection cards Testimonial.vue \u0026amp; TestimonialLoading.vue: Customer testimonial cards Blog.vue \u0026amp; BlogLoading.vue: Blog post cards Team.vue \u0026amp; TeamLoading.vue: Team member cards ResourceCard.vue \u0026amp; ResourceLoading.vue: Resource display cards Utility Components:\nPagination.vue: Reusable pagination component Select.vue: Custom select dropdown with search Loader.vue \u0026amp; LoaderFullScreen.vue: Loading indicators EmptyState.vue: Empty state displays ContentResources.vue: Resource content management TeamTabsFilter.vue: Tabbed team member filtering SCSS architecture The styling follows a well-organized SCSS architecture:\nscss/ ├── abstracts/ # Variables, mixins, functions │ ├── _functions.scss │ ├── _mixins.scss │ ├── _variables.scss │ ├── _mq.scss # Media query mixins │ └── _keyframes.scss ├── base/ # Base styles and typography │ ├── _typography.scss │ ├── _colors.scss │ ├── _fonts.scss │ └── _reset.scss └── components/ # Component-specific styles └── [125 component files] Key SCSS features:\nBEM methodology: Consistent naming convention throughout Media query mixins: Using sass-mq for responsive design Modular architecture: Each component has its own SCSS file Abstract layer: Reusable variables, mixins, and functions Vue transitions: Custom transition styles for Vue components JavaScript architecture The JavaScript is organized into two main entry points:\nMain application (app.js):\nInitializes core application functionality Sets up jQuery plugins and utilities Handles legacy browser support Vue application (vue/main.js):\nConfigures Vue 3 app with Pinia for state management Registers global Vue components Sets up Vee-Validate configuration Integrates third-party Vue plugins (VueTelInput, etc.) Component utilities (app/components/):\nheader.js: Header behavior and navigation footer.js: Footer functionality splide.js: Carousel initialization slick.js: Legacy carousel support accordions.js: Accordion interactions tabs.js: Tab functionality scrollTrigger.js: Scroll-based animations video.js: Video player setup sticky-sidebar.js: Sticky sidebar behavior Key features Multi-step forms The PersonalizedTripForm.vue component implements a sophisticated multi-step form with:\nStep-by-step navigation with progress indicators Form validation using Vee-Validate and Yup schemas Dynamic form fields based on user selections Phone number input with international support (VueTelInput) reCAPTCHA integration for spam protection Loading states and error handling Advanced filtering system The tour filtering system (ToursFilter.vue) provides:\nMultiple filter criteria (destination, activity type, trip type, month) Real-time filtering with URL parameter synchronization Responsive design with mobile accordion interface Custom select components with search functionality Empty states and loading indicators Integration with WordPress backend via Axios Responsive design The entire website is fully responsive with:\nMobile-first approach Breakpoint management using sass-mq Touch-friendly interactions Optimized images and assets Performance optimizations for mobile devices Performance optimizations Code splitting: Laravel Mix extracts vendor libraries Asset versioning: Automatic cache busting Image optimization: Lazy loading and responsive images Minification: Production builds are minified and optimized Tree shaking: Unused code elimination in production Accessibility Semantic HTML structure ARIA labels where appropriate Keyboard navigation support Focus management in forms Screen reader considerations Development workflow The project uses Laravel Mix for asset compilation:\n// Development npm run dev // Compile assets npm run watch // Watch for changes npm run hot // Hot module replacement // Production npm run production // Optimized production build BrowserSync integration provides:\nLive reloading during development Synchronized browser testing Proxy configuration for WordPress development Conclusion and final thoughts Building the Chile Nativo frontend from a Figma design was an excellent opportunity to:\nMaster Vue 3: Working with the Composition API, reactive systems, and modern Vue patterns Implement complex forms: Multi-step forms with validation, international phone inputs, and reCAPTCHA Build scalable architecture: Organizing 40+ Vue components and 125+ SCSS files in a maintainable structure Optimize performance: Implementing code splitting, lazy loading, and production optimizations Ensure design fidelity: Translating Figma designs into pixel-perfect implementations Handle responsive design: Creating seamless experiences across all device sizes The project demonstrates proficiency in:\nModern JavaScript frameworks (Vue 3) Build tools and asset compilation (Laravel Mix, Webpack) CSS architecture and methodologies (SCSS, BEM) Form validation and user experience Component-based development Design system implementation The integration with WordPress/Themosis backend required careful consideration of server-side rendering, API endpoints, and content management workflows, making this a full-stack frontend implementation.\nLive website: https://chilenativo.travel/\nFigma prototype: https://www.figma.com/proto/ywHPhSP1UfYUAE8eWVQv4L/Dise%C3%B1o-Desktop---Chile-Nativo?node-id=289-3912\u0026m=dev\u0026scaling=min-zoom\u0026content-scaling=fixed\u0026page-id=289%3A3911\u0026starting-point-node-id=289%3A3912\n","image":"//localhost:1313/images/project/chile-nativo/home.png","permalink":"//localhost:1313/projects/chile-nativo-patagonia-travel-website/","tags":["Vue 3","Laravel Mix","WordPress","Themosis","SCSS","JavaScript","Figma"],"title":"Chile Nativo: Patagonia Travel Website"},{"categories":["Projects"],"contents":"JAC Autos Chile is a comprehensive automotive website built on top of WordPress with the Themosis framework, featuring car model comparisons, multi-step quote forms, fleet management, branch listings, and advanced filtering systems using Vue 3, Pinia state management, Laravel Mix, and modern frontend technologies.\nOutline The project Key features The stack Frontend architecture Interactive components Conclusion Live website The project JAC Autos Chile is the official website for JAC Motors in Chile, showcasing SUVs, pickups, commercial vehicles, and electric vehicles. The website serves as the primary platform for vehicle exploration, quoting, dealership location, fleet management, and post-sale services.\nThe frontend development required implementing complex interactive features including car model comparisons, multi-step quote forms with model and version selection, advanced filtering systems, fleet management interfaces, and comprehensive content management.\nKey features The website includes several sophisticated features:\nCar Model Comparator: Side-by-side comparison of multiple vehicle models with difference highlighting Multi-step Quote Form: Comprehensive quote form with model selection, version selection, and customer information Advanced Filtering: Multi-criteria filtering for car models, branches, fleet vehicles, and blog posts Fleet Management: Dedicated fleet vehicle selection and management interface Branch Locator: Filterable dealership/branch listings with location information Blog System: Complete blog with filtering, search, and content management Manuals Listing: User manual and documentation management Search Functionality: Site-wide search with categorized results Sticky Navigation: Section-based sticky navigation for long pages 360° View: Interactive 360-degree vehicle viewing The stack The frontend stack consists of:\nVue 3.2.4: Modern reactive framework with Composition API Pinia 2.2.6: State management for Vue applications Laravel Mix 6.0: Asset compilation and bundling SCSS: Advanced styling with organized architecture Vee-Validate 4.14.6: Form validation with Yup schemas Axios 1.6.8: HTTP client for API requests Splide.js 4.1.4: Modern carousel and slider components @splidejs/vue-splide 0.6.12: Vue 3 wrapper for Splide Maska 3.0.3: Input masking for formatted inputs Vue-Select 4.0.0-beta.6: Custom select component Vue-Recaptcha 2.0.3: reCAPTCHA integration Headroom.js: Header behavior on scroll jQuery 3.7.1: DOM manipulation and legacy support SweetAlert2: Modern alert dialogs @fdograph/rut-utilities: Chilean RUT validation utilities Frontend architecture Vue components The application features a comprehensive set of Vue 3 components (40+ components):\nCar Model Components:\nCar.vue: Car model card component with comparison functionality CarLoading.vue: Loading skeleton for car cards CarVersion.vue: Car version/trim level component CarVersionLoading.vue: Loading skeleton for version cards CarModelsListingStatic.vue: Static car models listing CarModelsListingQuote.vue: Car models listing for quote flow CarVersionsListingQuote.vue: Versions listing for quote flow CarQuote.vue: Car quote display component CarQuoteLoading.vue: Loading skeleton for quote cards Comparison Components:\nComparator.vue: Main car comparison component with Splide integration ComparatorModal.vue: Modal version of comparator CardCompareModel.vue: Comparison card for individual models CardCompareModelLoading.vue: Loading skeleton for comparison cards Quote Components:\nQuote.vue: Main quote component with multi-step flow QuoteForm.vue: Comprehensive quote form with validation Filtering Components:\nFilters.vue: General filtering component FleetFilter.vue: Fleet-specific filtering BranchesFilter.vue: Branch/dealership filtering BlogFilter.vue: Blog post filtering AjaxListWithFilter.vue: AJAX-powered list with filtering Content Components:\nBlog.vue: Blog post card component BlogLoading.vue: Loading skeleton for blog cards Fleet.vue: Fleet vehicle card component Branch.vue: Branch/dealership card component BranchLoading.vue: Loading skeleton for branch cards Manual.vue: Manual/documentation card component ManualLoading.vue: Loading skeleton for manual cards ManualsListing.vue: Manuals listing component Form Components:\nContactForm.vue: Contact form with validation Select.vue: Custom select dropdown component UI Components:\nPagination.vue: Pagination component StickySectionSelector.vue: Sticky navigation for sections EmptyState.vue: Empty state displays Loader.vue: Loading indicator ErrorBoundary.vue: Error boundary component SearchResults.vue: Search results display SearchResultCard.vue \u0026amp; SearchResultCardLoading.vue: Search result cards Service Components:\nCardMaintenance.vue: Maintenance service card CardMaintenanceLoading.vue: Loading skeleton for maintenance cards JavaScript components The application includes 12 specialized JavaScript components:\nUI Components:\nheader.js: Header functionality and navigation headroom.js: Header hide/show on scroll megamenu.js: Mega menu functionality search-modal.js: Search modal functionality scrollUpBottom.js: Scroll to top/bottom functionality social-share.js: Social media sharing Media Components:\nvideo.js: Video player setup splide.js: Carousel initialization slick.js: Legacy carousel support Interactive Components:\naccordion.js: Accordion interactions tabs.js: Tab functionality Utilities:\nimg-to-svg.js: SVG image conversion utility scrollTrigger.js: Scroll-based animations SCSS architecture The styling follows a well-organized SCSS architecture:\nscss/ ├── abstracts/ # Variables, mixins, functions │ ├── _mixins.scss │ ├── _mq.scss # Media query mixins │ └── _vendor.scss ├── base/ # Base styles and typography │ ├── _typography.scss │ ├── _colors.scss │ ├── _container.scss │ └── _globals.scss └── components/ # Component-specific styles ├── [87 component files] └── cards/ # Card component styles └── [20 card-specific files] Key SCSS features:\nBEM methodology: Consistent naming convention throughout Media query mixins: Using sass-mq for responsive design Modular architecture: 106 component-specific SCSS files Card organization: Dedicated card component styles Interactive components Car model comparator The Comparator.vue component provides sophisticated car model comparison:\nFeatures:\nSide-by-side comparison: Compare up to 3 models simultaneously Difference highlighting: Toggle to highlight differences between models Splide integration: Smooth carousel navigation for multiple models Dynamic data loading: Load comparison data via AJAX Responsive design: Optimized for mobile and desktop Modal version: Full-screen modal comparison view Technical Implementation:\nPinia store for comparison state management Splide Vue component for carousel functionality Dynamic component rendering based on selected models Efficient data structure for comparison attributes Multi-step quote form The Quote.vue and QuoteForm.vue components implement a comprehensive quote system:\nFeatures:\nStep-by-step flow: Model selection → Version selection → Customer information Form validation: Using Vee-Validate with Yup schemas RUT validation: Chilean RUT validation using custom directive Input masking: Phone numbers and formatted inputs with Maska reCAPTCHA integration: Spam protection Edit functionality: Ability to go back and edit previous steps Selected vehicle display: Visual representation of selected model/version Loading states: Visual feedback during form submission Form steps include:\nStep 1: Category and model selection Step 2: Version/trim level selection Step 3: Customer information and submission Advanced filtering systems Multiple filtering components provide comprehensive filtering:\nFleet Filter (FleetFilter.vue):\nFilter fleet vehicles by category, price range, and features Real-time filtering with URL parameter synchronization Mobile-optimized interface Branches Filter (BranchesFilter.vue):\nFilter dealerships by location, region, and services Map integration support Contact information display Blog Filter (BlogFilter.vue):\nFilter blog posts by category, date, and tags Search functionality Pagination support Ajax List with Filter (AjaxListWithFilter.vue):\nGeneric AJAX-powered list component Multiple filter criteria Loading states and empty states Sticky section selector The StickySectionSelector.vue component provides section-based navigation:\nFeatures:\nSticky positioning: Stays visible while scrolling Active section highlighting: Highlights current section Smooth scrolling: Smooth scroll to sections Responsive design: Mobile-optimized display State management with Pinia The application uses Pinia for centralized state management:\nStores:\nComparator Store: Manages comparison state, selected models, and comparison data Quote Store: Manages quote flow state, selected model/version, and form data Filter Stores: Manage filter states for different content types Benefits:\nCentralized state management Type-safe state access Efficient reactivity Easy debugging with Vue DevTools Custom directives The application includes custom Vue directives:\nRUT Directive (input-rut):\nChilean RUT (tax ID) validation and formatting Real-time validation as user types Format enforcement (XX.XXX.XXX-X) Development workflow The project uses Laravel Mix for asset compilation:\n// Development npm run dev // Compile assets npm run watch // Watch for changes npm run hot // Hot module replacement // Production npm run production // Optimized production build BrowserSync integration provides:\nLive reloading during development Synchronized browser testing Proxy configuration for WordPress development Performance optimizations Code splitting: Laravel Mix extracts vendor libraries Asset versioning: Automatic cache busting Image optimization: Lazy loading and responsive images Minification: Production builds are minified and optimized Tree shaking: Unused code elimination in production Component lazy loading: Load components on demand Skeleton loading: Better perceived performance with loading states Accessibility Semantic HTML structure ARIA labels for interactive elements Keyboard navigation support Focus management in forms and modals Screen reader considerations Proper alt text for images Color contrast compliance Conclusion and final thoughts Building the JAC Autos Chile frontend was an excellent opportunity to:\nMaster Vue 3: Working with Composition API, Pinia state management, and modern Vue patterns Build complex comparisons: Creating sophisticated car model comparison interfaces Implement multi-step forms: Complex quote forms with validation, RUT formatting, and step navigation Create advanced filtering: Multiple filtering systems for different content types Optimize performance: Implementing efficient state management, lazy loading, and code splitting Handle automotive data: Managing complex vehicle data structures and relationships The project demonstrates proficiency in:\nModern JavaScript frameworks (Vue 3) State management (Pinia) Form validation and user experience (Vee-Validate, Yup, Maska) Build tools and asset compilation (Laravel Mix, Webpack) CSS architecture and methodologies (SCSS, BEM) Component-based development Custom directives Carousel and slider implementations (Splide) AJAX-powered interfaces The integration with WordPress/Themosis backend required careful consideration of server-side rendering, API endpoints, and content management workflows, making this a full-stack frontend implementation for a comprehensive automotive platform.\nLive website: https://jacautoschile.cl/\nFigma Prototype: https://www.figma.com/proto/wfsYoYThSR9VId6TVUGevk/JAC---Dise%C3%B1o-desktop?node-id=1-232\u0026m=dev\u0026scaling=min-zoom\u0026content-scaling=fixed\u0026page-id=0%3A1\u0026starting-point-node-id=62%3A3801\n","image":"//localhost:1313/images/project/jac/home.png","permalink":"//localhost:1313/projects/jac-autos-chile-automotive-website/","tags":["Vue 3","Pinia","Laravel Mix","WordPress","Themosis","SCSS","JavaScript","Splide"],"title":"JAC Autos Chile: Automotive Website"},{"categories":["Projects"],"contents":"ISC Chile is an educational consultancy website for study abroad programs, built on top of WordPress with the Themosis framework, featuring GSAP animations, multi-step contact forms, advanced blog filtering, and comprehensive content management using Vue 2, Laravel Mix, and modern frontend technologies.\nOutline The project Design implementation The stack Frontend architecture Key features Conclusion Live website The project ISC Chile is an educational consultancy agency that has been providing study abroad advisory services since 1996. The website serves as the primary platform for showcasing various educational programs including English courses, school exchanges, group travel programs, and Pathways programs for university admission abroad.\nThe frontend development was based on a comprehensive Figma design, requiring pixel-perfect implementation of complex UI components, multi-step forms, animated statistics, and responsive layouts that work seamlessly across all devices.\nDesign implementation The entire frontend was built from a detailed Figma design, ensuring:\nPixel-perfect accuracy: Matching the design specifications precisely (as evidenced by Figma height references in SCSS) Responsive design: Implementing breakpoints and mobile-first approach Component consistency: Maintaining design system patterns throughout Interactive elements: Translating static designs into dynamic, interactive components Animation and transitions: Implementing smooth GSAP-powered animations The stack The frontend stack consists of:\nVue 2.6.12: Reactive framework for building interactive components Laravel Mix 6.0: Asset compilation and bundling SCSS: Advanced styling with a well-organized architecture Vuex 3.6.2: State management for Vue applications Vee-Validate 3.4.14: Form validation GSAP 3.12.5: Professional animation library with ScrollTrigger Axios 0.18: HTTP client for API requests Splide.js 4.1.4: Modern carousel and slider components Slick Carousel 1.8.1: Legacy carousel support LightGallery 2.7.2: Lightbox gallery functionality Odometer 0.4.8: Animated number counting Headroom.js: Header behavior on scroll V-Calendar 2.4.2: Calendar component for date selection V-Mask 2.3.0: Input masking Vue-Select 3.20.2: Custom select component jQuery 3.2: DOM manipulation and legacy support SweetAlert: Alert dialogs Frontend architecture Vue components The application features a comprehensive set of Vue 2 components:\nForm Components:\nContact.vue: Multi-step contact form with validation and reCAPTCHA ContactFormStep1.vue: First step of the contact form ContactFormStep2.vue: Second step of the contact form ContactFormStep3.vue: Third step of the contact form FormBanner.vue: Banner form component Content Components:\nBlog.vue: Blog listing with advanced filtering and search BlogArticleCard.vue \u0026amp; BlogArticleCardLoading.vue: Blog post cards with loading states ExperiencesPanel.vue: Testimonials and experiences display panel ExperiencesFiltersMobile.vue: Mobile filter component for experiences Search Components:\nSearchResults.vue: Search results display component SearchResultCardLoading.vue: Loading skeleton for search results UI Components:\nCheckboxDropdown.vue: Custom checkbox dropdown component CheckboxDropdownFieldset.vue: Fieldset wrapper for checkbox dropdowns EmptyState.vue: Empty state displays Loader.vue \u0026amp; Loading.vue: Loading indicators JavaScript components The application includes 15 specialized JavaScript components:\nAnimation Components:\ngsap.js: GSAP animations with ScrollTrigger for scroll-based reveals scrolltrigger.js: Custom scroll trigger utilities odometer.js: Animated number counting with scroll triggers UI Components:\nheader.js: Header functionality and navigation headroom.js: Header hide/show on scroll megamenu.js: Mega menu functionality mobileMenu.js: Mobile menu interactions searchbar.js: Search bar functionality floating-banner.js: Floating banner component footer.js: Footer functionality Media Components:\nvideo.js: Video player setup lightgallery.js: Lightbox gallery initialization splide.js: Carousel initialization slick.js: Legacy carousel support Interactive Components:\naccordion.js: Accordion interactions tabs.js: Tab functionality cards.js: Card interactions Utilities:\nimg-to-svg.js: SVG image conversion utility SCSS architecture The styling follows a well-organized SCSS architecture:\nscss/ ├── abstracts/ # Variables, mixins, functions │ ├── _mixins.scss │ ├── _mq.scss # Media query mixins │ └── _vendor.scss ├── base/ # Base styles and typography │ ├── _typography.scss │ ├── _colors.scss │ ├── _container.scss │ ├── _globals.scss │ └── fonts/ # Custom TWK Everett font family └── components/ # Component-specific styles └── [45 component files] Key SCSS features:\nBEM methodology: Consistent naming convention throughout Media query mixins: Using sass-mq for responsive design Modular architecture: Each component has its own SCSS file Custom typography: TWK Everett font family with multiple weights Figma references: Direct references to Figma design specifications Key features Multi-step contact form The Contact.vue component implements a sophisticated multi-step form with:\nThree-step navigation: Step-by-step form progression Form validation: Using Vee-Validate with comprehensive rules Date picker: V-Calendar integration for date selection Input masking: V-Mask for phone numbers and formatted inputs reCAPTCHA integration: Spam protection Dynamic fields: Fields that change based on user selections Loading states: Visual feedback during form submission Error handling: Comprehensive error messages and validation Form steps include:\nStep 1: Personal information and contact details Step 2: Educational background and program interests Step 3: Additional information and submission GSAP animations The gsap.js component provides professional animations:\nFeatures:\nScroll-triggered animations: Elements animate on scroll Vertical scroll reveals: Fade and slide animations Horizontal scroll reveals: Staggered animations for grid layouts Timeline management: Complex animation sequences Performance optimized: Efficient animation triggers Animation types:\nFade in with vertical movement Staggered grid animations Scroll-based reveals Smooth transitions Advanced blog system The Blog.vue component provides comprehensive blog functionality:\nFeatures:\nCategory filtering: Filter posts by category Search functionality: Real-time search across blog posts Mobile filters: Dedicated mobile filter interface Pagination: Efficient content pagination Loading states: Skeleton loading screens Empty states: User-friendly empty state messages Experiences/testimonials panel The ExperiencesPanel.vue component displays student testimonials:\nFeatures:\nFilter by type: Filter testimonials (Students/Parents) Dynamic loading: Load testimonials from API Responsive design: Mobile-optimized display Carousel integration: Splide carousel for testimonial display Animated statistics The odometer.js component provides animated number counting:\nFeatures:\nScroll-triggered: Animations trigger on scroll Smooth counting: Odometer theme integration Performance optimized: Efficient scroll detection Mobile support: Optimized for all devices Search functionality The SearchResults.vue component provides comprehensive search:\nFeatures:\nMulti-content search: Search across programs, blog posts, and pages Result categorization: Organized search results Image support: Results with and without images Tag display: Category tags for results Loading states: Skeleton loading screens Custom typography The website features a custom font family, TWK Everett, with:\nMultiple weights: From Hairline to Super Italic variants: All weights include italic versions Optimized formats: WOFF, WOFF2, and OTF formats Performance: Efficient font loading and rendering Development workflow The project uses Laravel Mix for asset compilation:\n// Development npm run dev // Compile assets npm run watch // Watch for changes npm run hot // Hot module replacement // Production npm run production // Optimized production build BrowserSync integration provides:\nLive reloading during development Synchronized browser testing Proxy configuration for WordPress development Performance optimizations Code splitting: Laravel Mix extracts vendor libraries Asset versioning: Automatic cache busting Image optimization: Lazy loading and responsive images Minification: Production builds are minified and optimized Tree shaking: Unused code elimination in production Font optimization: Efficient font loading strategies Accessibility Semantic HTML structure ARIA labels for interactive elements Keyboard navigation support Focus management in forms Screen reader considerations Proper alt text for images Conclusion and final thoughts Building the ISC Chile frontend from a Figma design was an excellent opportunity to:\nMaster Vue 2: Working with Options API, Vuex state management, and Vue 2 patterns Implement GSAP animations: Creating professional scroll-triggered animations Build complex forms: Multi-step forms with validation, date pickers, and input masking Create advanced filtering: Blog filtering with search and category selection Optimize performance: Implementing efficient animations and lazy loading Ensure design fidelity: Translating Figma designs into pixel-perfect implementations (with direct Figma references in code) The project demonstrates proficiency in:\nModern JavaScript frameworks (Vue 2) Animation libraries (GSAP, ScrollTrigger) Form validation and user experience (Vee-Validate, V-Mask, V-Calendar) Build tools and asset compilation (Laravel Mix, Webpack) CSS architecture and methodologies (SCSS, BEM) Component-based development State management (Vuex) Design system implementation The integration with WordPress/Themosis backend required careful consideration of server-side rendering, API endpoints, and content management workflows, making this a full-stack frontend implementation for an educational consultancy platform.\nLive website: https://www.iscchile.cl/\nFigma prototype: https://www.figma.com/proto/BfdKGJlzx7xAnE7rpZ1vda/Dise%C3%B1o-ISC?page-id=314%3A12071\u0026type=design\u0026node-id=314-12072\u0026viewport=-1452%2C930%2C0.29\u0026t=hFYiwcionjRAZ47v-1\u0026scaling=min-zoom\n","image":"//localhost:1313/images/project/isc-chile/home.png","permalink":"//localhost:1313/projects/isc-chile-educational-consultancy-website/","tags":["Vue 2","Laravel Mix","WordPress","Themosis","SCSS","GSAP","JavaScript","Figma"],"title":"ISC Chile: Educational Consultancy Website"},{"categories":["Projects"],"contents":"Rutieri is a SaaS platform built with Strapi, React Native, Typescript and other technologies.\nOutline The idea Platform features The stack The API The frontend The mobile app Conclusion Landing Page The idea Before starting to write a single line of code, it is generally a good idea to think about the problem, it\u0026rsquo;s limitations and whether or not it has already been solved by someone else (AKA competitors).\nThe problem I was looking into had to do with the way in which public and private transportation companies manage their routes, drivers and users. This process is generally carried out on paper, e.g. not digital, hence this could be problematic in case of new drivers joining the organization or in case of restricting access to data to only specific users.\nAfter a little bit of research, I could only find one platform that provides a similiar solution but for their own company.\nPlatform features and user stories The following user stories illustrates the desired features the platform should have in order to solve the aforementioned problems.\nAs an administrator user, I want to: login in the admin panel. create an organization. create routes in the organization. invite drivers and users to the organization. manage requests to join the organization. assign routes to drivers in the organization. see in real time the drivers and users currently active in the map of the different routes. As a driver, I want to: login in the mobile app. join an organization by entering the code in the search bar. see my route on the map. become visible to passengers on the road. see the passengers waiting on the road. remove my visibility and finish my run. As a passenger, I want to: login in the mobile app. join an organization by entering the code in the search bar. see the different routes of my organization in the map. search for a destination and get the available routes that pass nearby. see the drivers currently active on the routes in real time. become visible to drivers of a route. The requirements The backend requires to handle user authentication, permissions, different data structures as content types and define relations between them. It\u0026rsquo;s also necessary to synchronise passengers and drivers and view them on a map real time in the administration panel as well as in the mobile app.\nThe administration panel is a web page that fetches data from the backend as well as from the real time data provider and it\u0026rsquo;s goal is to provide a way for administrators to manage their organization and users. We\u0026rsquo;re talking about a Single Page Application built in React.\nAs for the mobile application, there isn\u0026rsquo;t a better choice nowadays than React Native and it works just fine in this case.\nThe API Since all of the features involve authentication, permissions and roles, and because there is no need to reinvent the wheel, I chose to use Strapi to build the backend for it\u0026rsquo;s simplicity, ease of use and great developer experience, whereas for realtime data, I used Firebase.\nThe instance of Strapi and the Postgres database it requires was deployed in the cloud hosting platform https://fly.io.\nStrapi is good for managing users, content that\u0026rsquo;s typically updated and fetched via CRUD API, and relations between content types.\nThe platform needs the following content types:\nOrganizations to group routes, drivers and users Routes Two user roles: drivers and users (passengers) Below are some screenshots of the overview of these content types\nAs I said before, Strapi makes the creation of these content types and the relationships between them really straightforward.\nHowever, not everything related to the API can be provided by Strapi. Some realtime features need to be addressed with other solutions, such as geolocation data in real time for drivers and users to synchronise each other, maps and the ability to search for places. Such features were implemented using Firebase, Google Maps and Google Places.\nThe frontend The platform where users are able to login as administrators and manage their organizations and users is a single page web application built in React. Among the features of this project that I think stand out are:\nState managed by Context API Interface styled with Bootstrap React Router for pages Leaflet to display the map GeoFire library to synchronise geolocation data in real time with Firebase Use of localStorage to save user session Below are some sample screenshots of how this app looks like\nThe mobile application This one is by far the most complex part of this project.\nThe project was bootstraped with Infinitered\u0026rsquo;s Ignite, which provides a great boilerplate and surely saved me of what would have been between 1-2 months of work.\nIgnite\u0026rsquo;s boilerplate includes many features out of the box, including:\nReact Native and Typescript (of course) React Navigation MobX-State-Tree for state management Expo SDK for developer experience AsyncStorage for persistence apisauce as REST client And some other libraries and features that make React Native apps super powerful and a joy to work on.\nIt consists of three screens:\nWelcome screen Login screen Map screen In the welcome screen, users are able to go to the login screen if not logged in. Otherwise, if they\u0026rsquo;re in an organisation, it shows their role and org\u0026rsquo;s information, and if they\u0026rsquo;re not, they are able to enter the organisation code and request to join as driver or as passenger.\nWelcome screens Login screens If the user is a driver in an organisation, the welcome screen also shows the route assigned to them. By tapping on it, it takes them to the map, where they can see themselves and start the tour, becoming visible to passengers on the road but being able to see passengers on the road as well.\nDrivers can finish the tour at any time by pressing the button stop.\nIf the user is a passenger in an organisation, the welcome screen shows the different routes available in the organisation. By tapping on them, they are taken to the map where they can see themselves, the route and the drivers on the road.\nPassengers are able to navigate between the available routes and search for the location they want to go to by using the search bar at the top of the map screen, filtering out the routes that pass nearby (less than 200 meters), if there are. Google Places API and turf library work together in this search process.\nPassengers become visible to drivers on the road by pressing the button wait and if they press the button again, they stop waiting and are removed from the driver\u0026rsquo;s map.\nMap screens The start/wait and finish buttons dispatch actions that update their location in firebase, so that passengers are able to see the bus on the map as it moves in real time and viceversa.\nAs for the state management, the project consists of two models and three stores from Mobx-State-Tree library: User and Route models, user-status, route-store and root-store stores.\nUser model Located in /app/models/user/user.ts\nconst OrganizationModel = types.model({ name: types.string, code: types.string, id: types.identifierNumber, drivers: types.number, rutas: types.array(RouteModel) }) const UserModel = types .model(\u0026#34;User\u0026#34;) .props({ id: types.identifierNumber, username: types.string, email: types.string, token: types.string, role: types.union(types.literal(\u0026#34;passenger\u0026#34;), types.literal(\u0026#34;driver\u0026#34;)), ruta: types.maybeNull(RouteModel), organization: types.maybeNull(OrganizationModel), pending_request: types.maybeNull(OrganizationModel), }) Route model Located in /app/models/route/route.ts\nThis model follows the GeoJSON format for routes.\nconst RouteModel = types .model(\u0026#34;Ruta\u0026#34;) .props({ id: types.identifierNumber, name: types.string, latlong: types.maybeNull(types.model({ lat: types.number, longt: types.number })), coords: types.model({ type: FeatureTypes, features: types.array(types.model({ type: types.string, geometry: types.model({ type: types.string, coordinates: types.union(types.array(types.number), types.array(types.array(types.number))) }), properties: types.model({ name: types.string }) })) }) }) user-status store Located in /app/models/user-status/user-status.ts\nThis store is responsible for managing the state of the user. It stores the user once it\u0026rsquo;s logged in and removes it when the user logs out. It also has some views to get the user key for firebase purposes, get the role and get the route in case of a driver.\nThis store has some methods that get the user location from the device\u0026rsquo;s GPS, displays the user icon on the map and sends it to firebase.\nconst UserStatusModel = types .model(\u0026#34;UserStatus\u0026#34;) .extend(withEnvironment) .props({ user: types.maybeNull(UserModel), location: types.maybeNull( types.model({latitude: types.number, longitude: types.number}) ), visibility: types.maybeNull(types.number) }) route-store store Located in /app/models/route-store/route-store.ts\nThis store is responsible for managing the state of the available routes. It stores the routes, drivers and passengers on the different routes. It also has some view methods to filter the routes that pass nearby a destination specified by the user, get passengers waiting on a given route and get drivers active in a specific route.\nThis store initializes a GeoQuery from Geofire library and listens for events to set, update and remove drivers and passengers from the map as they move.\nconst RouteStoreModel = types .model(\u0026#34;RouteStore\u0026#34;) .props({ routes: types.array(RouteModel), passengers: types.map(types.model({ key: types.identifier, location: types.array(types.number) })), drivers: types.map(types.model({ key: types.identifier, location: types.array(types.number) })), destinationAddress: types.maybeNull(types.model({ name: types.string, coords: types.array(types.number) })) }) Conclusion and final thoughts Using a CMS as the backend can make the development a lot faster than building the API from scratch and with Strapi this is specially true. On the other hand, Strapi doesn\u0026rsquo;t really make a good fit for real time applications, therefore, Firebase is the way to go in this case.\nAs of the client side, React always works very good for pretty much any kind of application, and because React Native uses React under the hood, it is so convenient for us React developers and ir works pretty good for almost any kind of application as well.\nHowever, one thing that I didn\u0026rsquo;t mention in this post was the use of Typescript; I find this quote by Brice Wilson pretty good to point out the whole purpose and motivation to learn and use (well) this powerful language and tool ecosystem:\n\u0026ldquo;You won\u0026rsquo;t have to wait for a frustrated user to report the error. All of this means that you provide value to your users faster, and that\u0026rsquo;s really what it\u0026rsquo;s all about.\u0026rdquo;\nAll in all, I got a lot of learning by building this project, both in languages/frameworks used and production stuff such as infrastructure, cloud hosting and cloud-based APIs.\nProject landing page: https://rutieri.netlify.app\n","image":"//localhost:1313/images/project/rutieri/landing/homepage.webp","permalink":"//localhost:1313/projects/saas-platform-rutieri/","tags":["Strapi","React Native","React","Typescript","Firebase"],"title":"SaaS platform: Rutieri"},{"categories":["Tutorial"],"contents":"Enable comments in a Strapi application and display them in the frontend with React\nOutline Introduction Prerequisites What is Strapi Comment Manager? Installation Configuration Display comments on the frontend Installation of Strapi Comments Client Usage of Strapi Comments Client Plugin settings Manage comments Full source code of the frontend Conclusion Introduction A comment system comes in very handy for pretty much any kind of website. In the JAMstack ecosystem, while it\u0026rsquo;s ok to rely on third party solutions hosted on their own platform such as Disqus to enable comments, you usually want to keep your content and all the stuff related to it in the same admin dashboard.\nIn this article, I\u0026rsquo;ll show you how to enable and manage comments for your content very easily using the Comment Manager plugin, and display them in your frontend application.\nPrerequisites You should have a basic understanding of the following.\nBasic knowledge of JavaScript Basic knowledge of React (OPTIONAL) Basic understanding of Strapi - get started here. Your Strapi V4 project setup What is Strapi Comment Manager? Strapi Comment Manager is a plugin that enables comments for pretty much any kind of content. It allows your users to post comments and anyone can get the comments associated with a given slug.\nWith this plugin, admin users can view and manage very easily all the comments from the Strapi administration dashboard. Within the dashboard, you will be able to delete comments and subcomments and leave replies on comments.\nInstallation Once into the Strapi project root, you can install the plugin by running the following command:\nnpm install strapi-plugin-comment-manager Next, build the project to see the new plugin in the dashboard with the following command:\nnpm run build And that\u0026rsquo;s it! If everything runs correctly, the plugin should now be installed.\nConfiguration Now you need to enable some permissions so that the frontend can access the endpoints to post and fetch comments.\nIn your Strapi admin dashboard, head over to Settings, then over to Roles under Users \u0026amp; Permissions Plugin.\nLet\u0026rsquo;s first setup the Public API; click on Public and hit the dropdown button of Comment Manager. Now check count, find and getPageSize, then hit the Save button. Below is a screenshot of a proper configuration:\nNow let\u0026rsquo;s setup the Authenticated API. Go back to Roles and click on Authenticated. Open the dropdown for Comment Manager and mark as checked the option create on both Comment and Subcomment. Below is a screenshot of a proper configuration:\nWith this configuration, the frontend should now be able to make requests to get and post comments.\nDisplay comments on the frontend The plugin exposes an API to get and post comments if you want to have fine-grained control over the workflow of your comments system and you can check the documentation on the package page, but this plugin also comes with a purpose-built React component library that makes it super easy to get up and running without getting your hands dirty.\nThis components library is called strapi-comments-client, fully supports typescript and it handles for you all of the complexity of fetching and posting comments and subcomments for every content ID that you pass to it.\nInstallation of Strapi Comments Client You will need to have installed react ^17.0.2, react-dom ^17.0.2 and react-router-dom ^5.2.0.\nInside of your React project, run this command:\nnpm install strapi-comments-client --save Usage of Strapi Comments Client Using this library is very easy!\nThis library exports three main components:\nCommentsProvider Comments CommentForm And you can import them this way:\nimport { CommentsProvider, Comments, CommentForm } from \u0026#34;strapi-comments-client\u0026#34; All you have to do is wrap your App component into the CommentsProvider component. Then you will be able to place anywhere in your app the Comments component to render a list of comments for a given content ID and the CommentForm component to render a form to post comments.\nFor example, this could be your index.js or main.js file:\nimport React from \u0026#39;react\u0026#39; import ReactDOM from \u0026#39;react-dom\u0026#39; // The address of your strapi backend instance const STRAPI = \u0026#34;http://localhost:1337\u0026#34; ReactDOM.render( \u0026lt;React.StrictMode\u0026gt; \u0026lt;CommentsProvider apiURL={STRAPI}\u0026gt; \u0026lt;App /\u0026gt; \u0026lt;/CommentsProvider\u0026gt; \u0026lt;/React.StrictMode\u0026gt;, document.getElementById(\u0026#39;root\u0026#39;) ) Where apiURL is the URL of your running Strapi application, and this property is required.\nThis way, the comments provider will do all the magic of fetching and posting comments for you!\nThis library also exports an utility React.Context to update some of the parameters for fetching and posting comments:\nimport { CommentsConfigContext } from \u0026#34;strapi-comments-client\u0026#34; This CommentsConfigContext exposes two setter functions: setUser and setContentID\nWith setContentID you can load the comments for a given content and post comments to it. It receives a single parameter of type string and must be URLized, i.e. no spaces.\nWith setUser you can set the credentials of a given user to authorize the posting of comments. It receives a single parameter of type IUser, with the following Typescript interface:\ninterface IUser { username: string, email: string, id: string, token: string // This is a JWT } It\u0026rsquo;s a little confusing but we\u0026rsquo;ll see how to use it in a component:\nconst App = () =\u0026gt; { const { setUser, setContentID } = useContext(CommentsConfigContext) // The following data should come from Strapi Users and Permissions Plugin // for authenticated requests const user = { username: \u0026#34;John Doe\u0026#34;, email: \u0026#34;jhohndoe@gmail.com\u0026#34;, id: 5, token: \u0026#34;this_should_be_a_JWT\u0026#34; } if (user) { setUser(user) } setContentID(\u0026#34;sample-content-1\u0026#34;) // Load comments for this content return ( \u0026lt;\u0026gt; { !user \u0026amp;\u0026amp; \u0026lt;Login /\u0026gt; } \u0026lt;CommentForm /\u0026gt; \u0026lt;Comments /\u0026gt; \u0026lt;/\u0026gt; ) } And that\u0026rsquo;s it!\nAfter setting the content ID through setContentID, CommentsProvider will start loading the comments for the given content ID and the CommentForm will render an input to post comments related to the given content ID if there is a user. Otherwise, it will display the message Login to post a comment.\nHere\u0026rsquo;s how the interface looks like so far:\nThere\u0026rsquo;s also a button to Leave a reply, which will open a form to post a subcomment associated with the parent comment.\nThis library exports one more component: ErrorBox\nimport { ErrorBox } from \u0026#34;strapi-comments-client\u0026#34; .It\u0026rsquo;s useful if you\u0026rsquo;d like to display error messages when things go wrong fetching or posting comments.\nYou can place this component wherever you want, for example in between the CommentForm and the Comments components.\nIf you\u0026rsquo;re wondering how this error box looks like, here you have a sample:\nGeneral settings You can customize the page size, i.e. specify how many comments are returned at once.\nIn the Strapi admin panel, head over to Settings, then select Pagination under Comment Manager Plugin.\nHere you\u0026rsquo;ll find an input to set the page size, which defaults to 10.\nManage comments Once you\u0026rsquo;ve got the plugin up an running, as users start to post comments, you can manage and reply to them as admin from the Comment Manager section of the left sidebar in the Strapi admin dashboard.\nHere you can see two tabs: one for the latest comments and one for comments grouped by content ID.\nIn both of them you can delete comments and subcomments as well as leave replies.\nExample project You can find a full working example of a React App using the Strapi Comments Client Library in this repo\nConclusion With this plugin you can enable and manage comments for any content with little effort and even use a component library to display the comments in your frontend application made with React.\nAnd that\u0026rsquo;s it! The features are pretty basic at the moment but if there\u0026rsquo;s interest, I\u0026rsquo;m willing to work on more features as well as improve the UI/UX.\n","image":"//localhost:1313/images/post/strapilogo.jpg","permalink":"//localhost:1313/blogs/how-to-enable-and-manage-comments-in-your-strapi-application/","tags":["Strapi","Strapi tutorials"],"title":"How To Enable And Manage Comments In Your Strapi Application."},{"categories":["Documentation"],"contents":"Comment Manager is a Strapi plugin to allow your users to post comments.\nWith this plugin you can enable and manage comments for your content very easily!\nRequirements You should have installed an instance of Strapi v4.x.x\nInstallation Run the following command in your project root:\nnpm install strapi-plugin-comment-manager Configurarion For your frontend to have access to the API, enable the following permissions for Comment Manager from Users \u0026amp; Permissions Plugin on your project settings:\nFor public, enable: count, find and getPageSize.\nFor authenticated, enable create on both Comment and Subcomment.\nDisplay comments on the frontend Comments can be displayed in the frontend in two ways:\nUsing the React components library strapi-comments-client (recommended) Build your custom frontend using the API API There are some Typescript interfaces that will help to get an idea of the data structures.\nComments: interface IComment { id: string, from_admin: boolean, createdAt: string, content: string, author: IAuthor | null, subcomments?: ISubcomment[] } Subcomments: interface ISubcomment { id: string, from_admin: boolean, createdAt: string, content: string, author: IAuthor | null, } Authors: IAuthor { username: string, email: string, id: string } The following endpoints are exposed to fetch and post comments and subcomments:\nGet comments for a content ID Method: GET\nPath: /api/comment-manager/comments/:slug\nOptional query parameters: start, ignoreCount\nReturns:\n{ commentsCount?: Number, comments: IComment[] } The parameter start indicates how many comments to skip. This is for pagination purposes.\nThe parameter ignoreCount indicates whether or not to return the total number of comments associated with the given slug.\nGet the number of comments associated with a given content ID Method: GET\nPath: /api/comment-manager/comments/:slug/count\nReturns:\n{ count: Number } Post a comment Method: POST\nPath: /api/comment-manager/comments/:slug\nAuthentication: Bearer token\nPayload:\n{ content: string } Returns:\n{ id: Number } Post a subcomment Method: POST\nPath: /api/comment-manager/subcomments/:parent-id\nAuthentication: Bearer token\nPayload:\n{ content: string } Returns:\n{ id: Number } Get the page size Method: GET\nPath: /api/comment-manager/page-size\nReturns:\n{ pageSize: Number } General settings The plugin allows to set how many comments are returned per page by going to the Pagination section under Comment Manager Plugin on the Settings section.\nThe default page size is 10.\nManagement of comments Admin users are able to delete comments and subcomments as well as leave replies as admins from within the plugin page of the Strapi admin dashboard.\nThe plugin interface has two tabs: one for the latest comments and one for comments by content ID.\nRoadmap and future plans The plugin is pretty basic but it can be improved with more features and a better UI/UX. Collaborations and suggestions are very welcome.\n","image":"//localhost:1313/images/post/strapilogo.jpg","permalink":"//localhost:1313/blogs/strapi-plugin-comment-manager/","tags":["Strapi","Strapi plugins"],"title":"Strapi Plugin Comment Manager"},{"categories":["Projects"],"contents":"In this post I’m going to share my experience on building a SaaS using the headless CMS Strapi as the Backend, React Native and other technologies.\nOutline Introduction What is SaaS? The problem What is Strapi? Developing features in Strapi The frontend: How to get content Conclusion Landing Page Introduction Very often, developers, product and project managers, testers and pretty much the entire team share their ideas to decide what language and which framework they\u0026rsquo;ll use to build their next project. Some considerations must be taken into account, from which in my opinion there are three that are the most important:\nDeveloper experience and ease of use Does the language and framework chosen provide a good developer experience? Is the langauge the same for the backend and frontend?\nDeadlines Is there a deadline to finish the project? if so, there is a good chance to finish the project on time if the team chooses the language they have more experience in.\nMaintainability As there will be usually more than one person working on the same part at the same time, if everything is kept organised, the whole development process will be frictionless.\nWith that in mind, developers and project managers will have a better insight on which language/framework to use.\nOther aspects should also be considered such as what the data structure will look like.\nIn my case, as it is usual, the backend of my project needs a database for users and their roles among other entities and their relations and a dashboard to allow admins to manage the data, and I was lucky to find out Strapi, as it includes a lot of these features out of the box with one single line of command to get started.\nWhat is SaaS? SaaS stands for Software-as-a-Service and it just means that a software is provided as a service in the cloud and it gives a solution to a specific problem, for which the users are willing to pay either monthly or annual subscription.\nThe problem Before starting to write a single line of code, it is generally a good idea to think about the problem, it\u0026rsquo;s limitations and whether or not it has already been solved by someone else (AKA competitors).\nThe problem I was looking into had to do with the way in which public and private transportation companies manage their routes, drivers and users. After a little bit of research, I could only find one platform that provides a similiar solution but for their own company.\nSo the platform I built needed the following content types:\nOrganizations to group routes, drivers and users Routes Two user roles: drivers and users (passengers) As I said before, Strapi makes the creation of these content types and the relationships between them really easy, but let\u0026rsquo;s first see what is Strapi and how it turns the API development into a satisfactory and fun experience.\nWhat is Strapi? Strapi is an open source headless CMS that allows developers to build complete RESTful APIs in just a couple of days instead of months. It includes a lot of useful features as plugins out of the box. Users and Roles management, Media library and an interface to create, view, edit and delete content are just some of them.\nRegarding the API, how does it makes the development faster?\nFirst of all, it enforces a specific folder structure, which helps to keep everything well organised and clean.\nSecondly, all database schemas are generated automatically and queries are made in JSON format, which really saves a lot of time.\nLastly, we can add more features to our Strapi application very easily via plugins from the marketplace.\nIt\u0026rsquo;s also worth noting that Strapi is a self-hosted CMS, which means that we can host it in whatever cloud platform we want, as well as test it locally in our computers before deploying it to the cloud.\nDeveloping features in Strapi Creating and configuring endpoints in Strapi is as straightforward as declaring a JSON in a single file:\nCreating controllers is straightforward as well:\nEvery controller gets all the data related to the request in the ctx parameter and it\u0026rsquo;s also used to send the response. This keeps everything in one place and really helps to improve the readability.\nOnce the API endpoints are defined, the next step is to enable the permissions for the specific user roles to have access to these endpoints:\nThe frontend: how to get content Since Strapi is a headless CMS, it\u0026rsquo;ll only provide content through the API. That means that the content can be consumed from anywhere. In our case, this content will be used in two applications: one for the organization owners and one for the users and drivers.\nThe application for the organization owners is a dashboard where administrators can create organizations, routes, accept drivers and users in the organization and assign routes to drivers. This is just a React Application:\nThe application for drivers and users is a mobile application built in React Native. Firebase was used to synchronise geolocation data in real time between drivers and users and display this information in a Map from Google Maps:\nConclusion Using a CMS as the backend can make the development a lot faster than building the API from scratch and with Strapi this is specially true. Furthermore, this becomes more important when building a brand-new product, as it\u0026rsquo;s usually recommended to launch as soon as possible to gather feedback from the users and validate the idea.\nProject landing page: https://rutieri.netlify.app\n","image":"//localhost:1313/images/post/03.webp","permalink":"//localhost:1313/blogs/how-i-built-a-saas-on-top-of-strapi-and-why-you-should-too/","tags":["Strapi","React Native","Typescript"],"title":"How I Built A SaaS On Top Of Strapi, And Why You Should Too"},{"categories":["Tutorial"],"contents":"Enable User Reviews in a Strapi application and display them in the frontend with React\nOutline Introduction Prerequisites What is Strapi Ratings? Installation Configuration Display user reviews on the frontend Plugin settings Manage user reviews Full source code of the frontend Conclusion Introduction Ratings systems have become a crucial part of any website with ecommerce capabilites, as they allow the users to post reviews on the items they purchase and publish their opinion to the public. A couple of reviews can make the difference between pressing the “Buy” button and moving on to the next website in the Google search results.\nIn this article, I\u0026rsquo;ll show you how to enable and manage user reviews for your content very easily using the Ratings plugin, and display them in your frontend application.\nPrerequisites First of all, you need to have a basic understanding of the following.\nBasic knowledge of JavaScript Basic knowledge of React (OPTIONAL) Basic understanding of Strapi - get started here. Your Strapi V4 project setup What is Strapi Ratings? Strapi Ratings is a plugin that gives your Strapi application the ability to manage ratings for pretty much any kind of content. It allows your users to post reviews and anyone can get the reviews associated with a given slug.\nWith this plugin, admin users can view and manage very easily all the reviews from the Strapi administration dashboard. Within the dashboard, you will be able to see reviews related to content slugs as well as delete reviews.\nInstallation Once into the Strapi project root, you can install the plugin by running the following command:\nnpm install strapi-plugin-ratings Next, build the project to see the new plugin in the dashboard with the following command:\nnpm run build And that\u0026rsquo;s it! If everything runs correctly, the plugin should now be installed.\nConfiguration Now you need to enable some permissions so that the frontend can access the endpoints to post and fetch reviews.\nIn your Strapi admin dashboard, head over to Settings, then over to Roles under Users \u0026amp; Permissions Plugin.\nLet\u0026rsquo;s first setup the Public API; click on Public and hit the dropdown button of Ratings. Now check count, find, getPageSize and getStats, then hit the Save button. Below is a screenshot of a proper configuration:\nNow let\u0026rsquo;s setup the Authenticated API. Go back to Roles and click on Authenticated. Open the dropdown for Ratings and mark as checked the options create, find and getUserReview. Below is a screenshot of a proper configuration:\nWith this configuration, the frontend should now be able to make requests to get and post user reviews.\nDisplay use reviews on the frontend The plugin exposes an API to get and post reviews if you want to have fine-grained control over the workflow of your ratings system and you can check the documentation on the package page, but this plugin also comes with a purpose-built React component library that makes it super easy to get up and running without getting your hands dirty.\nThis components library is called strapi-ratings-client, fully supports typescript and it takes care of all the complexity of fetching and posting user reviews for every content ID that you pass to it.\nInstallation of Strapi Ratings Client You will need to have installed react ^17.0.2, react-dom ^17.0.2, bootstrap ^5.1.3 and @popperjs/core^2.11.2\nInside of your React project, run this command:\nnpm install strapi-ratings-client --save Usage of Strapi Ratings Client Using this library is very easy!\nThis library exports three main components:\nReviewsProvider Reviews ReviewForm And you can import them this way:\nimport { ReviewsProvider, Reviews, ReviewForm } from \u0026#34;strapi-ratings-client\u0026#34; All you have to do is wrap your App component into the ReviewsProvider component. Then you will be able to place anywhere in your app the Reviews component to render a list of user reviews for a given content ID and the ReviewForm component to render a form to allow your users to post reviews.\nFor example, this could be your index.js or main.js file:\nimport React from \u0026#39;react\u0026#39; import ReactDOM from \u0026#39;react-dom\u0026#39; // The address of your strapi backend instance const STRAPI = \u0026#34;http://localhost:1337\u0026#34; ReactDOM.render( \u0026lt;React.StrictMode\u0026gt; \u0026lt;ReviewsProvider apiURL={STRAPI}\u0026gt; \u0026lt;App /\u0026gt; \u0026lt;/ReviewsProvider\u0026gt; \u0026lt;/React.StrictMode\u0026gt;, document.getElementById(\u0026#39;root\u0026#39;) ) Where apiURL is the URL of your running Strapi application, and this property is required.\nThis way, the ratings provider will do all the magic of fetching and posting comments for you!\nThis library also exports an utility React.Context to update some of the parameters for fetching and posting reviews:\nimport { ReviewsConfigContext } from \u0026#34;strapi-ratings-client\u0026#34; This ReviewsConfigContext exposes three setter functions: setUser, setContentID and setCanPostReview.\nWith setContentID you can load the ratings for a given content and post reviews to it. It receives a single parameter of type string and must be URLized, i.e. no spaces.\nWith setUser you can set the credentials of a given user to authorize the posting of reviews. It receives a single parameter of type IUser, with the following Typescript interface:\ninterface IUser { username: string, email: string, id: string, token: string // This is a JWT } With setCanPostReview, you can enable the user to post a review on the given content. This is useful for when you only allow a user to post a review after they purchase the product.\nIt\u0026rsquo;s a little confusing but we\u0026rsquo;ll see how to use it in a component:\nconst App = () =\u0026gt; { const { setUser, setContentID, setCanPostReview } = useContext(ReviewsConfigContext) // The following data should come from Strapi Users and Permissions Plugin // for authenticated requests. const user = { username: \u0026#34;John Doe\u0026#34;, email: \u0026#34;jhohndoe@gmail.com\u0026#34;, id: 5, token: \u0026#34;this_should_be_a_JWT\u0026#34; } if (user) { setUser(user) } setContentID(\u0026#34;sample-content-1\u0026#34;) // Load reviews for this content setCanPostReview(true) // Allow this user to post a review return ( \u0026lt;\u0026gt; { !user \u0026amp;\u0026amp; \u0026lt;Login /\u0026gt; } \u0026lt;ReviewForm /\u0026gt; \u0026lt;Reviews /\u0026gt; \u0026lt;/\u0026gt; ) } And that\u0026rsquo;s it!\nAfter setting the content ID through setContentID, ReviewsProvider will start loading the reviews for the given content ID and the ReviewForm will render an input to post a user review related to the given content ID if there is a user and he’s allowed to post a review. Otherwise, it will display the message Login to post a review or nothing at all if the user is not allowed to post a review.\nHere\u0026rsquo;s how the interface looks like so far:\nThis library exports one more component: ErrorBox\nimport { ErrorBox } from \u0026#34;strapi-ratings-client\u0026#34; .It\u0026rsquo;s useful for when you\u0026rsquo;d like to display error messages when things go wrong fetching or posting reviews.\nYou can place this component wherever you want, for example in between the ReviewForm and the Reviews components.\nIf you\u0026rsquo;re wondering how this error box looks like, here‘s a screenshot:\nGeneral settings You can customize the page size, i.e. specify how many user reviews are showed at once.\nIn the Strapi admin panel, head over to Settings, then select Pagination under Ratings Plugin.\nHere you\u0026rsquo;ll find an input to set the page size, which defaults to 10.\nManage reviews Once you\u0026rsquo;ve got the plugin up an running, as users start to post reviews, you can view them from within the Ratings section of the left sidebar in the Strapi admin dashboard.\nHere you can see two tabs: one for the latest reviews and one for reviews grouped by content ID.\nIn both of them you can delete unwanted reviews.\nExample project You can find a full working example of a React App using the Strapi Ratings Client Library in this repo: https://github.com/luisguve/strapi-ratings-client-example\nConclusion With this plugin you can enable and manage user reviews for any content with little effort and even use a library of components styled with Bootstrap to display the user reviews in your frontend.\nAnd that\u0026rsquo;s it! The features are pretty basic at the moment but if there\u0026rsquo;s interest, I\u0026rsquo;m willing to work on more features as well as improve the UI/UX.\n","image":"//localhost:1313/images/post/tutorial-ratings.webp","permalink":"//localhost:1313/blogs/how-to-enable-and-manage-user-reviews-in-your-strapi-application/","tags":["Strapi","Strapi tutorials"],"title":"How To Enable And Manage User Reviews In Your Strapi Application"},{"categories":["Documentation"],"contents":"Ratings is a Strapi plugin that allows your users to post reviews.\nEnable and manage user reviews for your content very easily!\nRequirements You should have installed an instance of Strapi v4.x.x\nInstallation Run the following command in your project root:\nnpm install strapi-plugin-ratings Then, rebuild the admin dashboard using the following command\nnpm run build Configurarion For your frontend to have access to the API, enable the following permissions for Ratings from Users \u0026amp; Permissions Plugin on your project settings:\nFor public, enable: count, find, getPageSize and getStats.\nFor authenticated, enable create, find and getUserReview.\nDisplay user reviews on the frontend Reviews can be displayed in the frontend in two ways:\nUsing the React components library strapi-ratings-client (recommended) Build your custom frontend using the API endpoints, described as follows: API There are some Typescript interfaces that will help to get an idea of the data structures.\nReviews: interface IReview { id: number, createdAt: string, comment: string | null, author: IAuthor | null, score: number, } Authors: interface IAuthor { username: string, email: string, id: number } Content Stats interface IStats { averageScore: number; reviewsCount: number | null; } The following endpoints are exposed to fetch and post reviews:\nGet reviews for a content ID Method: GET\nPath: /api/ratings/reviews/:slug\nOptional query parameters: start, ignoreCount\nReturns:\n{ reviewsCount: number, averageScore: number, userReview: IReview | null, reviews: IReview[] } The parameter start indicates how many reviews to skip. This is for pagination purposes.\nThe parameter ignoreCount indicates whether or not to return the total number of reviews associated with the given slug.\nGet review stats for a content ID Method: GET\nPath: /api/ratings/reviews/:slug/stats\nReturns:\n{ averageScore: number, reviewsCount: number | null } Get the number of reviews associated with a given content ID Method: GET\nPath: /api/ratings/reviews/:slug/count\nReturns:\n{ count: number } Post a review Method: POST\nPath: /api/ratings/reviews/:slug\nAuthentication: Bearer token\nPayload:\n{ content: string } Returns:\n{ id: number } By default, every authenticated user can post reviews on any content.\nIn order to customize this behavior, e.g. allowing or disallowing a user from posting reviews, you must extend the service userCanPostReview from whithin register function in ./src/index.js. For example:\nstrapi.service(\u0026#34;plugin::ratings.review\u0026#34;).userCanPostReview = async (user, slug) =\u0026gt; { /* Here you will check whether or not the user is allowed to post a review on this content ID and return either true or false. */ return true } Notice that userCanPostReview will receive two parameters: the user from Users \u0026amp; Permissions Plugin, containing it\u0026rsquo;s id, username, confirmed, etc., and the slug, which is a string and refers to the content ID which the review is being posted on.\nIn case this function returns false, the response of the endpoint will be 403 (forbidden) with the text User cannot post a review on this content.\nGet the page size Method: GET\nPath: /api/ratings/page-size\nReturns:\n{ pageSize: number } General settings The plugin allows to set how many reviews are returned per page by going to the Pagination section under Ratings Plugin of the Settings section.\nThe default page size is 10.\nManagement of reviews Admin users are able to delete reviews from within the plugin page of the Strapi admin dashboard.\nThe plugin interface has two tabs: one for the latest reviews and one for reviews by content ID.\nRoadmap and future plans The plugin is pretty basic but it can be improved with more features and a better UI/UX. Collaborations and suggestions are very welcome.\n","image":"//localhost:1313/images/post/ratings.webp","permalink":"//localhost:1313/blogs/strapi-plugin-ratings/","tags":["Strapi","Strapi plugins"],"title":"Strapi Plugin Ratings"}]